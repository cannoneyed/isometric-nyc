# Water tile detection implementation
_Exported on 12/19/2025 at 15:31:20 EST from Cursor (2.2.20)_

---

**User**

Implement @tasks/032_detect_water_tiles.md 

---

**Cursor**

I'll implement this task which involves creating a water tile detection script, updating the generation app with a water tile toggle, and modifying the debug map. Let me start by exploring the relevant files to understand the codebase structure.

Now let me read the `debug_map.py` script and the frontend files to understand the current implementation:

Now I have a clear picture of the codebase. Let me create a plan and implement the task.

```python
"""
Detect Water Tiles - Scan generation tiles and mark those containing water color.

This script iterates over all tiles in the quadrants database and marks them
with the is_water flag if they contain the water color #4A6372.

Usage:
  uv run python src/isometric_nyc/e2e_generation/detect_water_tiles.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Options:
  --threshold N: Minimum percentage of pixels that must be water color (default: 1.0)
  --dry-run: Show what would be marked without making changes
"""

import argparse
import sqlite3
from io import BytesIO
from pathlib import Path

from PIL import Image

# The water color to detect
WATER_COLOR_HEX = "4A6372"
WATER_COLOR_RGB = tuple(int(WATER_COLOR_HEX[i : i + 2], 16) for i in (0, 2, 4))


def ensure_is_water_column(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table."""
  cursor = conn.cursor()
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_all_quadrants_with_generations(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bytes]]:
  """Get all quadrants that have generation data."""
  cursor = conn.cursor()
  cursor.execute("""
    SELECT quadrant_x, quadrant_y, generation
    FROM quadrants
    WHERE generation IS NOT NULL
    ORDER BY quadrant_x, quadrant_y
  """)
  return [(row[0], row[1], row[2]) for row in cursor.fetchall()]


def contains_water_color(
  png_bytes: bytes,
  threshold_percent: float = 1.0,
  tolerance: int = 5,
) -> tuple[bool, float]:
  """
  Check if an image contains the water color.

  Args:
    png_bytes: PNG image data
    threshold_percent: Minimum percentage of pixels that must match (default 1%)
    tolerance: Color matching tolerance (default 5)

  Returns:
    Tuple of (contains_water, percentage_of_water_pixels)
  """
  try:
    img = Image.open(BytesIO(png_bytes))
    img = img.convert("RGB")

    pixels = list(img.getdata())
    total_pixels = len(pixels)

    if total_pixels == 0:
      return False, 0.0

    # Count pixels that match the water color (within tolerance)
    water_r, water_g, water_b = WATER_COLOR_RGB
    matching_pixels = 0

    for r, g, b in pixels:
      if (
        abs(r - water_r) <= tolerance
        and abs(g - water_g) <= tolerance
        and abs(b - water_b) <= tolerance
      ):
        matching_pixels += 1

    percentage = (matching_pixels / total_pixels) * 100

    return percentage >= threshold_percent, percentage

  except Exception as e:
    print(f"  ‚ö†Ô∏è Error analyzing image: {e}")
    return False, 0.0


def mark_quadrant_as_water(conn: sqlite3.Connection, x: int, y: int) -> None:
  """Mark a quadrant as a water tile."""
  cursor = conn.cursor()
  cursor.execute(
    "UPDATE quadrants SET is_water = 1 WHERE quadrant_x = ? AND quadrant_y = ?",
    (x, y),
  )


def unmark_quadrant_as_water(conn: sqlite3.Connection, x: int, y: int) -> None:
  """Unmark a quadrant as a water tile."""
  cursor = conn.cursor()
  cursor.execute(
    "UPDATE quadrants SET is_water = 0 WHERE quadrant_x = ? AND quadrant_y = ?",
    (x, y),
  )


def detect_water_tiles(
  generation_dir: Path,
  threshold_percent: float = 1.0,
  dry_run: bool = False,
) -> dict:
  """
  Scan all tiles and detect which ones contain water.

  Args:
    generation_dir: Path to the generation directory
    threshold_percent: Minimum percentage of pixels that must be water color
    dry_run: If True, don't make any changes to the database

  Returns:
    Dict with statistics about the scan
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  conn = sqlite3.connect(db_path)

  try:
    # Ensure the is_water column exists
    if not dry_run:
      ensure_is_water_column(conn)

    # Get all quadrants with generations
    quadrants = get_all_quadrants_with_generations(conn)
    print(f"\nüìä Found {len(quadrants)} quadrants with generations")

    stats = {
      "total_scanned": 0,
      "water_tiles": 0,
      "non_water_tiles": 0,
      "errors": 0,
      "water_quadrants": [],
    }

    print(f"üîç Scanning for water color #{WATER_COLOR_HEX}...")
    print(f"   Threshold: {threshold_percent}% of pixels\n")

    for x, y, generation_bytes in quadrants:
      stats["total_scanned"] += 1

      is_water, percentage = contains_water_color(
        generation_bytes, threshold_percent
      )

      if is_water:
        stats["water_tiles"] += 1
        stats["water_quadrants"].append((x, y, percentage))

        if dry_run:
          print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water (would mark)")
        else:
          mark_quadrant_as_water(conn, x, y)
          print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water ‚úì")
      else:
        stats["non_water_tiles"] += 1
        # Optionally unmark if it was previously marked
        if not dry_run:
          unmark_quadrant_as_water(conn, x, y)

    if not dry_run:
      conn.commit()

    return stats

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Detect and mark water tiles in the generation database."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--threshold",
    type=float,
    default=1.0,
    help="Minimum percentage of pixels that must be water color (default: 1.0)",
  )
  parser.add_argument(
    "--dry-run",
    action="store_true",
    help="Show what would be marked without making changes",
  )

  args = parser.parse_args()

  # Resolve path
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  print(f"\n{'=' * 60}")
  print("üíß Water Tile Detection")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")
  print(f"   Water color: #{WATER_COLOR_HEX} (RGB{WATER_COLOR_RGB})")
  print(f"   Threshold: {args.threshold}%")
  if args.dry_run:
    print("   Mode: DRY RUN (no changes will be made)")
  print()

  try:
    stats = detect_water_tiles(
      generation_dir,
      threshold_percent=args.threshold,
      dry_run=args.dry_run,
    )

    print(f"\n{'=' * 60}")
    print("üìà Results")
    print(f"{'=' * 60}")
    print(f"   Total scanned: {stats['total_scanned']}")
    print(f"   Water tiles:   {stats['water_tiles']}")
    print(f"   Non-water:     {stats['non_water_tiles']}")

    if stats["water_quadrants"]:
      print(f"\nüíß Water tiles found ({len(stats['water_quadrants'])}):")
      for x, y, pct in stats["water_quadrants"]:
        print(f"      ({x}, {y}) - {pct:.1f}%")

    if args.dry_run:
      print("\n‚ö†Ô∏è  DRY RUN - No changes were made to the database")
    else:
      print(f"\n‚úÖ Marked {stats['water_tiles']} tile(s) as water")

    return 0

  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

I can see that water tile functionality already exists in the codebase. The tiles already have a `.water` class and a water indicator (üíß). Now I need to add a toggle to show/hide water tile highlights with a blue bounding box. Let me update the viewer to add this toggle functionality:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Generated Tiles Viewer</title>
    <link rel="stylesheet" href="/static/viewer.css" />
    <style>
      /* Dynamic grid sizing based on template variables */
      .grid {
        grid-template-columns: repeat({{ nx }}, {{ size_px }}px);
        grid-auto-rows: {{ size_px }}px;
      }
      .tile.placeholder {
        min-width: {{ size_px }}px;
        min-height: {{ size_px }}px;
      }
    </style>
  </head>
  <body>
    <!-- Config data for JS -->
    <script
      id="app-config"
      type="application/json"
      data-config='{"x": {{ x }}, "y": {{ y }}, "nx": {{ nx }}, "ny": {{ ny }}, "size_px": {{ size_px }}, "models": {{ models_config | safe }}, "default_model_id": "{{ default_model_id }}"}'
    ></script>

    <!-- Toast notification container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Fixed toolbar -->
    <div class="toolbar">
      <div class="toolbar-row toolbar-row-nav">
        <div class="controls">
          <label>X: <input type="number" id="x" value="{{ x }}" /></label>
          <label>Y: <input type="number" id="y" value="{{ y }}" /></label>
          <label
            >NX: <input type="number" id="nx" value="{{ nx }}" min="1" max="20"
          /></label>
          <label
            >NY: <input type="number" id="ny" value="{{ ny }}" min="1" max="20"
          /></label>
          <label
            >Size:
            <input type="number" id="sizePx" value="{{ size_px }}" step="32"
          /></label>
          <button onclick="goTo()">Go</button>
          <div class="toggle-group">
            <label
              ><input
                type="checkbox"
                id="showLines"
                {%
                if
                show_lines
                %}checked{%
                endif
                %}
                onchange="toggleLines()"
              />
              Lines</label
            >
            <label
              ><input
                type="checkbox"
                id="showCoords"
                {%
                if
                show_coords
                %}checked{%
                endif
                %}
                onchange="toggleCoords()"
              />
              Coords</label
            >
            <label
              ><input
                type="checkbox"
                id="showRender"
                {%
                if
                show_render
                %}checked{%
                endif
                %}
                onchange="toggleRender()"
              />
              Renders</label
            >
            <label
              ><input
                type="checkbox"
                id="showWater"
                onchange="toggleWaterHighlight()"
              />
              üíß Water</label
            >
          </div>
          <div class="toggle-group model-group">
            <label class="model-label"
              >Model:
              <select id="modelSelect" class="model-select">
                <!-- Populated by JavaScript -->
              </select>
            </label>
          </div>
        </div>
        <div class="toolbar-info">
          <span>({{ x }}, {{ y }}) ‚Üí ({{ x + nx - 1 }}, {{ y + ny - 1 }})</span>
          <span id="selectedQuadrantsDisplay" class="selected-quadrants"></span>
          <span class="generation-dir-info">{{ generation_dir }}</span>
        </div>
      </div>
      <div class="toolbar-row toolbar-row-tools">
        <div class="tools-group">
          <span class="tools-label">Tools:</span>
          <button
            id="selectTool"
            class="tool-btn"
            onclick="toggleSelectTool()"
            title="Select quadrants (S)"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path>
              <path d="M13 13l6 6"></path>
            </svg>
            Select
          </button>
          <button
            id="fixWaterTool"
            class="tool-btn"
            onclick="toggleFixWaterTool()"
            title="Fix water color (W)"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
            </svg>
            Fix Water
          </button>
          <button
            id="waterFillTool"
            class="tool-btn"
            onclick="toggleWaterFillTool()"
            title="Fill quadrant with water (F)"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <rect x="3" y="3" width="18" height="18" rx="2"></rect>
              <path d="M12 8v8"></path>
              <path d="M8 12h8"></path>
            </svg>
            Water Fill
          </button>
          <button
            id="waterSelectTool"
            class="tool-btn"
            onclick="toggleWaterSelectTool()"
            title="Mark quadrants as water tiles (T)"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
              <path d="M12 12v4"></path>
              <circle cx="12" cy="18" r="1"></circle>
            </svg>
            Water Select
          </button>
        </div>
        <div class="toolbar-divider"></div>
        <div class="actions-group">
          <button
            id="deselectAllBtn"
            class="action-btn deselect-btn"
            onclick="deselectAll()"
            disabled
          >
            Deselect
          </button>
          <button
            id="deleteBtn"
            class="action-btn delete-btn"
            onclick="deleteSelected()"
            disabled
            title="Delete data (generation or render based on current view)"
          >
            Delete
          </button>
          <button
            id="flagBtn"
            class="action-btn flag-btn"
            onclick="flagSelected()"
            disabled
            title="Flag selected quadrants for review"
          >
            üö© Flag
          </button>
          <button
            id="renderBtn"
            class="action-btn render-btn"
            onclick="renderSelected()"
            disabled
          >
            Render
          </button>
          <button
            id="generateBtn"
            class="action-btn generate-btn"
            onclick="generateSelected()"
            disabled
          >
            Generate
          </button>
          <button
            id="generateWithPromptBtn"
            class="action-btn generate-prompt-btn"
            onclick="showPromptDialog()"
            disabled
            title="Generate with additional prompt text"
          >
            + Prompt
          </button>
          <button
            id="generateRectBtn"
            class="action-btn generate-rect-btn"
            onclick="generateRectangle()"
            disabled
            title="Select exactly 2 quadrants to define rectangle corners"
          >
            Gen Rect
          </button>
          <button
            id="exportCmdBtn"
            class="action-btn export-cmd-btn"
            onclick="copyExportCommand()"
            disabled
            title="Copy export command to clipboard (select 2 quadrants)"
          >
            Export Cmd
          </button>
        </div>
        <div class="toolbar-divider"></div>
        <div class="utility-group">
          <button
            id="clearQueueBtn"
            class="utility-btn clear-queue-btn"
            onclick="clearQueue()"
            title="Clear all pending items from the generation queue"
          >
            Clear Queue
          </button>
          <button
            id="hardRefreshBtn"
            class="utility-btn hard-refresh-btn"
            onclick="hardRefresh()"
            title="Clear image cache and reload page"
          >
            ‚Üª Refresh
          </button>
        </div>
      </div>
      <div class="toolbar-row toolbar-row-status" id="selectionStatus">
        <span id="selectionCount"></span>
      </div>
      <div class="water-fix-status" id="waterFixStatus" style="display: none">
        <span class="water-fix-label">Target Color:</span>
        <span class="color-swatch" id="targetColorSwatch"></span>
        <span class="color-hex" id="targetColorHex"
          >Click a quadrant to pick color</span
        >
        <span class="water-fix-quadrant" id="waterFixQuadrant"></span>
        <button
          id="applyWaterFixBtn"
          class="apply-water-fix-btn"
          onclick="applyWaterFix()"
          disabled
        >
          Apply Fix
        </button>
        <button
          id="cancelWaterFixBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFix()"
        >
          Cancel
        </button>
      </div>
      <div class="water-fill-status" id="waterFillStatus" style="display: none">
        <span class="water-fill-label">Water Fill:</span>
        <span class="color-swatch water-color-preview"></span>
        <span class="water-fill-instruction" id="waterFillInstruction"
          >Click a quadrant to fill with water</span
        >
        <button
          id="cancelWaterFillBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFill()"
        >
          Cancel
        </button>
      </div>
      <div
        class="water-select-status"
        id="waterSelectStatus"
        style="display: none"
      >
        <span class="water-select-label">üíß Water Select:</span>
        <span class="water-select-instruction" id="waterSelectInstruction"
          >Click quadrants to toggle water status</span
        >
        <button
          id="cancelWaterSelectBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterSelect()"
        >
          Cancel
        </button>
      </div>
    </div>

    <div
      class="grid-container {% if show_lines %}show-lines{% endif %} {% if show_coords %}show-coords{% endif %}"
      id="gridContainer"
    >
      <div class="grid">
        {% for dy in range(ny) %} {% for dx in range(nx) %} {% set qx = x + dx
        %} {% set qy = y + dy %} {% set has_gen = tiles.get((dx, dy), False) %}
        {% set is_flagged = flagged_tiles.get((dx, dy), False) %} {% set
        is_water = water_tiles.get((dx, dy), False) %}
        <div
          class="tile {% if not has_gen %}placeholder{% endif %}{% if is_flagged %} flagged{% endif %}{% if is_water %} water{% endif %}"
          data-coords="{{ qx }},{{ qy }}"
          data-flagged="{{ 'true' if is_flagged else 'false' }}"
          data-water="{{ 'true' if is_water else 'false' }}"
        >
          <span class="coords">({{ qx }}, {{ qy }})</span>
          {% if has_gen %}
          <img
            src="/tile/{{ qx }}/{{ qy }}?render={{ '1' if show_render else '0' }}"
            alt="Tile {{ qx }},{{ qy }}"
          />
          {% endif %} {% if is_water %}
          <span class="water-indicator" title="Water tile">üíß</span>
          {% endif %}
        </div>
        {% endfor %} {% endfor %}
      </div>
    </div>

    <!-- Prompt Dialog -->
    <div id="promptDialog" class="dialog-overlay" style="display: none">
      <div class="dialog-content">
        <h3>Generate with Prompt</h3>
        <p class="dialog-description">
          Add additional instructions for the generation:
        </p>
        <textarea
          id="promptInput"
          class="prompt-input"
          placeholder="e.g., 'Add more trees' or 'Make the water darker'"
          rows="3"
        ></textarea>
        <div class="dialog-buttons">
          <button class="dialog-cancel-btn" onclick="hidePromptDialog()">
            Cancel
          </button>
          <button class="dialog-submit-btn" onclick="submitPromptGeneration()">
            Generate
          </button>
        </div>
      </div>
    </div>

    <script src="/static/viewer.js"></script>
  </body>
</html>

```

Now let me add the CSS styles for the water highlight and the JavaScript functionality:

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
  font-size: 12px;
  background: #1a1a2e;
  color: #eee;
  min-height: 100vh;
  padding: 15px;
  padding-top: 130px; /* Space for fixed toolbar with three rows */
}

.toolbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: #1a1a2e;
  padding: 10px 15px;
  z-index: 100;
  border-bottom: 1px solid #333;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.toolbar-row {
  display: flex;
  align-items: center;
  gap: 15px;
  flex-wrap: wrap;
}

.toolbar-row-nav {
  padding-bottom: 6px;
}

.toolbar-row-tools {
  padding-top: 6px;
  border-top: 1px solid #333;
  gap: 10px;
}

.toolbar-divider {
  width: 1px;
  height: 20px;
  background: #444;
  margin: 0 4px;
}

.actions-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.utility-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.toolbar-row-status {
  padding-top: 6px;
  border-top: 1px solid #333;
  font-size: 0.7rem;
  color: #888;
  min-height: 18px;
}

.toolbar-row-status.generating {
  color: #a855f7;
}

/* Action button base styles */
.action-btn {
  padding: 4px 8px;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  font-weight: 500;
  transition: all 0.2s;
}

.action-btn:disabled {
  background: #333 !important;
  color: #555 !important;
  cursor: not-allowed;
}

/* Utility button base styles */
.utility-btn {
  padding: 4px 8px;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  font-weight: 500;
  transition: all 0.2s;
}

.toolbar-info {
  color: #666;
  font-size: 0.75rem;
  margin-left: auto;
}

.toolbar-info span + span {
  margin-left: 12px;
}

.toolbar-info .selected-quadrants {
  color: #00d9ff;
  font-weight: bold;
}

.toolbar-info .generation-dir-info {
  display: none; /* Hide the long path on the nav row */
}

.controls {
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
}

.controls label {
  color: #888;
  font-size: 0.8rem;
}

.controls input[type="number"] {
  width: 50px;
  padding: 5px 6px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #16213e;
  color: #fff;
  font-family: inherit;
  font-size: 0.8rem;
}

.controls button {
  padding: 5px 12px;
  background: #00d9ff;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.75rem;
  font-weight: bold;
}

.controls button:hover {
  background: #00b8d4;
}

.toggle-group {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-left: 8px;
  padding-left: 12px;
  border-left: 1px solid #333;
}

.toggle-group label {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  user-select: none;
  font-size: 0.75rem;
}

.toggle-group input[type="checkbox"] {
  width: 14px;
  height: 14px;
  accent-color: #00d9ff;
  cursor: pointer;
}

.grid-container {
  display: inline-block;
  border-radius: 8px;
  overflow: hidden;
}

.grid-container.show-lines {
  border: 2px solid #333;
}

.grid {
  display: grid;
  background: #333;
}

.grid-container.show-lines .grid {
  gap: 2px;
}

.grid-container:not(.show-lines) .grid {
  gap: 0;
  background: transparent;
}

.grid-container:not(.show-lines) {
  border: none;
}

.tile {
  position: relative;
  background: #2a2a4a;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tile img {
  display: block;
  max-width: 100%;
  height: auto;
}

.tile.placeholder {
  background: #3a3a5a;
}

.tile .coords {
  position: absolute;
  top: 6px;
  left: 6px;
  background: rgba(0, 0, 0, 0.7);
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 0.65rem;
  color: #00d9ff;
  transition: opacity 0.2s;
}

.tile.placeholder .coords {
  color: #666;
}

.grid-container:not(.show-coords) .tile .coords {
  opacity: 0;
}

/* Tool button styles */
.tools-group {
  display: flex;
  align-items: center;
  gap: 8px;
  border-left: none;
  margin-left: 0;
  padding-left: 0;
}

.tools-label {
  color: #666;
  font-size: 0.7rem;
  margin-right: 4px;
}

.tool-btn {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: #2a2a3e;
  color: #666;
  border: 1px solid #444;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  transition: all 0.15s ease;
}

.tool-btn:hover {
  background: #3a3a4e;
  color: #999;
  border-color: #555;
}

.tool-btn.active {
  background: #10b981;
  color: #fff;
  border-color: #10b981;
  box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
}

.tool-btn.active:hover {
  background: #059669;
  border-color: #059669;
}

.tool-btn svg {
  width: 12px;
  height: 12px;
}

/* Selection styles */
.tile.selected {
  outline: 3px solid #ff3333;
  outline-offset: -3px;
  z-index: 10;
}

.grid-container.show-lines .tile.selected {
  outline-color: #ff3333;
}

.tile.selectable {
  cursor: pointer;
}

.tile.placeholder.selected {
  background: rgba(255, 51, 51, 0.15);
}

/* Flagged tile styles */
.tile.flagged {
  position: relative;
}

.tile.flagged::before {
  content: "üö©";
  position: absolute;
  top: 4px;
  right: 4px;
  font-size: 16px;
  z-index: 20;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
  pointer-events: none;
}

.tile.flagged::after {
  content: "";
  position: absolute;
  inset: 0;
  border: 2px solid #f97316;
  pointer-events: none;
  z-index: 5;
}

/* Locked tiles (during generation) */
.tile.locked {
  outline: 3px solid #a855f7;
  outline-offset: -3px;
  z-index: 10;
}

.grid-container.show-lines .tile.locked {
  outline-color: #a855f7;
}

.tile.placeholder.locked {
  background: rgba(168, 85, 247, 0.2);
}

/* Queued tiles (in queue, waiting to be generated) */
.tile.queued {
  outline: 3px dashed #c084fc !important;
  outline-offset: -3px;
  z-index: 9;
  animation: pulse-queue 1.5s ease-in-out infinite;
  /* Fallback: box-shadow for browsers that don't render dashed outlines well */
  box-shadow: inset 0 0 0 3px rgba(192, 132, 252, 0.5);
}

@keyframes pulse-queue {
  0%,
  100% {
    outline-color: #c084fc;
    box-shadow: inset 0 0 0 3px rgba(192, 132, 252, 0.5);
  }
  50% {
    outline-color: #8b5cf6;
    box-shadow: inset 0 0 0 3px rgba(139, 92, 246, 0.7);
  }
}

.grid-container.show-lines .tile.queued {
  outline-color: #c084fc;
}

.tile.placeholder.queued {
  background: rgba(168, 85, 247, 0.3) !important;
}

/* Allow selection while generating - only disable clicking on locked/queued tiles */
body.generating .tile.locked.selectable,
body.generating .tile.queued.selectable {
  cursor: not-allowed;
}

/* Selection status styles moved to .toolbar-status */

/* Clickable coordinate links in status bar */
.coord-link {
  color: #00d9ff;
  text-decoration: none;
  cursor: pointer;
  padding: 1px 3px;
  border-radius: 3px;
  transition: background-color 0.15s ease;
}

.coord-link:hover {
  background-color: rgba(0, 217, 255, 0.2);
  text-decoration: underline;
}

.selection-limit {
  color: #888;
  font-size: 0.65rem;
}

.deselect-btn {
  background: #6b7280;
  color: white;
}

.deselect-btn:hover:not(:disabled) {
  background: #4b5563;
}

.delete-btn {
  background: #dc2626;
  color: white;
}

.delete-btn:hover:not(:disabled) {
  background: #b91c1c;
}

.flag-btn {
  background: #f97316;
  color: white;
}

.flag-btn:hover:not(:disabled) {
  background: #ea580c;
}

.render-btn {
  background: #f59e0b;
  color: #1a1a2e;
  font-weight: bold;
}

.render-btn:hover:not(:disabled) {
  background: #d97706;
}

.render-btn.loading {
  background: #666;
  color: #fff;
  cursor: wait;
}

.render-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

.generate-btn {
  background: #00d9ff;
  color: #1a1a2e;
  font-weight: bold;
}

.generate-btn:hover:not(:disabled) {
  background: #00b8d4;
}

/* Generate Rectangle button */
.generate-rect-btn {
  background: #8b5cf6;
  color: white;
  font-weight: bold;
}

.generate-rect-btn:hover:not(:disabled) {
  background: #7c3aed;
}

.generate-rect-btn.loading {
  background: #666;
  cursor: wait;
}

.generate-rect-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

/* Clear Queue button */
.clear-queue-btn {
  background: #6b7280;
  color: white;
}

.clear-queue-btn:hover {
  background: #ef4444;
}

.clear-queue-btn:active {
  background: #dc2626;
}

.hard-refresh-btn {
  background: #3b82f6;
  color: white;
}

.hard-refresh-btn:hover {
  background: #2563eb;
}

.hard-refresh-btn:active {
  background: #1d4ed8;
}

/* Toast notification system */
.toast-container {
  position: fixed;
  bottom: 15px;
  right: 15px;
  z-index: 1000;
  display: flex;
  flex-direction: column-reverse;
  gap: 8px;
  max-width: 320px;
}

.toast {
  padding: 10px 14px;
  border-radius: 6px;
  font-size: 0.75rem;
  animation: slideIn 0.3s ease-out;
  display: flex;
  align-items: flex-start;
  gap: 10px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.toast.success {
  background: linear-gradient(135deg, #065f46 0%, #047857 100%);
  border: 1px solid #10b981;
  color: #d1fae5;
}

.toast.error {
  background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
  border: 1px solid #ef4444;
  color: #fee2e2;
}

.toast.info {
  background: linear-gradient(135deg, #1e3a5f 0%, #1e40af 100%);
  border: 1px solid #3b82f6;
  color: #dbeafe;
}

.toast.loading {
  background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
  border: 1px solid #6b7280;
  color: #e5e7eb;
}

.toast-icon {
  flex-shrink: 0;
  font-size: 1rem;
}

.toast-content {
  flex: 1;
}

.toast-title {
  font-weight: 600;
  margin-bottom: 2px;
}

.toast-message {
  opacity: 0.9;
  font-size: 0.7rem;
}

.toast-close {
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  opacity: 0.7;
  font-size: 1rem;
  padding: 0;
  line-height: 1;
}

.toast-close:hover {
  opacity: 1;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOut {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

.toast.removing {
  animation: slideOut 0.3s ease-in forwards;
}

/* Loading spinner for generate button */
.generate-btn.loading {
  background: #666;
  color: #fff;
  cursor: wait;
}

.generate-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Water fix tool styles */
.water-fix-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid rgba(59, 130, 246, 0.3);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #60a5fa;
  margin-top: 8px;
}

.water-fix-label {
  color: #93c5fd;
  font-weight: 500;
}

.color-swatch {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  border: 2px solid #fff;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3), inset 0 0 0 1px rgba(0, 0, 0, 0.1);
  background: #333;
}

.color-swatch.has-color {
  cursor: pointer;
}

.color-hex {
  font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
  font-size: 0.75rem;
  color: #93c5fd;
  min-width: 180px;
}

.water-fix-quadrant {
  color: #60a5fa;
  font-size: 0.7rem;
}

.apply-water-fix-btn {
  padding: 4px 12px;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
  margin-left: auto;
}

.apply-water-fix-btn:hover:not(:disabled) {
  background: #2563eb;
}

.apply-water-fix-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.apply-water-fix-btn.loading {
  background: #666;
  cursor: wait;
}

.cancel-water-fix-btn {
  padding: 4px 8px;
  background: #4b5563;
  color: #d1d5db;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  transition: all 0.2s;
}

.cancel-water-fix-btn:hover {
  background: #6b7280;
}

/* Fix water tool active state */
.tile.fix-water-selectable {
  cursor: crosshair;
}

.tile.fix-water-selectable:hover {
  outline: 2px solid #3b82f6;
  outline-offset: -2px;
}

.tile.water-fix-selected {
  outline: 3px solid #3b82f6;
  outline-offset: -3px;
  z-index: 10;
}

/* Water fill tool styles */
.water-fill-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(74, 99, 114, 0.15);
  border: 1px solid rgba(74, 99, 114, 0.4);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #7ba3b8;
  margin-top: 8px;
}

.water-fill-label {
  color: #93c5fd;
  font-weight: 500;
}

.water-color-preview {
  background: #4a6372 !important;
}

.water-fill-instruction {
  color: #7ba3b8;
}

.tile.water-fill-selectable {
  cursor: pointer;
}

.tile.water-fill-selectable:hover {
  outline: 2px solid #4a6372;
  outline-offset: -2px;
}

/* Model selector styles */
.model-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.model-label {
  display: flex;
  align-items: center;
  gap: 6px;
  color: #888;
  font-size: 0.75rem;
}

.model-select {
  padding: 4px 8px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #16213e;
  color: #fff;
  font-family: inherit;
  font-size: 0.75rem;
  cursor: pointer;
  min-width: 140px;
}

.model-select:hover {
  border-color: #00d9ff;
}

.model-select:focus {
  outline: none;
  border-color: #00d9ff;
  box-shadow: 0 0 0 2px rgba(0, 217, 255, 0.2);
}

.model-select option {
  background: #16213e;
  color: #fff;
  padding: 4px;
}

/* Generate with Prompt button */
.generate-prompt-btn {
  background: #9b59b6;
  color: #fff;
}

.generate-prompt-btn:hover:not(:disabled) {
  background: #8e44ad;
}

/* Prompt Dialog */
.dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.dialog-content {
  background: #1a1a2e;
  border: 1px solid #333;
  border-radius: 8px;
  padding: 24px;
  min-width: 400px;
  max-width: 500px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
}

.dialog-content h3 {
  margin: 0 0 12px 0;
  color: #fff;
  font-size: 18px;
}

.dialog-description {
  color: #aaa;
  font-size: 14px;
  margin: 0 0 16px 0;
}

.prompt-input {
  width: 100%;
  background: #0f0f1a;
  border: 1px solid #333;
  border-radius: 4px;
  color: #fff;
  font-size: 14px;
  padding: 12px;
  resize: vertical;
  font-family: inherit;
  box-sizing: border-box;
}

.prompt-input:focus {
  outline: none;
  border-color: #9b59b6;
  box-shadow: 0 0 0 2px rgba(155, 89, 182, 0.2);
}

.prompt-input::placeholder {
  color: #666;
}

.dialog-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 20px;
}

.dialog-cancel-btn {
  background: #333;
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

.dialog-cancel-btn:hover {
  background: #444;
}

.dialog-submit-btn {
  background: linear-gradient(135deg, #9b59b6, #8e44ad);
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.dialog-submit-btn:hover {
  background: linear-gradient(135deg, #a569c0, #9b59b6);
}

/* Queue Overlays - show pending generations as grouped rectangles */
.queue-overlay {
  position: absolute;
  border: 3px dashed #c084fc;
  border-radius: 4px;
  pointer-events: auto;
  z-index: 20;
  animation: pulse-queue-overlay 1.5s ease-in-out infinite;
  box-sizing: border-box;
}

/* Processing overlay - solid border, different color */
.queue-overlay.processing {
  border-style: solid;
  border-color: #a855f7;
  animation: pulse-processing-overlay 1s ease-in-out infinite;
}

@keyframes pulse-queue-overlay {
  0%,
  100% {
    border-color: #c084fc;
    box-shadow: 0 0 12px rgba(192, 132, 252, 0.3);
  }
  50% {
    border-color: #8b5cf6;
    box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
  }
}

@keyframes pulse-processing-overlay {
  0%,
  100% {
    border-color: #a855f7;
    box-shadow: 0 0 16px rgba(168, 85, 247, 0.4);
  }
  50% {
    border-color: #c084fc;
    box-shadow: 0 0 24px rgba(192, 132, 252, 0.7);
  }
}

.queue-overlay:hover {
  border-color: #a855f7;
  box-shadow: 0 0 16px rgba(168, 85, 247, 0.6);
}

/* Queue position badge */
.queue-badge {
  position: absolute;
  top: 6px;
  left: 6px;
  min-width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #8b5cf6, #a855f7);
  color: white;
  font-size: 12px;
  font-weight: bold;
  font-family: "SF Mono", "Monaco", monospace;
  border-radius: 6px;
  padding: 0 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  z-index: 1;
}

/* Processing badge - with spinner */
.queue-badge.processing {
  background: linear-gradient(135deg, #10b981, #059669);
  min-width: 28px;
  height: 28px;
}

/* Spinner animation for processing badge */
.processing-spinner {
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

/* Model label below badge */
.queue-model-label {
  position: absolute;
  top: 34px;
  left: 6px;
  font-size: 9px;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.9);
  background: rgba(139, 92, 246, 0.8);
  padding: 2px 6px;
  border-radius: 3px;
  max-width: calc(100% - 40px);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
}

/* Cancel button - visible on hover */
.queue-cancel-btn {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(220, 38, 38, 0.9);
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  opacity: 0;
  transform: scale(0.8);
  transition: all 0.15s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.queue-overlay:hover .queue-cancel-btn {
  opacity: 1;
  transform: scale(1);
}

.queue-cancel-btn:hover {
  background: #dc2626;
  transform: scale(1.1);
}

.queue-cancel-btn svg {
  width: 14px;
  height: 14px;
}

/* Make grid position relative for overlay positioning */
.grid {
  position: relative;
}

/* Water tile indicator styles */
.tile.water {
  position: relative;
}

.water-indicator {
  position: absolute;
  bottom: 4px;
  right: 4px;
  font-size: 14px;
  z-index: 20;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
  pointer-events: none;
  background: rgba(0, 0, 0, 0.5);
  border-radius: 3px;
  padding: 1px 3px;
}

/* Water select tool styles */
.water-select-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid rgba(59, 130, 246, 0.3);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #60a5fa;
  margin-top: 8px;
}

.water-select-label {
  color: #93c5fd;
  font-weight: 500;
}

.water-select-instruction {
  color: #60a5fa;
}

.tile.water-select-selectable {
  cursor: pointer;
}

.tile.water-select-selectable:hover {
  outline: 2px solid #3b82f6;
  outline-offset: -2px;
}

.tile.water-select-selectable.water:hover {
  outline-color: #f97316;
}

/* Water highlight mode - show water tiles with blue bounding box */
.grid-container.show-water-highlight .tile.water::after {
  content: "";
  position: absolute;
  inset: 0;
  border: 3px solid #3b82f6;
  pointer-events: none;
  z-index: 15;
  box-shadow: inset 0 0 0 1px rgba(59, 130, 246, 0.3);
}

```

Now let me add the JavaScript function for toggling water highlight:

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// LocalStorage keys for persistence
const STORAGE_KEY_MODEL = "viewer_selected_model";
const STORAGE_KEY_TOOL = "viewer_selected_tool";
const STORAGE_KEY_SELECTION = "viewer_selected_quadrants";

// Save selected model ID to localStorage
function saveSelectedModel(modelId) {
  try {
    localStorage.setItem(STORAGE_KEY_MODEL, modelId);
  } catch (e) {
    console.warn("Could not save model to localStorage:", e);
  }
}

// Get saved model ID from localStorage
function getSavedModel() {
  try {
    return localStorage.getItem(STORAGE_KEY_MODEL);
  } catch (e) {
    return null;
  }
}

// Save selected tool to localStorage
function saveSelectedTool(toolName) {
  try {
    localStorage.setItem(STORAGE_KEY_TOOL, toolName || "");
  } catch (e) {
    console.warn("Could not save tool to localStorage:", e);
  }
}

// Get saved tool from localStorage
function getSavedTool() {
  try {
    return localStorage.getItem(STORAGE_KEY_TOOL) || "";
  } catch (e) {
    return "";
  }
}

// Save selected quadrants to localStorage
function saveSelectedQuadrants() {
  try {
    const quadrantsArray = Array.from(selectedQuadrants);
    localStorage.setItem(STORAGE_KEY_SELECTION, JSON.stringify(quadrantsArray));
  } catch (e) {
    console.warn("Could not save selection to localStorage:", e);
  }
}

// Get saved quadrants from localStorage
function getSavedQuadrants() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY_SELECTION);
    return saved ? JSON.parse(saved) : [];
  } catch (e) {
    return [];
  }
}

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Check if saved model ID exists in available models
  const savedModelId = getSavedModel();
  const savedModelExists =
    savedModelId && config.models.some((m) => m.model_id === savedModelId);

  // Add options for each model
  config.models.forEach((model, index) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;

    // Select saved model if it exists, otherwise use default or first
    if (savedModelExists && model.model_id === savedModelId) {
      option.selected = true;
    } else if (
      !savedModelExists &&
      model.model_id === config.default_model_id
    ) {
      option.selected = true;
    } else if (!savedModelExists && !config.default_model_id && index === 0) {
      option.selected = true;
    }
    select.appendChild(option);
  });

  // Auto-blur after selection and save to localStorage
  select.addEventListener("change", () => {
    saveSelectedModel(select.value);
    select.blur();
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to ALL currently processing quadrants (from all models)
  const processingQuadrants =
    status.all_processing_quadrants || status.quadrants || [];
  const isProcessing = status.is_generating || status.active_model_count > 0;

  if (isProcessing && processingQuadrants.length > 0) {
    document.body.classList.add("generating");
    processingQuadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else if (!isProcessing) {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items AND create overlays
  // Also create overlays for processing items
  const processingItems = getProcessingItems(status);
  updateQueueOverlays(status.queue || [], processingItems);
}

// Extract currently processing items from status
function getProcessingItems(status) {
  const processingItems = [];
  if (status.queue_by_model) {
    Object.entries(status.queue_by_model).forEach(([modelId, info]) => {
      if (info.is_processing && info.current_item) {
        processingItems.push({
          ...info.current_item,
          model_id: modelId,
          _isProcessing: true,
        });
      }
    });
  }
  return processingItems;
}

// Create/update overlays for pending queue items and processing items
function updateQueueOverlays(queueItems, processingItems = []) {
  // Remove existing overlays
  document.querySelectorAll(".queue-overlay").forEach((el) => el.remove());

  // Also clear queued class from all tiles
  document.querySelectorAll(".tile.queued").forEach((tile) => {
    tile.classList.remove("queued");
  });

  const hasItems =
    (queueItems && queueItems.length > 0) ||
    (processingItems && processingItems.length > 0);
  if (!hasItems) return;

  const grid = document.querySelector(".grid");
  if (!grid) return;

  // Get grid dimensions from config
  const gridX = config.x;
  const gridY = config.y;
  const sizePx = config.size_px;
  const showLines = document.getElementById("showLines")?.checked || false;
  const gap = showLines ? 2 : 0;

  // Helper function to create an overlay for an item
  function createOverlay(item, options = {}) {
    const { isProcessing = false, queuePosition = null } = options;

    if (!item.quadrants || item.quadrants.length === 0) return null;

    // Calculate bounding box for this generation
    const quadrants = item.quadrants;
    let minCol = Infinity,
      maxCol = -Infinity;
    let minRow = Infinity,
      maxRow = -Infinity;

    // Track which tiles are visible in the current view
    const visibleQuadrants = [];

    quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        visibleQuadrants.push([qx, qy]);
        const col = qx - gridX;
        const row = qy - gridY;
        minCol = Math.min(minCol, col);
        maxCol = Math.max(maxCol, col);
        minRow = Math.min(minRow, row);
        maxRow = Math.max(maxRow, row);

        // Add appropriate class to tile
        if (isProcessing) {
          tile.classList.add("locked");
        } else if (!tile.classList.contains("locked")) {
          tile.classList.add("queued");
        }
      }
    });

    if (visibleQuadrants.length === 0) return null;

    // Create overlay element
    const overlay = document.createElement("div");
    overlay.className = isProcessing
      ? "queue-overlay processing"
      : "queue-overlay";
    overlay.dataset.itemId = item.id;

    // Calculate position and size
    const left = minCol * (sizePx + gap);
    const top = minRow * (sizePx + gap);
    const width = (maxCol - minCol + 1) * sizePx + (maxCol - minCol) * gap;
    const height = (maxRow - minRow + 1) * sizePx + (maxRow - minRow) * gap;

    overlay.style.left = `${left}px`;
    overlay.style.top = `${top}px`;
    overlay.style.width = `${width}px`;
    overlay.style.height = `${height}px`;

    // Badge: spinner for processing, number for queued
    const badge = document.createElement("div");
    badge.className = isProcessing ? "queue-badge processing" : "queue-badge";
    if (isProcessing) {
      badge.innerHTML = `<svg class="processing-spinner" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
        <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
      </svg>`;
    } else {
      badge.textContent = queuePosition;
    }
    overlay.appendChild(badge);

    // Model name label
    if (item.model_id) {
      const modelLabel = document.createElement("div");
      modelLabel.className = "queue-model-label";
      modelLabel.textContent =
        getModelDisplayName(item.model_id) || item.model_id;
      overlay.appendChild(modelLabel);
    }

    // Cancel button (visible on hover) - for both processing and queued
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "queue-cancel-btn";
    cancelBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
      <line x1="10" y1="11" x2="10" y2="17"/>
      <line x1="14" y1="11" x2="14" y2="17"/>
    </svg>`;
    cancelBtn.title = isProcessing
      ? "Cancel this generation (in progress)"
      : "Cancel this generation";
    cancelBtn.onclick = (e) => {
      e.stopPropagation();
      cancelQueueItem(item.id);
    };
    overlay.appendChild(cancelBtn);

    return overlay;
  }

  // First, create overlays for processing items (with spinner)
  processingItems.forEach((item) => {
    const overlay = createOverlay(item, { isProcessing: true });
    if (overlay) {
      grid.appendChild(overlay);
    }
  });

  // Then, create overlays for queued items (with per-model position numbers)
  // Track position within each model's queue
  const modelPositionCounters = {};

  queueItems.forEach((item) => {
    const modelId = item.model_id || "default";
    // Initialize or increment the counter for this model
    if (!modelPositionCounters[modelId]) {
      modelPositionCounters[modelId] = 1;
    }
    const positionInModelQueue = modelPositionCounters[modelId];
    modelPositionCounters[modelId]++;

    const overlay = createOverlay(item, {
      queuePosition: positionInModelQueue,
    });
    if (overlay) {
      grid.appendChild(overlay);
    }
  });
}

// Cancel a specific queue item
async function cancelQueueItem(itemId) {
  try {
    const response = await fetch(`/api/queue/cancel/${itemId}`, {
      method: "POST",
    });
    const result = await response.json();

    if (result.success && result.cancelled) {
      showToast("success", "Cancelled", result.message);
      // Trigger immediate status update
      checkGenerationStatus();
    } else if (result.success && !result.cancelled) {
      showToast("info", "Not found", result.message);
    } else {
      showToast("error", "Error", result.error || "Failed to cancel");
    }
  } catch (error) {
    console.error("Cancel queue item failed:", error);
    showToast("error", "Error", "Failed to cancel queue item");
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

// Navigate to center the view on a specific coordinate
function navigateToCoord(targetX, targetY) {
  const params = getParams();
  const nx = parseInt(params.nx);
  const ny = parseInt(params.ny);
  // Center the target coordinate in the view
  const x = targetX - Math.floor(nx / 2);
  const y = targetY - Math.floor(ny / 2);
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

// Hard refresh - clear image cache and reload page
function hardRefresh() {
  // Add cache-busting timestamp to all tile images to force reload
  const timestamp = Date.now();

  // Update all tile image sources to bust cache
  document.querySelectorAll(".tile img").forEach((img) => {
    const url = new URL(img.src);
    url.searchParams.set("_t", timestamp);
    img.src = url.toString();
  });

  // Also reload the page with cache bypass
  // The true parameter forces reload from server, not cache
  window.location.reload(true);
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function toggleWaterHighlight() {
  const container = document.getElementById("gridContainer");
  const showWater = document.getElementById("showWater").checked;
  container.classList.toggle("show-water-highlight", showWater);

  // Save preference to localStorage
  try {
    localStorage.setItem("viewer_show_water_highlight", showWater ? "1" : "0");
  } catch (e) {
    console.warn("Could not save water highlight preference:", e);
  }
}

// Initialize water highlight state from localStorage
function initWaterHighlight() {
  try {
    const saved = localStorage.getItem("viewer_show_water_highlight");
    if (saved === "1") {
      const checkbox = document.getElementById("showWater");
      if (checkbox) {
        checkbox.checked = true;
        toggleWaterHighlight();
      }
    }
  } catch (e) {
    // Ignore localStorage errors
  }
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  // Ignore keyboard shortcuts when prompt dialog is open
  const promptDialog = document.getElementById("promptDialog");
  if (promptDialog && promptDialog.style.display !== "none") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "t":
    case "T":
      toggleWaterSelectTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      if (waterSelectToolActive) cancelWaterSelect();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate other tools if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }
  if (waterSelectToolActive) {
    cancelWaterSelect();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
    saveSelectedTool("select");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
    saveSelectedTool("");
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate other tools if active
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }
  if (waterSelectToolActive) {
    cancelWaterSelect();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
    saveSelectedTool("fixwater");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar
    waterFixStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }
  if (waterSelectToolActive) {
    cancelWaterSelect();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar
    waterFillStatus.style.display = "flex";
    saveSelectedTool("waterfill");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar
    waterFillStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

// Water Select tool - marks quadrants as water tiles
let waterSelectToolActive = false;

function toggleWaterSelectTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }

  waterSelectToolActive = !waterSelectToolActive;
  const btn = document.getElementById("waterSelectTool");
  const tiles = document.querySelectorAll(".tile");
  const waterSelectStatus = document.getElementById("waterSelectStatus");

  if (waterSelectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-select-selectable");
    });
    // Show water select status bar
    waterSelectStatus.style.display = "flex";
    saveSelectedTool("waterselect");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-select-selectable");
    });
    // Hide water select status bar
    waterSelectStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function cancelWaterSelect() {
  if (waterSelectToolActive) {
    toggleWaterSelectTool();
  }
}

async function handleWaterSelectClick(tileEl) {
  if (!waterSelectToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Check current water status
  const isCurrentlyWater = tileEl.dataset.water === "true";
  const newWaterStatus = !isCurrentlyWater;

  const instruction = document.getElementById("waterSelectInstruction");
  instruction.textContent = `Updating (${qx}, ${qy})...`;

  try {
    const response = await fetch("/api/water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        quadrants: [[qx, qy]],
        is_water: newWaterStatus,
      }),
    });

    const result = await response.json();

    if (result.success) {
      // Update the tile's visual state
      if (newWaterStatus) {
        tileEl.classList.add("water");
        tileEl.dataset.water = "true";
        // Add water indicator if it doesn't exist
        if (!tileEl.querySelector(".water-indicator")) {
          const indicator = document.createElement("span");
          indicator.className = "water-indicator";
          indicator.title = "Water tile";
          indicator.textContent = "üíß";
          tileEl.appendChild(indicator);
        }
        showToast("success", "Marked as water", `Quadrant (${qx}, ${qy})`);
      } else {
        tileEl.classList.remove("water");
        tileEl.dataset.water = "false";
        // Remove water indicator
        const indicator = tileEl.querySelector(".water-indicator");
        if (indicator) {
          indicator.remove();
        }
        showToast("info", "Unmarked as water", `Quadrant (${qx}, ${qy})`);
      }

      instruction.textContent = "Click quadrants to toggle water status";
    } else {
      showToast("error", "Failed to update", result.error || "Unknown error");
      instruction.textContent = "Click quadrants to toggle water status";
    }
  } catch (error) {
    console.error("Water select error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click quadrants to toggle water status";
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const flagBtn = document.getElementById("flagBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    // Show all active models generating
    const activeModels = serverStatus.active_models || [];
    const processingQuadrants =
      serverStatus.all_processing_quadrants || serverStatus.quadrants || [];

    if (activeModels.length > 0 && processingQuadrants.length > 0) {
      // Show which models are actively generating with their queue counts
      const queueByModel = serverStatus.queue_by_model || {};

      if (activeModels.length === 1) {
        const modelId = activeModels[0];
        const modelName = getModelDisplayName(modelId) || modelId || "default";
        const modelInfo = queueByModel[modelId];
        const queueCount = modelInfo
          ? modelInfo.pending_count + (modelInfo.is_processing ? 1 : 0)
          : 0;
        // Create clickable coordinate links
        const coordsHtml = processingQuadrants
          .map(
            ([x, y]) =>
              `<a href="#" class="coord-link" data-x="${x}" data-y="${y}">(${x},${y})</a>`
          )
          .join(" ");
        const countStr = queueCount > 0 ? ` [${queueCount}]` : "";
        statusParts.push({
          html: `üîÑ ${modelName}${countStr}: ${coordsHtml}`,
        });
      } else {
        // Multiple models generating in parallel - show each with queue count and coords
        const queueByModel = serverStatus.queue_by_model || {};
        const modelPartsHtml = activeModels.map((modelId) => {
          const name = getModelDisplayName(modelId) || modelId || "default";
          const modelInfo = queueByModel[modelId];
          const queueCount = modelInfo
            ? modelInfo.pending_count + (modelInfo.is_processing ? 1 : 0)
            : 0;
          // Get quadrants for this specific model
          const modelQuadrants =
            modelInfo && modelInfo.current_item
              ? modelInfo.current_item.quadrants || []
              : [];
          const coordsHtml =
            modelQuadrants.length > 0
              ? " " +
                modelQuadrants
                  .map(
                    ([x, y]) =>
                      `<a href="#" class="coord-link" data-x="${x}" data-y="${y}">(${x},${y})</a>`
                  )
                  .join(" ")
              : "";
          const countStr = queueCount > 0 ? ` [${queueCount}]` : "";
          return `${name}${countStr}${coordsHtml}`;
        });
        statusParts.push({ html: `üîÑ ${modelPartsHtml.join(", ")}` });
      }
    } else if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      // Fallback to old behavior with clickable coords
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsHtml = serverStatus.quadrants
        .map(
          ([x, y]) =>
            `<a href="#" class="coord-link" data-x="${x}" data-y="${y}">(${x},${y})</a>`
        )
        .join(" ");
      statusParts.push({ html: `${action} ${coordsHtml}` });
    }

    // Show per-model queue counts (only models with items)
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      const queueParts = modelQueues
        .map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return { name, count };
        })
        .filter(({ count }) => count > 0)
        .map(({ name, count }) => `${name}: ${count}`);

      if (queueParts.length > 0) {
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    }
  }

  // Update selection display in toolbar-info (separate from status)
  const selectedDisplay = document.getElementById("selectedQuadrantsDisplay");
  if (selectedDisplay) {
    if (count > 0) {
      const coordsStr = Array.from(selectedQuadrants)
        .map((key) => {
          const [x, y] = key.split(",");
          return `(${x},${y})`;
        })
        .join(" ");
      selectedDisplay.textContent = `‚úì ${coordsStr}`;
      selectedDisplay.style.display = "";
    } else {
      selectedDisplay.textContent = "";
      selectedDisplay.style.display = "none";
    }
  }

  // Build status display - some parts may be HTML objects, others plain strings
  if (countEl) {
    if (statusParts.length > 0) {
      const statusHtml = statusParts
        .map((part) =>
          typeof part === "object" && part.html ? part.html : part
        )
        .join(" ‚Ä¢ ");
      countEl.innerHTML = statusHtml;

      // Add click handlers for coordinate links
      countEl.querySelectorAll(".coord-link").forEach((link) => {
        link.addEventListener("click", (e) => {
          e.preventDefault();
          const x = parseInt(link.dataset.x, 10);
          const y = parseInt(link.dataset.y, 10);
          navigateToCoord(x, y);
        });
      });
    } else if (count > 0) {
      countEl.textContent = `${count} selected`;
    } else {
      countEl.textContent = "";
    }
  }

  // Update status bar styling and visibility
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (statusEl) {
    if (isProcessing) {
      statusEl.classList.add("generating");
      statusEl.style.display = "";
    } else {
      statusEl.classList.remove("generating");
      // Hide the status row if there's no content
      const hasContent = countEl && countEl.textContent.trim() !== "";
      statusEl.style.display = hasContent ? "" : "none";
    }
  }

  // Enable buttons for selection (can add to queue even during processing)
  if (deselectBtn) deselectBtn.disabled = count === 0;
  if (deleteBtn) deleteBtn.disabled = count === 0;
  if (flagBtn) flagBtn.disabled = count === 0;
  if (renderBtn) renderBtn.disabled = count === 0;
  if (generateBtn) generateBtn.disabled = count === 0;
  // Generate with prompt button
  const generateWithPromptBtn = document.getElementById(
    "generateWithPromptBtn"
  );
  if (generateWithPromptBtn) {
    generateWithPromptBtn.disabled = count === 0;
  }
  // Generate Rectangle requires exactly 2 selected
  if (generateRectBtn) generateRectBtn.disabled = count !== 2;
  // Export Cmd requires exactly 2 selected
  const exportCmdBtn = document.getElementById("exportCmdBtn");
  if (exportCmdBtn) exportCmdBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Check if we're in render view mode
  const isRenderMode = document.getElementById("showRender")?.checked || false;
  const dataType = isRenderMode ? "render" : "generation";
  const apiEndpoint = isRenderMode ? "/api/delete-render" : "/api/delete";

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete ${dataType} data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch(apiEndpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function flagSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Check if any selected tiles are already flagged - if so, unflag them
  let anyFlagged = false;
  coords.forEach(([x, y]) => {
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
    if (tile && tile.dataset.flagged === "true") {
      anyFlagged = true;
    }
  });

  // Toggle: if any are flagged, unflag all; otherwise flag all
  const shouldFlag = !anyFlagged;

  try {
    const response = await fetch("/api/flag", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords, flag: shouldFlag }),
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        result.flagged ? "Flagged" : "Unflagged",
        result.message
      );

      // Update tile visual state
      coords.forEach(([x, y]) => {
        const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
        if (tile) {
          if (shouldFlag) {
            tile.classList.add("flagged");
            tile.dataset.flagged = "true";
          } else {
            tile.classList.remove("flagged");
            tile.dataset.flagged = "false";
          }
        }
      });

      // Deselect after flagging
      deselectAll();
    } else {
      showToast("error", "Flag failed", result.error);
    }
  } catch (error) {
    console.error("Flag error:", error);
    showToast("error", "Flag failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

// Prompt dialog functions
function showPromptDialog() {
  if (selectedQuadrants.size === 0) return;
  const dialog = document.getElementById("promptDialog");
  const input = document.getElementById("promptInput");
  if (dialog && input) {
    input.value = "";
    dialog.style.display = "flex";
    input.focus();
  }
}

function hidePromptDialog() {
  const dialog = document.getElementById("promptDialog");
  if (dialog) {
    dialog.style.display = "none";
  }
}

async function submitPromptGeneration() {
  const input = document.getElementById("promptInput");
  const prompt = input ? input.value.trim() : "";
  hidePromptDialog();
  await generateSelected(prompt);
}

async function generateSelected(prompt = null) {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();

  // Build context info for toast
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  const promptMsg = prompt ? " with prompt" : "";

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    // Include prompt if provided
    if (prompt) {
      requestBody.prompt = prompt;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log(
        "Generation queued at position:",
        result.position,
        "model:",
        result.model_id
      );
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `${toGenerate.length} quadrant(s)${promptMsg}${contextMsg} ‚Üí position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `${coords.length} quadrant(s) for render ‚Üí position ${result.position}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

async function copyExportCommand() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the export bounds."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  // Build the export command
  const command = `uv run python src/isometric_nyc/e2e_generation/export_import_generation_tile.py generations/v01 --tl='${minX},${minY}' --br='${maxX},${maxY}' --overwrite`;

  try {
    await navigator.clipboard.writeText(command);
    showToast(
      "success",
      "Command copied!",
      `Export command for (${minX},${minY}) to (${maxX},${maxY}) copied to clipboard`
    );
    console.log("Copied export command:", command);
  } catch (error) {
    console.error("Failed to copy to clipboard:", error);
    showToast(
      "error",
      "Copy failed",
      "Could not copy to clipboard. Check browser permissions."
    );
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  saveSelectedQuadrants();
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated (locked = actively processing)
  // Note: queued tiles CAN be selected (e.g., to cancel or manage them)
  const key = `${qx},${qy}`;
  if (tileEl.classList.contains("locked")) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently being processed`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  saveSelectedQuadrants();
  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle water select tool clicks
    if (waterSelectToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterSelectClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;
let lastProcessingQuadrants = new Set(); // Track quadrants that were processing

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

// Refresh a specific tile's image (or add image if it was a placeholder)
function refreshTileImage(qx, qy) {
  const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
  if (!tile) return;

  const showRender = document.getElementById("showRender")?.checked ? "1" : "0";
  const timestamp = Date.now();
  const imgUrl = `/tile/${qx}/${qy}?render=${showRender}&_t=${timestamp}`;

  let img = tile.querySelector("img");
  if (img) {
    // Update existing image
    img.src = imgUrl;
  } else {
    // Create new image for placeholder tile
    img = document.createElement("img");
    img.src = imgUrl;
    img.alt = `Tile ${qx},${qy}`;
    img.onload = () => {
      // Remove placeholder class once image loads
      tile.classList.remove("placeholder");
    };
    tile.appendChild(img);
  }
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes - consider active_model_count for parallel processing
    const wasGenerating = isGenerating || isRendering;
    const hasActiveModels = (status.active_model_count || 0) > 0;
    isGenerating =
      (status.is_generating || hasActiveModels) &&
      status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Get current processing quadrants
    const currentProcessingQuadrants = new Set(
      (status.all_processing_quadrants || status.quadrants || []).map(
        ([x, y]) => `${x},${y}`
      )
    );

    // Detect quadrants that just finished processing (were processing, now not)
    const completedQuadrants = [];
    lastProcessingQuadrants.forEach((coordKey) => {
      if (!currentProcessingQuadrants.has(coordKey)) {
        completedQuadrants.push(coordKey);
      }
    });

    // Refresh tiles for completed quadrants
    if (completedQuadrants.length > 0) {
      console.log("Refreshing completed quadrants:", completedQuadrants);
      completedQuadrants.forEach((coordKey) => {
        const [qx, qy] = coordKey.split(",").map(Number);
        refreshTileImage(qx, qy);
      });
    }

    // Update tracking for next poll
    lastProcessingQuadrants = currentProcessingQuadrants;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = "";
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              const count = info.pending_count + (info.is_processing ? 1 : 0);
              return { name, count };
            })
            .filter(({ count }) => count > 0)
            .map(({ name, count }) => `${name}: ${count}`);
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        if (queueMsg) {
          showToast("info", "Processing queue", queueMsg);
        }
      } else {
        // No more items - tiles already refreshed, just stop polling
        stopStatusPolling();
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Restore saved tool on page load
function restoreSavedTool() {
  const savedTool = getSavedTool();
  if (!savedTool) return;

  // Check if the tool button exists before activating
  switch (savedTool) {
    case "select":
      if (document.getElementById("selectTool")) {
        toggleSelectTool();
      }
      break;
    case "fixwater":
      if (document.getElementById("fixWaterTool")) {
        toggleFixWaterTool();
      }
      break;
    case "waterfill":
      if (document.getElementById("waterFillTool")) {
        toggleWaterFillTool();
      }
      break;
    case "waterselect":
      if (document.getElementById("waterSelectTool")) {
        toggleWaterSelectTool();
      }
      break;
    default:
      // Unknown tool, clear saved state
      saveSelectedTool("");
      break;
  }
}

// Restore saved quadrant selections on page load
function restoreSavedQuadrants() {
  const savedQuadrants = getSavedQuadrants();
  if (!savedQuadrants || savedQuadrants.length === 0) return;

  let restoredCount = 0;

  savedQuadrants.forEach((key) => {
    // Check if this quadrant tile exists on the current page
    const tile = document.querySelector(`.tile[data-coords="${key}"]`);
    if (tile) {
      // Don't restore if tile is locked (actively processing)
      // Queued tiles CAN be selected
      if (!tile.classList.contains("locked")) {
        selectedQuadrants.add(key);
        tile.classList.add("selected");
        restoredCount++;
      }
    }
  });

  if (restoredCount > 0) {
    console.log(`Restored ${restoredCount} selected quadrant(s)`);
    // Update localStorage to only contain valid selections
    saveSelectedQuadrants();
    updateSelectionStatus();
  } else if (savedQuadrants.length > 0) {
    // Had saved selections but none are on current page - clear storage
    saveSelectedQuadrants();
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  // Restore saved tool
  restoreSavedTool();

  // Restore saved quadrant selections
  restoreSavedQuadrants();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

Now I need to add the initialization call for water highlight in the initialize function:

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// LocalStorage keys for persistence
const STORAGE_KEY_MODEL = "viewer_selected_model";
const STORAGE_KEY_TOOL = "viewer_selected_tool";
const STORAGE_KEY_SELECTION = "viewer_selected_quadrants";

// Save selected model ID to localStorage
function saveSelectedModel(modelId) {
  try {
    localStorage.setItem(STORAGE_KEY_MODEL, modelId);
  } catch (e) {
    console.warn("Could not save model to localStorage:", e);
  }
}

// Get saved model ID from localStorage
function getSavedModel() {
  try {
    return localStorage.getItem(STORAGE_KEY_MODEL);
  } catch (e) {
    return null;
  }
}

// Save selected tool to localStorage
function saveSelectedTool(toolName) {
  try {
    localStorage.setItem(STORAGE_KEY_TOOL, toolName || "");
  } catch (e) {
    console.warn("Could not save tool to localStorage:", e);
  }
}

// Get saved tool from localStorage
function getSavedTool() {
  try {
    return localStorage.getItem(STORAGE_KEY_TOOL) || "";
  } catch (e) {
    return "";
  }
}

// Save selected quadrants to localStorage
function saveSelectedQuadrants() {
  try {
    const quadrantsArray = Array.from(selectedQuadrants);
    localStorage.setItem(STORAGE_KEY_SELECTION, JSON.stringify(quadrantsArray));
  } catch (e) {
    console.warn("Could not save selection to localStorage:", e);
  }
}

// Get saved quadrants from localStorage
function getSavedQuadrants() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY_SELECTION);
    return saved ? JSON.parse(saved) : [];
  } catch (e) {
    return [];
  }
}

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Check if saved model ID exists in available models
  const savedModelId = getSavedModel();
  const savedModelExists =
    savedModelId && config.models.some((m) => m.model_id === savedModelId);

  // Add options for each model
  config.models.forEach((model, index) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;

    // Select saved model if it exists, otherwise use default or first
    if (savedModelExists && model.model_id === savedModelId) {
      option.selected = true;
    } else if (
      !savedModelExists &&
      model.model_id === config.default_model_id
    ) {
      option.selected = true;
    } else if (!savedModelExists && !config.default_model_id && index === 0) {
      option.selected = true;
    }
    select.appendChild(option);
  });

  // Auto-blur after selection and save to localStorage
  select.addEventListener("change", () => {
    saveSelectedModel(select.value);
    select.blur();
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to ALL currently processing quadrants (from all models)
  const processingQuadrants =
    status.all_processing_quadrants || status.quadrants || [];
  const isProcessing = status.is_generating || status.active_model_count > 0;

  if (isProcessing && processingQuadrants.length > 0) {
    document.body.classList.add("generating");
    processingQuadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else if (!isProcessing) {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items AND create overlays
  // Also create overlays for processing items
  const processingItems = getProcessingItems(status);
  updateQueueOverlays(status.queue || [], processingItems);
}

// Extract currently processing items from status
function getProcessingItems(status) {
  const processingItems = [];
  if (status.queue_by_model) {
    Object.entries(status.queue_by_model).forEach(([modelId, info]) => {
      if (info.is_processing && info.current_item) {
        processingItems.push({
          ...info.current_item,
          model_id: modelId,
          _isProcessing: true,
        });
      }
    });
  }
  return processingItems;
}

// Create/update overlays for pending queue items and processing items
function updateQueueOverlays(queueItems, processingItems = []) {
  // Remove existing overlays
  document.querySelectorAll(".queue-overlay").forEach((el) => el.remove());

  // Also clear queued class from all tiles
  document.querySelectorAll(".tile.queued").forEach((tile) => {
    tile.classList.remove("queued");
  });

  const hasItems =
    (queueItems && queueItems.length > 0) ||
    (processingItems && processingItems.length > 0);
  if (!hasItems) return;

  const grid = document.querySelector(".grid");
  if (!grid) return;

  // Get grid dimensions from config
  const gridX = config.x;
  const gridY = config.y;
  const sizePx = config.size_px;
  const showLines = document.getElementById("showLines")?.checked || false;
  const gap = showLines ? 2 : 0;

  // Helper function to create an overlay for an item
  function createOverlay(item, options = {}) {
    const { isProcessing = false, queuePosition = null } = options;

    if (!item.quadrants || item.quadrants.length === 0) return null;

    // Calculate bounding box for this generation
    const quadrants = item.quadrants;
    let minCol = Infinity,
      maxCol = -Infinity;
    let minRow = Infinity,
      maxRow = -Infinity;

    // Track which tiles are visible in the current view
    const visibleQuadrants = [];

    quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        visibleQuadrants.push([qx, qy]);
        const col = qx - gridX;
        const row = qy - gridY;
        minCol = Math.min(minCol, col);
        maxCol = Math.max(maxCol, col);
        minRow = Math.min(minRow, row);
        maxRow = Math.max(maxRow, row);

        // Add appropriate class to tile
        if (isProcessing) {
          tile.classList.add("locked");
        } else if (!tile.classList.contains("locked")) {
          tile.classList.add("queued");
        }
      }
    });

    if (visibleQuadrants.length === 0) return null;

    // Create overlay element
    const overlay = document.createElement("div");
    overlay.className = isProcessing
      ? "queue-overlay processing"
      : "queue-overlay";
    overlay.dataset.itemId = item.id;

    // Calculate position and size
    const left = minCol * (sizePx + gap);
    const top = minRow * (sizePx + gap);
    const width = (maxCol - minCol + 1) * sizePx + (maxCol - minCol) * gap;
    const height = (maxRow - minRow + 1) * sizePx + (maxRow - minRow) * gap;

    overlay.style.left = `${left}px`;
    overlay.style.top = `${top}px`;
    overlay.style.width = `${width}px`;
    overlay.style.height = `${height}px`;

    // Badge: spinner for processing, number for queued
    const badge = document.createElement("div");
    badge.className = isProcessing ? "queue-badge processing" : "queue-badge";
    if (isProcessing) {
      badge.innerHTML = `<svg class="processing-spinner" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
        <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
      </svg>`;
    } else {
      badge.textContent = queuePosition;
    }
    overlay.appendChild(badge);

    // Model name label
    if (item.model_id) {
      const modelLabel = document.createElement("div");
      modelLabel.className = "queue-model-label";
      modelLabel.textContent =
        getModelDisplayName(item.model_id) || item.model_id;
      overlay.appendChild(modelLabel);
    }

    // Cancel button (visible on hover) - for both processing and queued
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "queue-cancel-btn";
    cancelBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
      <line x1="10" y1="11" x2="10" y2="17"/>
      <line x1="14" y1="11" x2="14" y2="17"/>
    </svg>`;
    cancelBtn.title = isProcessing
      ? "Cancel this generation (in progress)"
      : "Cancel this generation";
    cancelBtn.onclick = (e) => {
      e.stopPropagation();
      cancelQueueItem(item.id);
    };
    overlay.appendChild(cancelBtn);

    return overlay;
  }

  // First, create overlays for processing items (with spinner)
  processingItems.forEach((item) => {
    const overlay = createOverlay(item, { isProcessing: true });
    if (overlay) {
      grid.appendChild(overlay);
    }
  });

  // Then, create overlays for queued items (with per-model position numbers)
  // Track position within each model's queue
  const modelPositionCounters = {};

  queueItems.forEach((item) => {
    const modelId = item.model_id || "default";
    // Initialize or increment the counter for this model
    if (!modelPositionCounters[modelId]) {
      modelPositionCounters[modelId] = 1;
    }
    const positionInModelQueue = modelPositionCounters[modelId];
    modelPositionCounters[modelId]++;

    const overlay = createOverlay(item, {
      queuePosition: positionInModelQueue,
    });
    if (overlay) {
      grid.appendChild(overlay);
    }
  });
}

// Cancel a specific queue item
async function cancelQueueItem(itemId) {
  try {
    const response = await fetch(`/api/queue/cancel/${itemId}`, {
      method: "POST",
    });
    const result = await response.json();

    if (result.success && result.cancelled) {
      showToast("success", "Cancelled", result.message);
      // Trigger immediate status update
      checkGenerationStatus();
    } else if (result.success && !result.cancelled) {
      showToast("info", "Not found", result.message);
    } else {
      showToast("error", "Error", result.error || "Failed to cancel");
    }
  } catch (error) {
    console.error("Cancel queue item failed:", error);
    showToast("error", "Error", "Failed to cancel queue item");
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

// Navigate to center the view on a specific coordinate
function navigateToCoord(targetX, targetY) {
  const params = getParams();
  const nx = parseInt(params.nx);
  const ny = parseInt(params.ny);
  // Center the target coordinate in the view
  const x = targetX - Math.floor(nx / 2);
  const y = targetY - Math.floor(ny / 2);
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

// Hard refresh - clear image cache and reload page
function hardRefresh() {
  // Add cache-busting timestamp to all tile images to force reload
  const timestamp = Date.now();

  // Update all tile image sources to bust cache
  document.querySelectorAll(".tile img").forEach((img) => {
    const url = new URL(img.src);
    url.searchParams.set("_t", timestamp);
    img.src = url.toString();
  });

  // Also reload the page with cache bypass
  // The true parameter forces reload from server, not cache
  window.location.reload(true);
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function toggleWaterHighlight() {
  const container = document.getElementById("gridContainer");
  const showWater = document.getElementById("showWater").checked;
  container.classList.toggle("show-water-highlight", showWater);

  // Save preference to localStorage
  try {
    localStorage.setItem("viewer_show_water_highlight", showWater ? "1" : "0");
  } catch (e) {
    console.warn("Could not save water highlight preference:", e);
  }
}

// Initialize water highlight state from localStorage
function initWaterHighlight() {
  try {
    const saved = localStorage.getItem("viewer_show_water_highlight");
    if (saved === "1") {
      const checkbox = document.getElementById("showWater");
      if (checkbox) {
        checkbox.checked = true;
        toggleWaterHighlight();
      }
    }
  } catch (e) {
    // Ignore localStorage errors
  }
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  // Ignore keyboard shortcuts when prompt dialog is open
  const promptDialog = document.getElementById("promptDialog");
  if (promptDialog && promptDialog.style.display !== "none") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "t":
    case "T":
      toggleWaterSelectTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      if (waterSelectToolActive) cancelWaterSelect();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate other tools if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }
  if (waterSelectToolActive) {
    cancelWaterSelect();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
    saveSelectedTool("select");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
    saveSelectedTool("");
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate other tools if active
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }
  if (waterSelectToolActive) {
    cancelWaterSelect();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
    saveSelectedTool("fixwater");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar
    waterFixStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }
  if (waterSelectToolActive) {
    cancelWaterSelect();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar
    waterFillStatus.style.display = "flex";
    saveSelectedTool("waterfill");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar
    waterFillStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

// Water Select tool - marks quadrants as water tiles
let waterSelectToolActive = false;

function toggleWaterSelectTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }

  waterSelectToolActive = !waterSelectToolActive;
  const btn = document.getElementById("waterSelectTool");
  const tiles = document.querySelectorAll(".tile");
  const waterSelectStatus = document.getElementById("waterSelectStatus");

  if (waterSelectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-select-selectable");
    });
    // Show water select status bar
    waterSelectStatus.style.display = "flex";
    saveSelectedTool("waterselect");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-select-selectable");
    });
    // Hide water select status bar
    waterSelectStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function cancelWaterSelect() {
  if (waterSelectToolActive) {
    toggleWaterSelectTool();
  }
}

async function handleWaterSelectClick(tileEl) {
  if (!waterSelectToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Check current water status
  const isCurrentlyWater = tileEl.dataset.water === "true";
  const newWaterStatus = !isCurrentlyWater;

  const instruction = document.getElementById("waterSelectInstruction");
  instruction.textContent = `Updating (${qx}, ${qy})...`;

  try {
    const response = await fetch("/api/water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        quadrants: [[qx, qy]],
        is_water: newWaterStatus,
      }),
    });

    const result = await response.json();

    if (result.success) {
      // Update the tile's visual state
      if (newWaterStatus) {
        tileEl.classList.add("water");
        tileEl.dataset.water = "true";
        // Add water indicator if it doesn't exist
        if (!tileEl.querySelector(".water-indicator")) {
          const indicator = document.createElement("span");
          indicator.className = "water-indicator";
          indicator.title = "Water tile";
          indicator.textContent = "üíß";
          tileEl.appendChild(indicator);
        }
        showToast("success", "Marked as water", `Quadrant (${qx}, ${qy})`);
      } else {
        tileEl.classList.remove("water");
        tileEl.dataset.water = "false";
        // Remove water indicator
        const indicator = tileEl.querySelector(".water-indicator");
        if (indicator) {
          indicator.remove();
        }
        showToast("info", "Unmarked as water", `Quadrant (${qx}, ${qy})`);
      }

      instruction.textContent = "Click quadrants to toggle water status";
    } else {
      showToast("error", "Failed to update", result.error || "Unknown error");
      instruction.textContent = "Click quadrants to toggle water status";
    }
  } catch (error) {
    console.error("Water select error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click quadrants to toggle water status";
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const flagBtn = document.getElementById("flagBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    // Show all active models generating
    const activeModels = serverStatus.active_models || [];
    const processingQuadrants =
      serverStatus.all_processing_quadrants || serverStatus.quadrants || [];

    if (activeModels.length > 0 && processingQuadrants.length > 0) {
      // Show which models are actively generating with their queue counts
      const queueByModel = serverStatus.queue_by_model || {};

      if (activeModels.length === 1) {
        const modelId = activeModels[0];
        const modelName = getModelDisplayName(modelId) || modelId || "default";
        const modelInfo = queueByModel[modelId];
        const queueCount = modelInfo
          ? modelInfo.pending_count + (modelInfo.is_processing ? 1 : 0)
          : 0;
        // Create clickable coordinate links
        const coordsHtml = processingQuadrants
          .map(
            ([x, y]) =>
              `<a href="#" class="coord-link" data-x="${x}" data-y="${y}">(${x},${y})</a>`
          )
          .join(" ");
        const countStr = queueCount > 0 ? ` [${queueCount}]` : "";
        statusParts.push({
          html: `üîÑ ${modelName}${countStr}: ${coordsHtml}`,
        });
      } else {
        // Multiple models generating in parallel - show each with queue count and coords
        const queueByModel = serverStatus.queue_by_model || {};
        const modelPartsHtml = activeModels.map((modelId) => {
          const name = getModelDisplayName(modelId) || modelId || "default";
          const modelInfo = queueByModel[modelId];
          const queueCount = modelInfo
            ? modelInfo.pending_count + (modelInfo.is_processing ? 1 : 0)
            : 0;
          // Get quadrants for this specific model
          const modelQuadrants =
            modelInfo && modelInfo.current_item
              ? modelInfo.current_item.quadrants || []
              : [];
          const coordsHtml =
            modelQuadrants.length > 0
              ? " " +
                modelQuadrants
                  .map(
                    ([x, y]) =>
                      `<a href="#" class="coord-link" data-x="${x}" data-y="${y}">(${x},${y})</a>`
                  )
                  .join(" ")
              : "";
          const countStr = queueCount > 0 ? ` [${queueCount}]` : "";
          return `${name}${countStr}${coordsHtml}`;
        });
        statusParts.push({ html: `üîÑ ${modelPartsHtml.join(", ")}` });
      }
    } else if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      // Fallback to old behavior with clickable coords
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsHtml = serverStatus.quadrants
        .map(
          ([x, y]) =>
            `<a href="#" class="coord-link" data-x="${x}" data-y="${y}">(${x},${y})</a>`
        )
        .join(" ");
      statusParts.push({ html: `${action} ${coordsHtml}` });
    }

    // Show per-model queue counts (only models with items)
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      const queueParts = modelQueues
        .map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return { name, count };
        })
        .filter(({ count }) => count > 0)
        .map(({ name, count }) => `${name}: ${count}`);

      if (queueParts.length > 0) {
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    }
  }

  // Update selection display in toolbar-info (separate from status)
  const selectedDisplay = document.getElementById("selectedQuadrantsDisplay");
  if (selectedDisplay) {
    if (count > 0) {
      const coordsStr = Array.from(selectedQuadrants)
        .map((key) => {
          const [x, y] = key.split(",");
          return `(${x},${y})`;
        })
        .join(" ");
      selectedDisplay.textContent = `‚úì ${coordsStr}`;
      selectedDisplay.style.display = "";
    } else {
      selectedDisplay.textContent = "";
      selectedDisplay.style.display = "none";
    }
  }

  // Build status display - some parts may be HTML objects, others plain strings
  if (countEl) {
    if (statusParts.length > 0) {
      const statusHtml = statusParts
        .map((part) =>
          typeof part === "object" && part.html ? part.html : part
        )
        .join(" ‚Ä¢ ");
      countEl.innerHTML = statusHtml;

      // Add click handlers for coordinate links
      countEl.querySelectorAll(".coord-link").forEach((link) => {
        link.addEventListener("click", (e) => {
          e.preventDefault();
          const x = parseInt(link.dataset.x, 10);
          const y = parseInt(link.dataset.y, 10);
          navigateToCoord(x, y);
        });
      });
    } else if (count > 0) {
      countEl.textContent = `${count} selected`;
    } else {
      countEl.textContent = "";
    }
  }

  // Update status bar styling and visibility
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (statusEl) {
    if (isProcessing) {
      statusEl.classList.add("generating");
      statusEl.style.display = "";
    } else {
      statusEl.classList.remove("generating");
      // Hide the status row if there's no content
      const hasContent = countEl && countEl.textContent.trim() !== "";
      statusEl.style.display = hasContent ? "" : "none";
    }
  }

  // Enable buttons for selection (can add to queue even during processing)
  if (deselectBtn) deselectBtn.disabled = count === 0;
  if (deleteBtn) deleteBtn.disabled = count === 0;
  if (flagBtn) flagBtn.disabled = count === 0;
  if (renderBtn) renderBtn.disabled = count === 0;
  if (generateBtn) generateBtn.disabled = count === 0;
  // Generate with prompt button
  const generateWithPromptBtn = document.getElementById(
    "generateWithPromptBtn"
  );
  if (generateWithPromptBtn) {
    generateWithPromptBtn.disabled = count === 0;
  }
  // Generate Rectangle requires exactly 2 selected
  if (generateRectBtn) generateRectBtn.disabled = count !== 2;
  // Export Cmd requires exactly 2 selected
  const exportCmdBtn = document.getElementById("exportCmdBtn");
  if (exportCmdBtn) exportCmdBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Check if we're in render view mode
  const isRenderMode = document.getElementById("showRender")?.checked || false;
  const dataType = isRenderMode ? "render" : "generation";
  const apiEndpoint = isRenderMode ? "/api/delete-render" : "/api/delete";

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete ${dataType} data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch(apiEndpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function flagSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Check if any selected tiles are already flagged - if so, unflag them
  let anyFlagged = false;
  coords.forEach(([x, y]) => {
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
    if (tile && tile.dataset.flagged === "true") {
      anyFlagged = true;
    }
  });

  // Toggle: if any are flagged, unflag all; otherwise flag all
  const shouldFlag = !anyFlagged;

  try {
    const response = await fetch("/api/flag", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords, flag: shouldFlag }),
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        result.flagged ? "Flagged" : "Unflagged",
        result.message
      );

      // Update tile visual state
      coords.forEach(([x, y]) => {
        const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
        if (tile) {
          if (shouldFlag) {
            tile.classList.add("flagged");
            tile.dataset.flagged = "true";
          } else {
            tile.classList.remove("flagged");
            tile.dataset.flagged = "false";
          }
        }
      });

      // Deselect after flagging
      deselectAll();
    } else {
      showToast("error", "Flag failed", result.error);
    }
  } catch (error) {
    console.error("Flag error:", error);
    showToast("error", "Flag failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

// Prompt dialog functions
function showPromptDialog() {
  if (selectedQuadrants.size === 0) return;
  const dialog = document.getElementById("promptDialog");
  const input = document.getElementById("promptInput");
  if (dialog && input) {
    input.value = "";
    dialog.style.display = "flex";
    input.focus();
  }
}

function hidePromptDialog() {
  const dialog = document.getElementById("promptDialog");
  if (dialog) {
    dialog.style.display = "none";
  }
}

async function submitPromptGeneration() {
  const input = document.getElementById("promptInput");
  const prompt = input ? input.value.trim() : "";
  hidePromptDialog();
  await generateSelected(prompt);
}

async function generateSelected(prompt = null) {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();

  // Build context info for toast
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  const promptMsg = prompt ? " with prompt" : "";

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    // Include prompt if provided
    if (prompt) {
      requestBody.prompt = prompt;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log(
        "Generation queued at position:",
        result.position,
        "model:",
        result.model_id
      );
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `${toGenerate.length} quadrant(s)${promptMsg}${contextMsg} ‚Üí position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `${coords.length} quadrant(s) for render ‚Üí position ${result.position}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

async function copyExportCommand() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the export bounds."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  // Build the export command
  const command = `uv run python src/isometric_nyc/e2e_generation/export_import_generation_tile.py generations/v01 --tl='${minX},${minY}' --br='${maxX},${maxY}' --overwrite`;

  try {
    await navigator.clipboard.writeText(command);
    showToast(
      "success",
      "Command copied!",
      `Export command for (${minX},${minY}) to (${maxX},${maxY}) copied to clipboard`
    );
    console.log("Copied export command:", command);
  } catch (error) {
    console.error("Failed to copy to clipboard:", error);
    showToast(
      "error",
      "Copy failed",
      "Could not copy to clipboard. Check browser permissions."
    );
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  saveSelectedQuadrants();
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated (locked = actively processing)
  // Note: queued tiles CAN be selected (e.g., to cancel or manage them)
  const key = `${qx},${qy}`;
  if (tileEl.classList.contains("locked")) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently being processed`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  saveSelectedQuadrants();
  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle water select tool clicks
    if (waterSelectToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterSelectClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;
let lastProcessingQuadrants = new Set(); // Track quadrants that were processing

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

// Refresh a specific tile's image (or add image if it was a placeholder)
function refreshTileImage(qx, qy) {
  const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
  if (!tile) return;

  const showRender = document.getElementById("showRender")?.checked ? "1" : "0";
  const timestamp = Date.now();
  const imgUrl = `/tile/${qx}/${qy}?render=${showRender}&_t=${timestamp}`;

  let img = tile.querySelector("img");
  if (img) {
    // Update existing image
    img.src = imgUrl;
  } else {
    // Create new image for placeholder tile
    img = document.createElement("img");
    img.src = imgUrl;
    img.alt = `Tile ${qx},${qy}`;
    img.onload = () => {
      // Remove placeholder class once image loads
      tile.classList.remove("placeholder");
    };
    tile.appendChild(img);
  }
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes - consider active_model_count for parallel processing
    const wasGenerating = isGenerating || isRendering;
    const hasActiveModels = (status.active_model_count || 0) > 0;
    isGenerating =
      (status.is_generating || hasActiveModels) &&
      status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Get current processing quadrants
    const currentProcessingQuadrants = new Set(
      (status.all_processing_quadrants || status.quadrants || []).map(
        ([x, y]) => `${x},${y}`
      )
    );

    // Detect quadrants that just finished processing (were processing, now not)
    const completedQuadrants = [];
    lastProcessingQuadrants.forEach((coordKey) => {
      if (!currentProcessingQuadrants.has(coordKey)) {
        completedQuadrants.push(coordKey);
      }
    });

    // Refresh tiles for completed quadrants
    if (completedQuadrants.length > 0) {
      console.log("Refreshing completed quadrants:", completedQuadrants);
      completedQuadrants.forEach((coordKey) => {
        const [qx, qy] = coordKey.split(",").map(Number);
        refreshTileImage(qx, qy);
      });
    }

    // Update tracking for next poll
    lastProcessingQuadrants = currentProcessingQuadrants;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = "";
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              const count = info.pending_count + (info.is_processing ? 1 : 0);
              return { name, count };
            })
            .filter(({ count }) => count > 0)
            .map(({ name, count }) => `${name}: ${count}`);
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        if (queueMsg) {
          showToast("info", "Processing queue", queueMsg);
        }
      } else {
        // No more items - tiles already refreshed, just stop polling
        stopStatusPolling();
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Restore saved tool on page load
function restoreSavedTool() {
  const savedTool = getSavedTool();
  if (!savedTool) return;

  // Check if the tool button exists before activating
  switch (savedTool) {
    case "select":
      if (document.getElementById("selectTool")) {
        toggleSelectTool();
      }
      break;
    case "fixwater":
      if (document.getElementById("fixWaterTool")) {
        toggleFixWaterTool();
      }
      break;
    case "waterfill":
      if (document.getElementById("waterFillTool")) {
        toggleWaterFillTool();
      }
      break;
    case "waterselect":
      if (document.getElementById("waterSelectTool")) {
        toggleWaterSelectTool();
      }
      break;
    default:
      // Unknown tool, clear saved state
      saveSelectedTool("");
      break;
  }
}

// Restore saved quadrant selections on page load
function restoreSavedQuadrants() {
  const savedQuadrants = getSavedQuadrants();
  if (!savedQuadrants || savedQuadrants.length === 0) return;

  let restoredCount = 0;

  savedQuadrants.forEach((key) => {
    // Check if this quadrant tile exists on the current page
    const tile = document.querySelector(`.tile[data-coords="${key}"]`);
    if (tile) {
      // Don't restore if tile is locked (actively processing)
      // Queued tiles CAN be selected
      if (!tile.classList.contains("locked")) {
        selectedQuadrants.add(key);
        tile.classList.add("selected");
        restoredCount++;
      }
    }
  });

  if (restoredCount > 0) {
    console.log(`Restored ${restoredCount} selected quadrant(s)`);
    // Update localStorage to only contain valid selections
    saveSelectedQuadrants();
    updateSelectionStatus();
  } else if (savedQuadrants.length > 0) {
    // Had saved selections but none are on current page - clear storage
    saveSelectedQuadrants();
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  // Initialize water highlight toggle
  initWaterHighlight();

  // Restore saved tool
  restoreSavedTool();

  // Restore saved quadrant selections
  restoreSavedQuadrants();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

Now let me update the debug_map.py to show water tiles as blue squares:

```python
"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_nyc/e2e_generation/debug_map.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_nyc.e2e_generation.shared import calculate_offset

# Simplified NYC borough boundaries GeoJSON (all 5 boroughs)
# Source: NYC Open Data (dwillis/nyc-maps), simplified using Douglas-Peucker algorithm
# fmt: off
NYC_BOUNDARY_GEOJSON = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8205, 40.801], [-73.8137, 40.7971], [-73.7964, 40.7957], [-73.7928, 40.7888], [-73.7817, 40.7911], [-73.7833, 40.7949], [-73.7769, 40.7964], [-73.7706, 40.7885], [-73.7763, 40.7885], [-73.7668, 40.7798], [-73.7651, 40.7738], [-73.7447, 40.7566], [-73.7551, 40.7675], [-73.7555, 40.7777], [-73.7508, 40.7829], [-73.7013, 40.7508], [-73.7, 40.7392], [-73.7077, 40.7278], [-73.7303, 40.7222], [-73.7269, 40.71], [-73.7256, 40.6796], [-73.7283, 40.663], [-73.7252, 40.652], [-73.7414, 40.6469], [-73.74, 40.6351], [-73.7437, 40.639], [-73.747, 40.6369], [-73.7473, 40.6432], [-73.7548, 40.6478], [-73.7474, 40.6414], [-73.7486, 40.6354], [-73.765, 40.6294], [-73.7708, 40.62], [-73.7717, 40.6236], [-73.7752, 40.6193], [-73.7717, 40.6236], [-73.7792, 40.6273], [-73.7852, 40.6201], [-73.7809, 40.6136], [-73.7914, 40.6076], [-73.8008, 40.6119], [-73.7946, 40.6226], [-73.7897, 40.6226], [-73.7826, 40.6302], [-73.7895, 40.6343], [-73.7981, 40.631], [-73.7908, 40.6343], [-73.8212, 40.6491], [-73.8223, 40.6594], [-73.8113, 40.6606], [-73.8235, 40.6601], [-73.8231, 40.648], [-73.8309, 40.6516], [-73.8302, 40.6598], [-73.8319, 40.6549], [-73.831, 40.6582], [-73.8334, 40.6581], [-73.8311, 40.6486], [-73.8343, 40.6481], [-73.8387, 40.6625], [-73.8359, 40.6455], [-73.8495, 40.6441], [-73.8524, 40.6474], [-73.8494, 40.6514], [-73.8559, 40.6513], [-73.8614, 40.6564], [-73.8596, 40.6585], [-73.8632, 40.6583], [-73.8557, 40.6639], [-73.8576, 40.6717], [-73.8604, 40.6713], [-73.866, 40.6819], [-73.8689, 40.6952], [-73.8965, 40.6823], [-73.9058, 40.6941], [-73.9043, 40.6957], [-73.9219, 40.7094], [-73.9241, 40.7151], [-73.9206, 40.716], [-73.9252, 40.7223], [-73.9204, 40.7237], [-73.938, 40.7305], [-73.9459, 40.7375], [-73.9386, 40.7429], [-73.9472, 40.7379], [-73.9626, 40.7388], [-73.9568, 40.7488], [-73.9532, 40.7477], [-73.9562, 40.7497], [-73.9435, 40.7645], [-73.9349, 40.77], [-73.9378, 40.7736], [-73.9364, 40.7769], [-73.9286, 40.7766], [-73.9099, 40.7909], [-73.8959, 40.7856], [-73.9026, 40.7803], [-73.8944, 40.7842], [-73.8953, 40.7816], [-73.8917, 40.7822], [-73.8925, 40.7774], [-73.8918, 40.7749], [-73.8901, 40.7778], [-73.8895, 40.7735], [-73.8839, 40.7741], [-73.8849, 40.78], [-73.8787, 40.7806], [-73.8797, 40.7829], [-73.8752, 40.7815], [-73.8679, 40.7874], [-73.8726, 40.7808], [-73.8551, 40.7722], [-73.8582, 40.7703], [-73.8562, 40.7689], [-73.8628, 40.7668], [-73.8507, 40.7594], [-73.8391, 40.766], [-73.8478, 40.7668], [-73.8513, 40.7718], [-73.849, 40.778], [-73.8524, 40.7792], [-73.8492, 40.7823], [-73.8553, 40.782], [-73.8595, 40.7855], [-73.8528, 40.7882], [-73.8537, 40.794], [-73.8379, 40.7985], [-73.8403, 40.7976], [-73.8373, 40.789], [-73.8329, 40.7885], [-73.8279, 40.7929], [-73.8295, 40.7968], [-73.8205, 40.801]]]}}, {"type": "Feature", "properties": {"name": "Brooklyn"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9544, 40.7391], [-73.9292, 40.7274], [-73.9246, 40.7192], [-73.9322, 40.715], [-73.9333, 40.711], [-73.9304, 40.7087], [-73.9309, 40.7149], [-73.9236, 40.7173], [-73.9219, 40.7094], [-73.9043, 40.6957], [-73.9058, 40.6941], [-73.8965, 40.6823], [-73.8684, 40.6947], [-73.866, 40.6819], [-73.8604, 40.6713], [-73.8576, 40.6717], [-73.8557, 40.6639], [-73.8633, 40.6569], [-73.857, 40.6506], [-73.8572, 40.6437], [-73.8656, 40.6388], [-73.8793, 40.6546], [-73.868, 40.6381], [-73.8744, 40.6367], [-73.891, 40.6494], [-73.8771, 40.636], [-73.8836, 40.6309], [-73.8837, 40.6276], [-73.8875, 40.6283], [-73.8958, 40.6225], [-73.9175, 40.6314], [-73.8965, 40.6214], [-73.8959, 40.6145], [-73.891, 40.6128], [-73.894, 40.6112], [-73.8897, 40.6115], [-73.8933, 40.6067], [-73.8998, 40.6055], [-73.9013, 40.6117], [-73.9088, 40.6174], [-73.9016, 40.6058], [-73.9137, 40.604], [-73.9171, 40.6088], [-73.9142, 40.6149], [-73.9195, 40.6077], [-73.9089, 40.6016], [-73.884, 40.6056], [-73.8767, 40.5849], [-73.8797, 40.5801], [-73.8955, 40.5768], [-73.899, 40.5877], [-73.9115, 40.5861], [-73.9151, 40.5988], [-73.9215, 40.6019], [-73.9249, 40.5998], [-73.9302, 40.604], [-73.9321, 40.6027], [-73.9142, 40.5892], [-73.9248, 40.5856], [-73.9281, 40.5877], [-73.924, 40.5911], [-73.9286, 40.5886], [-73.9326, 40.5949], [-73.9313, 40.5868], [-73.9135, 40.5861], [-73.9125, 40.5834], [-73.9173, 40.5832], [-73.9115, 40.5818], [-73.9535, 40.583], [-73.9326, 40.5813], [-73.9311, 40.5762], [-74.0021, 40.5696], [-74.012, 40.5749], [-74.0119, 40.5797], [-74.006, 40.582], [-73.9884, 40.5788], [-73.986, 40.5817], [-73.9916, 40.5811], [-73.9903, 40.5846], [-74.0002, 40.5831], [-73.9941, 40.5887], [-74.0004, 40.5865], [-73.9984, 40.5935], [-74.036, 40.6093], [-74.0416, 40.6206], [-74.0368, 40.639], [-74.0388, 40.6396], [-74.0341, 40.6443], [-74.0282, 40.644], [-74.026, 40.6463], [-74.0294, 40.6488], [-74.0247, 40.6471], [-74.0261, 40.651], [-74.0229, 40.6512], [-74.0254, 40.6527], [-74.0212, 40.6508], [-74.0232, 40.6541], [-74.0179, 40.6541], [-74.0198, 40.6565], [-74.0167, 40.6553], [-74.0191, 40.6574], [-74.015, 40.657], [-74.0175, 40.6595], [-74.0155, 40.6608], [-74.0086, 40.6595], [-74.0096, 40.6633], [-74.0035, 40.6622], [-74.0077, 40.6648], [-73.9995, 40.6644], [-74.0029, 40.6665], [-73.9988, 40.6716], [-74.0029, 40.6673], [-74.007, 40.6661], [-74.0054, 40.6709], [-74.0075, 40.6671], [-74.0169, 40.6648], [-74.0193, 40.6716], [-74.0165, 40.6649], [-74.0103, 40.6691], [-74.0157, 40.671], [-74.013, 40.6733], [-74.0163, 40.6729], [-74.015, 40.6747], [-74.0188, 40.6723], [-74.0193, 40.6796], [-74.0128, 40.6836], [-74.013, 40.6804], [-74.0097, 40.6833], [-74.0119, 40.6839], [-74.001, 40.6901], [-73.9946, 40.7044], [-73.9783, 40.706], [-73.9757, 40.6996], [-73.9708, 40.7], [-73.9728, 40.7027], [-73.9695, 40.7005], [-73.9746, 40.7077], [-73.9711, 40.7059], [-73.9723, 40.7091], [-73.9675, 40.7034], [-73.97, 40.7105], [-73.9673, 40.717], [-73.9621, 40.7251], [-73.9579, 40.7246], [-73.9616, 40.7259], [-73.9623, 40.734], [-73.9544, 40.7391]], [[-73.9039, 40.6248], [-73.9039, 40.6248]]]}}, {"type": "Feature", "properties": {"name": "Staten Island"}, "geometry": {"type": "Polygon", "coordinates": [[[-74.0822, 40.6483], [-74.0717, 40.645], [-74.0703, 40.6425], [-74.0731, 40.6419], [-74.0702, 40.642], [-74.0729, 40.6409], [-74.07, 40.6411], [-74.0731, 40.6405], [-74.0735, 40.6372], [-74.0705, 40.6372], [-74.0734, 40.6369], [-74.073, 40.6303], [-74.068, 40.6288], [-74.0729, 40.63], [-74.0723, 40.6246], [-74.0538, 40.6059], [-74.0522, 40.5998], [-74.0734, 40.5783], [-74.091, 40.5667], [-74.1048, 40.553], [-74.1073, 40.5541], [-74.1128, 40.5479], [-74.1225, 40.5448], [-74.1369, 40.5293], [-74.1405, 40.535], [-74.1341, 40.5355], [-74.128, 40.5407], [-74.1307, 40.5463], [-74.1379, 40.546], [-74.1423, 40.5423], [-74.1413, 40.5371], [-74.1776, 40.5192], [-74.1848, 40.5193], [-74.1952, 40.51], [-74.1994, 40.513], [-74.2076, 40.5118], [-74.2176, 40.5033], [-74.2468, 40.4961], [-74.2532, 40.5001], [-74.2556, 40.5077], [-74.2535, 40.5117], [-74.2494, 40.517], [-74.2398, 40.5201], [-74.244, 40.5249], [-74.242, 40.5343], [-74.248, 40.5431], [-74.2307, 40.5556], [-74.2186, 40.5547], [-74.212, 40.5584], [-74.2046, 40.5893], [-74.1975, 40.5968], [-74.2028, 40.6083], [-74.2008, 40.6303], [-74.1946, 40.6374], [-74.18, 40.6453], [-74.1796, 40.6419], [-74.1744, 40.6451], [-74.1713, 40.6429], [-74.173, 40.6405], [-74.1661, 40.6424], [-74.1528, 40.6371], [-74.1514, 40.6394], [-74.1486, 40.6374], [-74.1344, 40.6419], [-74.127, 40.6393], [-74.1097, 40.6455], [-74.0822, 40.6483]]]}}, {"type": "Feature", "properties": {"name": "Bronx"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8729, 40.9044], [-73.8595, 40.9005], [-73.8511, 40.9104], [-73.8535, 40.9075], [-73.8414, 40.9042], [-73.8384, 40.8941], [-73.793, 40.8834], [-73.7974, 40.8751], [-73.8025, 40.8705], [-73.8034, 40.8725], [-73.803, 40.8692], [-73.8084, 40.8712], [-73.8031, 40.8658], [-73.7948, 40.8732], [-73.7929, 40.8793], [-73.7896, 40.8813], [-73.7844, 40.8784], [-73.7872, 40.8727], [-73.7836, 40.8738], [-73.7832, 40.8707], [-73.7914, 40.8681], [-73.7919, 40.8608], [-73.7987, 40.8549], [-73.8003, 40.8481], [-73.8042, 40.8533], [-73.8048, 40.8616], [-73.8077, 40.8585], [-73.8151, 40.8631], [-73.8123, 40.8542], [-73.8164, 40.8541], [-73.8171, 40.8513], [-73.815, 40.8455], [-73.8117, 40.8467], [-73.8144, 40.8431], [-73.8182, 40.8443], [-73.8147, 40.8414], [-73.8149, 40.831], [-73.8099, 40.8282], [-73.814, 40.8242], [-73.807, 40.8254], [-73.8046, 40.819], [-73.7974, 40.8158], [-73.803, 40.8124], [-73.807, 40.8165], [-73.8051, 40.8129], [-73.7909, 40.8073], [-73.7906, 40.8046], [-73.8162, 40.8138], [-73.8302, 40.8108], [-73.8316, 40.8049], [-73.8374, 40.8062], [-73.8423, 40.8291], [-73.8389, 40.8337], [-73.8397, 40.8396], [-73.8431, 40.8298], [-73.84, 40.8199], [-73.8462, 40.8107], [-73.8554, 40.8143], [-73.8491, 40.8123], [-73.8481, 40.8049], [-73.8561, 40.8046], [-73.8592, 40.8063], [-73.859, 40.8103], [-73.8594, 40.8082], [-73.8677, 40.8106], [-73.8765, 40.8161], [-73.8681, 40.8068], [-73.8723, 40.8002], [-73.8951, 40.8069], [-73.9022, 40.8049], [-73.9117, 40.7966], [-73.9276, 40.8027], [-73.9329, 40.8101], [-73.9331, 40.8352], [-73.9067, 40.8758], [-73.9103, 40.879], [-73.9178, 40.8757], [-73.9249, 40.8789], [-73.9115, 40.9138], [-73.8729, 40.9044]]]}}, {"type": "Feature", "properties": {"name": "Manhattan"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9264, 40.8776], [-73.9224, 40.8768], [-73.9213, 40.8731], [-73.9209, 40.8755], [-73.9104, 40.8715], [-73.9194, 40.8589], [-73.9216, 40.8601], [-73.9349, 40.8352], [-73.9343, 40.8096], [-73.929, 40.8011], [-73.9293, 40.7959], [-73.9432, 40.7833], [-73.9429, 40.7747], [-73.9714, 40.7438], [-73.9745, 40.7359], [-73.9715, 40.7274], [-73.9767, 40.7115], [-73.9981, 40.7085], [-74.0083, 40.7007], [-74.0151, 40.7003], [-74.0193, 40.7061], [-74.0167, 40.7186], [-74.0131, 40.7189], [-74.0117, 40.7259], [-74.0152, 40.7264], [-74.0115, 40.7264], [-74.0144, 40.7285], [-74.0109, 40.733], [-74.014, 40.7333], [-74.0107, 40.7334], [-74.0127, 40.7407], [-74.0095, 40.7407], [-74.0121, 40.7436], [-74.0089, 40.7439], [-74.0118, 40.7456], [-74.0095, 40.7458], [-74.0116, 40.7466], [-74.0092, 40.7468], [-74.0114, 40.7476], [-74.0091, 40.7478], [-74.01, 40.7529], [-74.0048, 40.7578], [-74.007, 40.7592], [-74.001, 40.7634], [-74.0031, 40.7647], [-73.9996, 40.7636], [-74.0023, 40.7656], [-73.9983, 40.7656], [-74.0016, 40.767], [-73.9981, 40.7659], [-74.0006, 40.7682], [-73.9972, 40.7671], [-73.9997, 40.7695], [-73.9971, 40.7687], [-73.999, 40.7705], [-73.9949, 40.7715], [-73.9967, 40.7735], [-73.9942, 40.7725], [-73.9962, 40.774], [-73.9923, 40.7751], [-73.9889, 40.7797], [-73.9916, 40.7796], [-73.9582, 40.8223], [-73.9461, 40.8439], [-73.947, 40.8505], [-73.9419, 40.8539], [-73.9264, 40.8776]]]}}, {"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.7667, 40.6143], [-73.7602, 40.6108], [-73.7616, 40.609], [-73.7458, 40.612], [-73.7382, 40.6027], [-73.7381, 40.5977], [-73.7418, 40.5967], [-73.7381, 40.5974], [-73.7376, 40.5944], [-73.8135, 40.5835], [-73.8703, 40.5642], [-73.9069, 40.5556], [-73.9407, 40.5418], [-73.9399, 40.5546], [-73.9262, 40.5616], [-73.912, 40.5659], [-73.9015, 40.563], [-73.8926, 40.5686], [-73.8778, 40.5688], [-73.8504, 40.5821], [-73.8393, 40.5819], [-73.8215, 40.5868], [-73.8096, 40.5936], [-73.8057, 40.5908], [-73.808, 40.5942], [-73.8024, 40.5926], [-73.8052, 40.5969], [-73.803, 40.5988], [-73.7864, 40.6032], [-73.7903, 40.5992], [-73.7898, 40.5947], [-73.7786, 40.6096], [-73.7742, 40.6089], [-73.7747, 40.6043], [-73.7813, 40.5978], [-73.775, 40.6017], [-73.7736, 40.5981], [-73.7681, 40.5978], [-73.7712, 40.5994], [-73.769, 40.6094], [-73.7742, 40.6118], [-73.7667, 40.6143]]]}}]}
# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bool]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, is_water) tuples.
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], bool(row[2])) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], False) for row in cursor.fetchall()]


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]]]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
      }
      for qx, qy, corners in quadrant_polygons
    ]
  )

  # NYC boundary GeoJSON for the map
  nyc_boundary_json = json.dumps(NYC_BOUNDARY_GEOJSON)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const polygon = L.polygon(q.corners, normalStyle).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hoverStyle);
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(normalStyle);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    if (quadrants.length > 0) {{
      const allLatLngs = quadrants.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []

    for qx, qy in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners))

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")

  try:
    create_debug_map(generation_dir, output_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

```python
"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_nyc/e2e_generation/debug_map.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_nyc.e2e_generation.shared import calculate_offset

# Simplified NYC borough boundaries GeoJSON (all 5 boroughs)
# Source: NYC Open Data (dwillis/nyc-maps), simplified using Douglas-Peucker algorithm
# fmt: off
NYC_BOUNDARY_GEOJSON = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8205, 40.801], [-73.8137, 40.7971], [-73.7964, 40.7957], [-73.7928, 40.7888], [-73.7817, 40.7911], [-73.7833, 40.7949], [-73.7769, 40.7964], [-73.7706, 40.7885], [-73.7763, 40.7885], [-73.7668, 40.7798], [-73.7651, 40.7738], [-73.7447, 40.7566], [-73.7551, 40.7675], [-73.7555, 40.7777], [-73.7508, 40.7829], [-73.7013, 40.7508], [-73.7, 40.7392], [-73.7077, 40.7278], [-73.7303, 40.7222], [-73.7269, 40.71], [-73.7256, 40.6796], [-73.7283, 40.663], [-73.7252, 40.652], [-73.7414, 40.6469], [-73.74, 40.6351], [-73.7437, 40.639], [-73.747, 40.6369], [-73.7473, 40.6432], [-73.7548, 40.6478], [-73.7474, 40.6414], [-73.7486, 40.6354], [-73.765, 40.6294], [-73.7708, 40.62], [-73.7717, 40.6236], [-73.7752, 40.6193], [-73.7717, 40.6236], [-73.7792, 40.6273], [-73.7852, 40.6201], [-73.7809, 40.6136], [-73.7914, 40.6076], [-73.8008, 40.6119], [-73.7946, 40.6226], [-73.7897, 40.6226], [-73.7826, 40.6302], [-73.7895, 40.6343], [-73.7981, 40.631], [-73.7908, 40.6343], [-73.8212, 40.6491], [-73.8223, 40.6594], [-73.8113, 40.6606], [-73.8235, 40.6601], [-73.8231, 40.648], [-73.8309, 40.6516], [-73.8302, 40.6598], [-73.8319, 40.6549], [-73.831, 40.6582], [-73.8334, 40.6581], [-73.8311, 40.6486], [-73.8343, 40.6481], [-73.8387, 40.6625], [-73.8359, 40.6455], [-73.8495, 40.6441], [-73.8524, 40.6474], [-73.8494, 40.6514], [-73.8559, 40.6513], [-73.8614, 40.6564], [-73.8596, 40.6585], [-73.8632, 40.6583], [-73.8557, 40.6639], [-73.8576, 40.6717], [-73.8604, 40.6713], [-73.866, 40.6819], [-73.8689, 40.6952], [-73.8965, 40.6823], [-73.9058, 40.6941], [-73.9043, 40.6957], [-73.9219, 40.7094], [-73.9241, 40.7151], [-73.9206, 40.716], [-73.9252, 40.7223], [-73.9204, 40.7237], [-73.938, 40.7305], [-73.9459, 40.7375], [-73.9386, 40.7429], [-73.9472, 40.7379], [-73.9626, 40.7388], [-73.9568, 40.7488], [-73.9532, 40.7477], [-73.9562, 40.7497], [-73.9435, 40.7645], [-73.9349, 40.77], [-73.9378, 40.7736], [-73.9364, 40.7769], [-73.9286, 40.7766], [-73.9099, 40.7909], [-73.8959, 40.7856], [-73.9026, 40.7803], [-73.8944, 40.7842], [-73.8953, 40.7816], [-73.8917, 40.7822], [-73.8925, 40.7774], [-73.8918, 40.7749], [-73.8901, 40.7778], [-73.8895, 40.7735], [-73.8839, 40.7741], [-73.8849, 40.78], [-73.8787, 40.7806], [-73.8797, 40.7829], [-73.8752, 40.7815], [-73.8679, 40.7874], [-73.8726, 40.7808], [-73.8551, 40.7722], [-73.8582, 40.7703], [-73.8562, 40.7689], [-73.8628, 40.7668], [-73.8507, 40.7594], [-73.8391, 40.766], [-73.8478, 40.7668], [-73.8513, 40.7718], [-73.849, 40.778], [-73.8524, 40.7792], [-73.8492, 40.7823], [-73.8553, 40.782], [-73.8595, 40.7855], [-73.8528, 40.7882], [-73.8537, 40.794], [-73.8379, 40.7985], [-73.8403, 40.7976], [-73.8373, 40.789], [-73.8329, 40.7885], [-73.8279, 40.7929], [-73.8295, 40.7968], [-73.8205, 40.801]]]}}, {"type": "Feature", "properties": {"name": "Brooklyn"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9544, 40.7391], [-73.9292, 40.7274], [-73.9246, 40.7192], [-73.9322, 40.715], [-73.9333, 40.711], [-73.9304, 40.7087], [-73.9309, 40.7149], [-73.9236, 40.7173], [-73.9219, 40.7094], [-73.9043, 40.6957], [-73.9058, 40.6941], [-73.8965, 40.6823], [-73.8684, 40.6947], [-73.866, 40.6819], [-73.8604, 40.6713], [-73.8576, 40.6717], [-73.8557, 40.6639], [-73.8633, 40.6569], [-73.857, 40.6506], [-73.8572, 40.6437], [-73.8656, 40.6388], [-73.8793, 40.6546], [-73.868, 40.6381], [-73.8744, 40.6367], [-73.891, 40.6494], [-73.8771, 40.636], [-73.8836, 40.6309], [-73.8837, 40.6276], [-73.8875, 40.6283], [-73.8958, 40.6225], [-73.9175, 40.6314], [-73.8965, 40.6214], [-73.8959, 40.6145], [-73.891, 40.6128], [-73.894, 40.6112], [-73.8897, 40.6115], [-73.8933, 40.6067], [-73.8998, 40.6055], [-73.9013, 40.6117], [-73.9088, 40.6174], [-73.9016, 40.6058], [-73.9137, 40.604], [-73.9171, 40.6088], [-73.9142, 40.6149], [-73.9195, 40.6077], [-73.9089, 40.6016], [-73.884, 40.6056], [-73.8767, 40.5849], [-73.8797, 40.5801], [-73.8955, 40.5768], [-73.899, 40.5877], [-73.9115, 40.5861], [-73.9151, 40.5988], [-73.9215, 40.6019], [-73.9249, 40.5998], [-73.9302, 40.604], [-73.9321, 40.6027], [-73.9142, 40.5892], [-73.9248, 40.5856], [-73.9281, 40.5877], [-73.924, 40.5911], [-73.9286, 40.5886], [-73.9326, 40.5949], [-73.9313, 40.5868], [-73.9135, 40.5861], [-73.9125, 40.5834], [-73.9173, 40.5832], [-73.9115, 40.5818], [-73.9535, 40.583], [-73.9326, 40.5813], [-73.9311, 40.5762], [-74.0021, 40.5696], [-74.012, 40.5749], [-74.0119, 40.5797], [-74.006, 40.582], [-73.9884, 40.5788], [-73.986, 40.5817], [-73.9916, 40.5811], [-73.9903, 40.5846], [-74.0002, 40.5831], [-73.9941, 40.5887], [-74.0004, 40.5865], [-73.9984, 40.5935], [-74.036, 40.6093], [-74.0416, 40.6206], [-74.0368, 40.639], [-74.0388, 40.6396], [-74.0341, 40.6443], [-74.0282, 40.644], [-74.026, 40.6463], [-74.0294, 40.6488], [-74.0247, 40.6471], [-74.0261, 40.651], [-74.0229, 40.6512], [-74.0254, 40.6527], [-74.0212, 40.6508], [-74.0232, 40.6541], [-74.0179, 40.6541], [-74.0198, 40.6565], [-74.0167, 40.6553], [-74.0191, 40.6574], [-74.015, 40.657], [-74.0175, 40.6595], [-74.0155, 40.6608], [-74.0086, 40.6595], [-74.0096, 40.6633], [-74.0035, 40.6622], [-74.0077, 40.6648], [-73.9995, 40.6644], [-74.0029, 40.6665], [-73.9988, 40.6716], [-74.0029, 40.6673], [-74.007, 40.6661], [-74.0054, 40.6709], [-74.0075, 40.6671], [-74.0169, 40.6648], [-74.0193, 40.6716], [-74.0165, 40.6649], [-74.0103, 40.6691], [-74.0157, 40.671], [-74.013, 40.6733], [-74.0163, 40.6729], [-74.015, 40.6747], [-74.0188, 40.6723], [-74.0193, 40.6796], [-74.0128, 40.6836], [-74.013, 40.6804], [-74.0097, 40.6833], [-74.0119, 40.6839], [-74.001, 40.6901], [-73.9946, 40.7044], [-73.9783, 40.706], [-73.9757, 40.6996], [-73.9708, 40.7], [-73.9728, 40.7027], [-73.9695, 40.7005], [-73.9746, 40.7077], [-73.9711, 40.7059], [-73.9723, 40.7091], [-73.9675, 40.7034], [-73.97, 40.7105], [-73.9673, 40.717], [-73.9621, 40.7251], [-73.9579, 40.7246], [-73.9616, 40.7259], [-73.9623, 40.734], [-73.9544, 40.7391]], [[-73.9039, 40.6248], [-73.9039, 40.6248]]]}}, {"type": "Feature", "properties": {"name": "Staten Island"}, "geometry": {"type": "Polygon", "coordinates": [[[-74.0822, 40.6483], [-74.0717, 40.645], [-74.0703, 40.6425], [-74.0731, 40.6419], [-74.0702, 40.642], [-74.0729, 40.6409], [-74.07, 40.6411], [-74.0731, 40.6405], [-74.0735, 40.6372], [-74.0705, 40.6372], [-74.0734, 40.6369], [-74.073, 40.6303], [-74.068, 40.6288], [-74.0729, 40.63], [-74.0723, 40.6246], [-74.0538, 40.6059], [-74.0522, 40.5998], [-74.0734, 40.5783], [-74.091, 40.5667], [-74.1048, 40.553], [-74.1073, 40.5541], [-74.1128, 40.5479], [-74.1225, 40.5448], [-74.1369, 40.5293], [-74.1405, 40.535], [-74.1341, 40.5355], [-74.128, 40.5407], [-74.1307, 40.5463], [-74.1379, 40.546], [-74.1423, 40.5423], [-74.1413, 40.5371], [-74.1776, 40.5192], [-74.1848, 40.5193], [-74.1952, 40.51], [-74.1994, 40.513], [-74.2076, 40.5118], [-74.2176, 40.5033], [-74.2468, 40.4961], [-74.2532, 40.5001], [-74.2556, 40.5077], [-74.2535, 40.5117], [-74.2494, 40.517], [-74.2398, 40.5201], [-74.244, 40.5249], [-74.242, 40.5343], [-74.248, 40.5431], [-74.2307, 40.5556], [-74.2186, 40.5547], [-74.212, 40.5584], [-74.2046, 40.5893], [-74.1975, 40.5968], [-74.2028, 40.6083], [-74.2008, 40.6303], [-74.1946, 40.6374], [-74.18, 40.6453], [-74.1796, 40.6419], [-74.1744, 40.6451], [-74.1713, 40.6429], [-74.173, 40.6405], [-74.1661, 40.6424], [-74.1528, 40.6371], [-74.1514, 40.6394], [-74.1486, 40.6374], [-74.1344, 40.6419], [-74.127, 40.6393], [-74.1097, 40.6455], [-74.0822, 40.6483]]]}}, {"type": "Feature", "properties": {"name": "Bronx"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8729, 40.9044], [-73.8595, 40.9005], [-73.8511, 40.9104], [-73.8535, 40.9075], [-73.8414, 40.9042], [-73.8384, 40.8941], [-73.793, 40.8834], [-73.7974, 40.8751], [-73.8025, 40.8705], [-73.8034, 40.8725], [-73.803, 40.8692], [-73.8084, 40.8712], [-73.8031, 40.8658], [-73.7948, 40.8732], [-73.7929, 40.8793], [-73.7896, 40.8813], [-73.7844, 40.8784], [-73.7872, 40.8727], [-73.7836, 40.8738], [-73.7832, 40.8707], [-73.7914, 40.8681], [-73.7919, 40.8608], [-73.7987, 40.8549], [-73.8003, 40.8481], [-73.8042, 40.8533], [-73.8048, 40.8616], [-73.8077, 40.8585], [-73.8151, 40.8631], [-73.8123, 40.8542], [-73.8164, 40.8541], [-73.8171, 40.8513], [-73.815, 40.8455], [-73.8117, 40.8467], [-73.8144, 40.8431], [-73.8182, 40.8443], [-73.8147, 40.8414], [-73.8149, 40.831], [-73.8099, 40.8282], [-73.814, 40.8242], [-73.807, 40.8254], [-73.8046, 40.819], [-73.7974, 40.8158], [-73.803, 40.8124], [-73.807, 40.8165], [-73.8051, 40.8129], [-73.7909, 40.8073], [-73.7906, 40.8046], [-73.8162, 40.8138], [-73.8302, 40.8108], [-73.8316, 40.8049], [-73.8374, 40.8062], [-73.8423, 40.8291], [-73.8389, 40.8337], [-73.8397, 40.8396], [-73.8431, 40.8298], [-73.84, 40.8199], [-73.8462, 40.8107], [-73.8554, 40.8143], [-73.8491, 40.8123], [-73.8481, 40.8049], [-73.8561, 40.8046], [-73.8592, 40.8063], [-73.859, 40.8103], [-73.8594, 40.8082], [-73.8677, 40.8106], [-73.8765, 40.8161], [-73.8681, 40.8068], [-73.8723, 40.8002], [-73.8951, 40.8069], [-73.9022, 40.8049], [-73.9117, 40.7966], [-73.9276, 40.8027], [-73.9329, 40.8101], [-73.9331, 40.8352], [-73.9067, 40.8758], [-73.9103, 40.879], [-73.9178, 40.8757], [-73.9249, 40.8789], [-73.9115, 40.9138], [-73.8729, 40.9044]]]}}, {"type": "Feature", "properties": {"name": "Manhattan"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9264, 40.8776], [-73.9224, 40.8768], [-73.9213, 40.8731], [-73.9209, 40.8755], [-73.9104, 40.8715], [-73.9194, 40.8589], [-73.9216, 40.8601], [-73.9349, 40.8352], [-73.9343, 40.8096], [-73.929, 40.8011], [-73.9293, 40.7959], [-73.9432, 40.7833], [-73.9429, 40.7747], [-73.9714, 40.7438], [-73.9745, 40.7359], [-73.9715, 40.7274], [-73.9767, 40.7115], [-73.9981, 40.7085], [-74.0083, 40.7007], [-74.0151, 40.7003], [-74.0193, 40.7061], [-74.0167, 40.7186], [-74.0131, 40.7189], [-74.0117, 40.7259], [-74.0152, 40.7264], [-74.0115, 40.7264], [-74.0144, 40.7285], [-74.0109, 40.733], [-74.014, 40.7333], [-74.0107, 40.7334], [-74.0127, 40.7407], [-74.0095, 40.7407], [-74.0121, 40.7436], [-74.0089, 40.7439], [-74.0118, 40.7456], [-74.0095, 40.7458], [-74.0116, 40.7466], [-74.0092, 40.7468], [-74.0114, 40.7476], [-74.0091, 40.7478], [-74.01, 40.7529], [-74.0048, 40.7578], [-74.007, 40.7592], [-74.001, 40.7634], [-74.0031, 40.7647], [-73.9996, 40.7636], [-74.0023, 40.7656], [-73.9983, 40.7656], [-74.0016, 40.767], [-73.9981, 40.7659], [-74.0006, 40.7682], [-73.9972, 40.7671], [-73.9997, 40.7695], [-73.9971, 40.7687], [-73.999, 40.7705], [-73.9949, 40.7715], [-73.9967, 40.7735], [-73.9942, 40.7725], [-73.9962, 40.774], [-73.9923, 40.7751], [-73.9889, 40.7797], [-73.9916, 40.7796], [-73.9582, 40.8223], [-73.9461, 40.8439], [-73.947, 40.8505], [-73.9419, 40.8539], [-73.9264, 40.8776]]]}}, {"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.7667, 40.6143], [-73.7602, 40.6108], [-73.7616, 40.609], [-73.7458, 40.612], [-73.7382, 40.6027], [-73.7381, 40.5977], [-73.7418, 40.5967], [-73.7381, 40.5974], [-73.7376, 40.5944], [-73.8135, 40.5835], [-73.8703, 40.5642], [-73.9069, 40.5556], [-73.9407, 40.5418], [-73.9399, 40.5546], [-73.9262, 40.5616], [-73.912, 40.5659], [-73.9015, 40.563], [-73.8926, 40.5686], [-73.8778, 40.5688], [-73.8504, 40.5821], [-73.8393, 40.5819], [-73.8215, 40.5868], [-73.8096, 40.5936], [-73.8057, 40.5908], [-73.808, 40.5942], [-73.8024, 40.5926], [-73.8052, 40.5969], [-73.803, 40.5988], [-73.7864, 40.6032], [-73.7903, 40.5992], [-73.7898, 40.5947], [-73.7786, 40.6096], [-73.7742, 40.6089], [-73.7747, 40.6043], [-73.7813, 40.5978], [-73.775, 40.6017], [-73.7736, 40.5981], [-73.7681, 40.5978], [-73.7712, 40.5994], [-73.769, 40.6094], [-73.7742, 40.6118], [-73.7667, 40.6143]]]}}]}
# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bool]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, is_water) tuples.
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], bool(row[2])) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], False) for row in cursor.fetchall()]


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]], bool]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
        "is_water": is_water,
      }
      for qx, qy, corners, is_water in quadrant_polygons
    ]
  )

  # NYC boundary GeoJSON for the map
  nyc_boundary_json = json.dumps(NYC_BOUNDARY_GEOJSON)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const polygon = L.polygon(q.corners, normalStyle).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hoverStyle);
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(normalStyle);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    if (quadrants.length > 0) {{
      const allLatLngs = quadrants.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []

    for qx, qy in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners))

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")

  try:
    create_debug_map(generation_dir, output_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

Now I need to update the HTML template in debug_map.py to display water tiles with blue color and update the legend:

```python
"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_nyc/e2e_generation/debug_map.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_nyc.e2e_generation.shared import calculate_offset

# Simplified NYC borough boundaries GeoJSON (all 5 boroughs)
# Source: NYC Open Data (dwillis/nyc-maps), simplified using Douglas-Peucker algorithm
# fmt: off
NYC_BOUNDARY_GEOJSON = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8205, 40.801], [-73.8137, 40.7971], [-73.7964, 40.7957], [-73.7928, 40.7888], [-73.7817, 40.7911], [-73.7833, 40.7949], [-73.7769, 40.7964], [-73.7706, 40.7885], [-73.7763, 40.7885], [-73.7668, 40.7798], [-73.7651, 40.7738], [-73.7447, 40.7566], [-73.7551, 40.7675], [-73.7555, 40.7777], [-73.7508, 40.7829], [-73.7013, 40.7508], [-73.7, 40.7392], [-73.7077, 40.7278], [-73.7303, 40.7222], [-73.7269, 40.71], [-73.7256, 40.6796], [-73.7283, 40.663], [-73.7252, 40.652], [-73.7414, 40.6469], [-73.74, 40.6351], [-73.7437, 40.639], [-73.747, 40.6369], [-73.7473, 40.6432], [-73.7548, 40.6478], [-73.7474, 40.6414], [-73.7486, 40.6354], [-73.765, 40.6294], [-73.7708, 40.62], [-73.7717, 40.6236], [-73.7752, 40.6193], [-73.7717, 40.6236], [-73.7792, 40.6273], [-73.7852, 40.6201], [-73.7809, 40.6136], [-73.7914, 40.6076], [-73.8008, 40.6119], [-73.7946, 40.6226], [-73.7897, 40.6226], [-73.7826, 40.6302], [-73.7895, 40.6343], [-73.7981, 40.631], [-73.7908, 40.6343], [-73.8212, 40.6491], [-73.8223, 40.6594], [-73.8113, 40.6606], [-73.8235, 40.6601], [-73.8231, 40.648], [-73.8309, 40.6516], [-73.8302, 40.6598], [-73.8319, 40.6549], [-73.831, 40.6582], [-73.8334, 40.6581], [-73.8311, 40.6486], [-73.8343, 40.6481], [-73.8387, 40.6625], [-73.8359, 40.6455], [-73.8495, 40.6441], [-73.8524, 40.6474], [-73.8494, 40.6514], [-73.8559, 40.6513], [-73.8614, 40.6564], [-73.8596, 40.6585], [-73.8632, 40.6583], [-73.8557, 40.6639], [-73.8576, 40.6717], [-73.8604, 40.6713], [-73.866, 40.6819], [-73.8689, 40.6952], [-73.8965, 40.6823], [-73.9058, 40.6941], [-73.9043, 40.6957], [-73.9219, 40.7094], [-73.9241, 40.7151], [-73.9206, 40.716], [-73.9252, 40.7223], [-73.9204, 40.7237], [-73.938, 40.7305], [-73.9459, 40.7375], [-73.9386, 40.7429], [-73.9472, 40.7379], [-73.9626, 40.7388], [-73.9568, 40.7488], [-73.9532, 40.7477], [-73.9562, 40.7497], [-73.9435, 40.7645], [-73.9349, 40.77], [-73.9378, 40.7736], [-73.9364, 40.7769], [-73.9286, 40.7766], [-73.9099, 40.7909], [-73.8959, 40.7856], [-73.9026, 40.7803], [-73.8944, 40.7842], [-73.8953, 40.7816], [-73.8917, 40.7822], [-73.8925, 40.7774], [-73.8918, 40.7749], [-73.8901, 40.7778], [-73.8895, 40.7735], [-73.8839, 40.7741], [-73.8849, 40.78], [-73.8787, 40.7806], [-73.8797, 40.7829], [-73.8752, 40.7815], [-73.8679, 40.7874], [-73.8726, 40.7808], [-73.8551, 40.7722], [-73.8582, 40.7703], [-73.8562, 40.7689], [-73.8628, 40.7668], [-73.8507, 40.7594], [-73.8391, 40.766], [-73.8478, 40.7668], [-73.8513, 40.7718], [-73.849, 40.778], [-73.8524, 40.7792], [-73.8492, 40.7823], [-73.8553, 40.782], [-73.8595, 40.7855], [-73.8528, 40.7882], [-73.8537, 40.794], [-73.8379, 40.7985], [-73.8403, 40.7976], [-73.8373, 40.789], [-73.8329, 40.7885], [-73.8279, 40.7929], [-73.8295, 40.7968], [-73.8205, 40.801]]]}}, {"type": "Feature", "properties": {"name": "Brooklyn"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9544, 40.7391], [-73.9292, 40.7274], [-73.9246, 40.7192], [-73.9322, 40.715], [-73.9333, 40.711], [-73.9304, 40.7087], [-73.9309, 40.7149], [-73.9236, 40.7173], [-73.9219, 40.7094], [-73.9043, 40.6957], [-73.9058, 40.6941], [-73.8965, 40.6823], [-73.8684, 40.6947], [-73.866, 40.6819], [-73.8604, 40.6713], [-73.8576, 40.6717], [-73.8557, 40.6639], [-73.8633, 40.6569], [-73.857, 40.6506], [-73.8572, 40.6437], [-73.8656, 40.6388], [-73.8793, 40.6546], [-73.868, 40.6381], [-73.8744, 40.6367], [-73.891, 40.6494], [-73.8771, 40.636], [-73.8836, 40.6309], [-73.8837, 40.6276], [-73.8875, 40.6283], [-73.8958, 40.6225], [-73.9175, 40.6314], [-73.8965, 40.6214], [-73.8959, 40.6145], [-73.891, 40.6128], [-73.894, 40.6112], [-73.8897, 40.6115], [-73.8933, 40.6067], [-73.8998, 40.6055], [-73.9013, 40.6117], [-73.9088, 40.6174], [-73.9016, 40.6058], [-73.9137, 40.604], [-73.9171, 40.6088], [-73.9142, 40.6149], [-73.9195, 40.6077], [-73.9089, 40.6016], [-73.884, 40.6056], [-73.8767, 40.5849], [-73.8797, 40.5801], [-73.8955, 40.5768], [-73.899, 40.5877], [-73.9115, 40.5861], [-73.9151, 40.5988], [-73.9215, 40.6019], [-73.9249, 40.5998], [-73.9302, 40.604], [-73.9321, 40.6027], [-73.9142, 40.5892], [-73.9248, 40.5856], [-73.9281, 40.5877], [-73.924, 40.5911], [-73.9286, 40.5886], [-73.9326, 40.5949], [-73.9313, 40.5868], [-73.9135, 40.5861], [-73.9125, 40.5834], [-73.9173, 40.5832], [-73.9115, 40.5818], [-73.9535, 40.583], [-73.9326, 40.5813], [-73.9311, 40.5762], [-74.0021, 40.5696], [-74.012, 40.5749], [-74.0119, 40.5797], [-74.006, 40.582], [-73.9884, 40.5788], [-73.986, 40.5817], [-73.9916, 40.5811], [-73.9903, 40.5846], [-74.0002, 40.5831], [-73.9941, 40.5887], [-74.0004, 40.5865], [-73.9984, 40.5935], [-74.036, 40.6093], [-74.0416, 40.6206], [-74.0368, 40.639], [-74.0388, 40.6396], [-74.0341, 40.6443], [-74.0282, 40.644], [-74.026, 40.6463], [-74.0294, 40.6488], [-74.0247, 40.6471], [-74.0261, 40.651], [-74.0229, 40.6512], [-74.0254, 40.6527], [-74.0212, 40.6508], [-74.0232, 40.6541], [-74.0179, 40.6541], [-74.0198, 40.6565], [-74.0167, 40.6553], [-74.0191, 40.6574], [-74.015, 40.657], [-74.0175, 40.6595], [-74.0155, 40.6608], [-74.0086, 40.6595], [-74.0096, 40.6633], [-74.0035, 40.6622], [-74.0077, 40.6648], [-73.9995, 40.6644], [-74.0029, 40.6665], [-73.9988, 40.6716], [-74.0029, 40.6673], [-74.007, 40.6661], [-74.0054, 40.6709], [-74.0075, 40.6671], [-74.0169, 40.6648], [-74.0193, 40.6716], [-74.0165, 40.6649], [-74.0103, 40.6691], [-74.0157, 40.671], [-74.013, 40.6733], [-74.0163, 40.6729], [-74.015, 40.6747], [-74.0188, 40.6723], [-74.0193, 40.6796], [-74.0128, 40.6836], [-74.013, 40.6804], [-74.0097, 40.6833], [-74.0119, 40.6839], [-74.001, 40.6901], [-73.9946, 40.7044], [-73.9783, 40.706], [-73.9757, 40.6996], [-73.9708, 40.7], [-73.9728, 40.7027], [-73.9695, 40.7005], [-73.9746, 40.7077], [-73.9711, 40.7059], [-73.9723, 40.7091], [-73.9675, 40.7034], [-73.97, 40.7105], [-73.9673, 40.717], [-73.9621, 40.7251], [-73.9579, 40.7246], [-73.9616, 40.7259], [-73.9623, 40.734], [-73.9544, 40.7391]], [[-73.9039, 40.6248], [-73.9039, 40.6248]]]}}, {"type": "Feature", "properties": {"name": "Staten Island"}, "geometry": {"type": "Polygon", "coordinates": [[[-74.0822, 40.6483], [-74.0717, 40.645], [-74.0703, 40.6425], [-74.0731, 40.6419], [-74.0702, 40.642], [-74.0729, 40.6409], [-74.07, 40.6411], [-74.0731, 40.6405], [-74.0735, 40.6372], [-74.0705, 40.6372], [-74.0734, 40.6369], [-74.073, 40.6303], [-74.068, 40.6288], [-74.0729, 40.63], [-74.0723, 40.6246], [-74.0538, 40.6059], [-74.0522, 40.5998], [-74.0734, 40.5783], [-74.091, 40.5667], [-74.1048, 40.553], [-74.1073, 40.5541], [-74.1128, 40.5479], [-74.1225, 40.5448], [-74.1369, 40.5293], [-74.1405, 40.535], [-74.1341, 40.5355], [-74.128, 40.5407], [-74.1307, 40.5463], [-74.1379, 40.546], [-74.1423, 40.5423], [-74.1413, 40.5371], [-74.1776, 40.5192], [-74.1848, 40.5193], [-74.1952, 40.51], [-74.1994, 40.513], [-74.2076, 40.5118], [-74.2176, 40.5033], [-74.2468, 40.4961], [-74.2532, 40.5001], [-74.2556, 40.5077], [-74.2535, 40.5117], [-74.2494, 40.517], [-74.2398, 40.5201], [-74.244, 40.5249], [-74.242, 40.5343], [-74.248, 40.5431], [-74.2307, 40.5556], [-74.2186, 40.5547], [-74.212, 40.5584], [-74.2046, 40.5893], [-74.1975, 40.5968], [-74.2028, 40.6083], [-74.2008, 40.6303], [-74.1946, 40.6374], [-74.18, 40.6453], [-74.1796, 40.6419], [-74.1744, 40.6451], [-74.1713, 40.6429], [-74.173, 40.6405], [-74.1661, 40.6424], [-74.1528, 40.6371], [-74.1514, 40.6394], [-74.1486, 40.6374], [-74.1344, 40.6419], [-74.127, 40.6393], [-74.1097, 40.6455], [-74.0822, 40.6483]]]}}, {"type": "Feature", "properties": {"name": "Bronx"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8729, 40.9044], [-73.8595, 40.9005], [-73.8511, 40.9104], [-73.8535, 40.9075], [-73.8414, 40.9042], [-73.8384, 40.8941], [-73.793, 40.8834], [-73.7974, 40.8751], [-73.8025, 40.8705], [-73.8034, 40.8725], [-73.803, 40.8692], [-73.8084, 40.8712], [-73.8031, 40.8658], [-73.7948, 40.8732], [-73.7929, 40.8793], [-73.7896, 40.8813], [-73.7844, 40.8784], [-73.7872, 40.8727], [-73.7836, 40.8738], [-73.7832, 40.8707], [-73.7914, 40.8681], [-73.7919, 40.8608], [-73.7987, 40.8549], [-73.8003, 40.8481], [-73.8042, 40.8533], [-73.8048, 40.8616], [-73.8077, 40.8585], [-73.8151, 40.8631], [-73.8123, 40.8542], [-73.8164, 40.8541], [-73.8171, 40.8513], [-73.815, 40.8455], [-73.8117, 40.8467], [-73.8144, 40.8431], [-73.8182, 40.8443], [-73.8147, 40.8414], [-73.8149, 40.831], [-73.8099, 40.8282], [-73.814, 40.8242], [-73.807, 40.8254], [-73.8046, 40.819], [-73.7974, 40.8158], [-73.803, 40.8124], [-73.807, 40.8165], [-73.8051, 40.8129], [-73.7909, 40.8073], [-73.7906, 40.8046], [-73.8162, 40.8138], [-73.8302, 40.8108], [-73.8316, 40.8049], [-73.8374, 40.8062], [-73.8423, 40.8291], [-73.8389, 40.8337], [-73.8397, 40.8396], [-73.8431, 40.8298], [-73.84, 40.8199], [-73.8462, 40.8107], [-73.8554, 40.8143], [-73.8491, 40.8123], [-73.8481, 40.8049], [-73.8561, 40.8046], [-73.8592, 40.8063], [-73.859, 40.8103], [-73.8594, 40.8082], [-73.8677, 40.8106], [-73.8765, 40.8161], [-73.8681, 40.8068], [-73.8723, 40.8002], [-73.8951, 40.8069], [-73.9022, 40.8049], [-73.9117, 40.7966], [-73.9276, 40.8027], [-73.9329, 40.8101], [-73.9331, 40.8352], [-73.9067, 40.8758], [-73.9103, 40.879], [-73.9178, 40.8757], [-73.9249, 40.8789], [-73.9115, 40.9138], [-73.8729, 40.9044]]]}}, {"type": "Feature", "properties": {"name": "Manhattan"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9264, 40.8776], [-73.9224, 40.8768], [-73.9213, 40.8731], [-73.9209, 40.8755], [-73.9104, 40.8715], [-73.9194, 40.8589], [-73.9216, 40.8601], [-73.9349, 40.8352], [-73.9343, 40.8096], [-73.929, 40.8011], [-73.9293, 40.7959], [-73.9432, 40.7833], [-73.9429, 40.7747], [-73.9714, 40.7438], [-73.9745, 40.7359], [-73.9715, 40.7274], [-73.9767, 40.7115], [-73.9981, 40.7085], [-74.0083, 40.7007], [-74.0151, 40.7003], [-74.0193, 40.7061], [-74.0167, 40.7186], [-74.0131, 40.7189], [-74.0117, 40.7259], [-74.0152, 40.7264], [-74.0115, 40.7264], [-74.0144, 40.7285], [-74.0109, 40.733], [-74.014, 40.7333], [-74.0107, 40.7334], [-74.0127, 40.7407], [-74.0095, 40.7407], [-74.0121, 40.7436], [-74.0089, 40.7439], [-74.0118, 40.7456], [-74.0095, 40.7458], [-74.0116, 40.7466], [-74.0092, 40.7468], [-74.0114, 40.7476], [-74.0091, 40.7478], [-74.01, 40.7529], [-74.0048, 40.7578], [-74.007, 40.7592], [-74.001, 40.7634], [-74.0031, 40.7647], [-73.9996, 40.7636], [-74.0023, 40.7656], [-73.9983, 40.7656], [-74.0016, 40.767], [-73.9981, 40.7659], [-74.0006, 40.7682], [-73.9972, 40.7671], [-73.9997, 40.7695], [-73.9971, 40.7687], [-73.999, 40.7705], [-73.9949, 40.7715], [-73.9967, 40.7735], [-73.9942, 40.7725], [-73.9962, 40.774], [-73.9923, 40.7751], [-73.9889, 40.7797], [-73.9916, 40.7796], [-73.9582, 40.8223], [-73.9461, 40.8439], [-73.947, 40.8505], [-73.9419, 40.8539], [-73.9264, 40.8776]]]}}, {"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.7667, 40.6143], [-73.7602, 40.6108], [-73.7616, 40.609], [-73.7458, 40.612], [-73.7382, 40.6027], [-73.7381, 40.5977], [-73.7418, 40.5967], [-73.7381, 40.5974], [-73.7376, 40.5944], [-73.8135, 40.5835], [-73.8703, 40.5642], [-73.9069, 40.5556], [-73.9407, 40.5418], [-73.9399, 40.5546], [-73.9262, 40.5616], [-73.912, 40.5659], [-73.9015, 40.563], [-73.8926, 40.5686], [-73.8778, 40.5688], [-73.8504, 40.5821], [-73.8393, 40.5819], [-73.8215, 40.5868], [-73.8096, 40.5936], [-73.8057, 40.5908], [-73.808, 40.5942], [-73.8024, 40.5926], [-73.8052, 40.5969], [-73.803, 40.5988], [-73.7864, 40.6032], [-73.7903, 40.5992], [-73.7898, 40.5947], [-73.7786, 40.6096], [-73.7742, 40.6089], [-73.7747, 40.6043], [-73.7813, 40.5978], [-73.775, 40.6017], [-73.7736, 40.5981], [-73.7681, 40.5978], [-73.7712, 40.5994], [-73.769, 40.6094], [-73.7742, 40.6118], [-73.7667, 40.6143]]]}}]}
# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bool]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, is_water) tuples.
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], bool(row[2])) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], False) for row in cursor.fetchall()]


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]], bool]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
        "is_water": is_water,
      }
      for qx, qy, corners, is_water in quadrant_polygons
    ]
  )

  # NYC boundary GeoJSON for the map
  nyc_boundary_json = json.dumps(NYC_BOUNDARY_GEOJSON)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.water {{
      background: rgba(59, 130, 246, 0.35);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const polygon = L.polygon(q.corners, normalStyle).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hoverStyle);
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(normalStyle);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    if (quadrants.length > 0) {{
      const allLatLngs = quadrants.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []

    for qx, qy in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners))

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")

  try:
    create_debug_map(generation_dir, output_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

```python
"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_nyc/e2e_generation/debug_map.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_nyc.e2e_generation.shared import calculate_offset

# Simplified NYC borough boundaries GeoJSON (all 5 boroughs)
# Source: NYC Open Data (dwillis/nyc-maps), simplified using Douglas-Peucker algorithm
# fmt: off
NYC_BOUNDARY_GEOJSON = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8205, 40.801], [-73.8137, 40.7971], [-73.7964, 40.7957], [-73.7928, 40.7888], [-73.7817, 40.7911], [-73.7833, 40.7949], [-73.7769, 40.7964], [-73.7706, 40.7885], [-73.7763, 40.7885], [-73.7668, 40.7798], [-73.7651, 40.7738], [-73.7447, 40.7566], [-73.7551, 40.7675], [-73.7555, 40.7777], [-73.7508, 40.7829], [-73.7013, 40.7508], [-73.7, 40.7392], [-73.7077, 40.7278], [-73.7303, 40.7222], [-73.7269, 40.71], [-73.7256, 40.6796], [-73.7283, 40.663], [-73.7252, 40.652], [-73.7414, 40.6469], [-73.74, 40.6351], [-73.7437, 40.639], [-73.747, 40.6369], [-73.7473, 40.6432], [-73.7548, 40.6478], [-73.7474, 40.6414], [-73.7486, 40.6354], [-73.765, 40.6294], [-73.7708, 40.62], [-73.7717, 40.6236], [-73.7752, 40.6193], [-73.7717, 40.6236], [-73.7792, 40.6273], [-73.7852, 40.6201], [-73.7809, 40.6136], [-73.7914, 40.6076], [-73.8008, 40.6119], [-73.7946, 40.6226], [-73.7897, 40.6226], [-73.7826, 40.6302], [-73.7895, 40.6343], [-73.7981, 40.631], [-73.7908, 40.6343], [-73.8212, 40.6491], [-73.8223, 40.6594], [-73.8113, 40.6606], [-73.8235, 40.6601], [-73.8231, 40.648], [-73.8309, 40.6516], [-73.8302, 40.6598], [-73.8319, 40.6549], [-73.831, 40.6582], [-73.8334, 40.6581], [-73.8311, 40.6486], [-73.8343, 40.6481], [-73.8387, 40.6625], [-73.8359, 40.6455], [-73.8495, 40.6441], [-73.8524, 40.6474], [-73.8494, 40.6514], [-73.8559, 40.6513], [-73.8614, 40.6564], [-73.8596, 40.6585], [-73.8632, 40.6583], [-73.8557, 40.6639], [-73.8576, 40.6717], [-73.8604, 40.6713], [-73.866, 40.6819], [-73.8689, 40.6952], [-73.8965, 40.6823], [-73.9058, 40.6941], [-73.9043, 40.6957], [-73.9219, 40.7094], [-73.9241, 40.7151], [-73.9206, 40.716], [-73.9252, 40.7223], [-73.9204, 40.7237], [-73.938, 40.7305], [-73.9459, 40.7375], [-73.9386, 40.7429], [-73.9472, 40.7379], [-73.9626, 40.7388], [-73.9568, 40.7488], [-73.9532, 40.7477], [-73.9562, 40.7497], [-73.9435, 40.7645], [-73.9349, 40.77], [-73.9378, 40.7736], [-73.9364, 40.7769], [-73.9286, 40.7766], [-73.9099, 40.7909], [-73.8959, 40.7856], [-73.9026, 40.7803], [-73.8944, 40.7842], [-73.8953, 40.7816], [-73.8917, 40.7822], [-73.8925, 40.7774], [-73.8918, 40.7749], [-73.8901, 40.7778], [-73.8895, 40.7735], [-73.8839, 40.7741], [-73.8849, 40.78], [-73.8787, 40.7806], [-73.8797, 40.7829], [-73.8752, 40.7815], [-73.8679, 40.7874], [-73.8726, 40.7808], [-73.8551, 40.7722], [-73.8582, 40.7703], [-73.8562, 40.7689], [-73.8628, 40.7668], [-73.8507, 40.7594], [-73.8391, 40.766], [-73.8478, 40.7668], [-73.8513, 40.7718], [-73.849, 40.778], [-73.8524, 40.7792], [-73.8492, 40.7823], [-73.8553, 40.782], [-73.8595, 40.7855], [-73.8528, 40.7882], [-73.8537, 40.794], [-73.8379, 40.7985], [-73.8403, 40.7976], [-73.8373, 40.789], [-73.8329, 40.7885], [-73.8279, 40.7929], [-73.8295, 40.7968], [-73.8205, 40.801]]]}}, {"type": "Feature", "properties": {"name": "Brooklyn"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9544, 40.7391], [-73.9292, 40.7274], [-73.9246, 40.7192], [-73.9322, 40.715], [-73.9333, 40.711], [-73.9304, 40.7087], [-73.9309, 40.7149], [-73.9236, 40.7173], [-73.9219, 40.7094], [-73.9043, 40.6957], [-73.9058, 40.6941], [-73.8965, 40.6823], [-73.8684, 40.6947], [-73.866, 40.6819], [-73.8604, 40.6713], [-73.8576, 40.6717], [-73.8557, 40.6639], [-73.8633, 40.6569], [-73.857, 40.6506], [-73.8572, 40.6437], [-73.8656, 40.6388], [-73.8793, 40.6546], [-73.868, 40.6381], [-73.8744, 40.6367], [-73.891, 40.6494], [-73.8771, 40.636], [-73.8836, 40.6309], [-73.8837, 40.6276], [-73.8875, 40.6283], [-73.8958, 40.6225], [-73.9175, 40.6314], [-73.8965, 40.6214], [-73.8959, 40.6145], [-73.891, 40.6128], [-73.894, 40.6112], [-73.8897, 40.6115], [-73.8933, 40.6067], [-73.8998, 40.6055], [-73.9013, 40.6117], [-73.9088, 40.6174], [-73.9016, 40.6058], [-73.9137, 40.604], [-73.9171, 40.6088], [-73.9142, 40.6149], [-73.9195, 40.6077], [-73.9089, 40.6016], [-73.884, 40.6056], [-73.8767, 40.5849], [-73.8797, 40.5801], [-73.8955, 40.5768], [-73.899, 40.5877], [-73.9115, 40.5861], [-73.9151, 40.5988], [-73.9215, 40.6019], [-73.9249, 40.5998], [-73.9302, 40.604], [-73.9321, 40.6027], [-73.9142, 40.5892], [-73.9248, 40.5856], [-73.9281, 40.5877], [-73.924, 40.5911], [-73.9286, 40.5886], [-73.9326, 40.5949], [-73.9313, 40.5868], [-73.9135, 40.5861], [-73.9125, 40.5834], [-73.9173, 40.5832], [-73.9115, 40.5818], [-73.9535, 40.583], [-73.9326, 40.5813], [-73.9311, 40.5762], [-74.0021, 40.5696], [-74.012, 40.5749], [-74.0119, 40.5797], [-74.006, 40.582], [-73.9884, 40.5788], [-73.986, 40.5817], [-73.9916, 40.5811], [-73.9903, 40.5846], [-74.0002, 40.5831], [-73.9941, 40.5887], [-74.0004, 40.5865], [-73.9984, 40.5935], [-74.036, 40.6093], [-74.0416, 40.6206], [-74.0368, 40.639], [-74.0388, 40.6396], [-74.0341, 40.6443], [-74.0282, 40.644], [-74.026, 40.6463], [-74.0294, 40.6488], [-74.0247, 40.6471], [-74.0261, 40.651], [-74.0229, 40.6512], [-74.0254, 40.6527], [-74.0212, 40.6508], [-74.0232, 40.6541], [-74.0179, 40.6541], [-74.0198, 40.6565], [-74.0167, 40.6553], [-74.0191, 40.6574], [-74.015, 40.657], [-74.0175, 40.6595], [-74.0155, 40.6608], [-74.0086, 40.6595], [-74.0096, 40.6633], [-74.0035, 40.6622], [-74.0077, 40.6648], [-73.9995, 40.6644], [-74.0029, 40.6665], [-73.9988, 40.6716], [-74.0029, 40.6673], [-74.007, 40.6661], [-74.0054, 40.6709], [-74.0075, 40.6671], [-74.0169, 40.6648], [-74.0193, 40.6716], [-74.0165, 40.6649], [-74.0103, 40.6691], [-74.0157, 40.671], [-74.013, 40.6733], [-74.0163, 40.6729], [-74.015, 40.6747], [-74.0188, 40.6723], [-74.0193, 40.6796], [-74.0128, 40.6836], [-74.013, 40.6804], [-74.0097, 40.6833], [-74.0119, 40.6839], [-74.001, 40.6901], [-73.9946, 40.7044], [-73.9783, 40.706], [-73.9757, 40.6996], [-73.9708, 40.7], [-73.9728, 40.7027], [-73.9695, 40.7005], [-73.9746, 40.7077], [-73.9711, 40.7059], [-73.9723, 40.7091], [-73.9675, 40.7034], [-73.97, 40.7105], [-73.9673, 40.717], [-73.9621, 40.7251], [-73.9579, 40.7246], [-73.9616, 40.7259], [-73.9623, 40.734], [-73.9544, 40.7391]], [[-73.9039, 40.6248], [-73.9039, 40.6248]]]}}, {"type": "Feature", "properties": {"name": "Staten Island"}, "geometry": {"type": "Polygon", "coordinates": [[[-74.0822, 40.6483], [-74.0717, 40.645], [-74.0703, 40.6425], [-74.0731, 40.6419], [-74.0702, 40.642], [-74.0729, 40.6409], [-74.07, 40.6411], [-74.0731, 40.6405], [-74.0735, 40.6372], [-74.0705, 40.6372], [-74.0734, 40.6369], [-74.073, 40.6303], [-74.068, 40.6288], [-74.0729, 40.63], [-74.0723, 40.6246], [-74.0538, 40.6059], [-74.0522, 40.5998], [-74.0734, 40.5783], [-74.091, 40.5667], [-74.1048, 40.553], [-74.1073, 40.5541], [-74.1128, 40.5479], [-74.1225, 40.5448], [-74.1369, 40.5293], [-74.1405, 40.535], [-74.1341, 40.5355], [-74.128, 40.5407], [-74.1307, 40.5463], [-74.1379, 40.546], [-74.1423, 40.5423], [-74.1413, 40.5371], [-74.1776, 40.5192], [-74.1848, 40.5193], [-74.1952, 40.51], [-74.1994, 40.513], [-74.2076, 40.5118], [-74.2176, 40.5033], [-74.2468, 40.4961], [-74.2532, 40.5001], [-74.2556, 40.5077], [-74.2535, 40.5117], [-74.2494, 40.517], [-74.2398, 40.5201], [-74.244, 40.5249], [-74.242, 40.5343], [-74.248, 40.5431], [-74.2307, 40.5556], [-74.2186, 40.5547], [-74.212, 40.5584], [-74.2046, 40.5893], [-74.1975, 40.5968], [-74.2028, 40.6083], [-74.2008, 40.6303], [-74.1946, 40.6374], [-74.18, 40.6453], [-74.1796, 40.6419], [-74.1744, 40.6451], [-74.1713, 40.6429], [-74.173, 40.6405], [-74.1661, 40.6424], [-74.1528, 40.6371], [-74.1514, 40.6394], [-74.1486, 40.6374], [-74.1344, 40.6419], [-74.127, 40.6393], [-74.1097, 40.6455], [-74.0822, 40.6483]]]}}, {"type": "Feature", "properties": {"name": "Bronx"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8729, 40.9044], [-73.8595, 40.9005], [-73.8511, 40.9104], [-73.8535, 40.9075], [-73.8414, 40.9042], [-73.8384, 40.8941], [-73.793, 40.8834], [-73.7974, 40.8751], [-73.8025, 40.8705], [-73.8034, 40.8725], [-73.803, 40.8692], [-73.8084, 40.8712], [-73.8031, 40.8658], [-73.7948, 40.8732], [-73.7929, 40.8793], [-73.7896, 40.8813], [-73.7844, 40.8784], [-73.7872, 40.8727], [-73.7836, 40.8738], [-73.7832, 40.8707], [-73.7914, 40.8681], [-73.7919, 40.8608], [-73.7987, 40.8549], [-73.8003, 40.8481], [-73.8042, 40.8533], [-73.8048, 40.8616], [-73.8077, 40.8585], [-73.8151, 40.8631], [-73.8123, 40.8542], [-73.8164, 40.8541], [-73.8171, 40.8513], [-73.815, 40.8455], [-73.8117, 40.8467], [-73.8144, 40.8431], [-73.8182, 40.8443], [-73.8147, 40.8414], [-73.8149, 40.831], [-73.8099, 40.8282], [-73.814, 40.8242], [-73.807, 40.8254], [-73.8046, 40.819], [-73.7974, 40.8158], [-73.803, 40.8124], [-73.807, 40.8165], [-73.8051, 40.8129], [-73.7909, 40.8073], [-73.7906, 40.8046], [-73.8162, 40.8138], [-73.8302, 40.8108], [-73.8316, 40.8049], [-73.8374, 40.8062], [-73.8423, 40.8291], [-73.8389, 40.8337], [-73.8397, 40.8396], [-73.8431, 40.8298], [-73.84, 40.8199], [-73.8462, 40.8107], [-73.8554, 40.8143], [-73.8491, 40.8123], [-73.8481, 40.8049], [-73.8561, 40.8046], [-73.8592, 40.8063], [-73.859, 40.8103], [-73.8594, 40.8082], [-73.8677, 40.8106], [-73.8765, 40.8161], [-73.8681, 40.8068], [-73.8723, 40.8002], [-73.8951, 40.8069], [-73.9022, 40.8049], [-73.9117, 40.7966], [-73.9276, 40.8027], [-73.9329, 40.8101], [-73.9331, 40.8352], [-73.9067, 40.8758], [-73.9103, 40.879], [-73.9178, 40.8757], [-73.9249, 40.8789], [-73.9115, 40.9138], [-73.8729, 40.9044]]]}}, {"type": "Feature", "properties": {"name": "Manhattan"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9264, 40.8776], [-73.9224, 40.8768], [-73.9213, 40.8731], [-73.9209, 40.8755], [-73.9104, 40.8715], [-73.9194, 40.8589], [-73.9216, 40.8601], [-73.9349, 40.8352], [-73.9343, 40.8096], [-73.929, 40.8011], [-73.9293, 40.7959], [-73.9432, 40.7833], [-73.9429, 40.7747], [-73.9714, 40.7438], [-73.9745, 40.7359], [-73.9715, 40.7274], [-73.9767, 40.7115], [-73.9981, 40.7085], [-74.0083, 40.7007], [-74.0151, 40.7003], [-74.0193, 40.7061], [-74.0167, 40.7186], [-74.0131, 40.7189], [-74.0117, 40.7259], [-74.0152, 40.7264], [-74.0115, 40.7264], [-74.0144, 40.7285], [-74.0109, 40.733], [-74.014, 40.7333], [-74.0107, 40.7334], [-74.0127, 40.7407], [-74.0095, 40.7407], [-74.0121, 40.7436], [-74.0089, 40.7439], [-74.0118, 40.7456], [-74.0095, 40.7458], [-74.0116, 40.7466], [-74.0092, 40.7468], [-74.0114, 40.7476], [-74.0091, 40.7478], [-74.01, 40.7529], [-74.0048, 40.7578], [-74.007, 40.7592], [-74.001, 40.7634], [-74.0031, 40.7647], [-73.9996, 40.7636], [-74.0023, 40.7656], [-73.9983, 40.7656], [-74.0016, 40.767], [-73.9981, 40.7659], [-74.0006, 40.7682], [-73.9972, 40.7671], [-73.9997, 40.7695], [-73.9971, 40.7687], [-73.999, 40.7705], [-73.9949, 40.7715], [-73.9967, 40.7735], [-73.9942, 40.7725], [-73.9962, 40.774], [-73.9923, 40.7751], [-73.9889, 40.7797], [-73.9916, 40.7796], [-73.9582, 40.8223], [-73.9461, 40.8439], [-73.947, 40.8505], [-73.9419, 40.8539], [-73.9264, 40.8776]]]}}, {"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.7667, 40.6143], [-73.7602, 40.6108], [-73.7616, 40.609], [-73.7458, 40.612], [-73.7382, 40.6027], [-73.7381, 40.5977], [-73.7418, 40.5967], [-73.7381, 40.5974], [-73.7376, 40.5944], [-73.8135, 40.5835], [-73.8703, 40.5642], [-73.9069, 40.5556], [-73.9407, 40.5418], [-73.9399, 40.5546], [-73.9262, 40.5616], [-73.912, 40.5659], [-73.9015, 40.563], [-73.8926, 40.5686], [-73.8778, 40.5688], [-73.8504, 40.5821], [-73.8393, 40.5819], [-73.8215, 40.5868], [-73.8096, 40.5936], [-73.8057, 40.5908], [-73.808, 40.5942], [-73.8024, 40.5926], [-73.8052, 40.5969], [-73.803, 40.5988], [-73.7864, 40.6032], [-73.7903, 40.5992], [-73.7898, 40.5947], [-73.7786, 40.6096], [-73.7742, 40.6089], [-73.7747, 40.6043], [-73.7813, 40.5978], [-73.775, 40.6017], [-73.7736, 40.5981], [-73.7681, 40.5978], [-73.7712, 40.5994], [-73.769, 40.6094], [-73.7742, 40.6118], [-73.7667, 40.6143]]]}}]}
# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bool]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, is_water) tuples.
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], bool(row[2])) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], False) for row in cursor.fetchall()]


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]], bool]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
        "is_water": is_water,
      }
      for qx, qy, corners, is_water in quadrant_polygons
    ]
  )

  # NYC boundary GeoJSON for the map
  nyc_boundary_json = json.dumps(NYC_BOUNDARY_GEOJSON)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.water {{
      background: rgba(59, 130, 246, 0.35);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch water"></div>
      <span>Water Tile</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const polygon = L.polygon(q.corners, normalStyle).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hoverStyle);
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(normalStyle);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    if (quadrants.length > 0) {{
      const allLatLngs = quadrants.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []

    for qx, qy in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners))

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")

  try:
    create_debug_map(generation_dir, output_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

Now I need to update the JavaScript to use blue for water tiles:

```python
"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_nyc/e2e_generation/debug_map.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_nyc.e2e_generation.shared import calculate_offset

# Simplified NYC borough boundaries GeoJSON (all 5 boroughs)
# Source: NYC Open Data (dwillis/nyc-maps), simplified using Douglas-Peucker algorithm
# fmt: off
NYC_BOUNDARY_GEOJSON = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8205, 40.801], [-73.8137, 40.7971], [-73.7964, 40.7957], [-73.7928, 40.7888], [-73.7817, 40.7911], [-73.7833, 40.7949], [-73.7769, 40.7964], [-73.7706, 40.7885], [-73.7763, 40.7885], [-73.7668, 40.7798], [-73.7651, 40.7738], [-73.7447, 40.7566], [-73.7551, 40.7675], [-73.7555, 40.7777], [-73.7508, 40.7829], [-73.7013, 40.7508], [-73.7, 40.7392], [-73.7077, 40.7278], [-73.7303, 40.7222], [-73.7269, 40.71], [-73.7256, 40.6796], [-73.7283, 40.663], [-73.7252, 40.652], [-73.7414, 40.6469], [-73.74, 40.6351], [-73.7437, 40.639], [-73.747, 40.6369], [-73.7473, 40.6432], [-73.7548, 40.6478], [-73.7474, 40.6414], [-73.7486, 40.6354], [-73.765, 40.6294], [-73.7708, 40.62], [-73.7717, 40.6236], [-73.7752, 40.6193], [-73.7717, 40.6236], [-73.7792, 40.6273], [-73.7852, 40.6201], [-73.7809, 40.6136], [-73.7914, 40.6076], [-73.8008, 40.6119], [-73.7946, 40.6226], [-73.7897, 40.6226], [-73.7826, 40.6302], [-73.7895, 40.6343], [-73.7981, 40.631], [-73.7908, 40.6343], [-73.8212, 40.6491], [-73.8223, 40.6594], [-73.8113, 40.6606], [-73.8235, 40.6601], [-73.8231, 40.648], [-73.8309, 40.6516], [-73.8302, 40.6598], [-73.8319, 40.6549], [-73.831, 40.6582], [-73.8334, 40.6581], [-73.8311, 40.6486], [-73.8343, 40.6481], [-73.8387, 40.6625], [-73.8359, 40.6455], [-73.8495, 40.6441], [-73.8524, 40.6474], [-73.8494, 40.6514], [-73.8559, 40.6513], [-73.8614, 40.6564], [-73.8596, 40.6585], [-73.8632, 40.6583], [-73.8557, 40.6639], [-73.8576, 40.6717], [-73.8604, 40.6713], [-73.866, 40.6819], [-73.8689, 40.6952], [-73.8965, 40.6823], [-73.9058, 40.6941], [-73.9043, 40.6957], [-73.9219, 40.7094], [-73.9241, 40.7151], [-73.9206, 40.716], [-73.9252, 40.7223], [-73.9204, 40.7237], [-73.938, 40.7305], [-73.9459, 40.7375], [-73.9386, 40.7429], [-73.9472, 40.7379], [-73.9626, 40.7388], [-73.9568, 40.7488], [-73.9532, 40.7477], [-73.9562, 40.7497], [-73.9435, 40.7645], [-73.9349, 40.77], [-73.9378, 40.7736], [-73.9364, 40.7769], [-73.9286, 40.7766], [-73.9099, 40.7909], [-73.8959, 40.7856], [-73.9026, 40.7803], [-73.8944, 40.7842], [-73.8953, 40.7816], [-73.8917, 40.7822], [-73.8925, 40.7774], [-73.8918, 40.7749], [-73.8901, 40.7778], [-73.8895, 40.7735], [-73.8839, 40.7741], [-73.8849, 40.78], [-73.8787, 40.7806], [-73.8797, 40.7829], [-73.8752, 40.7815], [-73.8679, 40.7874], [-73.8726, 40.7808], [-73.8551, 40.7722], [-73.8582, 40.7703], [-73.8562, 40.7689], [-73.8628, 40.7668], [-73.8507, 40.7594], [-73.8391, 40.766], [-73.8478, 40.7668], [-73.8513, 40.7718], [-73.849, 40.778], [-73.8524, 40.7792], [-73.8492, 40.7823], [-73.8553, 40.782], [-73.8595, 40.7855], [-73.8528, 40.7882], [-73.8537, 40.794], [-73.8379, 40.7985], [-73.8403, 40.7976], [-73.8373, 40.789], [-73.8329, 40.7885], [-73.8279, 40.7929], [-73.8295, 40.7968], [-73.8205, 40.801]]]}}, {"type": "Feature", "properties": {"name": "Brooklyn"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9544, 40.7391], [-73.9292, 40.7274], [-73.9246, 40.7192], [-73.9322, 40.715], [-73.9333, 40.711], [-73.9304, 40.7087], [-73.9309, 40.7149], [-73.9236, 40.7173], [-73.9219, 40.7094], [-73.9043, 40.6957], [-73.9058, 40.6941], [-73.8965, 40.6823], [-73.8684, 40.6947], [-73.866, 40.6819], [-73.8604, 40.6713], [-73.8576, 40.6717], [-73.8557, 40.6639], [-73.8633, 40.6569], [-73.857, 40.6506], [-73.8572, 40.6437], [-73.8656, 40.6388], [-73.8793, 40.6546], [-73.868, 40.6381], [-73.8744, 40.6367], [-73.891, 40.6494], [-73.8771, 40.636], [-73.8836, 40.6309], [-73.8837, 40.6276], [-73.8875, 40.6283], [-73.8958, 40.6225], [-73.9175, 40.6314], [-73.8965, 40.6214], [-73.8959, 40.6145], [-73.891, 40.6128], [-73.894, 40.6112], [-73.8897, 40.6115], [-73.8933, 40.6067], [-73.8998, 40.6055], [-73.9013, 40.6117], [-73.9088, 40.6174], [-73.9016, 40.6058], [-73.9137, 40.604], [-73.9171, 40.6088], [-73.9142, 40.6149], [-73.9195, 40.6077], [-73.9089, 40.6016], [-73.884, 40.6056], [-73.8767, 40.5849], [-73.8797, 40.5801], [-73.8955, 40.5768], [-73.899, 40.5877], [-73.9115, 40.5861], [-73.9151, 40.5988], [-73.9215, 40.6019], [-73.9249, 40.5998], [-73.9302, 40.604], [-73.9321, 40.6027], [-73.9142, 40.5892], [-73.9248, 40.5856], [-73.9281, 40.5877], [-73.924, 40.5911], [-73.9286, 40.5886], [-73.9326, 40.5949], [-73.9313, 40.5868], [-73.9135, 40.5861], [-73.9125, 40.5834], [-73.9173, 40.5832], [-73.9115, 40.5818], [-73.9535, 40.583], [-73.9326, 40.5813], [-73.9311, 40.5762], [-74.0021, 40.5696], [-74.012, 40.5749], [-74.0119, 40.5797], [-74.006, 40.582], [-73.9884, 40.5788], [-73.986, 40.5817], [-73.9916, 40.5811], [-73.9903, 40.5846], [-74.0002, 40.5831], [-73.9941, 40.5887], [-74.0004, 40.5865], [-73.9984, 40.5935], [-74.036, 40.6093], [-74.0416, 40.6206], [-74.0368, 40.639], [-74.0388, 40.6396], [-74.0341, 40.6443], [-74.0282, 40.644], [-74.026, 40.6463], [-74.0294, 40.6488], [-74.0247, 40.6471], [-74.0261, 40.651], [-74.0229, 40.6512], [-74.0254, 40.6527], [-74.0212, 40.6508], [-74.0232, 40.6541], [-74.0179, 40.6541], [-74.0198, 40.6565], [-74.0167, 40.6553], [-74.0191, 40.6574], [-74.015, 40.657], [-74.0175, 40.6595], [-74.0155, 40.6608], [-74.0086, 40.6595], [-74.0096, 40.6633], [-74.0035, 40.6622], [-74.0077, 40.6648], [-73.9995, 40.6644], [-74.0029, 40.6665], [-73.9988, 40.6716], [-74.0029, 40.6673], [-74.007, 40.6661], [-74.0054, 40.6709], [-74.0075, 40.6671], [-74.0169, 40.6648], [-74.0193, 40.6716], [-74.0165, 40.6649], [-74.0103, 40.6691], [-74.0157, 40.671], [-74.013, 40.6733], [-74.0163, 40.6729], [-74.015, 40.6747], [-74.0188, 40.6723], [-74.0193, 40.6796], [-74.0128, 40.6836], [-74.013, 40.6804], [-74.0097, 40.6833], [-74.0119, 40.6839], [-74.001, 40.6901], [-73.9946, 40.7044], [-73.9783, 40.706], [-73.9757, 40.6996], [-73.9708, 40.7], [-73.9728, 40.7027], [-73.9695, 40.7005], [-73.9746, 40.7077], [-73.9711, 40.7059], [-73.9723, 40.7091], [-73.9675, 40.7034], [-73.97, 40.7105], [-73.9673, 40.717], [-73.9621, 40.7251], [-73.9579, 40.7246], [-73.9616, 40.7259], [-73.9623, 40.734], [-73.9544, 40.7391]], [[-73.9039, 40.6248], [-73.9039, 40.6248]]]}}, {"type": "Feature", "properties": {"name": "Staten Island"}, "geometry": {"type": "Polygon", "coordinates": [[[-74.0822, 40.6483], [-74.0717, 40.645], [-74.0703, 40.6425], [-74.0731, 40.6419], [-74.0702, 40.642], [-74.0729, 40.6409], [-74.07, 40.6411], [-74.0731, 40.6405], [-74.0735, 40.6372], [-74.0705, 40.6372], [-74.0734, 40.6369], [-74.073, 40.6303], [-74.068, 40.6288], [-74.0729, 40.63], [-74.0723, 40.6246], [-74.0538, 40.6059], [-74.0522, 40.5998], [-74.0734, 40.5783], [-74.091, 40.5667], [-74.1048, 40.553], [-74.1073, 40.5541], [-74.1128, 40.5479], [-74.1225, 40.5448], [-74.1369, 40.5293], [-74.1405, 40.535], [-74.1341, 40.5355], [-74.128, 40.5407], [-74.1307, 40.5463], [-74.1379, 40.546], [-74.1423, 40.5423], [-74.1413, 40.5371], [-74.1776, 40.5192], [-74.1848, 40.5193], [-74.1952, 40.51], [-74.1994, 40.513], [-74.2076, 40.5118], [-74.2176, 40.5033], [-74.2468, 40.4961], [-74.2532, 40.5001], [-74.2556, 40.5077], [-74.2535, 40.5117], [-74.2494, 40.517], [-74.2398, 40.5201], [-74.244, 40.5249], [-74.242, 40.5343], [-74.248, 40.5431], [-74.2307, 40.5556], [-74.2186, 40.5547], [-74.212, 40.5584], [-74.2046, 40.5893], [-74.1975, 40.5968], [-74.2028, 40.6083], [-74.2008, 40.6303], [-74.1946, 40.6374], [-74.18, 40.6453], [-74.1796, 40.6419], [-74.1744, 40.6451], [-74.1713, 40.6429], [-74.173, 40.6405], [-74.1661, 40.6424], [-74.1528, 40.6371], [-74.1514, 40.6394], [-74.1486, 40.6374], [-74.1344, 40.6419], [-74.127, 40.6393], [-74.1097, 40.6455], [-74.0822, 40.6483]]]}}, {"type": "Feature", "properties": {"name": "Bronx"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8729, 40.9044], [-73.8595, 40.9005], [-73.8511, 40.9104], [-73.8535, 40.9075], [-73.8414, 40.9042], [-73.8384, 40.8941], [-73.793, 40.8834], [-73.7974, 40.8751], [-73.8025, 40.8705], [-73.8034, 40.8725], [-73.803, 40.8692], [-73.8084, 40.8712], [-73.8031, 40.8658], [-73.7948, 40.8732], [-73.7929, 40.8793], [-73.7896, 40.8813], [-73.7844, 40.8784], [-73.7872, 40.8727], [-73.7836, 40.8738], [-73.7832, 40.8707], [-73.7914, 40.8681], [-73.7919, 40.8608], [-73.7987, 40.8549], [-73.8003, 40.8481], [-73.8042, 40.8533], [-73.8048, 40.8616], [-73.8077, 40.8585], [-73.8151, 40.8631], [-73.8123, 40.8542], [-73.8164, 40.8541], [-73.8171, 40.8513], [-73.815, 40.8455], [-73.8117, 40.8467], [-73.8144, 40.8431], [-73.8182, 40.8443], [-73.8147, 40.8414], [-73.8149, 40.831], [-73.8099, 40.8282], [-73.814, 40.8242], [-73.807, 40.8254], [-73.8046, 40.819], [-73.7974, 40.8158], [-73.803, 40.8124], [-73.807, 40.8165], [-73.8051, 40.8129], [-73.7909, 40.8073], [-73.7906, 40.8046], [-73.8162, 40.8138], [-73.8302, 40.8108], [-73.8316, 40.8049], [-73.8374, 40.8062], [-73.8423, 40.8291], [-73.8389, 40.8337], [-73.8397, 40.8396], [-73.8431, 40.8298], [-73.84, 40.8199], [-73.8462, 40.8107], [-73.8554, 40.8143], [-73.8491, 40.8123], [-73.8481, 40.8049], [-73.8561, 40.8046], [-73.8592, 40.8063], [-73.859, 40.8103], [-73.8594, 40.8082], [-73.8677, 40.8106], [-73.8765, 40.8161], [-73.8681, 40.8068], [-73.8723, 40.8002], [-73.8951, 40.8069], [-73.9022, 40.8049], [-73.9117, 40.7966], [-73.9276, 40.8027], [-73.9329, 40.8101], [-73.9331, 40.8352], [-73.9067, 40.8758], [-73.9103, 40.879], [-73.9178, 40.8757], [-73.9249, 40.8789], [-73.9115, 40.9138], [-73.8729, 40.9044]]]}}, {"type": "Feature", "properties": {"name": "Manhattan"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9264, 40.8776], [-73.9224, 40.8768], [-73.9213, 40.8731], [-73.9209, 40.8755], [-73.9104, 40.8715], [-73.9194, 40.8589], [-73.9216, 40.8601], [-73.9349, 40.8352], [-73.9343, 40.8096], [-73.929, 40.8011], [-73.9293, 40.7959], [-73.9432, 40.7833], [-73.9429, 40.7747], [-73.9714, 40.7438], [-73.9745, 40.7359], [-73.9715, 40.7274], [-73.9767, 40.7115], [-73.9981, 40.7085], [-74.0083, 40.7007], [-74.0151, 40.7003], [-74.0193, 40.7061], [-74.0167, 40.7186], [-74.0131, 40.7189], [-74.0117, 40.7259], [-74.0152, 40.7264], [-74.0115, 40.7264], [-74.0144, 40.7285], [-74.0109, 40.733], [-74.014, 40.7333], [-74.0107, 40.7334], [-74.0127, 40.7407], [-74.0095, 40.7407], [-74.0121, 40.7436], [-74.0089, 40.7439], [-74.0118, 40.7456], [-74.0095, 40.7458], [-74.0116, 40.7466], [-74.0092, 40.7468], [-74.0114, 40.7476], [-74.0091, 40.7478], [-74.01, 40.7529], [-74.0048, 40.7578], [-74.007, 40.7592], [-74.001, 40.7634], [-74.0031, 40.7647], [-73.9996, 40.7636], [-74.0023, 40.7656], [-73.9983, 40.7656], [-74.0016, 40.767], [-73.9981, 40.7659], [-74.0006, 40.7682], [-73.9972, 40.7671], [-73.9997, 40.7695], [-73.9971, 40.7687], [-73.999, 40.7705], [-73.9949, 40.7715], [-73.9967, 40.7735], [-73.9942, 40.7725], [-73.9962, 40.774], [-73.9923, 40.7751], [-73.9889, 40.7797], [-73.9916, 40.7796], [-73.9582, 40.8223], [-73.9461, 40.8439], [-73.947, 40.8505], [-73.9419, 40.8539], [-73.9264, 40.8776]]]}}, {"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.7667, 40.6143], [-73.7602, 40.6108], [-73.7616, 40.609], [-73.7458, 40.612], [-73.7382, 40.6027], [-73.7381, 40.5977], [-73.7418, 40.5967], [-73.7381, 40.5974], [-73.7376, 40.5944], [-73.8135, 40.5835], [-73.8703, 40.5642], [-73.9069, 40.5556], [-73.9407, 40.5418], [-73.9399, 40.5546], [-73.9262, 40.5616], [-73.912, 40.5659], [-73.9015, 40.563], [-73.8926, 40.5686], [-73.8778, 40.5688], [-73.8504, 40.5821], [-73.8393, 40.5819], [-73.8215, 40.5868], [-73.8096, 40.5936], [-73.8057, 40.5908], [-73.808, 40.5942], [-73.8024, 40.5926], [-73.8052, 40.5969], [-73.803, 40.5988], [-73.7864, 40.6032], [-73.7903, 40.5992], [-73.7898, 40.5947], [-73.7786, 40.6096], [-73.7742, 40.6089], [-73.7747, 40.6043], [-73.7813, 40.5978], [-73.775, 40.6017], [-73.7736, 40.5981], [-73.7681, 40.5978], [-73.7712, 40.5994], [-73.769, 40.6094], [-73.7742, 40.6118], [-73.7667, 40.6143]]]}}]}
# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bool]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, is_water) tuples.
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], bool(row[2])) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], False) for row in cursor.fetchall()]


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]], bool]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
        "is_water": is_water,
      }
      for qx, qy, corners, is_water in quadrant_polygons
    ]
  )

  # NYC boundary GeoJSON for the map
  nyc_boundary_json = json.dumps(NYC_BOUNDARY_GEOJSON)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.water {{
      background: rgba(59, 130, 246, 0.35);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch water"></div>
      <span>Water Tile</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state (red for land)
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state (land)
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for water tiles (blue)
    const waterStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.35,
      color: '#3b82f6',
      weight: 1.5,
      opacity: 0.7
    }};

    // Style for water hover state
    const waterHoverStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.6,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const style = q.is_water ? waterStyle : normalStyle;
      const hStyle = q.is_water ? waterHoverStyle : hoverStyle;
      const polygon = L.polygon(q.corners, style).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hoverStyle);
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(normalStyle);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    if (quadrants.length > 0) {{
      const allLatLngs = quadrants.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []

    for qx, qy in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners))

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")

  try:
    create_debug_map(generation_dir, output_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

```python
"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_nyc/e2e_generation/debug_map.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_nyc.e2e_generation.shared import calculate_offset

# Simplified NYC borough boundaries GeoJSON (all 5 boroughs)
# Source: NYC Open Data (dwillis/nyc-maps), simplified using Douglas-Peucker algorithm
# fmt: off
NYC_BOUNDARY_GEOJSON = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8205, 40.801], [-73.8137, 40.7971], [-73.7964, 40.7957], [-73.7928, 40.7888], [-73.7817, 40.7911], [-73.7833, 40.7949], [-73.7769, 40.7964], [-73.7706, 40.7885], [-73.7763, 40.7885], [-73.7668, 40.7798], [-73.7651, 40.7738], [-73.7447, 40.7566], [-73.7551, 40.7675], [-73.7555, 40.7777], [-73.7508, 40.7829], [-73.7013, 40.7508], [-73.7, 40.7392], [-73.7077, 40.7278], [-73.7303, 40.7222], [-73.7269, 40.71], [-73.7256, 40.6796], [-73.7283, 40.663], [-73.7252, 40.652], [-73.7414, 40.6469], [-73.74, 40.6351], [-73.7437, 40.639], [-73.747, 40.6369], [-73.7473, 40.6432], [-73.7548, 40.6478], [-73.7474, 40.6414], [-73.7486, 40.6354], [-73.765, 40.6294], [-73.7708, 40.62], [-73.7717, 40.6236], [-73.7752, 40.6193], [-73.7717, 40.6236], [-73.7792, 40.6273], [-73.7852, 40.6201], [-73.7809, 40.6136], [-73.7914, 40.6076], [-73.8008, 40.6119], [-73.7946, 40.6226], [-73.7897, 40.6226], [-73.7826, 40.6302], [-73.7895, 40.6343], [-73.7981, 40.631], [-73.7908, 40.6343], [-73.8212, 40.6491], [-73.8223, 40.6594], [-73.8113, 40.6606], [-73.8235, 40.6601], [-73.8231, 40.648], [-73.8309, 40.6516], [-73.8302, 40.6598], [-73.8319, 40.6549], [-73.831, 40.6582], [-73.8334, 40.6581], [-73.8311, 40.6486], [-73.8343, 40.6481], [-73.8387, 40.6625], [-73.8359, 40.6455], [-73.8495, 40.6441], [-73.8524, 40.6474], [-73.8494, 40.6514], [-73.8559, 40.6513], [-73.8614, 40.6564], [-73.8596, 40.6585], [-73.8632, 40.6583], [-73.8557, 40.6639], [-73.8576, 40.6717], [-73.8604, 40.6713], [-73.866, 40.6819], [-73.8689, 40.6952], [-73.8965, 40.6823], [-73.9058, 40.6941], [-73.9043, 40.6957], [-73.9219, 40.7094], [-73.9241, 40.7151], [-73.9206, 40.716], [-73.9252, 40.7223], [-73.9204, 40.7237], [-73.938, 40.7305], [-73.9459, 40.7375], [-73.9386, 40.7429], [-73.9472, 40.7379], [-73.9626, 40.7388], [-73.9568, 40.7488], [-73.9532, 40.7477], [-73.9562, 40.7497], [-73.9435, 40.7645], [-73.9349, 40.77], [-73.9378, 40.7736], [-73.9364, 40.7769], [-73.9286, 40.7766], [-73.9099, 40.7909], [-73.8959, 40.7856], [-73.9026, 40.7803], [-73.8944, 40.7842], [-73.8953, 40.7816], [-73.8917, 40.7822], [-73.8925, 40.7774], [-73.8918, 40.7749], [-73.8901, 40.7778], [-73.8895, 40.7735], [-73.8839, 40.7741], [-73.8849, 40.78], [-73.8787, 40.7806], [-73.8797, 40.7829], [-73.8752, 40.7815], [-73.8679, 40.7874], [-73.8726, 40.7808], [-73.8551, 40.7722], [-73.8582, 40.7703], [-73.8562, 40.7689], [-73.8628, 40.7668], [-73.8507, 40.7594], [-73.8391, 40.766], [-73.8478, 40.7668], [-73.8513, 40.7718], [-73.849, 40.778], [-73.8524, 40.7792], [-73.8492, 40.7823], [-73.8553, 40.782], [-73.8595, 40.7855], [-73.8528, 40.7882], [-73.8537, 40.794], [-73.8379, 40.7985], [-73.8403, 40.7976], [-73.8373, 40.789], [-73.8329, 40.7885], [-73.8279, 40.7929], [-73.8295, 40.7968], [-73.8205, 40.801]]]}}, {"type": "Feature", "properties": {"name": "Brooklyn"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9544, 40.7391], [-73.9292, 40.7274], [-73.9246, 40.7192], [-73.9322, 40.715], [-73.9333, 40.711], [-73.9304, 40.7087], [-73.9309, 40.7149], [-73.9236, 40.7173], [-73.9219, 40.7094], [-73.9043, 40.6957], [-73.9058, 40.6941], [-73.8965, 40.6823], [-73.8684, 40.6947], [-73.866, 40.6819], [-73.8604, 40.6713], [-73.8576, 40.6717], [-73.8557, 40.6639], [-73.8633, 40.6569], [-73.857, 40.6506], [-73.8572, 40.6437], [-73.8656, 40.6388], [-73.8793, 40.6546], [-73.868, 40.6381], [-73.8744, 40.6367], [-73.891, 40.6494], [-73.8771, 40.636], [-73.8836, 40.6309], [-73.8837, 40.6276], [-73.8875, 40.6283], [-73.8958, 40.6225], [-73.9175, 40.6314], [-73.8965, 40.6214], [-73.8959, 40.6145], [-73.891, 40.6128], [-73.894, 40.6112], [-73.8897, 40.6115], [-73.8933, 40.6067], [-73.8998, 40.6055], [-73.9013, 40.6117], [-73.9088, 40.6174], [-73.9016, 40.6058], [-73.9137, 40.604], [-73.9171, 40.6088], [-73.9142, 40.6149], [-73.9195, 40.6077], [-73.9089, 40.6016], [-73.884, 40.6056], [-73.8767, 40.5849], [-73.8797, 40.5801], [-73.8955, 40.5768], [-73.899, 40.5877], [-73.9115, 40.5861], [-73.9151, 40.5988], [-73.9215, 40.6019], [-73.9249, 40.5998], [-73.9302, 40.604], [-73.9321, 40.6027], [-73.9142, 40.5892], [-73.9248, 40.5856], [-73.9281, 40.5877], [-73.924, 40.5911], [-73.9286, 40.5886], [-73.9326, 40.5949], [-73.9313, 40.5868], [-73.9135, 40.5861], [-73.9125, 40.5834], [-73.9173, 40.5832], [-73.9115, 40.5818], [-73.9535, 40.583], [-73.9326, 40.5813], [-73.9311, 40.5762], [-74.0021, 40.5696], [-74.012, 40.5749], [-74.0119, 40.5797], [-74.006, 40.582], [-73.9884, 40.5788], [-73.986, 40.5817], [-73.9916, 40.5811], [-73.9903, 40.5846], [-74.0002, 40.5831], [-73.9941, 40.5887], [-74.0004, 40.5865], [-73.9984, 40.5935], [-74.036, 40.6093], [-74.0416, 40.6206], [-74.0368, 40.639], [-74.0388, 40.6396], [-74.0341, 40.6443], [-74.0282, 40.644], [-74.026, 40.6463], [-74.0294, 40.6488], [-74.0247, 40.6471], [-74.0261, 40.651], [-74.0229, 40.6512], [-74.0254, 40.6527], [-74.0212, 40.6508], [-74.0232, 40.6541], [-74.0179, 40.6541], [-74.0198, 40.6565], [-74.0167, 40.6553], [-74.0191, 40.6574], [-74.015, 40.657], [-74.0175, 40.6595], [-74.0155, 40.6608], [-74.0086, 40.6595], [-74.0096, 40.6633], [-74.0035, 40.6622], [-74.0077, 40.6648], [-73.9995, 40.6644], [-74.0029, 40.6665], [-73.9988, 40.6716], [-74.0029, 40.6673], [-74.007, 40.6661], [-74.0054, 40.6709], [-74.0075, 40.6671], [-74.0169, 40.6648], [-74.0193, 40.6716], [-74.0165, 40.6649], [-74.0103, 40.6691], [-74.0157, 40.671], [-74.013, 40.6733], [-74.0163, 40.6729], [-74.015, 40.6747], [-74.0188, 40.6723], [-74.0193, 40.6796], [-74.0128, 40.6836], [-74.013, 40.6804], [-74.0097, 40.6833], [-74.0119, 40.6839], [-74.001, 40.6901], [-73.9946, 40.7044], [-73.9783, 40.706], [-73.9757, 40.6996], [-73.9708, 40.7], [-73.9728, 40.7027], [-73.9695, 40.7005], [-73.9746, 40.7077], [-73.9711, 40.7059], [-73.9723, 40.7091], [-73.9675, 40.7034], [-73.97, 40.7105], [-73.9673, 40.717], [-73.9621, 40.7251], [-73.9579, 40.7246], [-73.9616, 40.7259], [-73.9623, 40.734], [-73.9544, 40.7391]], [[-73.9039, 40.6248], [-73.9039, 40.6248]]]}}, {"type": "Feature", "properties": {"name": "Staten Island"}, "geometry": {"type": "Polygon", "coordinates": [[[-74.0822, 40.6483], [-74.0717, 40.645], [-74.0703, 40.6425], [-74.0731, 40.6419], [-74.0702, 40.642], [-74.0729, 40.6409], [-74.07, 40.6411], [-74.0731, 40.6405], [-74.0735, 40.6372], [-74.0705, 40.6372], [-74.0734, 40.6369], [-74.073, 40.6303], [-74.068, 40.6288], [-74.0729, 40.63], [-74.0723, 40.6246], [-74.0538, 40.6059], [-74.0522, 40.5998], [-74.0734, 40.5783], [-74.091, 40.5667], [-74.1048, 40.553], [-74.1073, 40.5541], [-74.1128, 40.5479], [-74.1225, 40.5448], [-74.1369, 40.5293], [-74.1405, 40.535], [-74.1341, 40.5355], [-74.128, 40.5407], [-74.1307, 40.5463], [-74.1379, 40.546], [-74.1423, 40.5423], [-74.1413, 40.5371], [-74.1776, 40.5192], [-74.1848, 40.5193], [-74.1952, 40.51], [-74.1994, 40.513], [-74.2076, 40.5118], [-74.2176, 40.5033], [-74.2468, 40.4961], [-74.2532, 40.5001], [-74.2556, 40.5077], [-74.2535, 40.5117], [-74.2494, 40.517], [-74.2398, 40.5201], [-74.244, 40.5249], [-74.242, 40.5343], [-74.248, 40.5431], [-74.2307, 40.5556], [-74.2186, 40.5547], [-74.212, 40.5584], [-74.2046, 40.5893], [-74.1975, 40.5968], [-74.2028, 40.6083], [-74.2008, 40.6303], [-74.1946, 40.6374], [-74.18, 40.6453], [-74.1796, 40.6419], [-74.1744, 40.6451], [-74.1713, 40.6429], [-74.173, 40.6405], [-74.1661, 40.6424], [-74.1528, 40.6371], [-74.1514, 40.6394], [-74.1486, 40.6374], [-74.1344, 40.6419], [-74.127, 40.6393], [-74.1097, 40.6455], [-74.0822, 40.6483]]]}}, {"type": "Feature", "properties": {"name": "Bronx"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8729, 40.9044], [-73.8595, 40.9005], [-73.8511, 40.9104], [-73.8535, 40.9075], [-73.8414, 40.9042], [-73.8384, 40.8941], [-73.793, 40.8834], [-73.7974, 40.8751], [-73.8025, 40.8705], [-73.8034, 40.8725], [-73.803, 40.8692], [-73.8084, 40.8712], [-73.8031, 40.8658], [-73.7948, 40.8732], [-73.7929, 40.8793], [-73.7896, 40.8813], [-73.7844, 40.8784], [-73.7872, 40.8727], [-73.7836, 40.8738], [-73.7832, 40.8707], [-73.7914, 40.8681], [-73.7919, 40.8608], [-73.7987, 40.8549], [-73.8003, 40.8481], [-73.8042, 40.8533], [-73.8048, 40.8616], [-73.8077, 40.8585], [-73.8151, 40.8631], [-73.8123, 40.8542], [-73.8164, 40.8541], [-73.8171, 40.8513], [-73.815, 40.8455], [-73.8117, 40.8467], [-73.8144, 40.8431], [-73.8182, 40.8443], [-73.8147, 40.8414], [-73.8149, 40.831], [-73.8099, 40.8282], [-73.814, 40.8242], [-73.807, 40.8254], [-73.8046, 40.819], [-73.7974, 40.8158], [-73.803, 40.8124], [-73.807, 40.8165], [-73.8051, 40.8129], [-73.7909, 40.8073], [-73.7906, 40.8046], [-73.8162, 40.8138], [-73.8302, 40.8108], [-73.8316, 40.8049], [-73.8374, 40.8062], [-73.8423, 40.8291], [-73.8389, 40.8337], [-73.8397, 40.8396], [-73.8431, 40.8298], [-73.84, 40.8199], [-73.8462, 40.8107], [-73.8554, 40.8143], [-73.8491, 40.8123], [-73.8481, 40.8049], [-73.8561, 40.8046], [-73.8592, 40.8063], [-73.859, 40.8103], [-73.8594, 40.8082], [-73.8677, 40.8106], [-73.8765, 40.8161], [-73.8681, 40.8068], [-73.8723, 40.8002], [-73.8951, 40.8069], [-73.9022, 40.8049], [-73.9117, 40.7966], [-73.9276, 40.8027], [-73.9329, 40.8101], [-73.9331, 40.8352], [-73.9067, 40.8758], [-73.9103, 40.879], [-73.9178, 40.8757], [-73.9249, 40.8789], [-73.9115, 40.9138], [-73.8729, 40.9044]]]}}, {"type": "Feature", "properties": {"name": "Manhattan"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9264, 40.8776], [-73.9224, 40.8768], [-73.9213, 40.8731], [-73.9209, 40.8755], [-73.9104, 40.8715], [-73.9194, 40.8589], [-73.9216, 40.8601], [-73.9349, 40.8352], [-73.9343, 40.8096], [-73.929, 40.8011], [-73.9293, 40.7959], [-73.9432, 40.7833], [-73.9429, 40.7747], [-73.9714, 40.7438], [-73.9745, 40.7359], [-73.9715, 40.7274], [-73.9767, 40.7115], [-73.9981, 40.7085], [-74.0083, 40.7007], [-74.0151, 40.7003], [-74.0193, 40.7061], [-74.0167, 40.7186], [-74.0131, 40.7189], [-74.0117, 40.7259], [-74.0152, 40.7264], [-74.0115, 40.7264], [-74.0144, 40.7285], [-74.0109, 40.733], [-74.014, 40.7333], [-74.0107, 40.7334], [-74.0127, 40.7407], [-74.0095, 40.7407], [-74.0121, 40.7436], [-74.0089, 40.7439], [-74.0118, 40.7456], [-74.0095, 40.7458], [-74.0116, 40.7466], [-74.0092, 40.7468], [-74.0114, 40.7476], [-74.0091, 40.7478], [-74.01, 40.7529], [-74.0048, 40.7578], [-74.007, 40.7592], [-74.001, 40.7634], [-74.0031, 40.7647], [-73.9996, 40.7636], [-74.0023, 40.7656], [-73.9983, 40.7656], [-74.0016, 40.767], [-73.9981, 40.7659], [-74.0006, 40.7682], [-73.9972, 40.7671], [-73.9997, 40.7695], [-73.9971, 40.7687], [-73.999, 40.7705], [-73.9949, 40.7715], [-73.9967, 40.7735], [-73.9942, 40.7725], [-73.9962, 40.774], [-73.9923, 40.7751], [-73.9889, 40.7797], [-73.9916, 40.7796], [-73.9582, 40.8223], [-73.9461, 40.8439], [-73.947, 40.8505], [-73.9419, 40.8539], [-73.9264, 40.8776]]]}}, {"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.7667, 40.6143], [-73.7602, 40.6108], [-73.7616, 40.609], [-73.7458, 40.612], [-73.7382, 40.6027], [-73.7381, 40.5977], [-73.7418, 40.5967], [-73.7381, 40.5974], [-73.7376, 40.5944], [-73.8135, 40.5835], [-73.8703, 40.5642], [-73.9069, 40.5556], [-73.9407, 40.5418], [-73.9399, 40.5546], [-73.9262, 40.5616], [-73.912, 40.5659], [-73.9015, 40.563], [-73.8926, 40.5686], [-73.8778, 40.5688], [-73.8504, 40.5821], [-73.8393, 40.5819], [-73.8215, 40.5868], [-73.8096, 40.5936], [-73.8057, 40.5908], [-73.808, 40.5942], [-73.8024, 40.5926], [-73.8052, 40.5969], [-73.803, 40.5988], [-73.7864, 40.6032], [-73.7903, 40.5992], [-73.7898, 40.5947], [-73.7786, 40.6096], [-73.7742, 40.6089], [-73.7747, 40.6043], [-73.7813, 40.5978], [-73.775, 40.6017], [-73.7736, 40.5981], [-73.7681, 40.5978], [-73.7712, 40.5994], [-73.769, 40.6094], [-73.7742, 40.6118], [-73.7667, 40.6143]]]}}]}
# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bool]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, is_water) tuples.
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], bool(row[2])) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], False) for row in cursor.fetchall()]


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]], bool]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
        "is_water": is_water,
      }
      for qx, qy, corners, is_water in quadrant_polygons
    ]
  )

  # NYC boundary GeoJSON for the map
  nyc_boundary_json = json.dumps(NYC_BOUNDARY_GEOJSON)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.water {{
      background: rgba(59, 130, 246, 0.35);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch water"></div>
      <span>Water Tile</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state (red for land)
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state (land)
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for water tiles (blue)
    const waterStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.35,
      color: '#3b82f6',
      weight: 1.5,
      opacity: 0.7
    }};

    // Style for water hover state
    const waterHoverStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.6,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const style = q.is_water ? waterStyle : normalStyle;
      const hStyle = q.is_water ? waterHoverStyle : hoverStyle;
      const polygon = L.polygon(q.corners, style).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hStyle);
        const waterLabel = q.is_water ? ' <span style="color: #3b82f6;">üíß</span>' : '';
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
            ${{waterLabel}}
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(style);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    if (quadrants.length > 0) {{
      const allLatLngs = quadrants.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []

    for qx, qy in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners))

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")

  try:
    create_debug_map(generation_dir, output_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

Now I need to update the part of the code that builds the quadrant_polygons list to include the is_water flag:

```python
"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_nyc/e2e_generation/debug_map.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_nyc.e2e_generation.shared import calculate_offset

# Simplified NYC borough boundaries GeoJSON (all 5 boroughs)
# Source: NYC Open Data (dwillis/nyc-maps), simplified using Douglas-Peucker algorithm
# fmt: off
NYC_BOUNDARY_GEOJSON = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8205, 40.801], [-73.8137, 40.7971], [-73.7964, 40.7957], [-73.7928, 40.7888], [-73.7817, 40.7911], [-73.7833, 40.7949], [-73.7769, 40.7964], [-73.7706, 40.7885], [-73.7763, 40.7885], [-73.7668, 40.7798], [-73.7651, 40.7738], [-73.7447, 40.7566], [-73.7551, 40.7675], [-73.7555, 40.7777], [-73.7508, 40.7829], [-73.7013, 40.7508], [-73.7, 40.7392], [-73.7077, 40.7278], [-73.7303, 40.7222], [-73.7269, 40.71], [-73.7256, 40.6796], [-73.7283, 40.663], [-73.7252, 40.652], [-73.7414, 40.6469], [-73.74, 40.6351], [-73.7437, 40.639], [-73.747, 40.6369], [-73.7473, 40.6432], [-73.7548, 40.6478], [-73.7474, 40.6414], [-73.7486, 40.6354], [-73.765, 40.6294], [-73.7708, 40.62], [-73.7717, 40.6236], [-73.7752, 40.6193], [-73.7717, 40.6236], [-73.7792, 40.6273], [-73.7852, 40.6201], [-73.7809, 40.6136], [-73.7914, 40.6076], [-73.8008, 40.6119], [-73.7946, 40.6226], [-73.7897, 40.6226], [-73.7826, 40.6302], [-73.7895, 40.6343], [-73.7981, 40.631], [-73.7908, 40.6343], [-73.8212, 40.6491], [-73.8223, 40.6594], [-73.8113, 40.6606], [-73.8235, 40.6601], [-73.8231, 40.648], [-73.8309, 40.6516], [-73.8302, 40.6598], [-73.8319, 40.6549], [-73.831, 40.6582], [-73.8334, 40.6581], [-73.8311, 40.6486], [-73.8343, 40.6481], [-73.8387, 40.6625], [-73.8359, 40.6455], [-73.8495, 40.6441], [-73.8524, 40.6474], [-73.8494, 40.6514], [-73.8559, 40.6513], [-73.8614, 40.6564], [-73.8596, 40.6585], [-73.8632, 40.6583], [-73.8557, 40.6639], [-73.8576, 40.6717], [-73.8604, 40.6713], [-73.866, 40.6819], [-73.8689, 40.6952], [-73.8965, 40.6823], [-73.9058, 40.6941], [-73.9043, 40.6957], [-73.9219, 40.7094], [-73.9241, 40.7151], [-73.9206, 40.716], [-73.9252, 40.7223], [-73.9204, 40.7237], [-73.938, 40.7305], [-73.9459, 40.7375], [-73.9386, 40.7429], [-73.9472, 40.7379], [-73.9626, 40.7388], [-73.9568, 40.7488], [-73.9532, 40.7477], [-73.9562, 40.7497], [-73.9435, 40.7645], [-73.9349, 40.77], [-73.9378, 40.7736], [-73.9364, 40.7769], [-73.9286, 40.7766], [-73.9099, 40.7909], [-73.8959, 40.7856], [-73.9026, 40.7803], [-73.8944, 40.7842], [-73.8953, 40.7816], [-73.8917, 40.7822], [-73.8925, 40.7774], [-73.8918, 40.7749], [-73.8901, 40.7778], [-73.8895, 40.7735], [-73.8839, 40.7741], [-73.8849, 40.78], [-73.8787, 40.7806], [-73.8797, 40.7829], [-73.8752, 40.7815], [-73.8679, 40.7874], [-73.8726, 40.7808], [-73.8551, 40.7722], [-73.8582, 40.7703], [-73.8562, 40.7689], [-73.8628, 40.7668], [-73.8507, 40.7594], [-73.8391, 40.766], [-73.8478, 40.7668], [-73.8513, 40.7718], [-73.849, 40.778], [-73.8524, 40.7792], [-73.8492, 40.7823], [-73.8553, 40.782], [-73.8595, 40.7855], [-73.8528, 40.7882], [-73.8537, 40.794], [-73.8379, 40.7985], [-73.8403, 40.7976], [-73.8373, 40.789], [-73.8329, 40.7885], [-73.8279, 40.7929], [-73.8295, 40.7968], [-73.8205, 40.801]]]}}, {"type": "Feature", "properties": {"name": "Brooklyn"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9544, 40.7391], [-73.9292, 40.7274], [-73.9246, 40.7192], [-73.9322, 40.715], [-73.9333, 40.711], [-73.9304, 40.7087], [-73.9309, 40.7149], [-73.9236, 40.7173], [-73.9219, 40.7094], [-73.9043, 40.6957], [-73.9058, 40.6941], [-73.8965, 40.6823], [-73.8684, 40.6947], [-73.866, 40.6819], [-73.8604, 40.6713], [-73.8576, 40.6717], [-73.8557, 40.6639], [-73.8633, 40.6569], [-73.857, 40.6506], [-73.8572, 40.6437], [-73.8656, 40.6388], [-73.8793, 40.6546], [-73.868, 40.6381], [-73.8744, 40.6367], [-73.891, 40.6494], [-73.8771, 40.636], [-73.8836, 40.6309], [-73.8837, 40.6276], [-73.8875, 40.6283], [-73.8958, 40.6225], [-73.9175, 40.6314], [-73.8965, 40.6214], [-73.8959, 40.6145], [-73.891, 40.6128], [-73.894, 40.6112], [-73.8897, 40.6115], [-73.8933, 40.6067], [-73.8998, 40.6055], [-73.9013, 40.6117], [-73.9088, 40.6174], [-73.9016, 40.6058], [-73.9137, 40.604], [-73.9171, 40.6088], [-73.9142, 40.6149], [-73.9195, 40.6077], [-73.9089, 40.6016], [-73.884, 40.6056], [-73.8767, 40.5849], [-73.8797, 40.5801], [-73.8955, 40.5768], [-73.899, 40.5877], [-73.9115, 40.5861], [-73.9151, 40.5988], [-73.9215, 40.6019], [-73.9249, 40.5998], [-73.9302, 40.604], [-73.9321, 40.6027], [-73.9142, 40.5892], [-73.9248, 40.5856], [-73.9281, 40.5877], [-73.924, 40.5911], [-73.9286, 40.5886], [-73.9326, 40.5949], [-73.9313, 40.5868], [-73.9135, 40.5861], [-73.9125, 40.5834], [-73.9173, 40.5832], [-73.9115, 40.5818], [-73.9535, 40.583], [-73.9326, 40.5813], [-73.9311, 40.5762], [-74.0021, 40.5696], [-74.012, 40.5749], [-74.0119, 40.5797], [-74.006, 40.582], [-73.9884, 40.5788], [-73.986, 40.5817], [-73.9916, 40.5811], [-73.9903, 40.5846], [-74.0002, 40.5831], [-73.9941, 40.5887], [-74.0004, 40.5865], [-73.9984, 40.5935], [-74.036, 40.6093], [-74.0416, 40.6206], [-74.0368, 40.639], [-74.0388, 40.6396], [-74.0341, 40.6443], [-74.0282, 40.644], [-74.026, 40.6463], [-74.0294, 40.6488], [-74.0247, 40.6471], [-74.0261, 40.651], [-74.0229, 40.6512], [-74.0254, 40.6527], [-74.0212, 40.6508], [-74.0232, 40.6541], [-74.0179, 40.6541], [-74.0198, 40.6565], [-74.0167, 40.6553], [-74.0191, 40.6574], [-74.015, 40.657], [-74.0175, 40.6595], [-74.0155, 40.6608], [-74.0086, 40.6595], [-74.0096, 40.6633], [-74.0035, 40.6622], [-74.0077, 40.6648], [-73.9995, 40.6644], [-74.0029, 40.6665], [-73.9988, 40.6716], [-74.0029, 40.6673], [-74.007, 40.6661], [-74.0054, 40.6709], [-74.0075, 40.6671], [-74.0169, 40.6648], [-74.0193, 40.6716], [-74.0165, 40.6649], [-74.0103, 40.6691], [-74.0157, 40.671], [-74.013, 40.6733], [-74.0163, 40.6729], [-74.015, 40.6747], [-74.0188, 40.6723], [-74.0193, 40.6796], [-74.0128, 40.6836], [-74.013, 40.6804], [-74.0097, 40.6833], [-74.0119, 40.6839], [-74.001, 40.6901], [-73.9946, 40.7044], [-73.9783, 40.706], [-73.9757, 40.6996], [-73.9708, 40.7], [-73.9728, 40.7027], [-73.9695, 40.7005], [-73.9746, 40.7077], [-73.9711, 40.7059], [-73.9723, 40.7091], [-73.9675, 40.7034], [-73.97, 40.7105], [-73.9673, 40.717], [-73.9621, 40.7251], [-73.9579, 40.7246], [-73.9616, 40.7259], [-73.9623, 40.734], [-73.9544, 40.7391]], [[-73.9039, 40.6248], [-73.9039, 40.6248]]]}}, {"type": "Feature", "properties": {"name": "Staten Island"}, "geometry": {"type": "Polygon", "coordinates": [[[-74.0822, 40.6483], [-74.0717, 40.645], [-74.0703, 40.6425], [-74.0731, 40.6419], [-74.0702, 40.642], [-74.0729, 40.6409], [-74.07, 40.6411], [-74.0731, 40.6405], [-74.0735, 40.6372], [-74.0705, 40.6372], [-74.0734, 40.6369], [-74.073, 40.6303], [-74.068, 40.6288], [-74.0729, 40.63], [-74.0723, 40.6246], [-74.0538, 40.6059], [-74.0522, 40.5998], [-74.0734, 40.5783], [-74.091, 40.5667], [-74.1048, 40.553], [-74.1073, 40.5541], [-74.1128, 40.5479], [-74.1225, 40.5448], [-74.1369, 40.5293], [-74.1405, 40.535], [-74.1341, 40.5355], [-74.128, 40.5407], [-74.1307, 40.5463], [-74.1379, 40.546], [-74.1423, 40.5423], [-74.1413, 40.5371], [-74.1776, 40.5192], [-74.1848, 40.5193], [-74.1952, 40.51], [-74.1994, 40.513], [-74.2076, 40.5118], [-74.2176, 40.5033], [-74.2468, 40.4961], [-74.2532, 40.5001], [-74.2556, 40.5077], [-74.2535, 40.5117], [-74.2494, 40.517], [-74.2398, 40.5201], [-74.244, 40.5249], [-74.242, 40.5343], [-74.248, 40.5431], [-74.2307, 40.5556], [-74.2186, 40.5547], [-74.212, 40.5584], [-74.2046, 40.5893], [-74.1975, 40.5968], [-74.2028, 40.6083], [-74.2008, 40.6303], [-74.1946, 40.6374], [-74.18, 40.6453], [-74.1796, 40.6419], [-74.1744, 40.6451], [-74.1713, 40.6429], [-74.173, 40.6405], [-74.1661, 40.6424], [-74.1528, 40.6371], [-74.1514, 40.6394], [-74.1486, 40.6374], [-74.1344, 40.6419], [-74.127, 40.6393], [-74.1097, 40.6455], [-74.0822, 40.6483]]]}}, {"type": "Feature", "properties": {"name": "Bronx"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8729, 40.9044], [-73.8595, 40.9005], [-73.8511, 40.9104], [-73.8535, 40.9075], [-73.8414, 40.9042], [-73.8384, 40.8941], [-73.793, 40.8834], [-73.7974, 40.8751], [-73.8025, 40.8705], [-73.8034, 40.8725], [-73.803, 40.8692], [-73.8084, 40.8712], [-73.8031, 40.8658], [-73.7948, 40.8732], [-73.7929, 40.8793], [-73.7896, 40.8813], [-73.7844, 40.8784], [-73.7872, 40.8727], [-73.7836, 40.8738], [-73.7832, 40.8707], [-73.7914, 40.8681], [-73.7919, 40.8608], [-73.7987, 40.8549], [-73.8003, 40.8481], [-73.8042, 40.8533], [-73.8048, 40.8616], [-73.8077, 40.8585], [-73.8151, 40.8631], [-73.8123, 40.8542], [-73.8164, 40.8541], [-73.8171, 40.8513], [-73.815, 40.8455], [-73.8117, 40.8467], [-73.8144, 40.8431], [-73.8182, 40.8443], [-73.8147, 40.8414], [-73.8149, 40.831], [-73.8099, 40.8282], [-73.814, 40.8242], [-73.807, 40.8254], [-73.8046, 40.819], [-73.7974, 40.8158], [-73.803, 40.8124], [-73.807, 40.8165], [-73.8051, 40.8129], [-73.7909, 40.8073], [-73.7906, 40.8046], [-73.8162, 40.8138], [-73.8302, 40.8108], [-73.8316, 40.8049], [-73.8374, 40.8062], [-73.8423, 40.8291], [-73.8389, 40.8337], [-73.8397, 40.8396], [-73.8431, 40.8298], [-73.84, 40.8199], [-73.8462, 40.8107], [-73.8554, 40.8143], [-73.8491, 40.8123], [-73.8481, 40.8049], [-73.8561, 40.8046], [-73.8592, 40.8063], [-73.859, 40.8103], [-73.8594, 40.8082], [-73.8677, 40.8106], [-73.8765, 40.8161], [-73.8681, 40.8068], [-73.8723, 40.8002], [-73.8951, 40.8069], [-73.9022, 40.8049], [-73.9117, 40.7966], [-73.9276, 40.8027], [-73.9329, 40.8101], [-73.9331, 40.8352], [-73.9067, 40.8758], [-73.9103, 40.879], [-73.9178, 40.8757], [-73.9249, 40.8789], [-73.9115, 40.9138], [-73.8729, 40.9044]]]}}, {"type": "Feature", "properties": {"name": "Manhattan"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9264, 40.8776], [-73.9224, 40.8768], [-73.9213, 40.8731], [-73.9209, 40.8755], [-73.9104, 40.8715], [-73.9194, 40.8589], [-73.9216, 40.8601], [-73.9349, 40.8352], [-73.9343, 40.8096], [-73.929, 40.8011], [-73.9293, 40.7959], [-73.9432, 40.7833], [-73.9429, 40.7747], [-73.9714, 40.7438], [-73.9745, 40.7359], [-73.9715, 40.7274], [-73.9767, 40.7115], [-73.9981, 40.7085], [-74.0083, 40.7007], [-74.0151, 40.7003], [-74.0193, 40.7061], [-74.0167, 40.7186], [-74.0131, 40.7189], [-74.0117, 40.7259], [-74.0152, 40.7264], [-74.0115, 40.7264], [-74.0144, 40.7285], [-74.0109, 40.733], [-74.014, 40.7333], [-74.0107, 40.7334], [-74.0127, 40.7407], [-74.0095, 40.7407], [-74.0121, 40.7436], [-74.0089, 40.7439], [-74.0118, 40.7456], [-74.0095, 40.7458], [-74.0116, 40.7466], [-74.0092, 40.7468], [-74.0114, 40.7476], [-74.0091, 40.7478], [-74.01, 40.7529], [-74.0048, 40.7578], [-74.007, 40.7592], [-74.001, 40.7634], [-74.0031, 40.7647], [-73.9996, 40.7636], [-74.0023, 40.7656], [-73.9983, 40.7656], [-74.0016, 40.767], [-73.9981, 40.7659], [-74.0006, 40.7682], [-73.9972, 40.7671], [-73.9997, 40.7695], [-73.9971, 40.7687], [-73.999, 40.7705], [-73.9949, 40.7715], [-73.9967, 40.7735], [-73.9942, 40.7725], [-73.9962, 40.774], [-73.9923, 40.7751], [-73.9889, 40.7797], [-73.9916, 40.7796], [-73.9582, 40.8223], [-73.9461, 40.8439], [-73.947, 40.8505], [-73.9419, 40.8539], [-73.9264, 40.8776]]]}}, {"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.7667, 40.6143], [-73.7602, 40.6108], [-73.7616, 40.609], [-73.7458, 40.612], [-73.7382, 40.6027], [-73.7381, 40.5977], [-73.7418, 40.5967], [-73.7381, 40.5974], [-73.7376, 40.5944], [-73.8135, 40.5835], [-73.8703, 40.5642], [-73.9069, 40.5556], [-73.9407, 40.5418], [-73.9399, 40.5546], [-73.9262, 40.5616], [-73.912, 40.5659], [-73.9015, 40.563], [-73.8926, 40.5686], [-73.8778, 40.5688], [-73.8504, 40.5821], [-73.8393, 40.5819], [-73.8215, 40.5868], [-73.8096, 40.5936], [-73.8057, 40.5908], [-73.808, 40.5942], [-73.8024, 40.5926], [-73.8052, 40.5969], [-73.803, 40.5988], [-73.7864, 40.6032], [-73.7903, 40.5992], [-73.7898, 40.5947], [-73.7786, 40.6096], [-73.7742, 40.6089], [-73.7747, 40.6043], [-73.7813, 40.5978], [-73.775, 40.6017], [-73.7736, 40.5981], [-73.7681, 40.5978], [-73.7712, 40.5994], [-73.769, 40.6094], [-73.7742, 40.6118], [-73.7667, 40.6143]]]}}]}
# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bool]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, is_water) tuples.
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], bool(row[2])) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], False) for row in cursor.fetchall()]


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]], bool]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
        "is_water": is_water,
      }
      for qx, qy, corners, is_water in quadrant_polygons
    ]
  )

  # NYC boundary GeoJSON for the map
  nyc_boundary_json = json.dumps(NYC_BOUNDARY_GEOJSON)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.water {{
      background: rgba(59, 130, 246, 0.35);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch water"></div>
      <span>Water Tile</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state (red for land)
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state (land)
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for water tiles (blue)
    const waterStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.35,
      color: '#3b82f6',
      weight: 1.5,
      opacity: 0.7
    }};

    // Style for water hover state
    const waterHoverStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.6,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const style = q.is_water ? waterStyle : normalStyle;
      const hStyle = q.is_water ? waterHoverStyle : hoverStyle;
      const polygon = L.polygon(q.corners, style).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hStyle);
        const waterLabel = q.is_water ? ' <span style="color: #3b82f6;">üíß</span>' : '';
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
            ${{waterLabel}}
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(style);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    if (quadrants.length > 0) {{
      const allLatLngs = quadrants.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []
    water_count = 0

    for qx, qy, is_water in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners, is_water))

      if is_water:
        water_count += 1

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    if water_count > 0:
      print(f"   üíß {water_count} water tiles detected")

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")

  try:
    create_debug_map(generation_dir, output_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

Now let me check the lints for the files I've modified:

Now let me mark the task as complete and verify everything works by running the script:

The script works. Let me run a dry-run to see what it detects:

The script is working and detecting water tiles. Let me check the summary at the end:

It looks like the script output was truncated. Let me see a shorter dry run to understand the output format better:

---

**User**

Can you add a progress tracker to the detect_water_tiles.py script

---

**Cursor**

```python
"""
Detect Water Tiles - Scan generation tiles and mark those containing water color.

This script iterates over all tiles in the quadrants database and marks them
with the is_water flag if they contain the water color #4A6372.

Usage:
  uv run python src/isometric_nyc/e2e_generation/detect_water_tiles.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Options:
  --threshold N: Minimum percentage of pixels that must be water color (default: 1.0)
  --dry-run: Show what would be marked without making changes
  --verbose: Show each water tile as it's detected
"""

import argparse
import sqlite3
import sys
import time
from io import BytesIO
from pathlib import Path

from PIL import Image

# The water color to detect
WATER_COLOR_HEX = "4A6372"
WATER_COLOR_RGB = tuple(int(WATER_COLOR_HEX[i : i + 2], 16) for i in (0, 2, 4))


def ensure_is_water_column(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table."""
  cursor = conn.cursor()
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_all_quadrants_with_generations(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bytes]]:
  """Get all quadrants that have generation data."""
  cursor = conn.cursor()
  cursor.execute("""
    SELECT quadrant_x, quadrant_y, generation
    FROM quadrants
    WHERE generation IS NOT NULL
    ORDER BY quadrant_x, quadrant_y
  """)
  return [(row[0], row[1], row[2]) for row in cursor.fetchall()]


def contains_water_color(
  png_bytes: bytes,
  threshold_percent: float = 1.0,
  tolerance: int = 5,
) -> tuple[bool, float]:
  """
  Check if an image contains the water color.

  Args:
    png_bytes: PNG image data
    threshold_percent: Minimum percentage of pixels that must match (default 1%)
    tolerance: Color matching tolerance (default 5)

  Returns:
    Tuple of (contains_water, percentage_of_water_pixels)
  """
  try:
    img = Image.open(BytesIO(png_bytes))
    img = img.convert("RGB")

    pixels = list(img.getdata())
    total_pixels = len(pixels)

    if total_pixels == 0:
      return False, 0.0

    # Count pixels that match the water color (within tolerance)
    water_r, water_g, water_b = WATER_COLOR_RGB
    matching_pixels = 0

    for r, g, b in pixels:
      if (
        abs(r - water_r) <= tolerance
        and abs(g - water_g) <= tolerance
        and abs(b - water_b) <= tolerance
      ):
        matching_pixels += 1

    percentage = (matching_pixels / total_pixels) * 100

    return percentage >= threshold_percent, percentage

  except Exception as e:
    print(f"  ‚ö†Ô∏è Error analyzing image: {e}")
    return False, 0.0


def mark_quadrant_as_water(conn: sqlite3.Connection, x: int, y: int) -> None:
  """Mark a quadrant as a water tile."""
  cursor = conn.cursor()
  cursor.execute(
    "UPDATE quadrants SET is_water = 1 WHERE quadrant_x = ? AND quadrant_y = ?",
    (x, y),
  )


def unmark_quadrant_as_water(conn: sqlite3.Connection, x: int, y: int) -> None:
  """Unmark a quadrant as a water tile."""
  cursor = conn.cursor()
  cursor.execute(
    "UPDATE quadrants SET is_water = 0 WHERE quadrant_x = ? AND quadrant_y = ?",
    (x, y),
  )


def detect_water_tiles(
  generation_dir: Path,
  threshold_percent: float = 1.0,
  dry_run: bool = False,
) -> dict:
  """
  Scan all tiles and detect which ones contain water.

  Args:
    generation_dir: Path to the generation directory
    threshold_percent: Minimum percentage of pixels that must be water color
    dry_run: If True, don't make any changes to the database

  Returns:
    Dict with statistics about the scan
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  conn = sqlite3.connect(db_path)

  try:
    # Ensure the is_water column exists
    if not dry_run:
      ensure_is_water_column(conn)

    # Get all quadrants with generations
    quadrants = get_all_quadrants_with_generations(conn)
    print(f"\nüìä Found {len(quadrants)} quadrants with generations")

    stats = {
      "total_scanned": 0,
      "water_tiles": 0,
      "non_water_tiles": 0,
      "errors": 0,
      "water_quadrants": [],
    }

    print(f"üîç Scanning for water color #{WATER_COLOR_HEX}...")
    print(f"   Threshold: {threshold_percent}% of pixels\n")

    for x, y, generation_bytes in quadrants:
      stats["total_scanned"] += 1

      is_water, percentage = contains_water_color(generation_bytes, threshold_percent)

      if is_water:
        stats["water_tiles"] += 1
        stats["water_quadrants"].append((x, y, percentage))

        if dry_run:
          print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water (would mark)")
        else:
          mark_quadrant_as_water(conn, x, y)
          print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water ‚úì")
      else:
        stats["non_water_tiles"] += 1
        # Optionally unmark if it was previously marked
        if not dry_run:
          unmark_quadrant_as_water(conn, x, y)

    if not dry_run:
      conn.commit()

    return stats

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Detect and mark water tiles in the generation database."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--threshold",
    type=float,
    default=1.0,
    help="Minimum percentage of pixels that must be water color (default: 1.0)",
  )
  parser.add_argument(
    "--dry-run",
    action="store_true",
    help="Show what would be marked without making changes",
  )

  args = parser.parse_args()

  # Resolve path
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  print(f"\n{'=' * 60}")
  print("üíß Water Tile Detection")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")
  print(f"   Water color: #{WATER_COLOR_HEX} (RGB{WATER_COLOR_RGB})")
  print(f"   Threshold: {args.threshold}%")
  if args.dry_run:
    print("   Mode: DRY RUN (no changes will be made)")
  print()

  try:
    stats = detect_water_tiles(
      generation_dir,
      threshold_percent=args.threshold,
      dry_run=args.dry_run,
    )

    print(f"\n{'=' * 60}")
    print("üìà Results")
    print(f"{'=' * 60}")
    print(f"   Total scanned: {stats['total_scanned']}")
    print(f"   Water tiles:   {stats['water_tiles']}")
    print(f"   Non-water:     {stats['non_water_tiles']}")

    if stats["water_quadrants"]:
      print(f"\nüíß Water tiles found ({len(stats['water_quadrants'])}):")
      for x, y, pct in stats["water_quadrants"]:
        print(f"      ({x}, {y}) - {pct:.1f}%")

    if args.dry_run:
      print("\n‚ö†Ô∏è  DRY RUN - No changes were made to the database")
    else:
      print(f"\n‚úÖ Marked {stats['water_tiles']} tile(s) as water")

    return 0

  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

```python
"""
Detect Water Tiles - Scan generation tiles and mark those containing water color.

This script iterates over all tiles in the quadrants database and marks them
with the is_water flag if they contain the water color #4A6372.

Usage:
  uv run python src/isometric_nyc/e2e_generation/detect_water_tiles.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Options:
  --threshold N: Minimum percentage of pixels that must be water color (default: 1.0)
  --dry-run: Show what would be marked without making changes
  --verbose: Show each water tile as it's detected
"""

import argparse
import sqlite3
import sys
import time
from io import BytesIO
from pathlib import Path

from PIL import Image

# The water color to detect
WATER_COLOR_HEX = "4A6372"
WATER_COLOR_RGB = tuple(int(WATER_COLOR_HEX[i : i + 2], 16) for i in (0, 2, 4))


def ensure_is_water_column(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table."""
  cursor = conn.cursor()
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_all_quadrants_with_generations(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bytes]]:
  """Get all quadrants that have generation data."""
  cursor = conn.cursor()
  cursor.execute("""
    SELECT quadrant_x, quadrant_y, generation
    FROM quadrants
    WHERE generation IS NOT NULL
    ORDER BY quadrant_x, quadrant_y
  """)
  return [(row[0], row[1], row[2]) for row in cursor.fetchall()]


def contains_water_color(
  png_bytes: bytes,
  threshold_percent: float = 1.0,
  tolerance: int = 5,
) -> tuple[bool, float]:
  """
  Check if an image contains the water color.

  Args:
    png_bytes: PNG image data
    threshold_percent: Minimum percentage of pixels that must match (default 1%)
    tolerance: Color matching tolerance (default 5)

  Returns:
    Tuple of (contains_water, percentage_of_water_pixels)
  """
  try:
    img = Image.open(BytesIO(png_bytes))
    img = img.convert("RGB")

    pixels = list(img.getdata())
    total_pixels = len(pixels)

    if total_pixels == 0:
      return False, 0.0

    # Count pixels that match the water color (within tolerance)
    water_r, water_g, water_b = WATER_COLOR_RGB
    matching_pixels = 0

    for r, g, b in pixels:
      if (
        abs(r - water_r) <= tolerance
        and abs(g - water_g) <= tolerance
        and abs(b - water_b) <= tolerance
      ):
        matching_pixels += 1

    percentage = (matching_pixels / total_pixels) * 100

    return percentage >= threshold_percent, percentage

  except Exception as e:
    print(f"  ‚ö†Ô∏è Error analyzing image: {e}")
    return False, 0.0


def mark_quadrant_as_water(conn: sqlite3.Connection, x: int, y: int) -> None:
  """Mark a quadrant as a water tile."""
  cursor = conn.cursor()
  cursor.execute(
    "UPDATE quadrants SET is_water = 1 WHERE quadrant_x = ? AND quadrant_y = ?",
    (x, y),
  )


def unmark_quadrant_as_water(conn: sqlite3.Connection, x: int, y: int) -> None:
  """Unmark a quadrant as a water tile."""
  cursor = conn.cursor()
  cursor.execute(
    "UPDATE quadrants SET is_water = 0 WHERE quadrant_x = ? AND quadrant_y = ?",
    (x, y),
  )


def format_time(seconds: float) -> str:
  """Format seconds into a human-readable time string."""
  if seconds < 60:
    return f"{seconds:.1f}s"
  elif seconds < 3600:
    minutes = int(seconds // 60)
    secs = int(seconds % 60)
    return f"{minutes}m {secs}s"
  else:
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    return f"{hours}h {minutes}m"


def print_progress(
  current: int,
  total: int,
  water_count: int,
  start_time: float,
  bar_width: int = 30,
) -> None:
  """Print a progress bar with stats."""
  if total == 0:
    return

  progress = current / total
  filled = int(bar_width * progress)
  bar = "‚ñà" * filled + "‚ñë" * (bar_width - filled)

  elapsed = time.time() - start_time
  if current > 0:
    eta = (elapsed / current) * (total - current)
    eta_str = format_time(eta)
  else:
    eta_str = "..."

  # Build the status line
  status = f"\rüîç [{bar}] {current:,}/{total:,} ({progress * 100:.1f}%) | üíß {water_count:,} water | ETA: {eta_str}  "

  # Print with carriage return to overwrite
  sys.stdout.write(status)
  sys.stdout.flush()


def detect_water_tiles(
  generation_dir: Path,
  threshold_percent: float = 1.0,
  dry_run: bool = False,
  verbose: bool = False,
) -> dict:
  """
  Scan all tiles and detect which ones contain water.

  Args:
    generation_dir: Path to the generation directory
    threshold_percent: Minimum percentage of pixels that must be water color
    dry_run: If True, don't make any changes to the database
    verbose: If True, print each water tile as detected

  Returns:
    Dict with statistics about the scan
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  conn = sqlite3.connect(db_path)

  try:
    # Ensure the is_water column exists
    if not dry_run:
      ensure_is_water_column(conn)

    # Get all quadrants with generations
    quadrants = get_all_quadrants_with_generations(conn)
    total = len(quadrants)
    print(f"\nüìä Found {total:,} quadrants with generations")

    stats = {
      "total_scanned": 0,
      "water_tiles": 0,
      "non_water_tiles": 0,
      "errors": 0,
      "water_quadrants": [],
    }

    print(f"üîç Scanning for water color #{WATER_COLOR_HEX}...")
    print(f"   Threshold: {threshold_percent}% of pixels")
    if verbose:
      print()  # Extra line before verbose output

    start_time = time.time()

    for i, (x, y, generation_bytes) in enumerate(quadrants):
      stats["total_scanned"] += 1

      is_water, percentage = contains_water_color(generation_bytes, threshold_percent)

      if is_water:
        stats["water_tiles"] += 1
        stats["water_quadrants"].append((x, y, percentage))

        if verbose:
          # Clear the progress bar line first
          sys.stdout.write("\r" + " " * 100 + "\r")
          if dry_run:
            print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water (would mark)")
          else:
            mark_quadrant_as_water(conn, x, y)
            print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water ‚úì")
        else:
          if not dry_run:
            mark_quadrant_as_water(conn, x, y)
      else:
        stats["non_water_tiles"] += 1
        # Optionally unmark if it was previously marked
        if not dry_run:
          unmark_quadrant_as_water(conn, x, y)

      # Update progress bar every 10 tiles (or always for small datasets)
      if total < 100 or (i + 1) % 10 == 0 or (i + 1) == total:
        print_progress(i + 1, total, stats["water_tiles"], start_time)

    # Clear the progress bar and print final stats
    elapsed = time.time() - start_time
    sys.stdout.write("\r" + " " * 100 + "\r")
    print(f"‚úÖ Scanned {total:,} tiles in {format_time(elapsed)}")

    if not dry_run:
      conn.commit()

    return stats

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Detect and mark water tiles in the generation database."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--threshold",
    type=float,
    default=1.0,
    help="Minimum percentage of pixels that must be water color (default: 1.0)",
  )
  parser.add_argument(
    "--dry-run",
    action="store_true",
    help="Show what would be marked without making changes",
  )

  args = parser.parse_args()

  # Resolve path
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  print(f"\n{'=' * 60}")
  print("üíß Water Tile Detection")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")
  print(f"   Water color: #{WATER_COLOR_HEX} (RGB{WATER_COLOR_RGB})")
  print(f"   Threshold: {args.threshold}%")
  if args.dry_run:
    print("   Mode: DRY RUN (no changes will be made)")
  print()

  try:
    stats = detect_water_tiles(
      generation_dir,
      threshold_percent=args.threshold,
      dry_run=args.dry_run,
    )

    print(f"\n{'=' * 60}")
    print("üìà Results")
    print(f"{'=' * 60}")
    print(f"   Total scanned: {stats['total_scanned']}")
    print(f"   Water tiles:   {stats['water_tiles']}")
    print(f"   Non-water:     {stats['non_water_tiles']}")

    if stats["water_quadrants"]:
      print(f"\nüíß Water tiles found ({len(stats['water_quadrants'])}):")
      for x, y, pct in stats["water_quadrants"]:
        print(f"      ({x}, {y}) - {pct:.1f}%")

    if args.dry_run:
      print("\n‚ö†Ô∏è  DRY RUN - No changes were made to the database")
    else:
      print(f"\n‚úÖ Marked {stats['water_tiles']} tile(s) as water")

    return 0

  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

```python
"""
Detect Water Tiles - Scan generation tiles and mark those containing water color.

This script iterates over all tiles in the quadrants database and marks them
with the is_water flag if they contain the water color #4A6372.

Usage:
  uv run python src/isometric_nyc/e2e_generation/detect_water_tiles.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Options:
  --threshold N: Minimum percentage of pixels that must be water color (default: 1.0)
  --dry-run: Show what would be marked without making changes
  --verbose: Show each water tile as it's detected
"""

import argparse
import sqlite3
import sys
import time
from io import BytesIO
from pathlib import Path

from PIL import Image

# The water color to detect
WATER_COLOR_HEX = "4A6372"
WATER_COLOR_RGB = tuple(int(WATER_COLOR_HEX[i : i + 2], 16) for i in (0, 2, 4))


def ensure_is_water_column(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table."""
  cursor = conn.cursor()
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_all_quadrants_with_generations(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bytes]]:
  """Get all quadrants that have generation data."""
  cursor = conn.cursor()
  cursor.execute("""
    SELECT quadrant_x, quadrant_y, generation
    FROM quadrants
    WHERE generation IS NOT NULL
    ORDER BY quadrant_x, quadrant_y
  """)
  return [(row[0], row[1], row[2]) for row in cursor.fetchall()]


def contains_water_color(
  png_bytes: bytes,
  threshold_percent: float = 1.0,
  tolerance: int = 5,
) -> tuple[bool, float]:
  """
  Check if an image contains the water color.

  Args:
    png_bytes: PNG image data
    threshold_percent: Minimum percentage of pixels that must match (default 1%)
    tolerance: Color matching tolerance (default 5)

  Returns:
    Tuple of (contains_water, percentage_of_water_pixels)
  """
  try:
    img = Image.open(BytesIO(png_bytes))
    img = img.convert("RGB")

    pixels = list(img.getdata())
    total_pixels = len(pixels)

    if total_pixels == 0:
      return False, 0.0

    # Count pixels that match the water color (within tolerance)
    water_r, water_g, water_b = WATER_COLOR_RGB
    matching_pixels = 0

    for r, g, b in pixels:
      if (
        abs(r - water_r) <= tolerance
        and abs(g - water_g) <= tolerance
        and abs(b - water_b) <= tolerance
      ):
        matching_pixels += 1

    percentage = (matching_pixels / total_pixels) * 100

    return percentage >= threshold_percent, percentage

  except Exception as e:
    print(f"  ‚ö†Ô∏è Error analyzing image: {e}")
    return False, 0.0


def mark_quadrant_as_water(conn: sqlite3.Connection, x: int, y: int) -> None:
  """Mark a quadrant as a water tile."""
  cursor = conn.cursor()
  cursor.execute(
    "UPDATE quadrants SET is_water = 1 WHERE quadrant_x = ? AND quadrant_y = ?",
    (x, y),
  )


def unmark_quadrant_as_water(conn: sqlite3.Connection, x: int, y: int) -> None:
  """Unmark a quadrant as a water tile."""
  cursor = conn.cursor()
  cursor.execute(
    "UPDATE quadrants SET is_water = 0 WHERE quadrant_x = ? AND quadrant_y = ?",
    (x, y),
  )


def format_time(seconds: float) -> str:
  """Format seconds into a human-readable time string."""
  if seconds < 60:
    return f"{seconds:.1f}s"
  elif seconds < 3600:
    minutes = int(seconds // 60)
    secs = int(seconds % 60)
    return f"{minutes}m {secs}s"
  else:
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    return f"{hours}h {minutes}m"


def print_progress(
  current: int,
  total: int,
  water_count: int,
  start_time: float,
  bar_width: int = 30,
) -> None:
  """Print a progress bar with stats."""
  if total == 0:
    return

  progress = current / total
  filled = int(bar_width * progress)
  bar = "‚ñà" * filled + "‚ñë" * (bar_width - filled)

  elapsed = time.time() - start_time
  if current > 0:
    eta = (elapsed / current) * (total - current)
    eta_str = format_time(eta)
  else:
    eta_str = "..."

  # Build the status line
  status = f"\rüîç [{bar}] {current:,}/{total:,} ({progress * 100:.1f}%) | üíß {water_count:,} water | ETA: {eta_str}  "

  # Print with carriage return to overwrite
  sys.stdout.write(status)
  sys.stdout.flush()


def detect_water_tiles(
  generation_dir: Path,
  threshold_percent: float = 1.0,
  dry_run: bool = False,
  verbose: bool = False,
) -> dict:
  """
  Scan all tiles and detect which ones contain water.

  Args:
    generation_dir: Path to the generation directory
    threshold_percent: Minimum percentage of pixels that must be water color
    dry_run: If True, don't make any changes to the database
    verbose: If True, print each water tile as detected

  Returns:
    Dict with statistics about the scan
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  conn = sqlite3.connect(db_path)

  try:
    # Ensure the is_water column exists
    if not dry_run:
      ensure_is_water_column(conn)

    # Get all quadrants with generations
    quadrants = get_all_quadrants_with_generations(conn)
    total = len(quadrants)
    print(f"\nüìä Found {total:,} quadrants with generations")

    stats = {
      "total_scanned": 0,
      "water_tiles": 0,
      "non_water_tiles": 0,
      "errors": 0,
      "water_quadrants": [],
    }

    print(f"üîç Scanning for water color #{WATER_COLOR_HEX}...")
    print(f"   Threshold: {threshold_percent}% of pixels")
    if verbose:
      print()  # Extra line before verbose output

    start_time = time.time()

    for i, (x, y, generation_bytes) in enumerate(quadrants):
      stats["total_scanned"] += 1

      is_water, percentage = contains_water_color(generation_bytes, threshold_percent)

      if is_water:
        stats["water_tiles"] += 1
        stats["water_quadrants"].append((x, y, percentage))

        if verbose:
          # Clear the progress bar line first
          sys.stdout.write("\r" + " " * 100 + "\r")
          if dry_run:
            print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water (would mark)")
          else:
            mark_quadrant_as_water(conn, x, y)
            print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water ‚úì")
        else:
          if not dry_run:
            mark_quadrant_as_water(conn, x, y)
      else:
        stats["non_water_tiles"] += 1
        # Optionally unmark if it was previously marked
        if not dry_run:
          unmark_quadrant_as_water(conn, x, y)

      # Update progress bar every 10 tiles (or always for small datasets)
      if total < 100 or (i + 1) % 10 == 0 or (i + 1) == total:
        print_progress(i + 1, total, stats["water_tiles"], start_time)

    # Clear the progress bar and print final stats
    elapsed = time.time() - start_time
    sys.stdout.write("\r" + " " * 100 + "\r")
    print(f"‚úÖ Scanned {total:,} tiles in {format_time(elapsed)}")

    if not dry_run:
      conn.commit()

    return stats

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Detect and mark water tiles in the generation database."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--threshold",
    type=float,
    default=1.0,
    help="Minimum percentage of pixels that must be water color (default: 1.0)",
  )
  parser.add_argument(
    "--dry-run",
    action="store_true",
    help="Show what would be marked without making changes",
  )
  parser.add_argument(
    "--verbose",
    "-v",
    action="store_true",
    help="Show each water tile as it's detected",
  )

  args = parser.parse_args()

  # Resolve path
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  print(f"\n{'=' * 60}")
  print("üíß Water Tile Detection")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")
  print(f"   Water color: #{WATER_COLOR_HEX} (RGB{WATER_COLOR_RGB})")
  print(f"   Threshold: {args.threshold}%")
  if args.dry_run:
    print("   Mode: DRY RUN (no changes will be made)")
  print()

  try:
    stats = detect_water_tiles(
      generation_dir,
      threshold_percent=args.threshold,
      dry_run=args.dry_run,
    )

    print(f"\n{'=' * 60}")
    print("üìà Results")
    print(f"{'=' * 60}")
    print(f"   Total scanned: {stats['total_scanned']}")
    print(f"   Water tiles:   {stats['water_tiles']}")
    print(f"   Non-water:     {stats['non_water_tiles']}")

    if stats["water_quadrants"]:
      print(f"\nüíß Water tiles found ({len(stats['water_quadrants'])}):")
      for x, y, pct in stats["water_quadrants"]:
        print(f"      ({x}, {y}) - {pct:.1f}%")

    if args.dry_run:
      print("\n‚ö†Ô∏è  DRY RUN - No changes were made to the database")
    else:
      print(f"\n‚úÖ Marked {stats['water_tiles']} tile(s) as water")

    return 0

  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

```python
"""
Detect Water Tiles - Scan generation tiles and mark those containing water color.

This script iterates over all tiles in the quadrants database and marks them
with the is_water flag if they contain the water color #4A6372.

Usage:
  uv run python src/isometric_nyc/e2e_generation/detect_water_tiles.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Options:
  --threshold N: Minimum percentage of pixels that must be water color (default: 1.0)
  --dry-run: Show what would be marked without making changes
  --verbose: Show each water tile as it's detected
"""

import argparse
import sqlite3
import sys
import time
from io import BytesIO
from pathlib import Path

from PIL import Image

# The water color to detect
WATER_COLOR_HEX = "4A6372"
WATER_COLOR_RGB = tuple(int(WATER_COLOR_HEX[i : i + 2], 16) for i in (0, 2, 4))


def ensure_is_water_column(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table."""
  cursor = conn.cursor()
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_all_quadrants_with_generations(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bytes]]:
  """Get all quadrants that have generation data."""
  cursor = conn.cursor()
  cursor.execute("""
    SELECT quadrant_x, quadrant_y, generation
    FROM quadrants
    WHERE generation IS NOT NULL
    ORDER BY quadrant_x, quadrant_y
  """)
  return [(row[0], row[1], row[2]) for row in cursor.fetchall()]


def contains_water_color(
  png_bytes: bytes,
  threshold_percent: float = 1.0,
  tolerance: int = 5,
) -> tuple[bool, float]:
  """
  Check if an image contains the water color.

  Args:
    png_bytes: PNG image data
    threshold_percent: Minimum percentage of pixels that must match (default 1%)
    tolerance: Color matching tolerance (default 5)

  Returns:
    Tuple of (contains_water, percentage_of_water_pixels)
  """
  try:
    img = Image.open(BytesIO(png_bytes))
    img = img.convert("RGB")

    pixels = list(img.getdata())
    total_pixels = len(pixels)

    if total_pixels == 0:
      return False, 0.0

    # Count pixels that match the water color (within tolerance)
    water_r, water_g, water_b = WATER_COLOR_RGB
    matching_pixels = 0

    for r, g, b in pixels:
      if (
        abs(r - water_r) <= tolerance
        and abs(g - water_g) <= tolerance
        and abs(b - water_b) <= tolerance
      ):
        matching_pixels += 1

    percentage = (matching_pixels / total_pixels) * 100

    return percentage >= threshold_percent, percentage

  except Exception as e:
    print(f"  ‚ö†Ô∏è Error analyzing image: {e}")
    return False, 0.0


def mark_quadrant_as_water(conn: sqlite3.Connection, x: int, y: int) -> None:
  """Mark a quadrant as a water tile."""
  cursor = conn.cursor()
  cursor.execute(
    "UPDATE quadrants SET is_water = 1 WHERE quadrant_x = ? AND quadrant_y = ?",
    (x, y),
  )


def unmark_quadrant_as_water(conn: sqlite3.Connection, x: int, y: int) -> None:
  """Unmark a quadrant as a water tile."""
  cursor = conn.cursor()
  cursor.execute(
    "UPDATE quadrants SET is_water = 0 WHERE quadrant_x = ? AND quadrant_y = ?",
    (x, y),
  )


def format_time(seconds: float) -> str:
  """Format seconds into a human-readable time string."""
  if seconds < 60:
    return f"{seconds:.1f}s"
  elif seconds < 3600:
    minutes = int(seconds // 60)
    secs = int(seconds % 60)
    return f"{minutes}m {secs}s"
  else:
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    return f"{hours}h {minutes}m"


def print_progress(
  current: int,
  total: int,
  water_count: int,
  start_time: float,
  bar_width: int = 30,
) -> None:
  """Print a progress bar with stats."""
  if total == 0:
    return

  progress = current / total
  filled = int(bar_width * progress)
  bar = "‚ñà" * filled + "‚ñë" * (bar_width - filled)

  elapsed = time.time() - start_time
  if current > 0:
    eta = (elapsed / current) * (total - current)
    eta_str = format_time(eta)
  else:
    eta_str = "..."

  # Build the status line
  status = f"\rüîç [{bar}] {current:,}/{total:,} ({progress * 100:.1f}%) | üíß {water_count:,} water | ETA: {eta_str}  "

  # Print with carriage return to overwrite
  sys.stdout.write(status)
  sys.stdout.flush()


def detect_water_tiles(
  generation_dir: Path,
  threshold_percent: float = 1.0,
  dry_run: bool = False,
  verbose: bool = False,
) -> dict:
  """
  Scan all tiles and detect which ones contain water.

  Args:
    generation_dir: Path to the generation directory
    threshold_percent: Minimum percentage of pixels that must be water color
    dry_run: If True, don't make any changes to the database
    verbose: If True, print each water tile as detected

  Returns:
    Dict with statistics about the scan
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  conn = sqlite3.connect(db_path)

  try:
    # Ensure the is_water column exists
    if not dry_run:
      ensure_is_water_column(conn)

    # Get all quadrants with generations
    quadrants = get_all_quadrants_with_generations(conn)
    total = len(quadrants)
    print(f"\nüìä Found {total:,} quadrants with generations")

    stats = {
      "total_scanned": 0,
      "water_tiles": 0,
      "non_water_tiles": 0,
      "errors": 0,
      "water_quadrants": [],
    }

    print(f"üîç Scanning for water color #{WATER_COLOR_HEX}...")
    print(f"   Threshold: {threshold_percent}% of pixels")
    if verbose:
      print()  # Extra line before verbose output

    start_time = time.time()

    for i, (x, y, generation_bytes) in enumerate(quadrants):
      stats["total_scanned"] += 1

      is_water, percentage = contains_water_color(generation_bytes, threshold_percent)

      if is_water:
        stats["water_tiles"] += 1
        stats["water_quadrants"].append((x, y, percentage))

        if verbose:
          # Clear the progress bar line first
          sys.stdout.write("\r" + " " * 100 + "\r")
          if dry_run:
            print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water (would mark)")
          else:
            mark_quadrant_as_water(conn, x, y)
            print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water ‚úì")
        else:
          if not dry_run:
            mark_quadrant_as_water(conn, x, y)
      else:
        stats["non_water_tiles"] += 1
        # Optionally unmark if it was previously marked
        if not dry_run:
          unmark_quadrant_as_water(conn, x, y)

      # Update progress bar every 10 tiles (or always for small datasets)
      if total < 100 or (i + 1) % 10 == 0 or (i + 1) == total:
        print_progress(i + 1, total, stats["water_tiles"], start_time)

    # Clear the progress bar and print final stats
    elapsed = time.time() - start_time
    sys.stdout.write("\r" + " " * 100 + "\r")
    print(f"‚úÖ Scanned {total:,} tiles in {format_time(elapsed)}")

    if not dry_run:
      conn.commit()

    return stats

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Detect and mark water tiles in the generation database."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--threshold",
    type=float,
    default=1.0,
    help="Minimum percentage of pixels that must be water color (default: 1.0)",
  )
  parser.add_argument(
    "--dry-run",
    action="store_true",
    help="Show what would be marked without making changes",
  )
  parser.add_argument(
    "--verbose",
    "-v",
    action="store_true",
    help="Show each water tile as it's detected",
  )

  args = parser.parse_args()

  # Resolve path
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  print(f"\n{'=' * 60}")
  print("üíß Water Tile Detection")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")
  print(f"   Water color: #{WATER_COLOR_HEX} (RGB{WATER_COLOR_RGB})")
  print(f"   Threshold: {args.threshold}%")
  if args.dry_run:
    print("   Mode: DRY RUN (no changes will be made)")
  print()

  try:
    stats = detect_water_tiles(
      generation_dir,
      threshold_percent=args.threshold,
      dry_run=args.dry_run,
      verbose=args.verbose,
    )

    print(f"\n{'=' * 60}")
    print("üìà Results")
    print(f"{'=' * 60}")
    print(f"   Total scanned: {stats['total_scanned']}")
    print(f"   Water tiles:   {stats['water_tiles']}")
    print(f"   Non-water:     {stats['non_water_tiles']}")

    if stats["water_quadrants"]:
      print(f"\nüíß Water tiles found ({len(stats['water_quadrants'])}):")
      for x, y, pct in stats["water_quadrants"]:
        print(f"      ({x}, {y}) - {pct:.1f}%")

    if args.dry_run:
      print("\n‚ö†Ô∏è  DRY RUN - No changes were made to the database")
    else:
      print(f"\n‚úÖ Marked {stats['water_tiles']} tile(s) as water")

    return 0

  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

```python
"""
Detect Water Tiles - Scan generation tiles and mark those containing water color.

This script iterates over all tiles in the quadrants database and marks them
with the is_water flag if they contain the water color #4A6372.

Usage:
  uv run python src/isometric_nyc/e2e_generation/detect_water_tiles.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Options:
  --threshold N: Minimum percentage of pixels that must be water color (default: 1.0)
  --dry-run: Show what would be marked without making changes
  --verbose: Show each water tile as it's detected
"""

import argparse
import sqlite3
import sys
import time
from io import BytesIO
from pathlib import Path

from PIL import Image

# The water color to detect
WATER_COLOR_HEX = "4A6372"
WATER_COLOR_RGB = tuple(int(WATER_COLOR_HEX[i : i + 2], 16) for i in (0, 2, 4))


def ensure_is_water_column(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table."""
  cursor = conn.cursor()
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_all_quadrants_with_generations(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bytes]]:
  """Get all quadrants that have generation data."""
  cursor = conn.cursor()
  cursor.execute("""
    SELECT quadrant_x, quadrant_y, generation
    FROM quadrants
    WHERE generation IS NOT NULL
    ORDER BY quadrant_x, quadrant_y
  """)
  return [(row[0], row[1], row[2]) for row in cursor.fetchall()]


def contains_water_color(
  png_bytes: bytes,
  threshold_percent: float = 1.0,
  tolerance: int = 5,
) -> tuple[bool, float]:
  """
  Check if an image contains the water color.

  Args:
    png_bytes: PNG image data
    threshold_percent: Minimum percentage of pixels that must match (default 1%)
    tolerance: Color matching tolerance (default 5)

  Returns:
    Tuple of (contains_water, percentage_of_water_pixels)
  """
  try:
    img = Image.open(BytesIO(png_bytes))
    img = img.convert("RGB")

    pixels = list(img.getdata())
    total_pixels = len(pixels)

    if total_pixels == 0:
      return False, 0.0

    # Count pixels that match the water color (within tolerance)
    water_r, water_g, water_b = WATER_COLOR_RGB
    matching_pixels = 0

    for r, g, b in pixels:
      if (
        abs(r - water_r) <= tolerance
        and abs(g - water_g) <= tolerance
        and abs(b - water_b) <= tolerance
      ):
        matching_pixels += 1

    percentage = (matching_pixels / total_pixels) * 100

    return percentage >= threshold_percent, percentage

  except Exception as e:
    print(f"  ‚ö†Ô∏è Error analyzing image: {e}")
    return False, 0.0


def mark_quadrant_as_water(conn: sqlite3.Connection, x: int, y: int) -> None:
  """Mark a quadrant as a water tile."""
  cursor = conn.cursor()
  cursor.execute(
    "UPDATE quadrants SET is_water = 1 WHERE quadrant_x = ? AND quadrant_y = ?",
    (x, y),
  )


def unmark_quadrant_as_water(conn: sqlite3.Connection, x: int, y: int) -> None:
  """Unmark a quadrant as a water tile."""
  cursor = conn.cursor()
  cursor.execute(
    "UPDATE quadrants SET is_water = 0 WHERE quadrant_x = ? AND quadrant_y = ?",
    (x, y),
  )


def format_time(seconds: float) -> str:
  """Format seconds into a human-readable time string."""
  if seconds < 60:
    return f"{seconds:.1f}s"
  elif seconds < 3600:
    minutes = int(seconds // 60)
    secs = int(seconds % 60)
    return f"{minutes}m {secs}s"
  else:
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    return f"{hours}h {minutes}m"


def print_progress(
  current: int,
  total: int,
  water_count: int,
  start_time: float,
  bar_width: int = 30,
) -> None:
  """Print a progress bar with stats."""
  if total == 0:
    return

  progress = current / total
  filled = int(bar_width * progress)
  bar = "‚ñà" * filled + "‚ñë" * (bar_width - filled)

  elapsed = time.time() - start_time
  if current > 0:
    eta = (elapsed / current) * (total - current)
    eta_str = format_time(eta)
  else:
    eta_str = "..."

  # Build the status line
  status = f"\rüîç [{bar}] {current:,}/{total:,} ({progress * 100:.1f}%) | üíß {water_count:,} water | ETA: {eta_str}  "

  # Print with carriage return to overwrite
  sys.stdout.write(status)
  sys.stdout.flush()


def detect_water_tiles(
  generation_dir: Path,
  threshold_percent: float = 1.0,
  dry_run: bool = False,
  verbose: bool = False,
) -> dict:
  """
  Scan all tiles and detect which ones contain water.

  Args:
    generation_dir: Path to the generation directory
    threshold_percent: Minimum percentage of pixels that must be water color
    dry_run: If True, don't make any changes to the database
    verbose: If True, print each water tile as detected

  Returns:
    Dict with statistics about the scan
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  conn = sqlite3.connect(db_path)

  try:
    # Ensure the is_water column exists
    if not dry_run:
      ensure_is_water_column(conn)

    # Get all quadrants with generations
    quadrants = get_all_quadrants_with_generations(conn)
    total = len(quadrants)
    print(f"\nüìä Found {total:,} quadrants with generations")

    stats = {
      "total_scanned": 0,
      "water_tiles": 0,
      "non_water_tiles": 0,
      "errors": 0,
      "water_quadrants": [],
    }

    print(f"üîç Scanning for water color #{WATER_COLOR_HEX}...")
    print(f"   Threshold: {threshold_percent}% of pixels")
    if verbose:
      print()  # Extra line before verbose output

    start_time = time.time()

    for i, (x, y, generation_bytes) in enumerate(quadrants):
      stats["total_scanned"] += 1

      is_water, percentage = contains_water_color(generation_bytes, threshold_percent)

      if is_water:
        stats["water_tiles"] += 1
        stats["water_quadrants"].append((x, y, percentage))

        if verbose:
          # Clear the progress bar line first
          sys.stdout.write("\r" + " " * 100 + "\r")
          if dry_run:
            print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water (would mark)")
          else:
            mark_quadrant_as_water(conn, x, y)
            print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water ‚úì")
        else:
          if not dry_run:
            mark_quadrant_as_water(conn, x, y)
      else:
        stats["non_water_tiles"] += 1
        # Optionally unmark if it was previously marked
        if not dry_run:
          unmark_quadrant_as_water(conn, x, y)

      # Update progress bar every 10 tiles (or always for small datasets)
      if total < 100 or (i + 1) % 10 == 0 or (i + 1) == total:
        print_progress(i + 1, total, stats["water_tiles"], start_time)

    # Clear the progress bar and print final stats
    elapsed = time.time() - start_time
    sys.stdout.write("\r" + " " * 100 + "\r")
    print(f"‚úÖ Scanned {total:,} tiles in {format_time(elapsed)}")

    if not dry_run:
      conn.commit()

    return stats

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Detect and mark water tiles in the generation database."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--threshold",
    type=float,
    default=1.0,
    help="Minimum percentage of pixels that must be water color (default: 1.0)",
  )
  parser.add_argument(
    "--dry-run",
    action="store_true",
    help="Show what would be marked without making changes",
  )
  parser.add_argument(
    "--verbose",
    "-v",
    action="store_true",
    help="Show each water tile as it's detected",
  )

  args = parser.parse_args()

  # Resolve path
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  print(f"\n{'=' * 60}")
  print("üíß Water Tile Detection")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")
  print(f"   Water color: #{WATER_COLOR_HEX} (RGB{WATER_COLOR_RGB})")
  print(f"   Threshold: {args.threshold}%")
  if args.dry_run:
    print("   Mode: DRY RUN (no changes will be made)")
  print()

  try:
    stats = detect_water_tiles(
      generation_dir,
      threshold_percent=args.threshold,
      dry_run=args.dry_run,
      verbose=args.verbose,
    )

    print(f"\n{'=' * 60}")
    print("üìà Results")
    print(f"{'=' * 60}")
    print(f"   Total scanned: {stats['total_scanned']:,}")
    print(f"   Water tiles:   {stats['water_tiles']:,}")
    print(f"   Non-water:     {stats['non_water_tiles']:,}")

    # Only show the full list if not already shown in verbose mode
    if stats["water_quadrants"] and not args.verbose:
      print(f"\nüíß Water tiles found ({len(stats['water_quadrants']):,}):")
      for x, y, pct in stats["water_quadrants"]:
        print(f"      ({x}, {y}) - {pct:.1f}%")

    if args.dry_run:
      print("\n‚ö†Ô∏è  DRY RUN - No changes were made to the database")
    else:
      print(f"\n‚úÖ Marked {stats['water_tiles']:,} tile(s) as water")

    return 0

  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

```python
"""
Detect Water Tiles - Scan generation tiles and mark those containing water color.

This script iterates over all tiles in the quadrants database and marks them
with the is_water flag if they contain the water color #4A6372.

Usage:
  uv run python src/isometric_nyc/e2e_generation/detect_water_tiles.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Options:
  --threshold N: Minimum percentage of pixels that must be water color (default: 1.0)
  --dry-run: Show what would be marked without making changes
  --verbose: Show each water tile as it's detected
"""

import argparse
import sqlite3
import sys
import time
from io import BytesIO
from pathlib import Path

from PIL import Image

# The water color to detect
WATER_COLOR_HEX = "4A6372"
WATER_COLOR_RGB = tuple(int(WATER_COLOR_HEX[i : i + 2], 16) for i in (0, 2, 4))


def ensure_is_water_column(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table."""
  cursor = conn.cursor()
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_all_quadrants_with_generations(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bytes]]:
  """Get all quadrants that have generation data."""
  cursor = conn.cursor()
  cursor.execute("""
    SELECT quadrant_x, quadrant_y, generation
    FROM quadrants
    WHERE generation IS NOT NULL
    ORDER BY quadrant_x, quadrant_y
  """)
  return [(row[0], row[1], row[2]) for row in cursor.fetchall()]


def contains_water_color(
  png_bytes: bytes,
  threshold_percent: float = 1.0,
  tolerance: int = 5,
) -> tuple[bool, float]:
  """
  Check if an image contains the water color.

  Args:
    png_bytes: PNG image data
    threshold_percent: Minimum percentage of pixels that must match (default 1%)
    tolerance: Color matching tolerance (default 5)

  Returns:
    Tuple of (contains_water, percentage_of_water_pixels)
  """
  try:
    img = Image.open(BytesIO(png_bytes))
    img = img.convert("RGB")

    pixels = list(img.getdata())
    total_pixels = len(pixels)

    if total_pixels == 0:
      return False, 0.0

    # Count pixels that match the water color (within tolerance)
    water_r, water_g, water_b = WATER_COLOR_RGB
    matching_pixels = 0

    for r, g, b in pixels:
      if (
        abs(r - water_r) <= tolerance
        and abs(g - water_g) <= tolerance
        and abs(b - water_b) <= tolerance
      ):
        matching_pixels += 1

    percentage = (matching_pixels / total_pixels) * 100

    return percentage >= threshold_percent, percentage

  except Exception as e:
    print(f"  ‚ö†Ô∏è Error analyzing image: {e}")
    return False, 0.0


def mark_quadrant_as_water(conn: sqlite3.Connection, x: int, y: int) -> None:
  """Mark a quadrant as a water tile."""
  cursor = conn.cursor()
  cursor.execute(
    "UPDATE quadrants SET is_water = 1 WHERE quadrant_x = ? AND quadrant_y = ?",
    (x, y),
  )


def unmark_quadrant_as_water(conn: sqlite3.Connection, x: int, y: int) -> None:
  """Unmark a quadrant as a water tile."""
  cursor = conn.cursor()
  cursor.execute(
    "UPDATE quadrants SET is_water = 0 WHERE quadrant_x = ? AND quadrant_y = ?",
    (x, y),
  )


def format_time(seconds: float) -> str:
  """Format seconds into a human-readable time string."""
  if seconds < 60:
    return f"{seconds:.1f}s"
  elif seconds < 3600:
    minutes = int(seconds // 60)
    secs = int(seconds % 60)
    return f"{minutes}m {secs}s"
  else:
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    return f"{hours}h {minutes}m"


def print_progress(
  current: int,
  total: int,
  water_count: int,
  start_time: float,
  bar_width: int = 30,
) -> None:
  """Print a progress bar with stats."""
  if total == 0:
    return

  progress = current / total
  filled = int(bar_width * progress)
  bar = "‚ñà" * filled + "‚ñë" * (bar_width - filled)

  elapsed = time.time() - start_time
  if current > 0:
    eta = (elapsed / current) * (total - current)
    eta_str = format_time(eta)
  else:
    eta_str = "..."

  # Build the status line
  status = f"\rüîç [{bar}] {current:,}/{total:,} ({progress * 100:.1f}%) | üíß {water_count:,} water | ETA: {eta_str}  "

  # Print with carriage return to overwrite
  sys.stdout.write(status)
  sys.stdout.flush()


def detect_water_tiles(
  generation_dir: Path,
  threshold_percent: float = 1.0,
  dry_run: bool = False,
  verbose: bool = False,
) -> dict:
  """
  Scan all tiles and detect which ones contain water.

  Args:
    generation_dir: Path to the generation directory
    threshold_percent: Minimum percentage of pixels that must be water color
    dry_run: If True, don't make any changes to the database
    verbose: If True, print each water tile as detected

  Returns:
    Dict with statistics about the scan
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  conn = sqlite3.connect(db_path)

  try:
    # Ensure the is_water column exists
    if not dry_run:
      ensure_is_water_column(conn)

    # Get all quadrants with generations
    quadrants = get_all_quadrants_with_generations(conn)
    total = len(quadrants)
    print(f"\nüìä Found {total:,} quadrants with generations")

    stats = {
      "total_scanned": 0,
      "water_tiles": 0,
      "non_water_tiles": 0,
      "errors": 0,
      "water_quadrants": [],
    }

    print(f"üîç Scanning for water color #{WATER_COLOR_HEX}...")
    print(f"   Threshold: {threshold_percent}% of pixels")
    if verbose:
      print()  # Extra line before verbose output

    start_time = time.time()

    for i, (x, y, generation_bytes) in enumerate(quadrants):
      stats["total_scanned"] += 1

      is_water, percentage = contains_water_color(generation_bytes, threshold_percent)

      if is_water:
        stats["water_tiles"] += 1
        stats["water_quadrants"].append((x, y, percentage))

        if verbose:
          # Clear the progress bar line first
          sys.stdout.write("\r" + " " * 100 + "\r")
          if dry_run:
            print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water (would mark)")
          else:
            mark_quadrant_as_water(conn, x, y)
            print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water ‚úì")
        else:
          if not dry_run:
            mark_quadrant_as_water(conn, x, y)
      else:
        stats["non_water_tiles"] += 1
        # Optionally unmark if it was previously marked
        if not dry_run:
          unmark_quadrant_as_water(conn, x, y)

      # Update progress bar every 10 tiles (or always for small datasets)
      if total < 100 or (i + 1) % 10 == 0 or (i + 1) == total:
        print_progress(i + 1, total, stats["water_tiles"], start_time)

    # Clear the progress bar and print final stats
    elapsed = time.time() - start_time
    sys.stdout.write("\r" + " " * 100 + "\r")
    print(f"‚úÖ Scanned {total:,} tiles in {format_time(elapsed)}")

    if not dry_run:
      conn.commit()

    return stats

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Detect and mark water tiles in the generation database."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--threshold",
    type=float,
    default=1.0,
    help="Minimum percentage of pixels that must be water color (default: 1.0)",
  )
  parser.add_argument(
    "--dry-run",
    action="store_true",
    help="Show what would be marked without making changes",
  )
  parser.add_argument(
    "--verbose",
    "-v",
    action="store_true",
    help="Show each water tile as it's detected",
  )

  args = parser.parse_args()

  # Resolve path
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  print(f"\n{'=' * 60}")
  print("üíß Water Tile Detection")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")
  print(f"   Water color: #{WATER_COLOR_HEX} (RGB{WATER_COLOR_RGB})")
  print(f"   Threshold: {args.threshold}%")
  mode_parts = []
  if args.dry_run:
    mode_parts.append("DRY RUN")
  if args.verbose:
    mode_parts.append("VERBOSE")
  if mode_parts:
    print(f"   Mode: {', '.join(mode_parts)}")
  print()

  try:
    stats = detect_water_tiles(
      generation_dir,
      threshold_percent=args.threshold,
      dry_run=args.dry_run,
      verbose=args.verbose,
    )

    print(f"\n{'=' * 60}")
    print("üìà Results")
    print(f"{'=' * 60}")
    print(f"   Total scanned: {stats['total_scanned']:,}")
    print(f"   Water tiles:   {stats['water_tiles']:,}")
    print(f"   Non-water:     {stats['non_water_tiles']:,}")

    # Only show the full list if not already shown in verbose mode
    if stats["water_quadrants"] and not args.verbose:
      print(f"\nüíß Water tiles found ({len(stats['water_quadrants']):,}):")
      for x, y, pct in stats["water_quadrants"]:
        print(f"      ({x}, {y}) - {pct:.1f}%")

    if args.dry_run:
      print("\n‚ö†Ô∏è  DRY RUN - No changes were made to the database")
    else:
      print(f"\n‚úÖ Marked {stats['water_tiles']:,} tile(s) as water")

    return 0

  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

I've added a progress tracker to the script. Here's what was added:

1. **Progress bar** - Shows a visual progress bar with:
   - Current position / total tiles
   - Percentage complete
   - Water tiles found so far
   - ETA (estimated time remaining)

2. **Time formatting** - Elapsed and ETA times are formatted nicely (seconds, minutes, or hours)

3. **`--verbose` / `-v` flag** - Added a new option:
   - Without `--verbose`: Shows only the progress bar during scanning, then prints the summary at the end
   - With `--verbose`: Shows each water tile as it's detected (like before), plus the progress bar

The progress bar updates every 10 tiles to avoid slowing down processing on large datasets. Example output during scanning:

```
üîç [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 5,000/14,652 (34.1%) | üíß 423 water | ETA: 2m 15s
```

```plaintext
üîç [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 5,000/14,652 (34.1%) | üíß 423 water | ETA: 2m 15s
```

---

**User**

can you parallelize the processing? It's very slow otherwise

---

**Cursor**

```python
"""
Detect Water Tiles - Scan generation tiles and mark those containing water color.

This script iterates over all tiles in the quadrants database and marks them
with the is_water flag if they contain the water color #4A6372.

Usage:
  uv run python src/isometric_nyc/e2e_generation/detect_water_tiles.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Options:
  --threshold N: Minimum percentage of pixels that must be water color (default: 1.0)
  --dry-run: Show what would be marked without making changes
  --verbose: Show each water tile as it's detected
  --workers N: Number of parallel workers (default: CPU count)
"""

import argparse
import multiprocessing
import os
import sqlite3
import sys
import time
from concurrent.futures import ProcessPoolExecutor, as_completed
from io import BytesIO
from pathlib import Path

from PIL import Image

# The water color to detect
WATER_COLOR_HEX = "4A6372"
WATER_COLOR_RGB = tuple(int(WATER_COLOR_HEX[i : i + 2], 16) for i in (0, 2, 4))


def ensure_is_water_column(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table."""
  cursor = conn.cursor()
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_all_quadrants_with_generations(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bytes]]:
  """Get all quadrants that have generation data."""
  cursor = conn.cursor()
  cursor.execute("""
    SELECT quadrant_x, quadrant_y, generation
    FROM quadrants
    WHERE generation IS NOT NULL
    ORDER BY quadrant_x, quadrant_y
  """)
  return [(row[0], row[1], row[2]) for row in cursor.fetchall()]


def analyze_tile(
  args: tuple[int, int, bytes, float, int],
) -> tuple[int, int, bool, float]:
  """
  Analyze a single tile for water content. Worker function for parallel processing.

  Args:
    args: Tuple of (x, y, png_bytes, threshold_percent, tolerance)

  Returns:
    Tuple of (x, y, is_water, percentage)
  """
  x, y, png_bytes, threshold_percent, tolerance = args

  try:
    img = Image.open(BytesIO(png_bytes))
    img = img.convert("RGB")

    pixels = list(img.getdata())
    total_pixels = len(pixels)

    if total_pixels == 0:
      return x, y, False, 0.0

    # Count pixels that match the water color (within tolerance)
    water_r, water_g, water_b = WATER_COLOR_RGB
    matching_pixels = 0

    for r, g, b in pixels:
      if (
        abs(r - water_r) <= tolerance
        and abs(g - water_g) <= tolerance
        and abs(b - water_b) <= tolerance
      ):
        matching_pixels += 1

    percentage = (matching_pixels / total_pixels) * 100
    is_water = percentage >= threshold_percent

    return x, y, is_water, percentage

  except Exception:
    return x, y, False, 0.0


def format_time(seconds: float) -> str:
  """Format seconds into a human-readable time string."""
  if seconds < 60:
    return f"{seconds:.1f}s"
  elif seconds < 3600:
    minutes = int(seconds // 60)
    secs = int(seconds % 60)
    return f"{minutes}m {secs}s"
  else:
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    return f"{hours}h {minutes}m"


def print_progress(
  current: int,
  total: int,
  water_count: int,
  start_time: float,
  workers: int,
  bar_width: int = 30,
) -> None:
  """Print a progress bar with stats."""
  if total == 0:
    return

  progress = current / total
  filled = int(bar_width * progress)
  bar = "‚ñà" * filled + "‚ñë" * (bar_width - filled)

  elapsed = time.time() - start_time
  if current > 0:
    eta = (elapsed / current) * (total - current)
    eta_str = format_time(eta)
  else:
    eta_str = "..."

  # Build the status line
  status = (
    f"\rüîç [{bar}] {current:,}/{total:,} ({progress * 100:.1f}%) "
    f"| üíß {water_count:,} water | ‚ö° {workers} workers | ETA: {eta_str}  "
  )

  # Print with carriage return to overwrite
  sys.stdout.write(status)
  sys.stdout.flush()


def detect_water_tiles(
  generation_dir: Path,
  threshold_percent: float = 1.0,
  dry_run: bool = False,
  verbose: bool = False,
  num_workers: int | None = None,
) -> dict:
  """
  Scan all tiles and detect which ones contain water using parallel processing.

  Args:
    generation_dir: Path to the generation directory
    threshold_percent: Minimum percentage of pixels that must be water color
    dry_run: If True, don't make any changes to the database
    verbose: If True, print each water tile as detected
    num_workers: Number of parallel workers (default: CPU count)

  Returns:
    Dict with statistics about the scan
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Determine number of workers
  if num_workers is None:
    num_workers = os.cpu_count() or 4
  num_workers = max(1, num_workers)

  conn = sqlite3.connect(db_path)

  try:
    # Ensure the is_water column exists
    if not dry_run:
      ensure_is_water_column(conn)

    # Get all quadrants with generations
    print("   Loading quadrants from database...")
    quadrants = get_all_quadrants_with_generations(conn)
    total = len(quadrants)
    print(f"\nüìä Found {total:,} quadrants with generations")

    stats = {
      "total_scanned": 0,
      "water_tiles": 0,
      "non_water_tiles": 0,
      "errors": 0,
      "water_quadrants": [],
    }

    print(f"üîç Scanning for water color #{WATER_COLOR_HEX}...")
    print(f"   Threshold: {threshold_percent}% of pixels")
    print(f"   Workers: {num_workers}")
    if verbose:
      print()  # Extra line before verbose output

    start_time = time.time()
    tolerance = 5

    # Prepare work items
    work_items = [
      (x, y, generation_bytes, threshold_percent, tolerance)
      for x, y, generation_bytes in quadrants
    ]

    # Lists to batch database updates
    water_coords: list[tuple[int, int]] = []
    non_water_coords: list[tuple[int, int]] = []

    # Process in parallel
    completed = 0
    with ProcessPoolExecutor(max_workers=num_workers) as executor:
      # Submit all tasks
      future_to_coord = {
        executor.submit(analyze_tile, item): (item[0], item[1])
        for item in work_items
      }

      # Process results as they complete
      for future in as_completed(future_to_coord):
        x, y, is_water, percentage = future.result()
        completed += 1
        stats["total_scanned"] += 1

        if is_water:
          stats["water_tiles"] += 1
          stats["water_quadrants"].append((x, y, percentage))
          water_coords.append((x, y))

          if verbose:
            # Clear the progress bar line first
            sys.stdout.write("\r" + " " * 120 + "\r")
            if dry_run:
              print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water (would mark)")
            else:
              print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water ‚úì")
        else:
          stats["non_water_tiles"] += 1
          non_water_coords.append((x, y))

        # Update progress bar periodically
        if total < 100 or completed % 50 == 0 or completed == total:
          print_progress(
            completed, total, stats["water_tiles"], start_time, num_workers
          )

    # Clear the progress bar and print final stats
    elapsed = time.time() - start_time
    sys.stdout.write("\r" + " " * 120 + "\r")
    tiles_per_sec = total / elapsed if elapsed > 0 else 0
    print(
      f"‚úÖ Scanned {total:,} tiles in {format_time(elapsed)} "
      f"({tiles_per_sec:.0f} tiles/sec)"
    )

    # Batch update database
    if not dry_run:
      print("   Updating database...")
      cursor = conn.cursor()

      # Mark water tiles
      if water_coords:
        cursor.executemany(
          "UPDATE quadrants SET is_water = 1 WHERE quadrant_x = ? AND quadrant_y = ?",
          water_coords,
        )

      # Unmark non-water tiles
      if non_water_coords:
        cursor.executemany(
          "UPDATE quadrants SET is_water = 0 WHERE quadrant_x = ? AND quadrant_y = ?",
          non_water_coords,
        )

      conn.commit()
      print("   ‚úì Database updated")

    return stats

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Detect and mark water tiles in the generation database."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--threshold",
    type=float,
    default=1.0,
    help="Minimum percentage of pixels that must be water color (default: 1.0)",
  )
  parser.add_argument(
    "--dry-run",
    action="store_true",
    help="Show what would be marked without making changes",
  )
  parser.add_argument(
    "--verbose",
    "-v",
    action="store_true",
    help="Show each water tile as it's detected",
  )
  parser.add_argument(
    "--workers",
    "-w",
    type=int,
    default=None,
    help=f"Number of parallel workers (default: CPU count = {os.cpu_count()})",
  )

  args = parser.parse_args()

  # Resolve path
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  num_workers = args.workers or os.cpu_count() or 4

  print(f"\n{'=' * 60}")
  print("üíß Water Tile Detection (Parallel)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")
  print(f"   Water color: #{WATER_COLOR_HEX} (RGB{WATER_COLOR_RGB})")
  print(f"   Threshold: {args.threshold}%")
  print(f"   Workers: {num_workers}")
  mode_parts = []
  if args.dry_run:
    mode_parts.append("DRY RUN")
  if args.verbose:
    mode_parts.append("VERBOSE")
  if mode_parts:
    print(f"   Mode: {', '.join(mode_parts)}")
  print()

  try:
    stats = detect_water_tiles(
      generation_dir,
      threshold_percent=args.threshold,
      dry_run=args.dry_run,
      verbose=args.verbose,
      num_workers=num_workers,
    )

    print(f"\n{'=' * 60}")
    print("üìà Results")
    print(f"{'=' * 60}")
    print(f"   Total scanned: {stats['total_scanned']:,}")
    print(f"   Water tiles:   {stats['water_tiles']:,}")
    print(f"   Non-water:     {stats['non_water_tiles']:,}")

    # Only show the full list if not already shown in verbose mode
    if stats["water_quadrants"] and not args.verbose:
      print(f"\nüíß Water tiles found ({len(stats['water_quadrants']):,}):")
      # Sort by coordinates for consistent output
      sorted_water = sorted(stats["water_quadrants"], key=lambda t: (t[0], t[1]))
      for x, y, pct in sorted_water:
        print(f"      ({x}, {y}) - {pct:.1f}%")

    if args.dry_run:
      print("\n‚ö†Ô∏è  DRY RUN - No changes were made to the database")
    else:
      print(f"\n‚úÖ Marked {stats['water_tiles']:,} tile(s) as water")

    return 0

  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  # Required for multiprocessing on Windows and macOS
  multiprocessing.freeze_support()
  exit(main())

```

I've parallelized the script using `ProcessPoolExecutor`. Here's what changed:

1. **Parallel processing with `ProcessPoolExecutor`** - The image analysis is now done in parallel across multiple CPU cores
2. **New `--workers` / `-w` flag** - You can specify how many parallel workers to use (defaults to CPU count, which is 8 on your machine)
3. **Batch database updates** - Instead of updating the database one row at a time, it now collects all changes and does batch updates at the end using `executemany()`, which is much faster
4. **Shows tiles/sec** - The final output now shows processing speed

The progress bar now also shows the worker count:
```
üîç [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 5,000/14,652 (34.1%) | üíß 423 water | ‚ö° 8 workers | ETA: 45s
```

This should be significantly faster since:
- Image analysis happens in parallel across all CPU cores
- Database writes are batched instead of individual commits
- The bottleneck (PIL image processing) is distributed across workers

```plaintext
üîç [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 5,000/14,652 (34.1%) | üíß 423 water | ‚ö° 8 workers | ETA: 45s
```

---

**User**

OK - now another detail - if/when a user specifies that a tile is NOT water in the database, it should no longer be possible to overwrite that with the script. So we should change the database scheme to something like "YES", "NO", or "EXPLICIT_NO" that indicates a tile is not water and won't be automatically classified as such

---

**Cursor**

Good idea! I'll update the database schema to support three states and modify the script and UI accordingly.

The new schema for `is_water`:
- `NULL` or `0` = Not classified / auto-detected as not water (can be overwritten)
- `1` = Water (auto or manual)  
- `-1` = Explicitly NOT water (protected from auto-detection)

```python
"""
Detect Water Tiles - Scan generation tiles and mark those containing water color.

This script iterates over all tiles in the quadrants database and marks them
with the is_water flag if they contain the water color #4A6372.

Usage:
  uv run python src/isometric_nyc/e2e_generation/detect_water_tiles.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Options:
  --threshold N: Minimum percentage of pixels that must be water color (default: 1.0)
  --dry-run: Show what would be marked without making changes
  --verbose: Show each water tile as it's detected
  --workers N: Number of parallel workers (default: CPU count)
"""

import argparse
import multiprocessing
import os
import sqlite3
import sys
import time
from concurrent.futures import ProcessPoolExecutor, as_completed
from io import BytesIO
from pathlib import Path

from PIL import Image

# The water color to detect
WATER_COLOR_HEX = "4A6372"
WATER_COLOR_RGB = tuple(int(WATER_COLOR_HEX[i : i + 2], 16) for i in (0, 2, 4))

# Water status values in the database
WATER_STATUS_NOT_WATER = 0  # Auto-detected as not water (can be overwritten)
WATER_STATUS_WATER = 1  # Water tile (auto or manual)
WATER_STATUS_EXPLICIT_NOT_WATER = -1  # Explicitly marked as NOT water (protected)


def ensure_is_water_column(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table."""
  cursor = conn.cursor()
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_all_quadrants_with_generations(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bytes]]:
  """Get all quadrants that have generation data."""
  cursor = conn.cursor()
  cursor.execute("""
    SELECT quadrant_x, quadrant_y, generation
    FROM quadrants
    WHERE generation IS NOT NULL
    ORDER BY quadrant_x, quadrant_y
  """)
  return [(row[0], row[1], row[2]) for row in cursor.fetchall()]


def analyze_tile(
  args: tuple[int, int, bytes, float, int],
) -> tuple[int, int, bool, float]:
  """
  Analyze a single tile for water content. Worker function for parallel processing.

  Args:
    args: Tuple of (x, y, png_bytes, threshold_percent, tolerance)

  Returns:
    Tuple of (x, y, is_water, percentage)
  """
  x, y, png_bytes, threshold_percent, tolerance = args

  try:
    img = Image.open(BytesIO(png_bytes))
    img = img.convert("RGB")

    pixels = list(img.getdata())
    total_pixels = len(pixels)

    if total_pixels == 0:
      return x, y, False, 0.0

    # Count pixels that match the water color (within tolerance)
    water_r, water_g, water_b = WATER_COLOR_RGB
    matching_pixels = 0

    for r, g, b in pixels:
      if (
        abs(r - water_r) <= tolerance
        and abs(g - water_g) <= tolerance
        and abs(b - water_b) <= tolerance
      ):
        matching_pixels += 1

    percentage = (matching_pixels / total_pixels) * 100
    is_water = percentage >= threshold_percent

    return x, y, is_water, percentage

  except Exception:
    return x, y, False, 0.0


def format_time(seconds: float) -> str:
  """Format seconds into a human-readable time string."""
  if seconds < 60:
    return f"{seconds:.1f}s"
  elif seconds < 3600:
    minutes = int(seconds // 60)
    secs = int(seconds % 60)
    return f"{minutes}m {secs}s"
  else:
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    return f"{hours}h {minutes}m"


def print_progress(
  current: int,
  total: int,
  water_count: int,
  start_time: float,
  workers: int,
  bar_width: int = 30,
) -> None:
  """Print a progress bar with stats."""
  if total == 0:
    return

  progress = current / total
  filled = int(bar_width * progress)
  bar = "‚ñà" * filled + "‚ñë" * (bar_width - filled)

  elapsed = time.time() - start_time
  if current > 0:
    eta = (elapsed / current) * (total - current)
    eta_str = format_time(eta)
  else:
    eta_str = "..."

  # Build the status line
  status = (
    f"\rüîç [{bar}] {current:,}/{total:,} ({progress * 100:.1f}%) "
    f"| üíß {water_count:,} water | ‚ö° {workers} workers | ETA: {eta_str}  "
  )

  # Print with carriage return to overwrite
  sys.stdout.write(status)
  sys.stdout.flush()


def detect_water_tiles(
  generation_dir: Path,
  threshold_percent: float = 1.0,
  dry_run: bool = False,
  verbose: bool = False,
  num_workers: int | None = None,
) -> dict:
  """
  Scan all tiles and detect which ones contain water using parallel processing.

  Args:
    generation_dir: Path to the generation directory
    threshold_percent: Minimum percentage of pixels that must be water color
    dry_run: If True, don't make any changes to the database
    verbose: If True, print each water tile as detected
    num_workers: Number of parallel workers (default: CPU count)

  Returns:
    Dict with statistics about the scan
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Determine number of workers
  if num_workers is None:
    num_workers = os.cpu_count() or 4
  num_workers = max(1, num_workers)

  conn = sqlite3.connect(db_path)

  try:
    # Ensure the is_water column exists
    if not dry_run:
      ensure_is_water_column(conn)

    # Get all quadrants with generations
    print("   Loading quadrants from database...")
    quadrants = get_all_quadrants_with_generations(conn)
    total = len(quadrants)
    print(f"\nüìä Found {total:,} quadrants with generations")

    stats = {
      "total_scanned": 0,
      "water_tiles": 0,
      "non_water_tiles": 0,
      "errors": 0,
      "water_quadrants": [],
    }

    print(f"üîç Scanning for water color #{WATER_COLOR_HEX}...")
    print(f"   Threshold: {threshold_percent}% of pixels")
    print(f"   Workers: {num_workers}")
    if verbose:
      print()  # Extra line before verbose output

    start_time = time.time()
    tolerance = 5

    # Prepare work items
    work_items = [
      (x, y, generation_bytes, threshold_percent, tolerance)
      for x, y, generation_bytes in quadrants
    ]

    # Lists to batch database updates
    water_coords: list[tuple[int, int]] = []
    non_water_coords: list[tuple[int, int]] = []

    # Process in parallel
    completed = 0
    with ProcessPoolExecutor(max_workers=num_workers) as executor:
      # Submit all tasks
      future_to_coord = {
        executor.submit(analyze_tile, item): (item[0], item[1]) for item in work_items
      }

      # Process results as they complete
      for future in as_completed(future_to_coord):
        x, y, is_water, percentage = future.result()
        completed += 1
        stats["total_scanned"] += 1

        if is_water:
          stats["water_tiles"] += 1
          stats["water_quadrants"].append((x, y, percentage))
          water_coords.append((x, y))

          if verbose:
            # Clear the progress bar line first
            sys.stdout.write("\r" + " " * 120 + "\r")
            if dry_run:
              print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water (would mark)")
            else:
              print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water ‚úì")
        else:
          stats["non_water_tiles"] += 1
          non_water_coords.append((x, y))

        # Update progress bar periodically
        if total < 100 or completed % 50 == 0 or completed == total:
          print_progress(
            completed, total, stats["water_tiles"], start_time, num_workers
          )

    # Clear the progress bar and print final stats
    elapsed = time.time() - start_time
    sys.stdout.write("\r" + " " * 120 + "\r")
    tiles_per_sec = total / elapsed if elapsed > 0 else 0
    print(
      f"‚úÖ Scanned {total:,} tiles in {format_time(elapsed)} "
      f"({tiles_per_sec:.0f} tiles/sec)"
    )

    # Batch update database
    if not dry_run:
      print("   Updating database...")
      cursor = conn.cursor()

      # Mark water tiles
      if water_coords:
        cursor.executemany(
          "UPDATE quadrants SET is_water = 1 WHERE quadrant_x = ? AND quadrant_y = ?",
          water_coords,
        )

      # Unmark non-water tiles
      if non_water_coords:
        cursor.executemany(
          "UPDATE quadrants SET is_water = 0 WHERE quadrant_x = ? AND quadrant_y = ?",
          non_water_coords,
        )

      conn.commit()
      print("   ‚úì Database updated")

    return stats

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Detect and mark water tiles in the generation database."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--threshold",
    type=float,
    default=1.0,
    help="Minimum percentage of pixels that must be water color (default: 1.0)",
  )
  parser.add_argument(
    "--dry-run",
    action="store_true",
    help="Show what would be marked without making changes",
  )
  parser.add_argument(
    "--verbose",
    "-v",
    action="store_true",
    help="Show each water tile as it's detected",
  )
  parser.add_argument(
    "--workers",
    "-w",
    type=int,
    default=None,
    help=f"Number of parallel workers (default: CPU count = {os.cpu_count()})",
  )

  args = parser.parse_args()

  # Resolve path
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  num_workers = args.workers or os.cpu_count() or 4

  print(f"\n{'=' * 60}")
  print("üíß Water Tile Detection (Parallel)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")
  print(f"   Water color: #{WATER_COLOR_HEX} (RGB{WATER_COLOR_RGB})")
  print(f"   Threshold: {args.threshold}%")
  print(f"   Workers: {num_workers}")
  mode_parts = []
  if args.dry_run:
    mode_parts.append("DRY RUN")
  if args.verbose:
    mode_parts.append("VERBOSE")
  if mode_parts:
    print(f"   Mode: {', '.join(mode_parts)}")
  print()

  try:
    stats = detect_water_tiles(
      generation_dir,
      threshold_percent=args.threshold,
      dry_run=args.dry_run,
      verbose=args.verbose,
      num_workers=num_workers,
    )

    print(f"\n{'=' * 60}")
    print("üìà Results")
    print(f"{'=' * 60}")
    print(f"   Total scanned: {stats['total_scanned']:,}")
    print(f"   Water tiles:   {stats['water_tiles']:,}")
    print(f"   Non-water:     {stats['non_water_tiles']:,}")

    # Only show the full list if not already shown in verbose mode
    if stats["water_quadrants"] and not args.verbose:
      print(f"\nüíß Water tiles found ({len(stats['water_quadrants']):,}):")
      # Sort by coordinates for consistent output
      sorted_water = sorted(stats["water_quadrants"], key=lambda t: (t[0], t[1]))
      for x, y, pct in sorted_water:
        print(f"      ({x}, {y}) - {pct:.1f}%")

    if args.dry_run:
      print("\n‚ö†Ô∏è  DRY RUN - No changes were made to the database")
    else:
      print(f"\n‚úÖ Marked {stats['water_tiles']:,} tile(s) as water")

    return 0

  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  # Required for multiprocessing on Windows and macOS
  multiprocessing.freeze_support()
  exit(main())

```

```python
"""
Detect Water Tiles - Scan generation tiles and mark those containing water color.

This script iterates over all tiles in the quadrants database and marks them
with the is_water flag if they contain the water color #4A6372.

Usage:
  uv run python src/isometric_nyc/e2e_generation/detect_water_tiles.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Options:
  --threshold N: Minimum percentage of pixels that must be water color (default: 1.0)
  --dry-run: Show what would be marked without making changes
  --verbose: Show each water tile as it's detected
  --workers N: Number of parallel workers (default: CPU count)
"""

import argparse
import multiprocessing
import os
import sqlite3
import sys
import time
from concurrent.futures import ProcessPoolExecutor, as_completed
from io import BytesIO
from pathlib import Path

from PIL import Image

# The water color to detect
WATER_COLOR_HEX = "4A6372"
WATER_COLOR_RGB = tuple(int(WATER_COLOR_HEX[i : i + 2], 16) for i in (0, 2, 4))

# Water status values in the database
WATER_STATUS_NOT_WATER = 0  # Auto-detected as not water (can be overwritten)
WATER_STATUS_WATER = 1  # Water tile (auto or manual)
WATER_STATUS_EXPLICIT_NOT_WATER = -1  # Explicitly marked as NOT water (protected)


def ensure_is_water_column(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table."""
  cursor = conn.cursor()
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_all_quadrants_with_generations(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bytes, int]]:
  """
  Get all quadrants that have generation data.

  Returns:
    List of (quadrant_x, quadrant_y, generation_bytes, is_water_status) tuples.
    is_water_status is -1 for explicitly not water, 0 for unclassified, 1 for water.
  """
  cursor = conn.cursor()
  cursor.execute("""
    SELECT quadrant_x, quadrant_y, generation, COALESCE(is_water, 0)
    FROM quadrants
    WHERE generation IS NOT NULL
    ORDER BY quadrant_x, quadrant_y
  """)
  return [(row[0], row[1], row[2], row[3]) for row in cursor.fetchall()]


def analyze_tile(
  args: tuple[int, int, bytes, float, int],
) -> tuple[int, int, bool, float]:
  """
  Analyze a single tile for water content. Worker function for parallel processing.

  Args:
    args: Tuple of (x, y, png_bytes, threshold_percent, tolerance)

  Returns:
    Tuple of (x, y, is_water, percentage)
  """
  x, y, png_bytes, threshold_percent, tolerance = args

  try:
    img = Image.open(BytesIO(png_bytes))
    img = img.convert("RGB")

    pixels = list(img.getdata())
    total_pixels = len(pixels)

    if total_pixels == 0:
      return x, y, False, 0.0

    # Count pixels that match the water color (within tolerance)
    water_r, water_g, water_b = WATER_COLOR_RGB
    matching_pixels = 0

    for r, g, b in pixels:
      if (
        abs(r - water_r) <= tolerance
        and abs(g - water_g) <= tolerance
        and abs(b - water_b) <= tolerance
      ):
        matching_pixels += 1

    percentage = (matching_pixels / total_pixels) * 100
    is_water = percentage >= threshold_percent

    return x, y, is_water, percentage

  except Exception:
    return x, y, False, 0.0


def format_time(seconds: float) -> str:
  """Format seconds into a human-readable time string."""
  if seconds < 60:
    return f"{seconds:.1f}s"
  elif seconds < 3600:
    minutes = int(seconds // 60)
    secs = int(seconds % 60)
    return f"{minutes}m {secs}s"
  else:
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    return f"{hours}h {minutes}m"


def print_progress(
  current: int,
  total: int,
  water_count: int,
  start_time: float,
  workers: int,
  bar_width: int = 30,
) -> None:
  """Print a progress bar with stats."""
  if total == 0:
    return

  progress = current / total
  filled = int(bar_width * progress)
  bar = "‚ñà" * filled + "‚ñë" * (bar_width - filled)

  elapsed = time.time() - start_time
  if current > 0:
    eta = (elapsed / current) * (total - current)
    eta_str = format_time(eta)
  else:
    eta_str = "..."

  # Build the status line
  status = (
    f"\rüîç [{bar}] {current:,}/{total:,} ({progress * 100:.1f}%) "
    f"| üíß {water_count:,} water | ‚ö° {workers} workers | ETA: {eta_str}  "
  )

  # Print with carriage return to overwrite
  sys.stdout.write(status)
  sys.stdout.flush()


def detect_water_tiles(
  generation_dir: Path,
  threshold_percent: float = 1.0,
  dry_run: bool = False,
  verbose: bool = False,
  num_workers: int | None = None,
) -> dict:
  """
  Scan all tiles and detect which ones contain water using parallel processing.

  Args:
    generation_dir: Path to the generation directory
    threshold_percent: Minimum percentage of pixels that must be water color
    dry_run: If True, don't make any changes to the database
    verbose: If True, print each water tile as detected
    num_workers: Number of parallel workers (default: CPU count)

  Returns:
    Dict with statistics about the scan
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Determine number of workers
  if num_workers is None:
    num_workers = os.cpu_count() or 4
  num_workers = max(1, num_workers)

  conn = sqlite3.connect(db_path)

  try:
    # Ensure the is_water column exists
    if not dry_run:
      ensure_is_water_column(conn)

    # Get all quadrants with generations
    print("   Loading quadrants from database...")
    quadrants = get_all_quadrants_with_generations(conn)
    total = len(quadrants)
    print(f"\nüìä Found {total:,} quadrants with generations")

    stats = {
      "total_scanned": 0,
      "water_tiles": 0,
      "non_water_tiles": 0,
      "errors": 0,
      "water_quadrants": [],
    }

    print(f"üîç Scanning for water color #{WATER_COLOR_HEX}...")
    print(f"   Threshold: {threshold_percent}% of pixels")
    print(f"   Workers: {num_workers}")
    if verbose:
      print()  # Extra line before verbose output

    start_time = time.time()
    tolerance = 5

    # Prepare work items
    work_items = [
      (x, y, generation_bytes, threshold_percent, tolerance)
      for x, y, generation_bytes in quadrants
    ]

    # Lists to batch database updates
    water_coords: list[tuple[int, int]] = []
    non_water_coords: list[tuple[int, int]] = []

    # Process in parallel
    completed = 0
    with ProcessPoolExecutor(max_workers=num_workers) as executor:
      # Submit all tasks
      future_to_coord = {
        executor.submit(analyze_tile, item): (item[0], item[1]) for item in work_items
      }

      # Process results as they complete
      for future in as_completed(future_to_coord):
        x, y, is_water, percentage = future.result()
        completed += 1
        stats["total_scanned"] += 1

        if is_water:
          stats["water_tiles"] += 1
          stats["water_quadrants"].append((x, y, percentage))
          water_coords.append((x, y))

          if verbose:
            # Clear the progress bar line first
            sys.stdout.write("\r" + " " * 120 + "\r")
            if dry_run:
              print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water (would mark)")
            else:
              print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water ‚úì")
        else:
          stats["non_water_tiles"] += 1
          non_water_coords.append((x, y))

        # Update progress bar periodically
        if total < 100 or completed % 50 == 0 or completed == total:
          print_progress(
            completed, total, stats["water_tiles"], start_time, num_workers
          )

    # Clear the progress bar and print final stats
    elapsed = time.time() - start_time
    sys.stdout.write("\r" + " " * 120 + "\r")
    tiles_per_sec = total / elapsed if elapsed > 0 else 0
    print(
      f"‚úÖ Scanned {total:,} tiles in {format_time(elapsed)} "
      f"({tiles_per_sec:.0f} tiles/sec)"
    )

    # Batch update database
    if not dry_run:
      print("   Updating database...")
      cursor = conn.cursor()

      # Mark water tiles
      if water_coords:
        cursor.executemany(
          "UPDATE quadrants SET is_water = 1 WHERE quadrant_x = ? AND quadrant_y = ?",
          water_coords,
        )

      # Unmark non-water tiles
      if non_water_coords:
        cursor.executemany(
          "UPDATE quadrants SET is_water = 0 WHERE quadrant_x = ? AND quadrant_y = ?",
          non_water_coords,
        )

      conn.commit()
      print("   ‚úì Database updated")

    return stats

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Detect and mark water tiles in the generation database."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--threshold",
    type=float,
    default=1.0,
    help="Minimum percentage of pixels that must be water color (default: 1.0)",
  )
  parser.add_argument(
    "--dry-run",
    action="store_true",
    help="Show what would be marked without making changes",
  )
  parser.add_argument(
    "--verbose",
    "-v",
    action="store_true",
    help="Show each water tile as it's detected",
  )
  parser.add_argument(
    "--workers",
    "-w",
    type=int,
    default=None,
    help=f"Number of parallel workers (default: CPU count = {os.cpu_count()})",
  )

  args = parser.parse_args()

  # Resolve path
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  num_workers = args.workers or os.cpu_count() or 4

  print(f"\n{'=' * 60}")
  print("üíß Water Tile Detection (Parallel)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")
  print(f"   Water color: #{WATER_COLOR_HEX} (RGB{WATER_COLOR_RGB})")
  print(f"   Threshold: {args.threshold}%")
  print(f"   Workers: {num_workers}")
  mode_parts = []
  if args.dry_run:
    mode_parts.append("DRY RUN")
  if args.verbose:
    mode_parts.append("VERBOSE")
  if mode_parts:
    print(f"   Mode: {', '.join(mode_parts)}")
  print()

  try:
    stats = detect_water_tiles(
      generation_dir,
      threshold_percent=args.threshold,
      dry_run=args.dry_run,
      verbose=args.verbose,
      num_workers=num_workers,
    )

    print(f"\n{'=' * 60}")
    print("üìà Results")
    print(f"{'=' * 60}")
    print(f"   Total scanned: {stats['total_scanned']:,}")
    print(f"   Water tiles:   {stats['water_tiles']:,}")
    print(f"   Non-water:     {stats['non_water_tiles']:,}")

    # Only show the full list if not already shown in verbose mode
    if stats["water_quadrants"] and not args.verbose:
      print(f"\nüíß Water tiles found ({len(stats['water_quadrants']):,}):")
      # Sort by coordinates for consistent output
      sorted_water = sorted(stats["water_quadrants"], key=lambda t: (t[0], t[1]))
      for x, y, pct in sorted_water:
        print(f"      ({x}, {y}) - {pct:.1f}%")

    if args.dry_run:
      print("\n‚ö†Ô∏è  DRY RUN - No changes were made to the database")
    else:
      print(f"\n‚úÖ Marked {stats['water_tiles']:,} tile(s) as water")

    return 0

  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  # Required for multiprocessing on Windows and macOS
  multiprocessing.freeze_support()
  exit(main())

```

```python
"""
Detect Water Tiles - Scan generation tiles and mark those containing water color.

This script iterates over all tiles in the quadrants database and marks them
with the is_water flag if they contain the water color #4A6372.

Usage:
  uv run python src/isometric_nyc/e2e_generation/detect_water_tiles.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Options:
  --threshold N: Minimum percentage of pixels that must be water color (default: 1.0)
  --dry-run: Show what would be marked without making changes
  --verbose: Show each water tile as it's detected
  --workers N: Number of parallel workers (default: CPU count)
"""

import argparse
import multiprocessing
import os
import sqlite3
import sys
import time
from concurrent.futures import ProcessPoolExecutor, as_completed
from io import BytesIO
from pathlib import Path

from PIL import Image

# The water color to detect
WATER_COLOR_HEX = "4A6372"
WATER_COLOR_RGB = tuple(int(WATER_COLOR_HEX[i : i + 2], 16) for i in (0, 2, 4))

# Water status values in the database
WATER_STATUS_NOT_WATER = 0  # Auto-detected as not water (can be overwritten)
WATER_STATUS_WATER = 1  # Water tile (auto or manual)
WATER_STATUS_EXPLICIT_NOT_WATER = -1  # Explicitly marked as NOT water (protected)


def ensure_is_water_column(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table."""
  cursor = conn.cursor()
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_all_quadrants_with_generations(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bytes, int]]:
  """
  Get all quadrants that have generation data.

  Returns:
    List of (quadrant_x, quadrant_y, generation_bytes, is_water_status) tuples.
    is_water_status is -1 for explicitly not water, 0 for unclassified, 1 for water.
  """
  cursor = conn.cursor()
  cursor.execute("""
    SELECT quadrant_x, quadrant_y, generation, COALESCE(is_water, 0)
    FROM quadrants
    WHERE generation IS NOT NULL
    ORDER BY quadrant_x, quadrant_y
  """)
  return [(row[0], row[1], row[2], row[3]) for row in cursor.fetchall()]


def analyze_tile(
  args: tuple[int, int, bytes, float, int],
) -> tuple[int, int, bool, float]:
  """
  Analyze a single tile for water content. Worker function for parallel processing.

  Args:
    args: Tuple of (x, y, png_bytes, threshold_percent, tolerance)

  Returns:
    Tuple of (x, y, is_water, percentage)
  """
  x, y, png_bytes, threshold_percent, tolerance = args

  try:
    img = Image.open(BytesIO(png_bytes))
    img = img.convert("RGB")

    pixels = list(img.getdata())
    total_pixels = len(pixels)

    if total_pixels == 0:
      return x, y, False, 0.0

    # Count pixels that match the water color (within tolerance)
    water_r, water_g, water_b = WATER_COLOR_RGB
    matching_pixels = 0

    for r, g, b in pixels:
      if (
        abs(r - water_r) <= tolerance
        and abs(g - water_g) <= tolerance
        and abs(b - water_b) <= tolerance
      ):
        matching_pixels += 1

    percentage = (matching_pixels / total_pixels) * 100
    is_water = percentage >= threshold_percent

    return x, y, is_water, percentage

  except Exception:
    return x, y, False, 0.0


def format_time(seconds: float) -> str:
  """Format seconds into a human-readable time string."""
  if seconds < 60:
    return f"{seconds:.1f}s"
  elif seconds < 3600:
    minutes = int(seconds // 60)
    secs = int(seconds % 60)
    return f"{minutes}m {secs}s"
  else:
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    return f"{hours}h {minutes}m"


def print_progress(
  current: int,
  total: int,
  water_count: int,
  start_time: float,
  workers: int,
  bar_width: int = 30,
) -> None:
  """Print a progress bar with stats."""
  if total == 0:
    return

  progress = current / total
  filled = int(bar_width * progress)
  bar = "‚ñà" * filled + "‚ñë" * (bar_width - filled)

  elapsed = time.time() - start_time
  if current > 0:
    eta = (elapsed / current) * (total - current)
    eta_str = format_time(eta)
  else:
    eta_str = "..."

  # Build the status line
  status = (
    f"\rüîç [{bar}] {current:,}/{total:,} ({progress * 100:.1f}%) "
    f"| üíß {water_count:,} water | ‚ö° {workers} workers | ETA: {eta_str}  "
  )

  # Print with carriage return to overwrite
  sys.stdout.write(status)
  sys.stdout.flush()


def detect_water_tiles(
  generation_dir: Path,
  threshold_percent: float = 1.0,
  dry_run: bool = False,
  verbose: bool = False,
  num_workers: int | None = None,
) -> dict:
  """
  Scan all tiles and detect which ones contain water using parallel processing.

  Args:
    generation_dir: Path to the generation directory
    threshold_percent: Minimum percentage of pixels that must be water color
    dry_run: If True, don't make any changes to the database
    verbose: If True, print each water tile as detected
    num_workers: Number of parallel workers (default: CPU count)

  Returns:
    Dict with statistics about the scan
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Determine number of workers
  if num_workers is None:
    num_workers = os.cpu_count() or 4
  num_workers = max(1, num_workers)

  conn = sqlite3.connect(db_path)

  try:
    # Ensure the is_water column exists
    if not dry_run:
      ensure_is_water_column(conn)

    # Get all quadrants with generations
    print("   Loading quadrants from database...")
    all_quadrants = get_all_quadrants_with_generations(conn)
    total_in_db = len(all_quadrants)

    # Filter out explicitly protected tiles (is_water = -1)
    protected_quadrants = [
      (x, y)
      for x, y, _, is_water in all_quadrants
      if is_water == WATER_STATUS_EXPLICIT_NOT_WATER
    ]
    quadrants_to_scan = [
      (x, y, gen_bytes, is_water)
      for x, y, gen_bytes, is_water in all_quadrants
      if is_water != WATER_STATUS_EXPLICIT_NOT_WATER
    ]

    total = len(quadrants_to_scan)
    skipped = len(protected_quadrants)

    print(f"\nüìä Found {total_in_db:,} quadrants with generations")
    if skipped > 0:
      print(f"   üõ°Ô∏è  Skipping {skipped:,} explicitly protected tiles")

    stats = {
      "total_scanned": 0,
      "water_tiles": 0,
      "non_water_tiles": 0,
      "skipped_protected": skipped,
      "errors": 0,
      "water_quadrants": [],
      "protected_quadrants": protected_quadrants,
    }

    if total == 0:
      print("   No tiles to scan (all protected or none exist)")
      return stats

    print(f"üîç Scanning {total:,} tiles for water color #{WATER_COLOR_HEX}...")
    print(f"   Threshold: {threshold_percent}% of pixels")
    print(f"   Workers: {num_workers}")
    if verbose:
      print()  # Extra line before verbose output

    start_time = time.time()
    tolerance = 5

    # Prepare work items (excluding protected tiles)
    work_items = [
      (x, y, generation_bytes, threshold_percent, tolerance)
      for x, y, generation_bytes, _ in quadrants_to_scan
    ]

    # Lists to batch database updates
    water_coords: list[tuple[int, int]] = []
    non_water_coords: list[tuple[int, int]] = []

    # Process in parallel
    completed = 0
    with ProcessPoolExecutor(max_workers=num_workers) as executor:
      # Submit all tasks
      future_to_coord = {
        executor.submit(analyze_tile, item): (item[0], item[1]) for item in work_items
      }

      # Process results as they complete
      for future in as_completed(future_to_coord):
        x, y, is_water, percentage = future.result()
        completed += 1
        stats["total_scanned"] += 1

        if is_water:
          stats["water_tiles"] += 1
          stats["water_quadrants"].append((x, y, percentage))
          water_coords.append((x, y))

          if verbose:
            # Clear the progress bar line first
            sys.stdout.write("\r" + " " * 120 + "\r")
            if dry_run:
              print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water (would mark)")
            else:
              print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water ‚úì")
        else:
          stats["non_water_tiles"] += 1
          non_water_coords.append((x, y))

        # Update progress bar periodically
        if total < 100 or completed % 50 == 0 or completed == total:
          print_progress(
            completed, total, stats["water_tiles"], start_time, num_workers
          )

    # Clear the progress bar and print final stats
    elapsed = time.time() - start_time
    sys.stdout.write("\r" + " " * 120 + "\r")
    tiles_per_sec = total / elapsed if elapsed > 0 else 0
    print(
      f"‚úÖ Scanned {total:,} tiles in {format_time(elapsed)} "
      f"({tiles_per_sec:.0f} tiles/sec)"
    )

    # Batch update database
    if not dry_run:
      print("   Updating database...")
      cursor = conn.cursor()

      # Mark water tiles
      if water_coords:
        cursor.executemany(
          "UPDATE quadrants SET is_water = 1 WHERE quadrant_x = ? AND quadrant_y = ?",
          water_coords,
        )

      # Unmark non-water tiles
      if non_water_coords:
        cursor.executemany(
          "UPDATE quadrants SET is_water = 0 WHERE quadrant_x = ? AND quadrant_y = ?",
          non_water_coords,
        )

      conn.commit()
      print("   ‚úì Database updated")

    return stats

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Detect and mark water tiles in the generation database."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--threshold",
    type=float,
    default=1.0,
    help="Minimum percentage of pixels that must be water color (default: 1.0)",
  )
  parser.add_argument(
    "--dry-run",
    action="store_true",
    help="Show what would be marked without making changes",
  )
  parser.add_argument(
    "--verbose",
    "-v",
    action="store_true",
    help="Show each water tile as it's detected",
  )
  parser.add_argument(
    "--workers",
    "-w",
    type=int,
    default=None,
    help=f"Number of parallel workers (default: CPU count = {os.cpu_count()})",
  )

  args = parser.parse_args()

  # Resolve path
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  num_workers = args.workers or os.cpu_count() or 4

  print(f"\n{'=' * 60}")
  print("üíß Water Tile Detection (Parallel)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")
  print(f"   Water color: #{WATER_COLOR_HEX} (RGB{WATER_COLOR_RGB})")
  print(f"   Threshold: {args.threshold}%")
  print(f"   Workers: {num_workers}")
  mode_parts = []
  if args.dry_run:
    mode_parts.append("DRY RUN")
  if args.verbose:
    mode_parts.append("VERBOSE")
  if mode_parts:
    print(f"   Mode: {', '.join(mode_parts)}")
  print()

  try:
    stats = detect_water_tiles(
      generation_dir,
      threshold_percent=args.threshold,
      dry_run=args.dry_run,
      verbose=args.verbose,
      num_workers=num_workers,
    )

    print(f"\n{'=' * 60}")
    print("üìà Results")
    print(f"{'=' * 60}")
    print(f"   Total scanned: {stats['total_scanned']:,}")
    print(f"   Water tiles:   {stats['water_tiles']:,}")
    print(f"   Non-water:     {stats['non_water_tiles']:,}")

    # Only show the full list if not already shown in verbose mode
    if stats["water_quadrants"] and not args.verbose:
      print(f"\nüíß Water tiles found ({len(stats['water_quadrants']):,}):")
      # Sort by coordinates for consistent output
      sorted_water = sorted(stats["water_quadrants"], key=lambda t: (t[0], t[1]))
      for x, y, pct in sorted_water:
        print(f"      ({x}, {y}) - {pct:.1f}%")

    if args.dry_run:
      print("\n‚ö†Ô∏è  DRY RUN - No changes were made to the database")
    else:
      print(f"\n‚úÖ Marked {stats['water_tiles']:,} tile(s) as water")

    return 0

  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  # Required for multiprocessing on Windows and macOS
  multiprocessing.freeze_support()
  exit(main())

```

```python
"""
Detect Water Tiles - Scan generation tiles and mark those containing water color.

This script iterates over all tiles in the quadrants database and marks them
with the is_water flag if they contain the water color #4A6372.

Usage:
  uv run python src/isometric_nyc/e2e_generation/detect_water_tiles.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Options:
  --threshold N: Minimum percentage of pixels that must be water color (default: 1.0)
  --dry-run: Show what would be marked without making changes
  --verbose: Show each water tile as it's detected
  --workers N: Number of parallel workers (default: CPU count)
"""

import argparse
import multiprocessing
import os
import sqlite3
import sys
import time
from concurrent.futures import ProcessPoolExecutor, as_completed
from io import BytesIO
from pathlib import Path

from PIL import Image

# The water color to detect
WATER_COLOR_HEX = "4A6372"
WATER_COLOR_RGB = tuple(int(WATER_COLOR_HEX[i : i + 2], 16) for i in (0, 2, 4))

# Water status values in the database
WATER_STATUS_NOT_WATER = 0  # Auto-detected as not water (can be overwritten)
WATER_STATUS_WATER = 1  # Water tile (auto or manual)
WATER_STATUS_EXPLICIT_NOT_WATER = -1  # Explicitly marked as NOT water (protected)


def ensure_is_water_column(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table."""
  cursor = conn.cursor()
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_all_quadrants_with_generations(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, bytes, int]]:
  """
  Get all quadrants that have generation data.

  Returns:
    List of (quadrant_x, quadrant_y, generation_bytes, is_water_status) tuples.
    is_water_status is -1 for explicitly not water, 0 for unclassified, 1 for water.
  """
  cursor = conn.cursor()
  cursor.execute("""
    SELECT quadrant_x, quadrant_y, generation, COALESCE(is_water, 0)
    FROM quadrants
    WHERE generation IS NOT NULL
    ORDER BY quadrant_x, quadrant_y
  """)
  return [(row[0], row[1], row[2], row[3]) for row in cursor.fetchall()]


def analyze_tile(
  args: tuple[int, int, bytes, float, int],
) -> tuple[int, int, bool, float]:
  """
  Analyze a single tile for water content. Worker function for parallel processing.

  Args:
    args: Tuple of (x, y, png_bytes, threshold_percent, tolerance)

  Returns:
    Tuple of (x, y, is_water, percentage)
  """
  x, y, png_bytes, threshold_percent, tolerance = args

  try:
    img = Image.open(BytesIO(png_bytes))
    img = img.convert("RGB")

    pixels = list(img.getdata())
    total_pixels = len(pixels)

    if total_pixels == 0:
      return x, y, False, 0.0

    # Count pixels that match the water color (within tolerance)
    water_r, water_g, water_b = WATER_COLOR_RGB
    matching_pixels = 0

    for r, g, b in pixels:
      if (
        abs(r - water_r) <= tolerance
        and abs(g - water_g) <= tolerance
        and abs(b - water_b) <= tolerance
      ):
        matching_pixels += 1

    percentage = (matching_pixels / total_pixels) * 100
    is_water = percentage >= threshold_percent

    return x, y, is_water, percentage

  except Exception:
    return x, y, False, 0.0


def format_time(seconds: float) -> str:
  """Format seconds into a human-readable time string."""
  if seconds < 60:
    return f"{seconds:.1f}s"
  elif seconds < 3600:
    minutes = int(seconds // 60)
    secs = int(seconds % 60)
    return f"{minutes}m {secs}s"
  else:
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    return f"{hours}h {minutes}m"


def print_progress(
  current: int,
  total: int,
  water_count: int,
  start_time: float,
  workers: int,
  bar_width: int = 30,
) -> None:
  """Print a progress bar with stats."""
  if total == 0:
    return

  progress = current / total
  filled = int(bar_width * progress)
  bar = "‚ñà" * filled + "‚ñë" * (bar_width - filled)

  elapsed = time.time() - start_time
  if current > 0:
    eta = (elapsed / current) * (total - current)
    eta_str = format_time(eta)
  else:
    eta_str = "..."

  # Build the status line
  status = (
    f"\rüîç [{bar}] {current:,}/{total:,} ({progress * 100:.1f}%) "
    f"| üíß {water_count:,} water | ‚ö° {workers} workers | ETA: {eta_str}  "
  )

  # Print with carriage return to overwrite
  sys.stdout.write(status)
  sys.stdout.flush()


def detect_water_tiles(
  generation_dir: Path,
  threshold_percent: float = 1.0,
  dry_run: bool = False,
  verbose: bool = False,
  num_workers: int | None = None,
) -> dict:
  """
  Scan all tiles and detect which ones contain water using parallel processing.

  Args:
    generation_dir: Path to the generation directory
    threshold_percent: Minimum percentage of pixels that must be water color
    dry_run: If True, don't make any changes to the database
    verbose: If True, print each water tile as detected
    num_workers: Number of parallel workers (default: CPU count)

  Returns:
    Dict with statistics about the scan
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Determine number of workers
  if num_workers is None:
    num_workers = os.cpu_count() or 4
  num_workers = max(1, num_workers)

  conn = sqlite3.connect(db_path)

  try:
    # Ensure the is_water column exists
    if not dry_run:
      ensure_is_water_column(conn)

    # Get all quadrants with generations
    print("   Loading quadrants from database...")
    all_quadrants = get_all_quadrants_with_generations(conn)
    total_in_db = len(all_quadrants)

    # Filter out explicitly protected tiles (is_water = -1)
    protected_quadrants = [
      (x, y)
      for x, y, _, is_water in all_quadrants
      if is_water == WATER_STATUS_EXPLICIT_NOT_WATER
    ]
    quadrants_to_scan = [
      (x, y, gen_bytes, is_water)
      for x, y, gen_bytes, is_water in all_quadrants
      if is_water != WATER_STATUS_EXPLICIT_NOT_WATER
    ]

    total = len(quadrants_to_scan)
    skipped = len(protected_quadrants)

    print(f"\nüìä Found {total_in_db:,} quadrants with generations")
    if skipped > 0:
      print(f"   üõ°Ô∏è  Skipping {skipped:,} explicitly protected tiles")

    stats = {
      "total_scanned": 0,
      "water_tiles": 0,
      "non_water_tiles": 0,
      "skipped_protected": skipped,
      "errors": 0,
      "water_quadrants": [],
      "protected_quadrants": protected_quadrants,
    }

    if total == 0:
      print("   No tiles to scan (all protected or none exist)")
      return stats

    print(f"üîç Scanning {total:,} tiles for water color #{WATER_COLOR_HEX}...")
    print(f"   Threshold: {threshold_percent}% of pixels")
    print(f"   Workers: {num_workers}")
    if verbose:
      print()  # Extra line before verbose output

    start_time = time.time()
    tolerance = 5

    # Prepare work items (excluding protected tiles)
    work_items = [
      (x, y, generation_bytes, threshold_percent, tolerance)
      for x, y, generation_bytes, _ in quadrants_to_scan
    ]

    # Lists to batch database updates
    water_coords: list[tuple[int, int]] = []
    non_water_coords: list[tuple[int, int]] = []

    # Process in parallel
    completed = 0
    with ProcessPoolExecutor(max_workers=num_workers) as executor:
      # Submit all tasks
      future_to_coord = {
        executor.submit(analyze_tile, item): (item[0], item[1]) for item in work_items
      }

      # Process results as they complete
      for future in as_completed(future_to_coord):
        x, y, is_water, percentage = future.result()
        completed += 1
        stats["total_scanned"] += 1

        if is_water:
          stats["water_tiles"] += 1
          stats["water_quadrants"].append((x, y, percentage))
          water_coords.append((x, y))

          if verbose:
            # Clear the progress bar line first
            sys.stdout.write("\r" + " " * 120 + "\r")
            if dry_run:
              print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water (would mark)")
            else:
              print(f"   üíß ({x:4d}, {y:4d}) - {percentage:.1f}% water ‚úì")
        else:
          stats["non_water_tiles"] += 1
          non_water_coords.append((x, y))

        # Update progress bar periodically
        if total < 100 or completed % 50 == 0 or completed == total:
          print_progress(
            completed, total, stats["water_tiles"], start_time, num_workers
          )

    # Clear the progress bar and print final stats
    elapsed = time.time() - start_time
    sys.stdout.write("\r" + " " * 120 + "\r")
    tiles_per_sec = total / elapsed if elapsed > 0 else 0
    print(
      f"‚úÖ Scanned {total:,} tiles in {format_time(elapsed)} "
      f"({tiles_per_sec:.0f} tiles/sec)"
    )

    # Batch update database
    if not dry_run:
      print("   Updating database...")
      cursor = conn.cursor()

      # Mark water tiles
      if water_coords:
        cursor.executemany(
          "UPDATE quadrants SET is_water = 1 WHERE quadrant_x = ? AND quadrant_y = ?",
          water_coords,
        )

      # Unmark non-water tiles
      if non_water_coords:
        cursor.executemany(
          "UPDATE quadrants SET is_water = 0 WHERE quadrant_x = ? AND quadrant_y = ?",
          non_water_coords,
        )

      conn.commit()
      print("   ‚úì Database updated")

    return stats

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Detect and mark water tiles in the generation database."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--threshold",
    type=float,
    default=1.0,
    help="Minimum percentage of pixels that must be water color (default: 1.0)",
  )
  parser.add_argument(
    "--dry-run",
    action="store_true",
    help="Show what would be marked without making changes",
  )
  parser.add_argument(
    "--verbose",
    "-v",
    action="store_true",
    help="Show each water tile as it's detected",
  )
  parser.add_argument(
    "--workers",
    "-w",
    type=int,
    default=None,
    help=f"Number of parallel workers (default: CPU count = {os.cpu_count()})",
  )

  args = parser.parse_args()

  # Resolve path
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  num_workers = args.workers or os.cpu_count() or 4

  print(f"\n{'=' * 60}")
  print("üíß Water Tile Detection (Parallel)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")
  print(f"   Water color: #{WATER_COLOR_HEX} (RGB{WATER_COLOR_RGB})")
  print(f"   Threshold: {args.threshold}%")
  print(f"   Workers: {num_workers}")
  mode_parts = []
  if args.dry_run:
    mode_parts.append("DRY RUN")
  if args.verbose:
    mode_parts.append("VERBOSE")
  if mode_parts:
    print(f"   Mode: {', '.join(mode_parts)}")
  print()

  try:
    stats = detect_water_tiles(
      generation_dir,
      threshold_percent=args.threshold,
      dry_run=args.dry_run,
      verbose=args.verbose,
      num_workers=num_workers,
    )

    print(f"\n{'=' * 60}")
    print("üìà Results")
    print(f"{'=' * 60}")
    print(f"   Total scanned: {stats['total_scanned']:,}")
    print(f"   Water tiles:   {stats['water_tiles']:,}")
    print(f"   Non-water:     {stats['non_water_tiles']:,}")
    if stats.get("skipped_protected", 0) > 0:
      print(f"   üõ°Ô∏è  Protected:   {stats['skipped_protected']:,} (skipped)")

    # Only show the full list if not already shown in verbose mode
    if stats["water_quadrants"] and not args.verbose:
      print(f"\nüíß Water tiles found ({len(stats['water_quadrants']):,}):")
      # Sort by coordinates for consistent output
      sorted_water = sorted(stats["water_quadrants"], key=lambda t: (t[0], t[1]))
      for x, y, pct in sorted_water:
        print(f"      ({x}, {y}) - {pct:.1f}%")

    if args.dry_run:
      print("\n‚ö†Ô∏è  DRY RUN - No changes were made to the database")
    else:
      print(f"\n‚úÖ Marked {stats['water_tiles']:,} tile(s) as water")

    return 0

  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  # Required for multiprocessing on Windows and macOS
  multiprocessing.freeze_support()
  exit(main())

```

Now let me update the `app.py` to support the new water status values:

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  cancel_queue_item_by_id,
  clear_completed_items,
  clear_pending_queue,
  get_all_processing_items,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def ensure_flagged_column_exists(conn: sqlite3.Connection) -> None:
  """Ensure the flagged column exists in the quadrants table (migration)."""
  cursor = conn.cursor()
  # Check if column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "flagged" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN flagged INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'flagged' column to quadrants table")


def ensure_is_water_column_exists(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table (migration)."""
  cursor = conn.cursor()
  # Check if column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


def get_quadrant_info(x: int, y: int, use_render: bool = False) -> dict:
  """
  Get info about a quadrant including whether it has data, is flagged, and water status.

  Water status values:
    -1: Explicitly NOT water (protected from auto-detection)
     0: Not water (auto-detected, can be changed)
     1: Water tile
  """
  conn = get_db_connection()
  try:
    # Ensure columns exist
    ensure_flagged_column_exists(conn)
    ensure_is_water_column_exists(conn)

    cursor = conn.cursor()
    column = "render" if use_render else "generation"
    cursor.execute(
      f"""
      SELECT {column} IS NOT NULL, COALESCE(flagged, 0), COALESCE(is_water, 0)
      FROM quadrants
      WHERE quadrant_x = ? AND quadrant_y = ?
      """,
      (x, y),
    )
    row = cursor.fetchone()
    if row:
      water_status = row[2]
      return {
        "has_data": bool(row[0]),
        "flagged": bool(row[1]),
        "is_water": water_status == 1,  # True if water
        "is_explicit_not_water": water_status == -1,  # True if explicitly not water
        "water_status": water_status,  # Raw value: -1, 0, or 1
      }
    return {
      "has_data": False,
      "flagged": False,
      "is_water": False,
      "is_explicit_not_water": False,
      "water_status": 0,
    }
  finally:
    conn.close()


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data, flagged status, and water status
  tiles = {}
  flagged_tiles = {}
  water_tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      info = get_quadrant_info(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = info["has_data"]
      flagged_tiles[(dx, dy)] = info["flagged"]
      water_tiles[(dx, dy)] = info["is_water"]

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    flagged_tiles=flagged_tiles,
    water_tiles=water_tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def calculate_context_quadrants(
  conn: sqlite3.Connection,
  selected_quadrants: list[tuple[int, int]],
) -> list[tuple[int, int]]:
  """
  Calculate context quadrants lazily at execution time.

  This determines which adjacent quadrants have existing generations
  that can provide context for the current generation.

  For a valid generation, we need at least a 2x2 block where all 4 quadrants
  are either being generated or already generated.

  Args:
    conn: Database connection
    selected_quadrants: The quadrants being generated

  Returns:
    List of quadrant coordinates that have existing generations and can
    provide context for the current generation.
  """
  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation as shared_get_quadrant_generation,
  )

  selected_set = set(selected_quadrants)
  context = []

  # Find all quadrants adjacent to the selection that have generations
  # Check all potential 2x2 blocks that include any selected quadrant
  checked = set()

  for qx, qy in selected_quadrants:
    # Check all neighbors that could form a 2x2 block with this quadrant
    # A quadrant can be in 4 different 2x2 blocks (as TL, TR, BL, BR corner)
    potential_context = [
      # Neighbors for 2x2 where (qx, qy) is top-left
      (qx + 1, qy),
      (qx, qy + 1),
      (qx + 1, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is top-right
      (qx - 1, qy),
      (qx - 1, qy + 1),
      (qx, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is bottom-left
      (qx, qy - 1),
      (qx + 1, qy - 1),
      (qx + 1, qy),
      # Neighbors for 2x2 where (qx, qy) is bottom-right
      (qx - 1, qy - 1),
      (qx, qy - 1),
      (qx - 1, qy),
    ]

    for nx, ny in potential_context:
      coord = (nx, ny)
      if coord in checked or coord in selected_set:
        continue
      checked.add(coord)

      # Check if this quadrant has an existing generation
      gen = shared_get_quadrant_generation(conn, nx, ny)
      if gen is not None:
        context.append(coord)

  return context


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.
    prompt: Optional additional prompt text for generation

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants, prompt
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None
    prompt = row[4]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]

    # Calculate context lazily if not explicitly provided
    # This ensures we use the most up-to-date context based on what's
    # actually generated at execution time (not queue time)
    if context_quadrants_raw:
      context_quadrants = [(q[0], q[1]) for q in context_quadrants_raw]
      print(
        f"   üìã Using explicit context from queue: {len(context_quadrants)} quadrant(s)"
      )
    else:
      # Calculate context lazily based on current generation state
      context_quadrants = calculate_context_quadrants(conn, selected_quadrants)
      if context_quadrants:
        print(f"   üìã Calculated lazy context: {len(context_quadrants)} quadrant(s)")
      else:
        print(
          "   üìã No context quadrants (2x2 self-contained or no adjacent generations)"
        )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    if prompt:
      print(f"   Prompt: {prompt}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      # Retry logic for generation - retry up to 3 times
      max_generation_retries = 3
      generation_retry_delay = 5.0  # seconds between generation retries

      for gen_attempt in range(1, max_generation_retries + 1):
        result = run_generation(
          conn, config, selected_quadrants, model_id, context_quadrants, prompt
        )

        if result["success"]:
          print(f"‚úÖ Generation complete: {result['message']}")
          generation_state["status"] = "complete"
          generation_state["message"] = result["message"]
          mark_item_complete(conn, item_id, result["message"])
          return result

        # Generation failed
        if gen_attempt < max_generation_retries:
          print(
            f"‚ö†Ô∏è  Generation failed (attempt {gen_attempt}/{max_generation_retries}): "
            f"{result['error']}"
          )
          print(f"‚è≥ Waiting {generation_retry_delay}s before retrying generation...")
          update_generation_state(
            "retrying",
            f"Generation failed, retrying (attempt {gen_attempt + 1}/{max_generation_retries})...",
          )
          time.sleep(generation_retry_delay)
        else:
          # All retries exhausted
          print(
            f"‚ùå Generation failed after {max_generation_retries} attempts: "
            f"{result['error']}"
          )
          generation_state["status"] = "error"
          generation_state["error"] = result["error"]
          mark_item_error(conn, item_id, result["error"])
          return result

      # Should not reach here, but just in case
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_models": model_status["processing_models"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
      # All quadrants being processed across all models
      "all_processing_quadrants": model_status["all_processing_quadrants"],
    }

    # Set is_generating based on whether any models are active
    response["is_generating"] = len(active_models) > 0

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/queue/cancel/<int:item_id>", methods=["POST"])
def api_cancel_queue_item(item_id: int):
  """
  API endpoint to cancel a specific queue item by its ID.

  Returns:
    {
      "success": true,
      "cancelled": true,
      "item_id": N,
      "message": "Cancelled queue item N"
    }
  """
  global generation_cancelled

  print(f"\n{'=' * 60}")
  print(f"üóëÔ∏è  Cancel queue item request received: item_id={item_id}")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # First check if this item was processing (not just pending)
    cursor = conn.cursor()
    cursor.execute(
      "SELECT status, model_id FROM generation_queue WHERE id = ?",
      (item_id,),
    )
    row = cursor.fetchone()
    was_processing = row and row[0] == "processing"
    cancelled_model_id = row[1] if row else None

    cancelled = cancel_queue_item_by_id(conn, item_id)

    if cancelled:
      print(f"‚úÖ Cancelled queue item {item_id}")

      # Only set the global cancellation flag if this was a PROCESSING item
      # Pending items just get marked as cancelled in the database
      if was_processing:
        generation_cancelled = True
        print("   ‚ö†Ô∏è  Item was processing, signaling cancellation")

        # Also remove this model from busy set so it can pick up new work
        if cancelled_model_id:
          with busy_models_lock:
            busy_models.discard(cancelled_model_id)

      return jsonify(
        {
          "success": True,
          "cancelled": True,
          "item_id": item_id,
          "message": f"Cancelled queue item {item_id}",
        }
      )
    else:
      print(f"‚ÑπÔ∏è  Queue item {item_id} not found or already completed")
      return jsonify(
        {
          "success": True,
          "cancelled": False,
          "item_id": item_id,
          "message": f"Queue item {item_id} not found or already completed",
        }
      )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


@app.route("/api/delete-render", methods=["POST"])
def api_delete_render():
  """API endpoint to delete render data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the render column (set to NULL) but keep the row
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET render = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted render data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


@app.route("/api/flag", methods=["POST"])
def api_flag():
  """API endpoint to flag/unflag selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Get flag value (default to True/1 for flagging, False/0 for unflagging)
  flag_value = 1 if data.get("flag", True) else 0

  conn = get_db_connection()

  try:
    # Ensure the flagged column exists
    ensure_flagged_column_exists(conn)

    flagged_count = 0
    for qx, qy in quadrants:
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET flagged = ?
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (flag_value, qx, qy),
      )
      if cursor.rowcount > 0:
        flagged_count += 1

    conn.commit()

    action = "Flagged" if flag_value else "Unflagged"
    return jsonify(
      {
        "success": True,
        "message": f"{action} {flagged_count} quadrant{'s' if flagged_count != 1 else ''}",
        "count": flagged_count,
        "flagged": bool(flag_value),
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


@app.route("/api/water", methods=["POST"])
def api_water():
  """API endpoint to mark/unmark selected quadrants as water tiles."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Get water value (default to True/1 for marking as water, False/0 for unmarking)
  water_value = 1 if data.get("is_water", True) else 0

  conn = get_db_connection()

  try:
    # Ensure the is_water column exists
    ensure_is_water_column_exists(conn)

    water_count = 0
    for qx, qy in quadrants:
      # First ensure the quadrant exists in the database
      cursor = conn.execute(
        "SELECT 1 FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
        (qx, qy),
      )
      if cursor.fetchone() is None:
        # Quadrant doesn't exist, skip it
        continue

      cursor = conn.execute(
        """
        UPDATE quadrants
        SET is_water = ?
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (water_value, qx, qy),
      )
      if cursor.rowcount > 0:
        water_count += 1

    conn.commit()

    action = "Marked as water" if water_value else "Unmarked as water"
    return jsonify(
      {
        "success": True,
        "message": f"{action}: {water_count} quadrant{'s' if water_count != 1 else ''}",
        "count": water_count,
        "is_water": bool(water_value),
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  # Parse optional prompt
  prompt = data.get("prompt")
  if prompt and not isinstance(prompt, str):
    return jsonify(
      {
        "success": False,
        "error": "prompt must be a string",
      }
    ), 400

  # Clean up prompt (strip whitespace, None if empty)
  if prompt:
    prompt = prompt.strip()
    if not prompt:
      prompt = None

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  if prompt:
    print(f"   Prompt: {prompt}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(
    selected_quadrants, "generate", model_id, context_quadrants, prompt
  )
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


def load_queued_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """
  Load all quadrants from pending and processing queue items.

  These quadrants are scheduled for generation and should be considered
  when planning new rectangles to avoid seam issues.
  """
  queued: set[Point] = set()

  # Get pending items
  pending_items = get_pending_queue(conn)
  for item in pending_items:
    if item.item_type == QueueItemType.GENERATE:
      for qx, qy in item.quadrants:
        queued.add(Point(qx, qy))

  # Get processing items
  processing_items = get_all_processing_items(conn)
  for item in processing_items:
    if item.item_type == QueueItemType.GENERATE:
      for qx, qy in item.quadrants:
        queued.add(Point(qx, qy))

  return queued


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants and pending/processing quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)
    queued = load_queued_quadrants(conn)

    if queued:
      print(f"   Considering {len(queued)} queued/processing quadrant(s) for seam avoidance")

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated, queued)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  cancel_queue_item_by_id,
  clear_completed_items,
  clear_pending_queue,
  get_all_processing_items,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def ensure_flagged_column_exists(conn: sqlite3.Connection) -> None:
  """Ensure the flagged column exists in the quadrants table (migration)."""
  cursor = conn.cursor()
  # Check if column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "flagged" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN flagged INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'flagged' column to quadrants table")


def ensure_is_water_column_exists(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table (migration)."""
  cursor = conn.cursor()
  # Check if column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


def get_quadrant_info(x: int, y: int, use_render: bool = False) -> dict:
  """
  Get info about a quadrant including whether it has data, is flagged, and water status.

  Water status values:
    -1: Explicitly NOT water (protected from auto-detection)
     0: Not water (auto-detected, can be changed)
     1: Water tile
  """
  conn = get_db_connection()
  try:
    # Ensure columns exist
    ensure_flagged_column_exists(conn)
    ensure_is_water_column_exists(conn)

    cursor = conn.cursor()
    column = "render" if use_render else "generation"
    cursor.execute(
      f"""
      SELECT {column} IS NOT NULL, COALESCE(flagged, 0), COALESCE(is_water, 0)
      FROM quadrants
      WHERE quadrant_x = ? AND quadrant_y = ?
      """,
      (x, y),
    )
    row = cursor.fetchone()
    if row:
      water_status = row[2]
      return {
        "has_data": bool(row[0]),
        "flagged": bool(row[1]),
        "is_water": water_status == 1,  # True if water
        "is_explicit_not_water": water_status == -1,  # True if explicitly not water
        "water_status": water_status,  # Raw value: -1, 0, or 1
      }
    return {
      "has_data": False,
      "flagged": False,
      "is_water": False,
      "is_explicit_not_water": False,
      "water_status": 0,
    }
  finally:
    conn.close()


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data, flagged status, and water status
  tiles = {}
  flagged_tiles = {}
  water_tiles = {}
  explicit_not_water_tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      info = get_quadrant_info(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = info["has_data"]
      flagged_tiles[(dx, dy)] = info["flagged"]
      water_tiles[(dx, dy)] = info["is_water"]
      explicit_not_water_tiles[(dx, dy)] = info["is_explicit_not_water"]

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    flagged_tiles=flagged_tiles,
    water_tiles=water_tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def calculate_context_quadrants(
  conn: sqlite3.Connection,
  selected_quadrants: list[tuple[int, int]],
) -> list[tuple[int, int]]:
  """
  Calculate context quadrants lazily at execution time.

  This determines which adjacent quadrants have existing generations
  that can provide context for the current generation.

  For a valid generation, we need at least a 2x2 block where all 4 quadrants
  are either being generated or already generated.

  Args:
    conn: Database connection
    selected_quadrants: The quadrants being generated

  Returns:
    List of quadrant coordinates that have existing generations and can
    provide context for the current generation.
  """
  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation as shared_get_quadrant_generation,
  )

  selected_set = set(selected_quadrants)
  context = []

  # Find all quadrants adjacent to the selection that have generations
  # Check all potential 2x2 blocks that include any selected quadrant
  checked = set()

  for qx, qy in selected_quadrants:
    # Check all neighbors that could form a 2x2 block with this quadrant
    # A quadrant can be in 4 different 2x2 blocks (as TL, TR, BL, BR corner)
    potential_context = [
      # Neighbors for 2x2 where (qx, qy) is top-left
      (qx + 1, qy),
      (qx, qy + 1),
      (qx + 1, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is top-right
      (qx - 1, qy),
      (qx - 1, qy + 1),
      (qx, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is bottom-left
      (qx, qy - 1),
      (qx + 1, qy - 1),
      (qx + 1, qy),
      # Neighbors for 2x2 where (qx, qy) is bottom-right
      (qx - 1, qy - 1),
      (qx, qy - 1),
      (qx - 1, qy),
    ]

    for nx, ny in potential_context:
      coord = (nx, ny)
      if coord in checked or coord in selected_set:
        continue
      checked.add(coord)

      # Check if this quadrant has an existing generation
      gen = shared_get_quadrant_generation(conn, nx, ny)
      if gen is not None:
        context.append(coord)

  return context


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.
    prompt: Optional additional prompt text for generation

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants, prompt
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None
    prompt = row[4]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]

    # Calculate context lazily if not explicitly provided
    # This ensures we use the most up-to-date context based on what's
    # actually generated at execution time (not queue time)
    if context_quadrants_raw:
      context_quadrants = [(q[0], q[1]) for q in context_quadrants_raw]
      print(
        f"   üìã Using explicit context from queue: {len(context_quadrants)} quadrant(s)"
      )
    else:
      # Calculate context lazily based on current generation state
      context_quadrants = calculate_context_quadrants(conn, selected_quadrants)
      if context_quadrants:
        print(f"   üìã Calculated lazy context: {len(context_quadrants)} quadrant(s)")
      else:
        print(
          "   üìã No context quadrants (2x2 self-contained or no adjacent generations)"
        )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    if prompt:
      print(f"   Prompt: {prompt}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      # Retry logic for generation - retry up to 3 times
      max_generation_retries = 3
      generation_retry_delay = 5.0  # seconds between generation retries

      for gen_attempt in range(1, max_generation_retries + 1):
        result = run_generation(
          conn, config, selected_quadrants, model_id, context_quadrants, prompt
        )

        if result["success"]:
          print(f"‚úÖ Generation complete: {result['message']}")
          generation_state["status"] = "complete"
          generation_state["message"] = result["message"]
          mark_item_complete(conn, item_id, result["message"])
          return result

        # Generation failed
        if gen_attempt < max_generation_retries:
          print(
            f"‚ö†Ô∏è  Generation failed (attempt {gen_attempt}/{max_generation_retries}): "
            f"{result['error']}"
          )
          print(f"‚è≥ Waiting {generation_retry_delay}s before retrying generation...")
          update_generation_state(
            "retrying",
            f"Generation failed, retrying (attempt {gen_attempt + 1}/{max_generation_retries})...",
          )
          time.sleep(generation_retry_delay)
        else:
          # All retries exhausted
          print(
            f"‚ùå Generation failed after {max_generation_retries} attempts: "
            f"{result['error']}"
          )
          generation_state["status"] = "error"
          generation_state["error"] = result["error"]
          mark_item_error(conn, item_id, result["error"])
          return result

      # Should not reach here, but just in case
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_models": model_status["processing_models"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
      # All quadrants being processed across all models
      "all_processing_quadrants": model_status["all_processing_quadrants"],
    }

    # Set is_generating based on whether any models are active
    response["is_generating"] = len(active_models) > 0

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/queue/cancel/<int:item_id>", methods=["POST"])
def api_cancel_queue_item(item_id: int):
  """
  API endpoint to cancel a specific queue item by its ID.

  Returns:
    {
      "success": true,
      "cancelled": true,
      "item_id": N,
      "message": "Cancelled queue item N"
    }
  """
  global generation_cancelled

  print(f"\n{'=' * 60}")
  print(f"üóëÔ∏è  Cancel queue item request received: item_id={item_id}")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # First check if this item was processing (not just pending)
    cursor = conn.cursor()
    cursor.execute(
      "SELECT status, model_id FROM generation_queue WHERE id = ?",
      (item_id,),
    )
    row = cursor.fetchone()
    was_processing = row and row[0] == "processing"
    cancelled_model_id = row[1] if row else None

    cancelled = cancel_queue_item_by_id(conn, item_id)

    if cancelled:
      print(f"‚úÖ Cancelled queue item {item_id}")

      # Only set the global cancellation flag if this was a PROCESSING item
      # Pending items just get marked as cancelled in the database
      if was_processing:
        generation_cancelled = True
        print("   ‚ö†Ô∏è  Item was processing, signaling cancellation")

        # Also remove this model from busy set so it can pick up new work
        if cancelled_model_id:
          with busy_models_lock:
            busy_models.discard(cancelled_model_id)

      return jsonify(
        {
          "success": True,
          "cancelled": True,
          "item_id": item_id,
          "message": f"Cancelled queue item {item_id}",
        }
      )
    else:
      print(f"‚ÑπÔ∏è  Queue item {item_id} not found or already completed")
      return jsonify(
        {
          "success": True,
          "cancelled": False,
          "item_id": item_id,
          "message": f"Queue item {item_id} not found or already completed",
        }
      )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


@app.route("/api/delete-render", methods=["POST"])
def api_delete_render():
  """API endpoint to delete render data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the render column (set to NULL) but keep the row
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET render = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted render data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


@app.route("/api/flag", methods=["POST"])
def api_flag():
  """API endpoint to flag/unflag selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Get flag value (default to True/1 for flagging, False/0 for unflagging)
  flag_value = 1 if data.get("flag", True) else 0

  conn = get_db_connection()

  try:
    # Ensure the flagged column exists
    ensure_flagged_column_exists(conn)

    flagged_count = 0
    for qx, qy in quadrants:
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET flagged = ?
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (flag_value, qx, qy),
      )
      if cursor.rowcount > 0:
        flagged_count += 1

    conn.commit()

    action = "Flagged" if flag_value else "Unflagged"
    return jsonify(
      {
        "success": True,
        "message": f"{action} {flagged_count} quadrant{'s' if flagged_count != 1 else ''}",
        "count": flagged_count,
        "flagged": bool(flag_value),
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


@app.route("/api/water", methods=["POST"])
def api_water():
  """API endpoint to mark/unmark selected quadrants as water tiles."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Get water value (default to True/1 for marking as water, False/0 for unmarking)
  water_value = 1 if data.get("is_water", True) else 0

  conn = get_db_connection()

  try:
    # Ensure the is_water column exists
    ensure_is_water_column_exists(conn)

    water_count = 0
    for qx, qy in quadrants:
      # First ensure the quadrant exists in the database
      cursor = conn.execute(
        "SELECT 1 FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
        (qx, qy),
      )
      if cursor.fetchone() is None:
        # Quadrant doesn't exist, skip it
        continue

      cursor = conn.execute(
        """
        UPDATE quadrants
        SET is_water = ?
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (water_value, qx, qy),
      )
      if cursor.rowcount > 0:
        water_count += 1

    conn.commit()

    action = "Marked as water" if water_value else "Unmarked as water"
    return jsonify(
      {
        "success": True,
        "message": f"{action}: {water_count} quadrant{'s' if water_count != 1 else ''}",
        "count": water_count,
        "is_water": bool(water_value),
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  # Parse optional prompt
  prompt = data.get("prompt")
  if prompt and not isinstance(prompt, str):
    return jsonify(
      {
        "success": False,
        "error": "prompt must be a string",
      }
    ), 400

  # Clean up prompt (strip whitespace, None if empty)
  if prompt:
    prompt = prompt.strip()
    if not prompt:
      prompt = None

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  if prompt:
    print(f"   Prompt: {prompt}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(
    selected_quadrants, "generate", model_id, context_quadrants, prompt
  )
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


def load_queued_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """
  Load all quadrants from pending and processing queue items.

  These quadrants are scheduled for generation and should be considered
  when planning new rectangles to avoid seam issues.
  """
  queued: set[Point] = set()

  # Get pending items
  pending_items = get_pending_queue(conn)
  for item in pending_items:
    if item.item_type == QueueItemType.GENERATE:
      for qx, qy in item.quadrants:
        queued.add(Point(qx, qy))

  # Get processing items
  processing_items = get_all_processing_items(conn)
  for item in processing_items:
    if item.item_type == QueueItemType.GENERATE:
      for qx, qy in item.quadrants:
        queued.add(Point(qx, qy))

  return queued


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants and pending/processing quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)
    queued = load_queued_quadrants(conn)

    if queued:
      print(f"   Considering {len(queued)} queued/processing quadrant(s) for seam avoidance")

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated, queued)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  cancel_queue_item_by_id,
  clear_completed_items,
  clear_pending_queue,
  get_all_processing_items,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def ensure_flagged_column_exists(conn: sqlite3.Connection) -> None:
  """Ensure the flagged column exists in the quadrants table (migration)."""
  cursor = conn.cursor()
  # Check if column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "flagged" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN flagged INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'flagged' column to quadrants table")


def ensure_is_water_column_exists(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table (migration)."""
  cursor = conn.cursor()
  # Check if column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


def get_quadrant_info(x: int, y: int, use_render: bool = False) -> dict:
  """
  Get info about a quadrant including whether it has data, is flagged, and water status.

  Water status values:
    -1: Explicitly NOT water (protected from auto-detection)
     0: Not water (auto-detected, can be changed)
     1: Water tile
  """
  conn = get_db_connection()
  try:
    # Ensure columns exist
    ensure_flagged_column_exists(conn)
    ensure_is_water_column_exists(conn)

    cursor = conn.cursor()
    column = "render" if use_render else "generation"
    cursor.execute(
      f"""
      SELECT {column} IS NOT NULL, COALESCE(flagged, 0), COALESCE(is_water, 0)
      FROM quadrants
      WHERE quadrant_x = ? AND quadrant_y = ?
      """,
      (x, y),
    )
    row = cursor.fetchone()
    if row:
      water_status = row[2]
      return {
        "has_data": bool(row[0]),
        "flagged": bool(row[1]),
        "is_water": water_status == 1,  # True if water
        "is_explicit_not_water": water_status == -1,  # True if explicitly not water
        "water_status": water_status,  # Raw value: -1, 0, or 1
      }
    return {
      "has_data": False,
      "flagged": False,
      "is_water": False,
      "is_explicit_not_water": False,
      "water_status": 0,
    }
  finally:
    conn.close()


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data, flagged status, and water status
  tiles = {}
  flagged_tiles = {}
  water_tiles = {}
  explicit_not_water_tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      info = get_quadrant_info(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = info["has_data"]
      flagged_tiles[(dx, dy)] = info["flagged"]
      water_tiles[(dx, dy)] = info["is_water"]
      explicit_not_water_tiles[(dx, dy)] = info["is_explicit_not_water"]

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    flagged_tiles=flagged_tiles,
    water_tiles=water_tiles,
    explicit_not_water_tiles=explicit_not_water_tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def calculate_context_quadrants(
  conn: sqlite3.Connection,
  selected_quadrants: list[tuple[int, int]],
) -> list[tuple[int, int]]:
  """
  Calculate context quadrants lazily at execution time.

  This determines which adjacent quadrants have existing generations
  that can provide context for the current generation.

  For a valid generation, we need at least a 2x2 block where all 4 quadrants
  are either being generated or already generated.

  Args:
    conn: Database connection
    selected_quadrants: The quadrants being generated

  Returns:
    List of quadrant coordinates that have existing generations and can
    provide context for the current generation.
  """
  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation as shared_get_quadrant_generation,
  )

  selected_set = set(selected_quadrants)
  context = []

  # Find all quadrants adjacent to the selection that have generations
  # Check all potential 2x2 blocks that include any selected quadrant
  checked = set()

  for qx, qy in selected_quadrants:
    # Check all neighbors that could form a 2x2 block with this quadrant
    # A quadrant can be in 4 different 2x2 blocks (as TL, TR, BL, BR corner)
    potential_context = [
      # Neighbors for 2x2 where (qx, qy) is top-left
      (qx + 1, qy),
      (qx, qy + 1),
      (qx + 1, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is top-right
      (qx - 1, qy),
      (qx - 1, qy + 1),
      (qx, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is bottom-left
      (qx, qy - 1),
      (qx + 1, qy - 1),
      (qx + 1, qy),
      # Neighbors for 2x2 where (qx, qy) is bottom-right
      (qx - 1, qy - 1),
      (qx, qy - 1),
      (qx - 1, qy),
    ]

    for nx, ny in potential_context:
      coord = (nx, ny)
      if coord in checked or coord in selected_set:
        continue
      checked.add(coord)

      # Check if this quadrant has an existing generation
      gen = shared_get_quadrant_generation(conn, nx, ny)
      if gen is not None:
        context.append(coord)

  return context


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.
    prompt: Optional additional prompt text for generation

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants, prompt
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None
    prompt = row[4]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]

    # Calculate context lazily if not explicitly provided
    # This ensures we use the most up-to-date context based on what's
    # actually generated at execution time (not queue time)
    if context_quadrants_raw:
      context_quadrants = [(q[0], q[1]) for q in context_quadrants_raw]
      print(
        f"   üìã Using explicit context from queue: {len(context_quadrants)} quadrant(s)"
      )
    else:
      # Calculate context lazily based on current generation state
      context_quadrants = calculate_context_quadrants(conn, selected_quadrants)
      if context_quadrants:
        print(f"   üìã Calculated lazy context: {len(context_quadrants)} quadrant(s)")
      else:
        print(
          "   üìã No context quadrants (2x2 self-contained or no adjacent generations)"
        )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    if prompt:
      print(f"   Prompt: {prompt}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      # Retry logic for generation - retry up to 3 times
      max_generation_retries = 3
      generation_retry_delay = 5.0  # seconds between generation retries

      for gen_attempt in range(1, max_generation_retries + 1):
        result = run_generation(
          conn, config, selected_quadrants, model_id, context_quadrants, prompt
        )

        if result["success"]:
          print(f"‚úÖ Generation complete: {result['message']}")
          generation_state["status"] = "complete"
          generation_state["message"] = result["message"]
          mark_item_complete(conn, item_id, result["message"])
          return result

        # Generation failed
        if gen_attempt < max_generation_retries:
          print(
            f"‚ö†Ô∏è  Generation failed (attempt {gen_attempt}/{max_generation_retries}): "
            f"{result['error']}"
          )
          print(f"‚è≥ Waiting {generation_retry_delay}s before retrying generation...")
          update_generation_state(
            "retrying",
            f"Generation failed, retrying (attempt {gen_attempt + 1}/{max_generation_retries})...",
          )
          time.sleep(generation_retry_delay)
        else:
          # All retries exhausted
          print(
            f"‚ùå Generation failed after {max_generation_retries} attempts: "
            f"{result['error']}"
          )
          generation_state["status"] = "error"
          generation_state["error"] = result["error"]
          mark_item_error(conn, item_id, result["error"])
          return result

      # Should not reach here, but just in case
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_models": model_status["processing_models"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
      # All quadrants being processed across all models
      "all_processing_quadrants": model_status["all_processing_quadrants"],
    }

    # Set is_generating based on whether any models are active
    response["is_generating"] = len(active_models) > 0

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/queue/cancel/<int:item_id>", methods=["POST"])
def api_cancel_queue_item(item_id: int):
  """
  API endpoint to cancel a specific queue item by its ID.

  Returns:
    {
      "success": true,
      "cancelled": true,
      "item_id": N,
      "message": "Cancelled queue item N"
    }
  """
  global generation_cancelled

  print(f"\n{'=' * 60}")
  print(f"üóëÔ∏è  Cancel queue item request received: item_id={item_id}")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # First check if this item was processing (not just pending)
    cursor = conn.cursor()
    cursor.execute(
      "SELECT status, model_id FROM generation_queue WHERE id = ?",
      (item_id,),
    )
    row = cursor.fetchone()
    was_processing = row and row[0] == "processing"
    cancelled_model_id = row[1] if row else None

    cancelled = cancel_queue_item_by_id(conn, item_id)

    if cancelled:
      print(f"‚úÖ Cancelled queue item {item_id}")

      # Only set the global cancellation flag if this was a PROCESSING item
      # Pending items just get marked as cancelled in the database
      if was_processing:
        generation_cancelled = True
        print("   ‚ö†Ô∏è  Item was processing, signaling cancellation")

        # Also remove this model from busy set so it can pick up new work
        if cancelled_model_id:
          with busy_models_lock:
            busy_models.discard(cancelled_model_id)

      return jsonify(
        {
          "success": True,
          "cancelled": True,
          "item_id": item_id,
          "message": f"Cancelled queue item {item_id}",
        }
      )
    else:
      print(f"‚ÑπÔ∏è  Queue item {item_id} not found or already completed")
      return jsonify(
        {
          "success": True,
          "cancelled": False,
          "item_id": item_id,
          "message": f"Queue item {item_id} not found or already completed",
        }
      )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


@app.route("/api/delete-render", methods=["POST"])
def api_delete_render():
  """API endpoint to delete render data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the render column (set to NULL) but keep the row
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET render = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted render data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


@app.route("/api/flag", methods=["POST"])
def api_flag():
  """API endpoint to flag/unflag selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Get flag value (default to True/1 for flagging, False/0 for unflagging)
  flag_value = 1 if data.get("flag", True) else 0

  conn = get_db_connection()

  try:
    # Ensure the flagged column exists
    ensure_flagged_column_exists(conn)

    flagged_count = 0
    for qx, qy in quadrants:
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET flagged = ?
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (flag_value, qx, qy),
      )
      if cursor.rowcount > 0:
        flagged_count += 1

    conn.commit()

    action = "Flagged" if flag_value else "Unflagged"
    return jsonify(
      {
        "success": True,
        "message": f"{action} {flagged_count} quadrant{'s' if flagged_count != 1 else ''}",
        "count": flagged_count,
        "flagged": bool(flag_value),
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


@app.route("/api/water", methods=["POST"])
def api_water():
  """API endpoint to mark/unmark selected quadrants as water tiles."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Get water value (default to True/1 for marking as water, False/0 for unmarking)
  water_value = 1 if data.get("is_water", True) else 0

  conn = get_db_connection()

  try:
    # Ensure the is_water column exists
    ensure_is_water_column_exists(conn)

    water_count = 0
    for qx, qy in quadrants:
      # First ensure the quadrant exists in the database
      cursor = conn.execute(
        "SELECT 1 FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
        (qx, qy),
      )
      if cursor.fetchone() is None:
        # Quadrant doesn't exist, skip it
        continue

      cursor = conn.execute(
        """
        UPDATE quadrants
        SET is_water = ?
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (water_value, qx, qy),
      )
      if cursor.rowcount > 0:
        water_count += 1

    conn.commit()

    action = "Marked as water" if water_value else "Unmarked as water"
    return jsonify(
      {
        "success": True,
        "message": f"{action}: {water_count} quadrant{'s' if water_count != 1 else ''}",
        "count": water_count,
        "is_water": bool(water_value),
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  # Parse optional prompt
  prompt = data.get("prompt")
  if prompt and not isinstance(prompt, str):
    return jsonify(
      {
        "success": False,
        "error": "prompt must be a string",
      }
    ), 400

  # Clean up prompt (strip whitespace, None if empty)
  if prompt:
    prompt = prompt.strip()
    if not prompt:
      prompt = None

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  if prompt:
    print(f"   Prompt: {prompt}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(
    selected_quadrants, "generate", model_id, context_quadrants, prompt
  )
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


def load_queued_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """
  Load all quadrants from pending and processing queue items.

  These quadrants are scheduled for generation and should be considered
  when planning new rectangles to avoid seam issues.
  """
  queued: set[Point] = set()

  # Get pending items
  pending_items = get_pending_queue(conn)
  for item in pending_items:
    if item.item_type == QueueItemType.GENERATE:
      for qx, qy in item.quadrants:
        queued.add(Point(qx, qy))

  # Get processing items
  processing_items = get_all_processing_items(conn)
  for item in processing_items:
    if item.item_type == QueueItemType.GENERATE:
      for qx, qy in item.quadrants:
        queued.add(Point(qx, qy))

  return queued


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants and pending/processing quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)
    queued = load_queued_quadrants(conn)

    if queued:
      print(f"   Considering {len(queued)} queued/processing quadrant(s) for seam avoidance")

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated, queued)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  cancel_queue_item_by_id,
  clear_completed_items,
  clear_pending_queue,
  get_all_processing_items,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def ensure_flagged_column_exists(conn: sqlite3.Connection) -> None:
  """Ensure the flagged column exists in the quadrants table (migration)."""
  cursor = conn.cursor()
  # Check if column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "flagged" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN flagged INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'flagged' column to quadrants table")


def ensure_is_water_column_exists(conn: sqlite3.Connection) -> None:
  """Ensure the is_water column exists in the quadrants table (migration)."""
  cursor = conn.cursor()
  # Check if column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "is_water" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN is_water INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'is_water' column to quadrants table")


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


def get_quadrant_info(x: int, y: int, use_render: bool = False) -> dict:
  """
  Get info about a quadrant including whether it has data, is flagged, and water status.

  Water status values:
    -1: Explicitly NOT water (protected from auto-detection)
     0: Not water (auto-detected, can be changed)
     1: Water tile
  """
  conn = get_db_connection()
  try:
    # Ensure columns exist
    ensure_flagged_column_exists(conn)
    ensure_is_water_column_exists(conn)

    cursor = conn.cursor()
    column = "render" if use_render else "generation"
    cursor.execute(
      f"""
      SELECT {column} IS NOT NULL, COALESCE(flagged, 0), COALESCE(is_water, 0)
      FROM quadrants
      WHERE quadrant_x = ? AND quadrant_y = ?
      """,
      (x, y),
    )
    row = cursor.fetchone()
    if row:
      water_status = row[2]
      return {
        "has_data": bool(row[0]),
        "flagged": bool(row[1]),
        "is_water": water_status == 1,  # True if water
        "is_explicit_not_water": water_status == -1,  # True if explicitly not water
        "water_status": water_status,  # Raw value: -1, 0, or 1
      }
    return {
      "has_data": False,
      "flagged": False,
      "is_water": False,
      "is_explicit_not_water": False,
      "water_status": 0,
    }
  finally:
    conn.close()


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data, flagged status, and water status
  tiles = {}
  flagged_tiles = {}
  water_tiles = {}
  explicit_not_water_tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      info = get_quadrant_info(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = info["has_data"]
      flagged_tiles[(dx, dy)] = info["flagged"]
      water_tiles[(dx, dy)] = info["is_water"]
      explicit_not_water_tiles[(dx, dy)] = info["is_explicit_not_water"]

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    flagged_tiles=flagged_tiles,
    water_tiles=water_tiles,
    explicit_not_water_tiles=explicit_not_water_tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def calculate_context_quadrants(
  conn: sqlite3.Connection,
  selected_quadrants: list[tuple[int, int]],
) -> list[tuple[int, int]]:
  """
  Calculate context quadrants lazily at execution time.

  This determines which adjacent quadrants have existing generations
  that can provide context for the current generation.

  For a valid generation, we need at least a 2x2 block where all 4 quadrants
  are either being generated or already generated.

  Args:
    conn: Database connection
    selected_quadrants: The quadrants being generated

  Returns:
    List of quadrant coordinates that have existing generations and can
    provide context for the current generation.
  """
  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation as shared_get_quadrant_generation,
  )

  selected_set = set(selected_quadrants)
  context = []

  # Find all quadrants adjacent to the selection that have generations
  # Check all potential 2x2 blocks that include any selected quadrant
  checked = set()

  for qx, qy in selected_quadrants:
    # Check all neighbors that could form a 2x2 block with this quadrant
    # A quadrant can be in 4 different 2x2 blocks (as TL, TR, BL, BR corner)
    potential_context = [
      # Neighbors for 2x2 where (qx, qy) is top-left
      (qx + 1, qy),
      (qx, qy + 1),
      (qx + 1, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is top-right
      (qx - 1, qy),
      (qx - 1, qy + 1),
      (qx, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is bottom-left
      (qx, qy - 1),
      (qx + 1, qy - 1),
      (qx + 1, qy),
      # Neighbors for 2x2 where (qx, qy) is bottom-right
      (qx - 1, qy - 1),
      (qx, qy - 1),
      (qx - 1, qy),
    ]

    for nx, ny in potential_context:
      coord = (nx, ny)
      if coord in checked or coord in selected_set:
        continue
      checked.add(coord)

      # Check if this quadrant has an existing generation
      gen = shared_get_quadrant_generation(conn, nx, ny)
      if gen is not None:
        context.append(coord)

  return context


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.
    prompt: Optional additional prompt text for generation

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants, prompt
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None
    prompt = row[4]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]

    # Calculate context lazily if not explicitly provided
    # This ensures we use the most up-to-date context based on what's
    # actually generated at execution time (not queue time)
    if context_quadrants_raw:
      context_quadrants = [(q[0], q[1]) for q in context_quadrants_raw]
      print(
        f"   üìã Using explicit context from queue: {len(context_quadrants)} quadrant(s)"
      )
    else:
      # Calculate context lazily based on current generation state
      context_quadrants = calculate_context_quadrants(conn, selected_quadrants)
      if context_quadrants:
        print(f"   üìã Calculated lazy context: {len(context_quadrants)} quadrant(s)")
      else:
        print(
          "   üìã No context quadrants (2x2 self-contained or no adjacent generations)"
        )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    if prompt:
      print(f"   Prompt: {prompt}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      # Retry logic for generation - retry up to 3 times
      max_generation_retries = 3
      generation_retry_delay = 5.0  # seconds between generation retries

      for gen_attempt in range(1, max_generation_retries + 1):
        result = run_generation(
          conn, config, selected_quadrants, model_id, context_quadrants, prompt
        )

        if result["success"]:
          print(f"‚úÖ Generation complete: {result['message']}")
          generation_state["status"] = "complete"
          generation_state["message"] = result["message"]
          mark_item_complete(conn, item_id, result["message"])
          return result

        # Generation failed
        if gen_attempt < max_generation_retries:
          print(
            f"‚ö†Ô∏è  Generation failed (attempt {gen_attempt}/{max_generation_retries}): "
            f"{result['error']}"
          )
          print(f"‚è≥ Waiting {generation_retry_delay}s before retrying generation...")
          update_generation_state(
            "retrying",
            f"Generation failed, retrying (attempt {gen_attempt + 1}/{max_generation_retries})...",
          )
          time.sleep(generation_retry_delay)
        else:
          # All retries exhausted
          print(
            f"‚ùå Generation failed after {max_generation_retries} attempts: "
            f"{result['error']}"
          )
          generation_state["status"] = "error"
          generation_state["error"] = result["error"]
          mark_item_error(conn, item_id, result["error"])
          return result

      # Should not reach here, but just in case
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_models": model_status["processing_models"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
      # All quadrants being processed across all models
      "all_processing_quadrants": model_status["all_processing_quadrants"],
    }

    # Set is_generating based on whether any models are active
    response["is_generating"] = len(active_models) > 0

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/queue/cancel/<int:item_id>", methods=["POST"])
def api_cancel_queue_item(item_id: int):
  """
  API endpoint to cancel a specific queue item by its ID.

  Returns:
    {
      "success": true,
      "cancelled": true,
      "item_id": N,
      "message": "Cancelled queue item N"
    }
  """
  global generation_cancelled

  print(f"\n{'=' * 60}")
  print(f"üóëÔ∏è  Cancel queue item request received: item_id={item_id}")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # First check if this item was processing (not just pending)
    cursor = conn.cursor()
    cursor.execute(
      "SELECT status, model_id FROM generation_queue WHERE id = ?",
      (item_id,),
    )
    row = cursor.fetchone()
    was_processing = row and row[0] == "processing"
    cancelled_model_id = row[1] if row else None

    cancelled = cancel_queue_item_by_id(conn, item_id)

    if cancelled:
      print(f"‚úÖ Cancelled queue item {item_id}")

      # Only set the global cancellation flag if this was a PROCESSING item
      # Pending items just get marked as cancelled in the database
      if was_processing:
        generation_cancelled = True
        print("   ‚ö†Ô∏è  Item was processing, signaling cancellation")

        # Also remove this model from busy set so it can pick up new work
        if cancelled_model_id:
          with busy_models_lock:
            busy_models.discard(cancelled_model_id)

      return jsonify(
        {
          "success": True,
          "cancelled": True,
          "item_id": item_id,
          "message": f"Cancelled queue item {item_id}",
        }
      )
    else:
      print(f"‚ÑπÔ∏è  Queue item {item_id} not found or already completed")
      return jsonify(
        {
          "success": True,
          "cancelled": False,
          "item_id": item_id,
          "message": f"Queue item {item_id} not found or already completed",
        }
      )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


@app.route("/api/delete-render", methods=["POST"])
def api_delete_render():
  """API endpoint to delete render data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the render column (set to NULL) but keep the row
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET render = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted render data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


@app.route("/api/flag", methods=["POST"])
def api_flag():
  """API endpoint to flag/unflag selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Get flag value (default to True/1 for flagging, False/0 for unflagging)
  flag_value = 1 if data.get("flag", True) else 0

  conn = get_db_connection()

  try:
    # Ensure the flagged column exists
    ensure_flagged_column_exists(conn)

    flagged_count = 0
    for qx, qy in quadrants:
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET flagged = ?
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (flag_value, qx, qy),
      )
      if cursor.rowcount > 0:
        flagged_count += 1

    conn.commit()

    action = "Flagged" if flag_value else "Unflagged"
    return jsonify(
      {
        "success": True,
        "message": f"{action} {flagged_count} quadrant{'s' if flagged_count != 1 else ''}",
        "count": flagged_count,
        "flagged": bool(flag_value),
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


@app.route("/api/water", methods=["POST"])
def api_water():
  """
  API endpoint to mark/unmark selected quadrants as water tiles.

  Water status values:
    -1: Explicitly NOT water (protected from auto-detection)
     0: Not water (auto-detected, can be changed by script)
     1: Water tile

  Request body:
    {
      "quadrants": [[x, y], ...],
      "is_water": true/false,  // true=water(1), false=not water(0)
      "explicit_not_water": true  // Optional: if true, sets to -1 (protected)
    }
  """
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Determine water value:
  # - explicit_not_water=true ‚Üí -1 (protected from auto-detection)
  # - is_water=true ‚Üí 1 (water)
  # - is_water=false ‚Üí 0 (not water, can be auto-changed)
  if data.get("explicit_not_water", False):
    water_value = -1
    action = "Marked as explicitly NOT water (protected)"
  elif data.get("is_water", True):
    water_value = 1
    action = "Marked as water"
  else:
    water_value = 0
    action = "Unmarked as water"

  conn = get_db_connection()

  try:
    # Ensure the is_water column exists
    ensure_is_water_column_exists(conn)

    water_count = 0
    for qx, qy in quadrants:
      # First ensure the quadrant exists in the database
      cursor = conn.execute(
        "SELECT 1 FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
        (qx, qy),
      )
      if cursor.fetchone() is None:
        # Quadrant doesn't exist, skip it
        continue

      cursor = conn.execute(
        """
        UPDATE quadrants
        SET is_water = ?
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (water_value, qx, qy),
      )
      if cursor.rowcount > 0:
        water_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"{action}: {water_count} quadrant{'s' if water_count != 1 else ''}",
        "count": water_count,
        "water_status": water_value,
        "is_water": water_value == 1,
        "is_explicit_not_water": water_value == -1,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  # Parse optional prompt
  prompt = data.get("prompt")
  if prompt and not isinstance(prompt, str):
    return jsonify(
      {
        "success": False,
        "error": "prompt must be a string",
      }
    ), 400

  # Clean up prompt (strip whitespace, None if empty)
  if prompt:
    prompt = prompt.strip()
    if not prompt:
      prompt = None

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  if prompt:
    print(f"   Prompt: {prompt}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(
    selected_quadrants, "generate", model_id, context_quadrants, prompt
  )
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


def load_queued_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """
  Load all quadrants from pending and processing queue items.

  These quadrants are scheduled for generation and should be considered
  when planning new rectangles to avoid seam issues.
  """
  queued: set[Point] = set()

  # Get pending items
  pending_items = get_pending_queue(conn)
  for item in pending_items:
    if item.item_type == QueueItemType.GENERATE:
      for qx, qy in item.quadrants:
        queued.add(Point(qx, qy))

  # Get processing items
  processing_items = get_all_processing_items(conn)
  for item in processing_items:
    if item.item_type == QueueItemType.GENERATE:
      for qx, qy in item.quadrants:
        queued.add(Point(qx, qy))

  return queued


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants and pending/processing quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)
    queued = load_queued_quadrants(conn)

    if queued:
      print(f"   Considering {len(queued)} queued/processing quadrant(s) for seam avoidance")

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated, queued)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

Now let me update the viewer template to handle the new state:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Generated Tiles Viewer</title>
    <link rel="stylesheet" href="/static/viewer.css" />
    <style>
      /* Dynamic grid sizing based on template variables */
      .grid {
        grid-template-columns: repeat({{ nx }}, {{ size_px }}px);
        grid-auto-rows: {{ size_px }}px;
      }
      .tile.placeholder {
        min-width: {{ size_px }}px;
        min-height: {{ size_px }}px;
      }
    </style>
  </head>
  <body>
    <!-- Config data for JS -->
    <script
      id="app-config"
      type="application/json"
      data-config='{"x": {{ x }}, "y": {{ y }}, "nx": {{ nx }}, "ny": {{ ny }}, "size_px": {{ size_px }}, "models": {{ models_config | safe }}, "default_model_id": "{{ default_model_id }}"}'
    ></script>

    <!-- Toast notification container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Fixed toolbar -->
    <div class="toolbar">
      <div class="toolbar-row toolbar-row-nav">
        <div class="controls">
          <label>X: <input type="number" id="x" value="{{ x }}" /></label>
          <label>Y: <input type="number" id="y" value="{{ y }}" /></label>
          <label
            >NX: <input type="number" id="nx" value="{{ nx }}" min="1" max="20"
          /></label>
          <label
            >NY: <input type="number" id="ny" value="{{ ny }}" min="1" max="20"
          /></label>
          <label
            >Size:
            <input type="number" id="sizePx" value="{{ size_px }}" step="32"
          /></label>
          <button onclick="goTo()">Go</button>
          <div class="toggle-group">
            <label
              ><input
                type="checkbox"
                id="showLines"
                {%
                if
                show_lines
                %}checked{%
                endif
                %}
                onchange="toggleLines()"
              />
              Lines</label
            >
            <label
              ><input
                type="checkbox"
                id="showCoords"
                {%
                if
                show_coords
                %}checked{%
                endif
                %}
                onchange="toggleCoords()"
              />
              Coords</label
            >
            <label
              ><input
                type="checkbox"
                id="showRender"
                {%
                if
                show_render
                %}checked{%
                endif
                %}
                onchange="toggleRender()"
              />
              Renders</label
            >
            <label
              ><input
                type="checkbox"
                id="showWater"
                onchange="toggleWaterHighlight()"
              />
              üíß Water</label
            >
          </div>
          <div class="toggle-group model-group">
            <label class="model-label"
              >Model:
              <select id="modelSelect" class="model-select">
                <!-- Populated by JavaScript -->
              </select>
            </label>
          </div>
        </div>
        <div class="toolbar-info">
          <span>({{ x }}, {{ y }}) ‚Üí ({{ x + nx - 1 }}, {{ y + ny - 1 }})</span>
          <span id="selectedQuadrantsDisplay" class="selected-quadrants"></span>
          <span class="generation-dir-info">{{ generation_dir }}</span>
        </div>
      </div>
      <div class="toolbar-row toolbar-row-tools">
        <div class="tools-group">
          <span class="tools-label">Tools:</span>
          <button
            id="selectTool"
            class="tool-btn"
            onclick="toggleSelectTool()"
            title="Select quadrants (S)"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path>
              <path d="M13 13l6 6"></path>
            </svg>
            Select
          </button>
          <button
            id="fixWaterTool"
            class="tool-btn"
            onclick="toggleFixWaterTool()"
            title="Fix water color (W)"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
            </svg>
            Fix Water
          </button>
          <button
            id="waterFillTool"
            class="tool-btn"
            onclick="toggleWaterFillTool()"
            title="Fill quadrant with water (F)"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <rect x="3" y="3" width="18" height="18" rx="2"></rect>
              <path d="M12 8v8"></path>
              <path d="M8 12h8"></path>
            </svg>
            Water Fill
          </button>
          <button
            id="waterSelectTool"
            class="tool-btn"
            onclick="toggleWaterSelectTool()"
            title="Mark quadrants as water tiles (T)"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
              <path d="M12 12v4"></path>
              <circle cx="12" cy="18" r="1"></circle>
            </svg>
            Water Select
          </button>
        </div>
        <div class="toolbar-divider"></div>
        <div class="actions-group">
          <button
            id="deselectAllBtn"
            class="action-btn deselect-btn"
            onclick="deselectAll()"
            disabled
          >
            Deselect
          </button>
          <button
            id="deleteBtn"
            class="action-btn delete-btn"
            onclick="deleteSelected()"
            disabled
            title="Delete data (generation or render based on current view)"
          >
            Delete
          </button>
          <button
            id="flagBtn"
            class="action-btn flag-btn"
            onclick="flagSelected()"
            disabled
            title="Flag selected quadrants for review"
          >
            üö© Flag
          </button>
          <button
            id="renderBtn"
            class="action-btn render-btn"
            onclick="renderSelected()"
            disabled
          >
            Render
          </button>
          <button
            id="generateBtn"
            class="action-btn generate-btn"
            onclick="generateSelected()"
            disabled
          >
            Generate
          </button>
          <button
            id="generateWithPromptBtn"
            class="action-btn generate-prompt-btn"
            onclick="showPromptDialog()"
            disabled
            title="Generate with additional prompt text"
          >
            + Prompt
          </button>
          <button
            id="generateRectBtn"
            class="action-btn generate-rect-btn"
            onclick="generateRectangle()"
            disabled
            title="Select exactly 2 quadrants to define rectangle corners"
          >
            Gen Rect
          </button>
          <button
            id="exportCmdBtn"
            class="action-btn export-cmd-btn"
            onclick="copyExportCommand()"
            disabled
            title="Copy export command to clipboard (select 2 quadrants)"
          >
            Export Cmd
          </button>
        </div>
        <div class="toolbar-divider"></div>
        <div class="utility-group">
          <button
            id="clearQueueBtn"
            class="utility-btn clear-queue-btn"
            onclick="clearQueue()"
            title="Clear all pending items from the generation queue"
          >
            Clear Queue
          </button>
          <button
            id="hardRefreshBtn"
            class="utility-btn hard-refresh-btn"
            onclick="hardRefresh()"
            title="Clear image cache and reload page"
          >
            ‚Üª Refresh
          </button>
        </div>
      </div>
      <div class="toolbar-row toolbar-row-status" id="selectionStatus">
        <span id="selectionCount"></span>
      </div>
      <div class="water-fix-status" id="waterFixStatus" style="display: none">
        <span class="water-fix-label">Target Color:</span>
        <span class="color-swatch" id="targetColorSwatch"></span>
        <span class="color-hex" id="targetColorHex"
          >Click a quadrant to pick color</span
        >
        <span class="water-fix-quadrant" id="waterFixQuadrant"></span>
        <button
          id="applyWaterFixBtn"
          class="apply-water-fix-btn"
          onclick="applyWaterFix()"
          disabled
        >
          Apply Fix
        </button>
        <button
          id="cancelWaterFixBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFix()"
        >
          Cancel
        </button>
      </div>
      <div class="water-fill-status" id="waterFillStatus" style="display: none">
        <span class="water-fill-label">Water Fill:</span>
        <span class="color-swatch water-color-preview"></span>
        <span class="water-fill-instruction" id="waterFillInstruction"
          >Click a quadrant to fill with water</span
        >
        <button
          id="cancelWaterFillBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFill()"
        >
          Cancel
        </button>
      </div>
      <div
        class="water-select-status"
        id="waterSelectStatus"
        style="display: none"
      >
        <span class="water-select-label">üíß Water Select:</span>
        <span class="water-select-instruction" id="waterSelectInstruction"
          >Click quadrants to toggle water status</span
        >
        <button
          id="cancelWaterSelectBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterSelect()"
        >
          Cancel
        </button>
      </div>
    </div>

    <div
      class="grid-container {% if show_lines %}show-lines{% endif %} {% if show_coords %}show-coords{% endif %}"
      id="gridContainer"
    >
      <div class="grid">
        {% for dy in range(ny) %} {% for dx in range(nx) %} {% set qx = x + dx
        %} {% set qy = y + dy %} {% set has_gen = tiles.get((dx, dy), False) %}
        {% set is_flagged = flagged_tiles.get((dx, dy), False) %} {% set
        is_water = water_tiles.get((dx, dy), False) %} {% set
        is_explicit_not_water = explicit_not_water_tiles.get((dx, dy), False) %}
        <div
          class="tile {% if not has_gen %}placeholder{% endif %}{% if is_flagged %} flagged{% endif %}{% if is_water %} water{% endif %}{% if is_explicit_not_water %} explicit-not-water{% endif %}"
          data-coords="{{ qx }},{{ qy }}"
          data-flagged="{{ 'true' if is_flagged else 'false' }}"
          data-water="{{ 'true' if is_water else 'false' }}"
          data-explicit-not-water="{{ 'true' if is_explicit_not_water else 'false' }}"
        >
          <span class="coords">({{ qx }}, {{ qy }})</span>
          {% if has_gen %}
          <img
            src="/tile/{{ qx }}/{{ qy }}?render={{ '1' if show_render else '0' }}"
            alt="Tile {{ qx }},{{ qy }}"
          />
          {% endif %} {% if is_water %}
          <span class="water-indicator" title="Water tile">üíß</span>
          {% endif %} {% if is_explicit_not_water %}
          <span class="explicit-not-water-indicator" title="Explicitly NOT water (protected)">üö´</span>
          {% endif %}
        </div>
        {% endfor %} {% endfor %}
      </div>
    </div>

    <!-- Prompt Dialog -->
    <div id="promptDialog" class="dialog-overlay" style="display: none">
      <div class="dialog-content">
        <h3>Generate with Prompt</h3>
        <p class="dialog-description">
          Add additional instructions for the generation:
        </p>
        <textarea
          id="promptInput"
          class="prompt-input"
          placeholder="e.g., 'Add more trees' or 'Make the water darker'"
          rows="3"
        ></textarea>
        <div class="dialog-buttons">
          <button class="dialog-cancel-btn" onclick="hidePromptDialog()">
            Cancel
          </button>
          <button class="dialog-submit-btn" onclick="submitPromptGeneration()">
            Generate
          </button>
        </div>
      </div>
    </div>

    <script src="/static/viewer.js"></script>
  </body>
</html>

```

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
  font-size: 12px;
  background: #1a1a2e;
  color: #eee;
  min-height: 100vh;
  padding: 15px;
  padding-top: 130px; /* Space for fixed toolbar with three rows */
}

.toolbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: #1a1a2e;
  padding: 10px 15px;
  z-index: 100;
  border-bottom: 1px solid #333;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.toolbar-row {
  display: flex;
  align-items: center;
  gap: 15px;
  flex-wrap: wrap;
}

.toolbar-row-nav {
  padding-bottom: 6px;
}

.toolbar-row-tools {
  padding-top: 6px;
  border-top: 1px solid #333;
  gap: 10px;
}

.toolbar-divider {
  width: 1px;
  height: 20px;
  background: #444;
  margin: 0 4px;
}

.actions-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.utility-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.toolbar-row-status {
  padding-top: 6px;
  border-top: 1px solid #333;
  font-size: 0.7rem;
  color: #888;
  min-height: 18px;
}

.toolbar-row-status.generating {
  color: #a855f7;
}

/* Action button base styles */
.action-btn {
  padding: 4px 8px;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  font-weight: 500;
  transition: all 0.2s;
}

.action-btn:disabled {
  background: #333 !important;
  color: #555 !important;
  cursor: not-allowed;
}

/* Utility button base styles */
.utility-btn {
  padding: 4px 8px;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  font-weight: 500;
  transition: all 0.2s;
}

.toolbar-info {
  color: #666;
  font-size: 0.75rem;
  margin-left: auto;
}

.toolbar-info span + span {
  margin-left: 12px;
}

.toolbar-info .selected-quadrants {
  color: #00d9ff;
  font-weight: bold;
}

.toolbar-info .generation-dir-info {
  display: none; /* Hide the long path on the nav row */
}

.controls {
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
}

.controls label {
  color: #888;
  font-size: 0.8rem;
}

.controls input[type="number"] {
  width: 50px;
  padding: 5px 6px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #16213e;
  color: #fff;
  font-family: inherit;
  font-size: 0.8rem;
}

.controls button {
  padding: 5px 12px;
  background: #00d9ff;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.75rem;
  font-weight: bold;
}

.controls button:hover {
  background: #00b8d4;
}

.toggle-group {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-left: 8px;
  padding-left: 12px;
  border-left: 1px solid #333;
}

.toggle-group label {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  user-select: none;
  font-size: 0.75rem;
}

.toggle-group input[type="checkbox"] {
  width: 14px;
  height: 14px;
  accent-color: #00d9ff;
  cursor: pointer;
}

.grid-container {
  display: inline-block;
  border-radius: 8px;
  overflow: hidden;
}

.grid-container.show-lines {
  border: 2px solid #333;
}

.grid {
  display: grid;
  background: #333;
}

.grid-container.show-lines .grid {
  gap: 2px;
}

.grid-container:not(.show-lines) .grid {
  gap: 0;
  background: transparent;
}

.grid-container:not(.show-lines) {
  border: none;
}

.tile {
  position: relative;
  background: #2a2a4a;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tile img {
  display: block;
  max-width: 100%;
  height: auto;
}

.tile.placeholder {
  background: #3a3a5a;
}

.tile .coords {
  position: absolute;
  top: 6px;
  left: 6px;
  background: rgba(0, 0, 0, 0.7);
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 0.65rem;
  color: #00d9ff;
  transition: opacity 0.2s;
}

.tile.placeholder .coords {
  color: #666;
}

.grid-container:not(.show-coords) .tile .coords {
  opacity: 0;
}

/* Tool button styles */
.tools-group {
  display: flex;
  align-items: center;
  gap: 8px;
  border-left: none;
  margin-left: 0;
  padding-left: 0;
}

.tools-label {
  color: #666;
  font-size: 0.7rem;
  margin-right: 4px;
}

.tool-btn {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: #2a2a3e;
  color: #666;
  border: 1px solid #444;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  transition: all 0.15s ease;
}

.tool-btn:hover {
  background: #3a3a4e;
  color: #999;
  border-color: #555;
}

.tool-btn.active {
  background: #10b981;
  color: #fff;
  border-color: #10b981;
  box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
}

.tool-btn.active:hover {
  background: #059669;
  border-color: #059669;
}

.tool-btn svg {
  width: 12px;
  height: 12px;
}

/* Selection styles */
.tile.selected {
  outline: 3px solid #ff3333;
  outline-offset: -3px;
  z-index: 10;
}

.grid-container.show-lines .tile.selected {
  outline-color: #ff3333;
}

.tile.selectable {
  cursor: pointer;
}

.tile.placeholder.selected {
  background: rgba(255, 51, 51, 0.15);
}

/* Flagged tile styles */
.tile.flagged {
  position: relative;
}

.tile.flagged::before {
  content: "üö©";
  position: absolute;
  top: 4px;
  right: 4px;
  font-size: 16px;
  z-index: 20;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
  pointer-events: none;
}

.tile.flagged::after {
  content: "";
  position: absolute;
  inset: 0;
  border: 2px solid #f97316;
  pointer-events: none;
  z-index: 5;
}

/* Locked tiles (during generation) */
.tile.locked {
  outline: 3px solid #a855f7;
  outline-offset: -3px;
  z-index: 10;
}

.grid-container.show-lines .tile.locked {
  outline-color: #a855f7;
}

.tile.placeholder.locked {
  background: rgba(168, 85, 247, 0.2);
}

/* Queued tiles (in queue, waiting to be generated) */
.tile.queued {
  outline: 3px dashed #c084fc !important;
  outline-offset: -3px;
  z-index: 9;
  animation: pulse-queue 1.5s ease-in-out infinite;
  /* Fallback: box-shadow for browsers that don't render dashed outlines well */
  box-shadow: inset 0 0 0 3px rgba(192, 132, 252, 0.5);
}

@keyframes pulse-queue {
  0%,
  100% {
    outline-color: #c084fc;
    box-shadow: inset 0 0 0 3px rgba(192, 132, 252, 0.5);
  }
  50% {
    outline-color: #8b5cf6;
    box-shadow: inset 0 0 0 3px rgba(139, 92, 246, 0.7);
  }
}

.grid-container.show-lines .tile.queued {
  outline-color: #c084fc;
}

.tile.placeholder.queued {
  background: rgba(168, 85, 247, 0.3) !important;
}

/* Allow selection while generating - only disable clicking on locked/queued tiles */
body.generating .tile.locked.selectable,
body.generating .tile.queued.selectable {
  cursor: not-allowed;
}

/* Selection status styles moved to .toolbar-status */

/* Clickable coordinate links in status bar */
.coord-link {
  color: #00d9ff;
  text-decoration: none;
  cursor: pointer;
  padding: 1px 3px;
  border-radius: 3px;
  transition: background-color 0.15s ease;
}

.coord-link:hover {
  background-color: rgba(0, 217, 255, 0.2);
  text-decoration: underline;
}

.selection-limit {
  color: #888;
  font-size: 0.65rem;
}

.deselect-btn {
  background: #6b7280;
  color: white;
}

.deselect-btn:hover:not(:disabled) {
  background: #4b5563;
}

.delete-btn {
  background: #dc2626;
  color: white;
}

.delete-btn:hover:not(:disabled) {
  background: #b91c1c;
}

.flag-btn {
  background: #f97316;
  color: white;
}

.flag-btn:hover:not(:disabled) {
  background: #ea580c;
}

.render-btn {
  background: #f59e0b;
  color: #1a1a2e;
  font-weight: bold;
}

.render-btn:hover:not(:disabled) {
  background: #d97706;
}

.render-btn.loading {
  background: #666;
  color: #fff;
  cursor: wait;
}

.render-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

.generate-btn {
  background: #00d9ff;
  color: #1a1a2e;
  font-weight: bold;
}

.generate-btn:hover:not(:disabled) {
  background: #00b8d4;
}

/* Generate Rectangle button */
.generate-rect-btn {
  background: #8b5cf6;
  color: white;
  font-weight: bold;
}

.generate-rect-btn:hover:not(:disabled) {
  background: #7c3aed;
}

.generate-rect-btn.loading {
  background: #666;
  cursor: wait;
}

.generate-rect-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

/* Clear Queue button */
.clear-queue-btn {
  background: #6b7280;
  color: white;
}

.clear-queue-btn:hover {
  background: #ef4444;
}

.clear-queue-btn:active {
  background: #dc2626;
}

.hard-refresh-btn {
  background: #3b82f6;
  color: white;
}

.hard-refresh-btn:hover {
  background: #2563eb;
}

.hard-refresh-btn:active {
  background: #1d4ed8;
}

/* Toast notification system */
.toast-container {
  position: fixed;
  bottom: 15px;
  right: 15px;
  z-index: 1000;
  display: flex;
  flex-direction: column-reverse;
  gap: 8px;
  max-width: 320px;
}

.toast {
  padding: 10px 14px;
  border-radius: 6px;
  font-size: 0.75rem;
  animation: slideIn 0.3s ease-out;
  display: flex;
  align-items: flex-start;
  gap: 10px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.toast.success {
  background: linear-gradient(135deg, #065f46 0%, #047857 100%);
  border: 1px solid #10b981;
  color: #d1fae5;
}

.toast.error {
  background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
  border: 1px solid #ef4444;
  color: #fee2e2;
}

.toast.info {
  background: linear-gradient(135deg, #1e3a5f 0%, #1e40af 100%);
  border: 1px solid #3b82f6;
  color: #dbeafe;
}

.toast.loading {
  background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
  border: 1px solid #6b7280;
  color: #e5e7eb;
}

.toast-icon {
  flex-shrink: 0;
  font-size: 1rem;
}

.toast-content {
  flex: 1;
}

.toast-title {
  font-weight: 600;
  margin-bottom: 2px;
}

.toast-message {
  opacity: 0.9;
  font-size: 0.7rem;
}

.toast-close {
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  opacity: 0.7;
  font-size: 1rem;
  padding: 0;
  line-height: 1;
}

.toast-close:hover {
  opacity: 1;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOut {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

.toast.removing {
  animation: slideOut 0.3s ease-in forwards;
}

/* Loading spinner for generate button */
.generate-btn.loading {
  background: #666;
  color: #fff;
  cursor: wait;
}

.generate-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Water fix tool styles */
.water-fix-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid rgba(59, 130, 246, 0.3);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #60a5fa;
  margin-top: 8px;
}

.water-fix-label {
  color: #93c5fd;
  font-weight: 500;
}

.color-swatch {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  border: 2px solid #fff;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3), inset 0 0 0 1px rgba(0, 0, 0, 0.1);
  background: #333;
}

.color-swatch.has-color {
  cursor: pointer;
}

.color-hex {
  font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
  font-size: 0.75rem;
  color: #93c5fd;
  min-width: 180px;
}

.water-fix-quadrant {
  color: #60a5fa;
  font-size: 0.7rem;
}

.apply-water-fix-btn {
  padding: 4px 12px;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
  margin-left: auto;
}

.apply-water-fix-btn:hover:not(:disabled) {
  background: #2563eb;
}

.apply-water-fix-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.apply-water-fix-btn.loading {
  background: #666;
  cursor: wait;
}

.cancel-water-fix-btn {
  padding: 4px 8px;
  background: #4b5563;
  color: #d1d5db;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  transition: all 0.2s;
}

.cancel-water-fix-btn:hover {
  background: #6b7280;
}

/* Fix water tool active state */
.tile.fix-water-selectable {
  cursor: crosshair;
}

.tile.fix-water-selectable:hover {
  outline: 2px solid #3b82f6;
  outline-offset: -2px;
}

.tile.water-fix-selected {
  outline: 3px solid #3b82f6;
  outline-offset: -3px;
  z-index: 10;
}

/* Water fill tool styles */
.water-fill-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(74, 99, 114, 0.15);
  border: 1px solid rgba(74, 99, 114, 0.4);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #7ba3b8;
  margin-top: 8px;
}

.water-fill-label {
  color: #93c5fd;
  font-weight: 500;
}

.water-color-preview {
  background: #4a6372 !important;
}

.water-fill-instruction {
  color: #7ba3b8;
}

.tile.water-fill-selectable {
  cursor: pointer;
}

.tile.water-fill-selectable:hover {
  outline: 2px solid #4a6372;
  outline-offset: -2px;
}

/* Model selector styles */
.model-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.model-label {
  display: flex;
  align-items: center;
  gap: 6px;
  color: #888;
  font-size: 0.75rem;
}

.model-select {
  padding: 4px 8px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #16213e;
  color: #fff;
  font-family: inherit;
  font-size: 0.75rem;
  cursor: pointer;
  min-width: 140px;
}

.model-select:hover {
  border-color: #00d9ff;
}

.model-select:focus {
  outline: none;
  border-color: #00d9ff;
  box-shadow: 0 0 0 2px rgba(0, 217, 255, 0.2);
}

.model-select option {
  background: #16213e;
  color: #fff;
  padding: 4px;
}

/* Generate with Prompt button */
.generate-prompt-btn {
  background: #9b59b6;
  color: #fff;
}

.generate-prompt-btn:hover:not(:disabled) {
  background: #8e44ad;
}

/* Prompt Dialog */
.dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.dialog-content {
  background: #1a1a2e;
  border: 1px solid #333;
  border-radius: 8px;
  padding: 24px;
  min-width: 400px;
  max-width: 500px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
}

.dialog-content h3 {
  margin: 0 0 12px 0;
  color: #fff;
  font-size: 18px;
}

.dialog-description {
  color: #aaa;
  font-size: 14px;
  margin: 0 0 16px 0;
}

.prompt-input {
  width: 100%;
  background: #0f0f1a;
  border: 1px solid #333;
  border-radius: 4px;
  color: #fff;
  font-size: 14px;
  padding: 12px;
  resize: vertical;
  font-family: inherit;
  box-sizing: border-box;
}

.prompt-input:focus {
  outline: none;
  border-color: #9b59b6;
  box-shadow: 0 0 0 2px rgba(155, 89, 182, 0.2);
}

.prompt-input::placeholder {
  color: #666;
}

.dialog-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 20px;
}

.dialog-cancel-btn {
  background: #333;
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

.dialog-cancel-btn:hover {
  background: #444;
}

.dialog-submit-btn {
  background: linear-gradient(135deg, #9b59b6, #8e44ad);
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.dialog-submit-btn:hover {
  background: linear-gradient(135deg, #a569c0, #9b59b6);
}

/* Queue Overlays - show pending generations as grouped rectangles */
.queue-overlay {
  position: absolute;
  border: 3px dashed #c084fc;
  border-radius: 4px;
  pointer-events: auto;
  z-index: 20;
  animation: pulse-queue-overlay 1.5s ease-in-out infinite;
  box-sizing: border-box;
}

/* Processing overlay - solid border, different color */
.queue-overlay.processing {
  border-style: solid;
  border-color: #a855f7;
  animation: pulse-processing-overlay 1s ease-in-out infinite;
}

@keyframes pulse-queue-overlay {
  0%,
  100% {
    border-color: #c084fc;
    box-shadow: 0 0 12px rgba(192, 132, 252, 0.3);
  }
  50% {
    border-color: #8b5cf6;
    box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
  }
}

@keyframes pulse-processing-overlay {
  0%,
  100% {
    border-color: #a855f7;
    box-shadow: 0 0 16px rgba(168, 85, 247, 0.4);
  }
  50% {
    border-color: #c084fc;
    box-shadow: 0 0 24px rgba(192, 132, 252, 0.7);
  }
}

.queue-overlay:hover {
  border-color: #a855f7;
  box-shadow: 0 0 16px rgba(168, 85, 247, 0.6);
}

/* Queue position badge */
.queue-badge {
  position: absolute;
  top: 6px;
  left: 6px;
  min-width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #8b5cf6, #a855f7);
  color: white;
  font-size: 12px;
  font-weight: bold;
  font-family: "SF Mono", "Monaco", monospace;
  border-radius: 6px;
  padding: 0 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  z-index: 1;
}

/* Processing badge - with spinner */
.queue-badge.processing {
  background: linear-gradient(135deg, #10b981, #059669);
  min-width: 28px;
  height: 28px;
}

/* Spinner animation for processing badge */
.processing-spinner {
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

/* Model label below badge */
.queue-model-label {
  position: absolute;
  top: 34px;
  left: 6px;
  font-size: 9px;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.9);
  background: rgba(139, 92, 246, 0.8);
  padding: 2px 6px;
  border-radius: 3px;
  max-width: calc(100% - 40px);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
}

/* Cancel button - visible on hover */
.queue-cancel-btn {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(220, 38, 38, 0.9);
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  opacity: 0;
  transform: scale(0.8);
  transition: all 0.15s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.queue-overlay:hover .queue-cancel-btn {
  opacity: 1;
  transform: scale(1);
}

.queue-cancel-btn:hover {
  background: #dc2626;
  transform: scale(1.1);
}

.queue-cancel-btn svg {
  width: 14px;
  height: 14px;
}

/* Make grid position relative for overlay positioning */
.grid {
  position: relative;
}

/* Water tile indicator styles */
.tile.water {
  position: relative;
}

.water-indicator {
  position: absolute;
  bottom: 4px;
  right: 4px;
  font-size: 14px;
  z-index: 20;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
  pointer-events: none;
  background: rgba(0, 0, 0, 0.5);
  border-radius: 3px;
  padding: 1px 3px;
}

/* Water select tool styles */
.water-select-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid rgba(59, 130, 246, 0.3);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #60a5fa;
  margin-top: 8px;
}

.water-select-label {
  color: #93c5fd;
  font-weight: 500;
}

.water-select-instruction {
  color: #60a5fa;
}

.tile.water-select-selectable {
  cursor: pointer;
}

.tile.water-select-selectable:hover {
  outline: 2px solid #3b82f6;
  outline-offset: -2px;
}

.tile.water-select-selectable.water:hover {
  outline-color: #f97316;
}

.tile.water-select-selectable.explicit-not-water:hover {
  outline-color: #dc2626;
}

/* Explicit not water indicator */
.explicit-not-water-indicator {
  position: absolute;
  bottom: 4px;
  right: 4px;
  font-size: 14px;
  z-index: 20;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
  pointer-events: none;
  background: rgba(220, 38, 38, 0.7);
  border-radius: 3px;
  padding: 1px 3px;
}

/* Explicit not water tile styling */
.tile.explicit-not-water {
  position: relative;
}

.tile.explicit-not-water::after {
  content: "";
  position: absolute;
  inset: 0;
  border: 2px dashed #dc2626;
  pointer-events: none;
  z-index: 5;
  opacity: 0.6;
}

/* Water highlight mode - show water tiles with blue bounding box */
.grid-container.show-water-highlight .tile.water::after {
  content: "";
  position: absolute;
  inset: 0;
  border: 3px solid #3b82f6;
  pointer-events: none;
  z-index: 15;
  box-shadow: inset 0 0 0 1px rgba(59, 130, 246, 0.3);
}

```

Now let me update the JavaScript to handle the three-state water toggle:

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// LocalStorage keys for persistence
const STORAGE_KEY_MODEL = "viewer_selected_model";
const STORAGE_KEY_TOOL = "viewer_selected_tool";
const STORAGE_KEY_SELECTION = "viewer_selected_quadrants";

// Save selected model ID to localStorage
function saveSelectedModel(modelId) {
  try {
    localStorage.setItem(STORAGE_KEY_MODEL, modelId);
  } catch (e) {
    console.warn("Could not save model to localStorage:", e);
  }
}

// Get saved model ID from localStorage
function getSavedModel() {
  try {
    return localStorage.getItem(STORAGE_KEY_MODEL);
  } catch (e) {
    return null;
  }
}

// Save selected tool to localStorage
function saveSelectedTool(toolName) {
  try {
    localStorage.setItem(STORAGE_KEY_TOOL, toolName || "");
  } catch (e) {
    console.warn("Could not save tool to localStorage:", e);
  }
}

// Get saved tool from localStorage
function getSavedTool() {
  try {
    return localStorage.getItem(STORAGE_KEY_TOOL) || "";
  } catch (e) {
    return "";
  }
}

// Save selected quadrants to localStorage
function saveSelectedQuadrants() {
  try {
    const quadrantsArray = Array.from(selectedQuadrants);
    localStorage.setItem(STORAGE_KEY_SELECTION, JSON.stringify(quadrantsArray));
  } catch (e) {
    console.warn("Could not save selection to localStorage:", e);
  }
}

// Get saved quadrants from localStorage
function getSavedQuadrants() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY_SELECTION);
    return saved ? JSON.parse(saved) : [];
  } catch (e) {
    return [];
  }
}

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Check if saved model ID exists in available models
  const savedModelId = getSavedModel();
  const savedModelExists =
    savedModelId && config.models.some((m) => m.model_id === savedModelId);

  // Add options for each model
  config.models.forEach((model, index) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;

    // Select saved model if it exists, otherwise use default or first
    if (savedModelExists && model.model_id === savedModelId) {
      option.selected = true;
    } else if (
      !savedModelExists &&
      model.model_id === config.default_model_id
    ) {
      option.selected = true;
    } else if (!savedModelExists && !config.default_model_id && index === 0) {
      option.selected = true;
    }
    select.appendChild(option);
  });

  // Auto-blur after selection and save to localStorage
  select.addEventListener("change", () => {
    saveSelectedModel(select.value);
    select.blur();
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to ALL currently processing quadrants (from all models)
  const processingQuadrants =
    status.all_processing_quadrants || status.quadrants || [];
  const isProcessing = status.is_generating || status.active_model_count > 0;

  if (isProcessing && processingQuadrants.length > 0) {
    document.body.classList.add("generating");
    processingQuadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else if (!isProcessing) {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items AND create overlays
  // Also create overlays for processing items
  const processingItems = getProcessingItems(status);
  updateQueueOverlays(status.queue || [], processingItems);
}

// Extract currently processing items from status
function getProcessingItems(status) {
  const processingItems = [];
  if (status.queue_by_model) {
    Object.entries(status.queue_by_model).forEach(([modelId, info]) => {
      if (info.is_processing && info.current_item) {
        processingItems.push({
          ...info.current_item,
          model_id: modelId,
          _isProcessing: true,
        });
      }
    });
  }
  return processingItems;
}

// Create/update overlays for pending queue items and processing items
function updateQueueOverlays(queueItems, processingItems = []) {
  // Remove existing overlays
  document.querySelectorAll(".queue-overlay").forEach((el) => el.remove());

  // Also clear queued class from all tiles
  document.querySelectorAll(".tile.queued").forEach((tile) => {
    tile.classList.remove("queued");
  });

  const hasItems =
    (queueItems && queueItems.length > 0) ||
    (processingItems && processingItems.length > 0);
  if (!hasItems) return;

  const grid = document.querySelector(".grid");
  if (!grid) return;

  // Get grid dimensions from config
  const gridX = config.x;
  const gridY = config.y;
  const sizePx = config.size_px;
  const showLines = document.getElementById("showLines")?.checked || false;
  const gap = showLines ? 2 : 0;

  // Helper function to create an overlay for an item
  function createOverlay(item, options = {}) {
    const { isProcessing = false, queuePosition = null } = options;

    if (!item.quadrants || item.quadrants.length === 0) return null;

    // Calculate bounding box for this generation
    const quadrants = item.quadrants;
    let minCol = Infinity,
      maxCol = -Infinity;
    let minRow = Infinity,
      maxRow = -Infinity;

    // Track which tiles are visible in the current view
    const visibleQuadrants = [];

    quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        visibleQuadrants.push([qx, qy]);
        const col = qx - gridX;
        const row = qy - gridY;
        minCol = Math.min(minCol, col);
        maxCol = Math.max(maxCol, col);
        minRow = Math.min(minRow, row);
        maxRow = Math.max(maxRow, row);

        // Add appropriate class to tile
        if (isProcessing) {
          tile.classList.add("locked");
        } else if (!tile.classList.contains("locked")) {
          tile.classList.add("queued");
        }
      }
    });

    if (visibleQuadrants.length === 0) return null;

    // Create overlay element
    const overlay = document.createElement("div");
    overlay.className = isProcessing
      ? "queue-overlay processing"
      : "queue-overlay";
    overlay.dataset.itemId = item.id;

    // Calculate position and size
    const left = minCol * (sizePx + gap);
    const top = minRow * (sizePx + gap);
    const width = (maxCol - minCol + 1) * sizePx + (maxCol - minCol) * gap;
    const height = (maxRow - minRow + 1) * sizePx + (maxRow - minRow) * gap;

    overlay.style.left = `${left}px`;
    overlay.style.top = `${top}px`;
    overlay.style.width = `${width}px`;
    overlay.style.height = `${height}px`;

    // Badge: spinner for processing, number for queued
    const badge = document.createElement("div");
    badge.className = isProcessing ? "queue-badge processing" : "queue-badge";
    if (isProcessing) {
      badge.innerHTML = `<svg class="processing-spinner" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
        <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
      </svg>`;
    } else {
      badge.textContent = queuePosition;
    }
    overlay.appendChild(badge);

    // Model name label
    if (item.model_id) {
      const modelLabel = document.createElement("div");
      modelLabel.className = "queue-model-label";
      modelLabel.textContent =
        getModelDisplayName(item.model_id) || item.model_id;
      overlay.appendChild(modelLabel);
    }

    // Cancel button (visible on hover) - for both processing and queued
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "queue-cancel-btn";
    cancelBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
      <line x1="10" y1="11" x2="10" y2="17"/>
      <line x1="14" y1="11" x2="14" y2="17"/>
    </svg>`;
    cancelBtn.title = isProcessing
      ? "Cancel this generation (in progress)"
      : "Cancel this generation";
    cancelBtn.onclick = (e) => {
      e.stopPropagation();
      cancelQueueItem(item.id);
    };
    overlay.appendChild(cancelBtn);

    return overlay;
  }

  // First, create overlays for processing items (with spinner)
  processingItems.forEach((item) => {
    const overlay = createOverlay(item, { isProcessing: true });
    if (overlay) {
      grid.appendChild(overlay);
    }
  });

  // Then, create overlays for queued items (with per-model position numbers)
  // Track position within each model's queue
  const modelPositionCounters = {};

  queueItems.forEach((item) => {
    const modelId = item.model_id || "default";
    // Initialize or increment the counter for this model
    if (!modelPositionCounters[modelId]) {
      modelPositionCounters[modelId] = 1;
    }
    const positionInModelQueue = modelPositionCounters[modelId];
    modelPositionCounters[modelId]++;

    const overlay = createOverlay(item, {
      queuePosition: positionInModelQueue,
    });
    if (overlay) {
      grid.appendChild(overlay);
    }
  });
}

// Cancel a specific queue item
async function cancelQueueItem(itemId) {
  try {
    const response = await fetch(`/api/queue/cancel/${itemId}`, {
      method: "POST",
    });
    const result = await response.json();

    if (result.success && result.cancelled) {
      showToast("success", "Cancelled", result.message);
      // Trigger immediate status update
      checkGenerationStatus();
    } else if (result.success && !result.cancelled) {
      showToast("info", "Not found", result.message);
    } else {
      showToast("error", "Error", result.error || "Failed to cancel");
    }
  } catch (error) {
    console.error("Cancel queue item failed:", error);
    showToast("error", "Error", "Failed to cancel queue item");
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

// Navigate to center the view on a specific coordinate
function navigateToCoord(targetX, targetY) {
  const params = getParams();
  const nx = parseInt(params.nx);
  const ny = parseInt(params.ny);
  // Center the target coordinate in the view
  const x = targetX - Math.floor(nx / 2);
  const y = targetY - Math.floor(ny / 2);
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

// Hard refresh - clear image cache and reload page
function hardRefresh() {
  // Add cache-busting timestamp to all tile images to force reload
  const timestamp = Date.now();

  // Update all tile image sources to bust cache
  document.querySelectorAll(".tile img").forEach((img) => {
    const url = new URL(img.src);
    url.searchParams.set("_t", timestamp);
    img.src = url.toString();
  });

  // Also reload the page with cache bypass
  // The true parameter forces reload from server, not cache
  window.location.reload(true);
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function toggleWaterHighlight() {
  const container = document.getElementById("gridContainer");
  const showWater = document.getElementById("showWater").checked;
  container.classList.toggle("show-water-highlight", showWater);

  // Save preference to localStorage
  try {
    localStorage.setItem("viewer_show_water_highlight", showWater ? "1" : "0");
  } catch (e) {
    console.warn("Could not save water highlight preference:", e);
  }
}

// Initialize water highlight state from localStorage
function initWaterHighlight() {
  try {
    const saved = localStorage.getItem("viewer_show_water_highlight");
    if (saved === "1") {
      const checkbox = document.getElementById("showWater");
      if (checkbox) {
        checkbox.checked = true;
        toggleWaterHighlight();
      }
    }
  } catch (e) {
    // Ignore localStorage errors
  }
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  // Ignore keyboard shortcuts when prompt dialog is open
  const promptDialog = document.getElementById("promptDialog");
  if (promptDialog && promptDialog.style.display !== "none") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "t":
    case "T":
      toggleWaterSelectTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      if (waterSelectToolActive) cancelWaterSelect();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate other tools if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }
  if (waterSelectToolActive) {
    cancelWaterSelect();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
    saveSelectedTool("select");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
    saveSelectedTool("");
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate other tools if active
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }
  if (waterSelectToolActive) {
    cancelWaterSelect();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
    saveSelectedTool("fixwater");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar
    waterFixStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }
  if (waterSelectToolActive) {
    cancelWaterSelect();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar
    waterFillStatus.style.display = "flex";
    saveSelectedTool("waterfill");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar
    waterFillStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

// Water Select tool - marks quadrants as water tiles
let waterSelectToolActive = false;

function toggleWaterSelectTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }

  waterSelectToolActive = !waterSelectToolActive;
  const btn = document.getElementById("waterSelectTool");
  const tiles = document.querySelectorAll(".tile");
  const waterSelectStatus = document.getElementById("waterSelectStatus");

  if (waterSelectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-select-selectable");
    });
    // Show water select status bar
    waterSelectStatus.style.display = "flex";
    saveSelectedTool("waterselect");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-select-selectable");
    });
    // Hide water select status bar
    waterSelectStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function cancelWaterSelect() {
  if (waterSelectToolActive) {
    toggleWaterSelectTool();
  }
}

async function handleWaterSelectClick(tileEl) {
  if (!waterSelectToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Three-state cycle: unset (0) ‚Üí water (1) ‚Üí explicit not water (-1) ‚Üí unset (0)
  const isCurrentlyWater = tileEl.dataset.water === "true";
  const isExplicitNotWater = tileEl.dataset.explicitNotWater === "true";

  let requestBody;
  let expectedState;

  if (isExplicitNotWater) {
    // Currently explicit not water ‚Üí go to unset (0)
    requestBody = { quadrants: [[qx, qy]], is_water: false };
    expectedState = "unset";
  } else if (isCurrentlyWater) {
    // Currently water ‚Üí go to explicit not water (-1)
    requestBody = { quadrants: [[qx, qy]], explicit_not_water: true };
    expectedState = "explicit_not_water";
  } else {
    // Currently unset ‚Üí go to water (1)
    requestBody = { quadrants: [[qx, qy]], is_water: true };
    expectedState = "water";
  }

  const instruction = document.getElementById("waterSelectInstruction");
  instruction.textContent = `Updating (${qx}, ${qy})...`;

  try {
    const response = await fetch("/api/water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.success) {
      // Update the tile's visual state based on the new status
      updateTileWaterState(tileEl, result.water_status);

      const messages = {
        water: "Marked as water üíß",
        explicit_not_water: "Protected from auto-detection üõ°Ô∏è",
        unset: "Reset to auto-detect",
      };
      showToast(
        expectedState === "water" ? "success" : "info",
        messages[expectedState],
        `Quadrant (${qx}, ${qy})`
      );

      instruction.textContent =
        "Click to cycle: unset ‚Üí water ‚Üí protected ‚Üí unset";
    } else {
      showToast("error", "Failed to update", result.error || "Unknown error");
      instruction.textContent =
        "Click to cycle: unset ‚Üí water ‚Üí protected ‚Üí unset";
    }
  } catch (error) {
    console.error("Water select error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent =
      "Click to cycle: unset ‚Üí water ‚Üí protected ‚Üí unset";
  }
}

// Update a tile's visual state based on water_status value
function updateTileWaterState(tileEl, waterStatus) {
  // Remove all water-related classes and indicators
  tileEl.classList.remove("water", "explicit-not-water");
  tileEl.dataset.water = "false";
  tileEl.dataset.explicitNotWater = "false";

  const waterIndicator = tileEl.querySelector(".water-indicator");
  if (waterIndicator) waterIndicator.remove();

  const notWaterIndicator = tileEl.querySelector(".explicit-not-water-indicator");
  if (notWaterIndicator) notWaterIndicator.remove();

  if (waterStatus === 1) {
    // Water tile
    tileEl.classList.add("water");
    tileEl.dataset.water = "true";
    const indicator = document.createElement("span");
    indicator.className = "water-indicator";
    indicator.title = "Water tile";
    indicator.textContent = "üíß";
    tileEl.appendChild(indicator);
  } else if (waterStatus === -1) {
    // Explicit not water (protected)
    tileEl.classList.add("explicit-not-water");
    tileEl.dataset.explicitNotWater = "true";
    const indicator = document.createElement("span");
    indicator.className = "explicit-not-water-indicator";
    indicator.title = "Explicitly NOT water (protected)";
    indicator.textContent = "üõ°Ô∏è";
    tileEl.appendChild(indicator);
  }
  // waterStatus === 0: unset, no visual indicator needed
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const flagBtn = document.getElementById("flagBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    // Show all active models generating
    const activeModels = serverStatus.active_models || [];
    const processingQuadrants =
      serverStatus.all_processing_quadrants || serverStatus.quadrants || [];

    if (activeModels.length > 0 && processingQuadrants.length > 0) {
      // Show which models are actively generating with their queue counts
      const queueByModel = serverStatus.queue_by_model || {};

      if (activeModels.length === 1) {
        const modelId = activeModels[0];
        const modelName = getModelDisplayName(modelId) || modelId || "default";
        const modelInfo = queueByModel[modelId];
        const queueCount = modelInfo
          ? modelInfo.pending_count + (modelInfo.is_processing ? 1 : 0)
          : 0;
        // Create clickable coordinate links
        const coordsHtml = processingQuadrants
          .map(
            ([x, y]) =>
              `<a href="#" class="coord-link" data-x="${x}" data-y="${y}">(${x},${y})</a>`
          )
          .join(" ");
        const countStr = queueCount > 0 ? ` [${queueCount}]` : "";
        statusParts.push({
          html: `üîÑ ${modelName}${countStr}: ${coordsHtml}`,
        });
      } else {
        // Multiple models generating in parallel - show each with queue count and coords
        const queueByModel = serverStatus.queue_by_model || {};
        const modelPartsHtml = activeModels.map((modelId) => {
          const name = getModelDisplayName(modelId) || modelId || "default";
          const modelInfo = queueByModel[modelId];
          const queueCount = modelInfo
            ? modelInfo.pending_count + (modelInfo.is_processing ? 1 : 0)
            : 0;
          // Get quadrants for this specific model
          const modelQuadrants =
            modelInfo && modelInfo.current_item
              ? modelInfo.current_item.quadrants || []
              : [];
          const coordsHtml =
            modelQuadrants.length > 0
              ? " " +
                modelQuadrants
                  .map(
                    ([x, y]) =>
                      `<a href="#" class="coord-link" data-x="${x}" data-y="${y}">(${x},${y})</a>`
                  )
                  .join(" ")
              : "";
          const countStr = queueCount > 0 ? ` [${queueCount}]` : "";
          return `${name}${countStr}${coordsHtml}`;
        });
        statusParts.push({ html: `üîÑ ${modelPartsHtml.join(", ")}` });
      }
    } else if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      // Fallback to old behavior with clickable coords
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsHtml = serverStatus.quadrants
        .map(
          ([x, y]) =>
            `<a href="#" class="coord-link" data-x="${x}" data-y="${y}">(${x},${y})</a>`
        )
        .join(" ");
      statusParts.push({ html: `${action} ${coordsHtml}` });
    }

    // Show per-model queue counts (only models with items)
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      const queueParts = modelQueues
        .map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return { name, count };
        })
        .filter(({ count }) => count > 0)
        .map(({ name, count }) => `${name}: ${count}`);

      if (queueParts.length > 0) {
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    }
  }

  // Update selection display in toolbar-info (separate from status)
  const selectedDisplay = document.getElementById("selectedQuadrantsDisplay");
  if (selectedDisplay) {
    if (count > 0) {
      const coordsStr = Array.from(selectedQuadrants)
        .map((key) => {
          const [x, y] = key.split(",");
          return `(${x},${y})`;
        })
        .join(" ");
      selectedDisplay.textContent = `‚úì ${coordsStr}`;
      selectedDisplay.style.display = "";
    } else {
      selectedDisplay.textContent = "";
      selectedDisplay.style.display = "none";
    }
  }

  // Build status display - some parts may be HTML objects, others plain strings
  if (countEl) {
    if (statusParts.length > 0) {
      const statusHtml = statusParts
        .map((part) =>
          typeof part === "object" && part.html ? part.html : part
        )
        .join(" ‚Ä¢ ");
      countEl.innerHTML = statusHtml;

      // Add click handlers for coordinate links
      countEl.querySelectorAll(".coord-link").forEach((link) => {
        link.addEventListener("click", (e) => {
          e.preventDefault();
          const x = parseInt(link.dataset.x, 10);
          const y = parseInt(link.dataset.y, 10);
          navigateToCoord(x, y);
        });
      });
    } else if (count > 0) {
      countEl.textContent = `${count} selected`;
    } else {
      countEl.textContent = "";
    }
  }

  // Update status bar styling and visibility
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (statusEl) {
    if (isProcessing) {
      statusEl.classList.add("generating");
      statusEl.style.display = "";
    } else {
      statusEl.classList.remove("generating");
      // Hide the status row if there's no content
      const hasContent = countEl && countEl.textContent.trim() !== "";
      statusEl.style.display = hasContent ? "" : "none";
    }
  }

  // Enable buttons for selection (can add to queue even during processing)
  if (deselectBtn) deselectBtn.disabled = count === 0;
  if (deleteBtn) deleteBtn.disabled = count === 0;
  if (flagBtn) flagBtn.disabled = count === 0;
  if (renderBtn) renderBtn.disabled = count === 0;
  if (generateBtn) generateBtn.disabled = count === 0;
  // Generate with prompt button
  const generateWithPromptBtn = document.getElementById(
    "generateWithPromptBtn"
  );
  if (generateWithPromptBtn) {
    generateWithPromptBtn.disabled = count === 0;
  }
  // Generate Rectangle requires exactly 2 selected
  if (generateRectBtn) generateRectBtn.disabled = count !== 2;
  // Export Cmd requires exactly 2 selected
  const exportCmdBtn = document.getElementById("exportCmdBtn");
  if (exportCmdBtn) exportCmdBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Check if we're in render view mode
  const isRenderMode = document.getElementById("showRender")?.checked || false;
  const dataType = isRenderMode ? "render" : "generation";
  const apiEndpoint = isRenderMode ? "/api/delete-render" : "/api/delete";

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete ${dataType} data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch(apiEndpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function flagSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Check if any selected tiles are already flagged - if so, unflag them
  let anyFlagged = false;
  coords.forEach(([x, y]) => {
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
    if (tile && tile.dataset.flagged === "true") {
      anyFlagged = true;
    }
  });

  // Toggle: if any are flagged, unflag all; otherwise flag all
  const shouldFlag = !anyFlagged;

  try {
    const response = await fetch("/api/flag", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords, flag: shouldFlag }),
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        result.flagged ? "Flagged" : "Unflagged",
        result.message
      );

      // Update tile visual state
      coords.forEach(([x, y]) => {
        const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
        if (tile) {
          if (shouldFlag) {
            tile.classList.add("flagged");
            tile.dataset.flagged = "true";
          } else {
            tile.classList.remove("flagged");
            tile.dataset.flagged = "false";
          }
        }
      });

      // Deselect after flagging
      deselectAll();
    } else {
      showToast("error", "Flag failed", result.error);
    }
  } catch (error) {
    console.error("Flag error:", error);
    showToast("error", "Flag failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

// Prompt dialog functions
function showPromptDialog() {
  if (selectedQuadrants.size === 0) return;
  const dialog = document.getElementById("promptDialog");
  const input = document.getElementById("promptInput");
  if (dialog && input) {
    input.value = "";
    dialog.style.display = "flex";
    input.focus();
  }
}

function hidePromptDialog() {
  const dialog = document.getElementById("promptDialog");
  if (dialog) {
    dialog.style.display = "none";
  }
}

async function submitPromptGeneration() {
  const input = document.getElementById("promptInput");
  const prompt = input ? input.value.trim() : "";
  hidePromptDialog();
  await generateSelected(prompt);
}

async function generateSelected(prompt = null) {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();

  // Build context info for toast
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  const promptMsg = prompt ? " with prompt" : "";

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    // Include prompt if provided
    if (prompt) {
      requestBody.prompt = prompt;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log(
        "Generation queued at position:",
        result.position,
        "model:",
        result.model_id
      );
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `${toGenerate.length} quadrant(s)${promptMsg}${contextMsg} ‚Üí position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `${coords.length} quadrant(s) for render ‚Üí position ${result.position}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

async function copyExportCommand() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the export bounds."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  // Build the export command
  const command = `uv run python src/isometric_nyc/e2e_generation/export_import_generation_tile.py generations/v01 --tl='${minX},${minY}' --br='${maxX},${maxY}' --overwrite`;

  try {
    await navigator.clipboard.writeText(command);
    showToast(
      "success",
      "Command copied!",
      `Export command for (${minX},${minY}) to (${maxX},${maxY}) copied to clipboard`
    );
    console.log("Copied export command:", command);
  } catch (error) {
    console.error("Failed to copy to clipboard:", error);
    showToast(
      "error",
      "Copy failed",
      "Could not copy to clipboard. Check browser permissions."
    );
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  saveSelectedQuadrants();
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated (locked = actively processing)
  // Note: queued tiles CAN be selected (e.g., to cancel or manage them)
  const key = `${qx},${qy}`;
  if (tileEl.classList.contains("locked")) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently being processed`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  saveSelectedQuadrants();
  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle water select tool clicks
    if (waterSelectToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterSelectClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;
let lastProcessingQuadrants = new Set(); // Track quadrants that were processing

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

// Refresh a specific tile's image (or add image if it was a placeholder)
function refreshTileImage(qx, qy) {
  const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
  if (!tile) return;

  const showRender = document.getElementById("showRender")?.checked ? "1" : "0";
  const timestamp = Date.now();
  const imgUrl = `/tile/${qx}/${qy}?render=${showRender}&_t=${timestamp}`;

  let img = tile.querySelector("img");
  if (img) {
    // Update existing image
    img.src = imgUrl;
  } else {
    // Create new image for placeholder tile
    img = document.createElement("img");
    img.src = imgUrl;
    img.alt = `Tile ${qx},${qy}`;
    img.onload = () => {
      // Remove placeholder class once image loads
      tile.classList.remove("placeholder");
    };
    tile.appendChild(img);
  }
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes - consider active_model_count for parallel processing
    const wasGenerating = isGenerating || isRendering;
    const hasActiveModels = (status.active_model_count || 0) > 0;
    isGenerating =
      (status.is_generating || hasActiveModels) &&
      status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Get current processing quadrants
    const currentProcessingQuadrants = new Set(
      (status.all_processing_quadrants || status.quadrants || []).map(
        ([x, y]) => `${x},${y}`
      )
    );

    // Detect quadrants that just finished processing (were processing, now not)
    const completedQuadrants = [];
    lastProcessingQuadrants.forEach((coordKey) => {
      if (!currentProcessingQuadrants.has(coordKey)) {
        completedQuadrants.push(coordKey);
      }
    });

    // Refresh tiles for completed quadrants
    if (completedQuadrants.length > 0) {
      console.log("Refreshing completed quadrants:", completedQuadrants);
      completedQuadrants.forEach((coordKey) => {
        const [qx, qy] = coordKey.split(",").map(Number);
        refreshTileImage(qx, qy);
      });
    }

    // Update tracking for next poll
    lastProcessingQuadrants = currentProcessingQuadrants;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = "";
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              const count = info.pending_count + (info.is_processing ? 1 : 0);
              return { name, count };
            })
            .filter(({ count }) => count > 0)
            .map(({ name, count }) => `${name}: ${count}`);
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        if (queueMsg) {
          showToast("info", "Processing queue", queueMsg);
        }
      } else {
        // No more items - tiles already refreshed, just stop polling
        stopStatusPolling();
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Restore saved tool on page load
function restoreSavedTool() {
  const savedTool = getSavedTool();
  if (!savedTool) return;

  // Check if the tool button exists before activating
  switch (savedTool) {
    case "select":
      if (document.getElementById("selectTool")) {
        toggleSelectTool();
      }
      break;
    case "fixwater":
      if (document.getElementById("fixWaterTool")) {
        toggleFixWaterTool();
      }
      break;
    case "waterfill":
      if (document.getElementById("waterFillTool")) {
        toggleWaterFillTool();
      }
      break;
    case "waterselect":
      if (document.getElementById("waterSelectTool")) {
        toggleWaterSelectTool();
      }
      break;
    default:
      // Unknown tool, clear saved state
      saveSelectedTool("");
      break;
  }
}

// Restore saved quadrant selections on page load
function restoreSavedQuadrants() {
  const savedQuadrants = getSavedQuadrants();
  if (!savedQuadrants || savedQuadrants.length === 0) return;

  let restoredCount = 0;

  savedQuadrants.forEach((key) => {
    // Check if this quadrant tile exists on the current page
    const tile = document.querySelector(`.tile[data-coords="${key}"]`);
    if (tile) {
      // Don't restore if tile is locked (actively processing)
      // Queued tiles CAN be selected
      if (!tile.classList.contains("locked")) {
        selectedQuadrants.add(key);
        tile.classList.add("selected");
        restoredCount++;
      }
    }
  });

  if (restoredCount > 0) {
    console.log(`Restored ${restoredCount} selected quadrant(s)`);
    // Update localStorage to only contain valid selections
    saveSelectedQuadrants();
    updateSelectionStatus();
  } else if (savedQuadrants.length > 0) {
    // Had saved selections but none are on current page - clear storage
    saveSelectedQuadrants();
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  // Initialize water highlight toggle
  initWaterHighlight();

  // Restore saved tool
  restoreSavedTool();

  // Restore saved quadrant selections
  restoreSavedQuadrants();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Generated Tiles Viewer</title>
    <link rel="stylesheet" href="/static/viewer.css" />
    <style>
      /* Dynamic grid sizing based on template variables */
      .grid {
        grid-template-columns: repeat({{ nx }}, {{ size_px }}px);
        grid-auto-rows: {{ size_px }}px;
      }
      .tile.placeholder {
        min-width: {{ size_px }}px;
        min-height: {{ size_px }}px;
      }
    </style>
  </head>
  <body>
    <!-- Config data for JS -->
    <script
      id="app-config"
      type="application/json"
      data-config='{"x": {{ x }}, "y": {{ y }}, "nx": {{ nx }}, "ny": {{ ny }}, "size_px": {{ size_px }}, "models": {{ models_config | safe }}, "default_model_id": "{{ default_model_id }}"}'
    ></script>

    <!-- Toast notification container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Fixed toolbar -->
    <div class="toolbar">
      <div class="toolbar-row toolbar-row-nav">
        <div class="controls">
          <label>X: <input type="number" id="x" value="{{ x }}" /></label>
          <label>Y: <input type="number" id="y" value="{{ y }}" /></label>
          <label
            >NX: <input type="number" id="nx" value="{{ nx }}" min="1" max="20"
          /></label>
          <label
            >NY: <input type="number" id="ny" value="{{ ny }}" min="1" max="20"
          /></label>
          <label
            >Size:
            <input type="number" id="sizePx" value="{{ size_px }}" step="32"
          /></label>
          <button onclick="goTo()">Go</button>
          <div class="toggle-group">
            <label
              ><input
                type="checkbox"
                id="showLines"
                {%
                if
                show_lines
                %}checked{%
                endif
                %}
                onchange="toggleLines()"
              />
              Lines</label
            >
            <label
              ><input
                type="checkbox"
                id="showCoords"
                {%
                if
                show_coords
                %}checked{%
                endif
                %}
                onchange="toggleCoords()"
              />
              Coords</label
            >
            <label
              ><input
                type="checkbox"
                id="showRender"
                {%
                if
                show_render
                %}checked{%
                endif
                %}
                onchange="toggleRender()"
              />
              Renders</label
            >
            <label
              ><input
                type="checkbox"
                id="showWater"
                onchange="toggleWaterHighlight()"
              />
              üíß Water</label
            >
          </div>
          <div class="toggle-group model-group">
            <label class="model-label"
              >Model:
              <select id="modelSelect" class="model-select">
                <!-- Populated by JavaScript -->
              </select>
            </label>
          </div>
        </div>
        <div class="toolbar-info">
          <span>({{ x }}, {{ y }}) ‚Üí ({{ x + nx - 1 }}, {{ y + ny - 1 }})</span>
          <span id="selectedQuadrantsDisplay" class="selected-quadrants"></span>
          <span class="generation-dir-info">{{ generation_dir }}</span>
        </div>
      </div>
      <div class="toolbar-row toolbar-row-tools">
        <div class="tools-group">
          <span class="tools-label">Tools:</span>
          <button
            id="selectTool"
            class="tool-btn"
            onclick="toggleSelectTool()"
            title="Select quadrants (S)"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path>
              <path d="M13 13l6 6"></path>
            </svg>
            Select
          </button>
          <button
            id="fixWaterTool"
            class="tool-btn"
            onclick="toggleFixWaterTool()"
            title="Fix water color (W)"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
            </svg>
            Fix Water
          </button>
          <button
            id="waterFillTool"
            class="tool-btn"
            onclick="toggleWaterFillTool()"
            title="Fill quadrant with water (F)"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <rect x="3" y="3" width="18" height="18" rx="2"></rect>
              <path d="M12 8v8"></path>
              <path d="M8 12h8"></path>
            </svg>
            Water Fill
          </button>
          <button
            id="waterSelectTool"
            class="tool-btn"
            onclick="toggleWaterSelectTool()"
            title="Mark quadrants as water tiles (T)"
          >
            <svg
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
            >
              <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
              <path d="M12 12v4"></path>
              <circle cx="12" cy="18" r="1"></circle>
            </svg>
            Water Select
          </button>
        </div>
        <div class="toolbar-divider"></div>
        <div class="actions-group">
          <button
            id="deselectAllBtn"
            class="action-btn deselect-btn"
            onclick="deselectAll()"
            disabled
          >
            Deselect
          </button>
          <button
            id="deleteBtn"
            class="action-btn delete-btn"
            onclick="deleteSelected()"
            disabled
            title="Delete data (generation or render based on current view)"
          >
            Delete
          </button>
          <button
            id="flagBtn"
            class="action-btn flag-btn"
            onclick="flagSelected()"
            disabled
            title="Flag selected quadrants for review"
          >
            üö© Flag
          </button>
          <button
            id="renderBtn"
            class="action-btn render-btn"
            onclick="renderSelected()"
            disabled
          >
            Render
          </button>
          <button
            id="generateBtn"
            class="action-btn generate-btn"
            onclick="generateSelected()"
            disabled
          >
            Generate
          </button>
          <button
            id="generateWithPromptBtn"
            class="action-btn generate-prompt-btn"
            onclick="showPromptDialog()"
            disabled
            title="Generate with additional prompt text"
          >
            + Prompt
          </button>
          <button
            id="generateRectBtn"
            class="action-btn generate-rect-btn"
            onclick="generateRectangle()"
            disabled
            title="Select exactly 2 quadrants to define rectangle corners"
          >
            Gen Rect
          </button>
          <button
            id="exportCmdBtn"
            class="action-btn export-cmd-btn"
            onclick="copyExportCommand()"
            disabled
            title="Copy export command to clipboard (select 2 quadrants)"
          >
            Export Cmd
          </button>
        </div>
        <div class="toolbar-divider"></div>
        <div class="utility-group">
          <button
            id="clearQueueBtn"
            class="utility-btn clear-queue-btn"
            onclick="clearQueue()"
            title="Clear all pending items from the generation queue"
          >
            Clear Queue
          </button>
          <button
            id="hardRefreshBtn"
            class="utility-btn hard-refresh-btn"
            onclick="hardRefresh()"
            title="Clear image cache and reload page"
          >
            ‚Üª Refresh
          </button>
        </div>
      </div>
      <div class="toolbar-row toolbar-row-status" id="selectionStatus">
        <span id="selectionCount"></span>
      </div>
      <div class="water-fix-status" id="waterFixStatus" style="display: none">
        <span class="water-fix-label">Target Color:</span>
        <span class="color-swatch" id="targetColorSwatch"></span>
        <span class="color-hex" id="targetColorHex"
          >Click a quadrant to pick color</span
        >
        <span class="water-fix-quadrant" id="waterFixQuadrant"></span>
        <button
          id="applyWaterFixBtn"
          class="apply-water-fix-btn"
          onclick="applyWaterFix()"
          disabled
        >
          Apply Fix
        </button>
        <button
          id="cancelWaterFixBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFix()"
        >
          Cancel
        </button>
      </div>
      <div class="water-fill-status" id="waterFillStatus" style="display: none">
        <span class="water-fill-label">Water Fill:</span>
        <span class="color-swatch water-color-preview"></span>
        <span class="water-fill-instruction" id="waterFillInstruction"
          >Click a quadrant to fill with water</span
        >
        <button
          id="cancelWaterFillBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFill()"
        >
          Cancel
        </button>
      </div>
      <div
        class="water-select-status"
        id="waterSelectStatus"
        style="display: none"
      >
        <span class="water-select-label">üíß Water Select:</span>
        <span class="water-select-instruction" id="waterSelectInstruction"
          >Click to cycle: unset ‚Üí water üíß ‚Üí protected üõ°Ô∏è ‚Üí unset</span
        >
        <button
          id="cancelWaterSelectBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterSelect()"
        >
          Cancel
        </button>
      </div>
    </div>

    <div
      class="grid-container {% if show_lines %}show-lines{% endif %} {% if show_coords %}show-coords{% endif %}"
      id="gridContainer"
    >
      <div class="grid">
        {% for dy in range(ny) %} {% for dx in range(nx) %} {% set qx = x + dx
        %} {% set qy = y + dy %} {% set has_gen = tiles.get((dx, dy), False) %}
        {% set is_flagged = flagged_tiles.get((dx, dy), False) %} {% set
        is_water = water_tiles.get((dx, dy), False) %} {% set
        is_explicit_not_water = explicit_not_water_tiles.get((dx, dy), False) %}
        <div
          class="tile {% if not has_gen %}placeholder{% endif %}{% if is_flagged %} flagged{% endif %}{% if is_water %} water{% endif %}{% if is_explicit_not_water %} explicit-not-water{% endif %}"
          data-coords="{{ qx }},{{ qy }}"
          data-flagged="{{ 'true' if is_flagged else 'false' }}"
          data-water="{{ 'true' if is_water else 'false' }}"
          data-explicit-not-water="{{ 'true' if is_explicit_not_water else 'false' }}"
        >
          <span class="coords">({{ qx }}, {{ qy }})</span>
          {% if has_gen %}
          <img
            src="/tile/{{ qx }}/{{ qy }}?render={{ '1' if show_render else '0' }}"
            alt="Tile {{ qx }},{{ qy }}"
          />
          {% endif %} {% if is_water %}
          <span class="water-indicator" title="Water tile">üíß</span>
          {% endif %} {% if is_explicit_not_water %}
          <span class="explicit-not-water-indicator" title="Explicitly NOT water (protected)">üö´</span>
          {% endif %}
        </div>
        {% endfor %} {% endfor %}
      </div>
    </div>

    <!-- Prompt Dialog -->
    <div id="promptDialog" class="dialog-overlay" style="display: none">
      <div class="dialog-content">
        <h3>Generate with Prompt</h3>
        <p class="dialog-description">
          Add additional instructions for the generation:
        </p>
        <textarea
          id="promptInput"
          class="prompt-input"
          placeholder="e.g., 'Add more trees' or 'Make the water darker'"
          rows="3"
        ></textarea>
        <div class="dialog-buttons">
          <button class="dialog-cancel-btn" onclick="hidePromptDialog()">
            Cancel
          </button>
          <button class="dialog-submit-btn" onclick="submitPromptGeneration()">
            Generate
          </button>
        </div>
      </div>
    </div>

    <script src="/static/viewer.js"></script>
  </body>
</html>

```

Now let me update `debug_map.py` to also show protected tiles with a different color:

```python
"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_nyc/e2e_generation/debug_map.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_nyc.e2e_generation.shared import calculate_offset

# Simplified NYC borough boundaries GeoJSON (all 5 boroughs)
# Source: NYC Open Data (dwillis/nyc-maps), simplified using Douglas-Peucker algorithm
# fmt: off
NYC_BOUNDARY_GEOJSON = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8205, 40.801], [-73.8137, 40.7971], [-73.7964, 40.7957], [-73.7928, 40.7888], [-73.7817, 40.7911], [-73.7833, 40.7949], [-73.7769, 40.7964], [-73.7706, 40.7885], [-73.7763, 40.7885], [-73.7668, 40.7798], [-73.7651, 40.7738], [-73.7447, 40.7566], [-73.7551, 40.7675], [-73.7555, 40.7777], [-73.7508, 40.7829], [-73.7013, 40.7508], [-73.7, 40.7392], [-73.7077, 40.7278], [-73.7303, 40.7222], [-73.7269, 40.71], [-73.7256, 40.6796], [-73.7283, 40.663], [-73.7252, 40.652], [-73.7414, 40.6469], [-73.74, 40.6351], [-73.7437, 40.639], [-73.747, 40.6369], [-73.7473, 40.6432], [-73.7548, 40.6478], [-73.7474, 40.6414], [-73.7486, 40.6354], [-73.765, 40.6294], [-73.7708, 40.62], [-73.7717, 40.6236], [-73.7752, 40.6193], [-73.7717, 40.6236], [-73.7792, 40.6273], [-73.7852, 40.6201], [-73.7809, 40.6136], [-73.7914, 40.6076], [-73.8008, 40.6119], [-73.7946, 40.6226], [-73.7897, 40.6226], [-73.7826, 40.6302], [-73.7895, 40.6343], [-73.7981, 40.631], [-73.7908, 40.6343], [-73.8212, 40.6491], [-73.8223, 40.6594], [-73.8113, 40.6606], [-73.8235, 40.6601], [-73.8231, 40.648], [-73.8309, 40.6516], [-73.8302, 40.6598], [-73.8319, 40.6549], [-73.831, 40.6582], [-73.8334, 40.6581], [-73.8311, 40.6486], [-73.8343, 40.6481], [-73.8387, 40.6625], [-73.8359, 40.6455], [-73.8495, 40.6441], [-73.8524, 40.6474], [-73.8494, 40.6514], [-73.8559, 40.6513], [-73.8614, 40.6564], [-73.8596, 40.6585], [-73.8632, 40.6583], [-73.8557, 40.6639], [-73.8576, 40.6717], [-73.8604, 40.6713], [-73.866, 40.6819], [-73.8689, 40.6952], [-73.8965, 40.6823], [-73.9058, 40.6941], [-73.9043, 40.6957], [-73.9219, 40.7094], [-73.9241, 40.7151], [-73.9206, 40.716], [-73.9252, 40.7223], [-73.9204, 40.7237], [-73.938, 40.7305], [-73.9459, 40.7375], [-73.9386, 40.7429], [-73.9472, 40.7379], [-73.9626, 40.7388], [-73.9568, 40.7488], [-73.9532, 40.7477], [-73.9562, 40.7497], [-73.9435, 40.7645], [-73.9349, 40.77], [-73.9378, 40.7736], [-73.9364, 40.7769], [-73.9286, 40.7766], [-73.9099, 40.7909], [-73.8959, 40.7856], [-73.9026, 40.7803], [-73.8944, 40.7842], [-73.8953, 40.7816], [-73.8917, 40.7822], [-73.8925, 40.7774], [-73.8918, 40.7749], [-73.8901, 40.7778], [-73.8895, 40.7735], [-73.8839, 40.7741], [-73.8849, 40.78], [-73.8787, 40.7806], [-73.8797, 40.7829], [-73.8752, 40.7815], [-73.8679, 40.7874], [-73.8726, 40.7808], [-73.8551, 40.7722], [-73.8582, 40.7703], [-73.8562, 40.7689], [-73.8628, 40.7668], [-73.8507, 40.7594], [-73.8391, 40.766], [-73.8478, 40.7668], [-73.8513, 40.7718], [-73.849, 40.778], [-73.8524, 40.7792], [-73.8492, 40.7823], [-73.8553, 40.782], [-73.8595, 40.7855], [-73.8528, 40.7882], [-73.8537, 40.794], [-73.8379, 40.7985], [-73.8403, 40.7976], [-73.8373, 40.789], [-73.8329, 40.7885], [-73.8279, 40.7929], [-73.8295, 40.7968], [-73.8205, 40.801]]]}}, {"type": "Feature", "properties": {"name": "Brooklyn"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9544, 40.7391], [-73.9292, 40.7274], [-73.9246, 40.7192], [-73.9322, 40.715], [-73.9333, 40.711], [-73.9304, 40.7087], [-73.9309, 40.7149], [-73.9236, 40.7173], [-73.9219, 40.7094], [-73.9043, 40.6957], [-73.9058, 40.6941], [-73.8965, 40.6823], [-73.8684, 40.6947], [-73.866, 40.6819], [-73.8604, 40.6713], [-73.8576, 40.6717], [-73.8557, 40.6639], [-73.8633, 40.6569], [-73.857, 40.6506], [-73.8572, 40.6437], [-73.8656, 40.6388], [-73.8793, 40.6546], [-73.868, 40.6381], [-73.8744, 40.6367], [-73.891, 40.6494], [-73.8771, 40.636], [-73.8836, 40.6309], [-73.8837, 40.6276], [-73.8875, 40.6283], [-73.8958, 40.6225], [-73.9175, 40.6314], [-73.8965, 40.6214], [-73.8959, 40.6145], [-73.891, 40.6128], [-73.894, 40.6112], [-73.8897, 40.6115], [-73.8933, 40.6067], [-73.8998, 40.6055], [-73.9013, 40.6117], [-73.9088, 40.6174], [-73.9016, 40.6058], [-73.9137, 40.604], [-73.9171, 40.6088], [-73.9142, 40.6149], [-73.9195, 40.6077], [-73.9089, 40.6016], [-73.884, 40.6056], [-73.8767, 40.5849], [-73.8797, 40.5801], [-73.8955, 40.5768], [-73.899, 40.5877], [-73.9115, 40.5861], [-73.9151, 40.5988], [-73.9215, 40.6019], [-73.9249, 40.5998], [-73.9302, 40.604], [-73.9321, 40.6027], [-73.9142, 40.5892], [-73.9248, 40.5856], [-73.9281, 40.5877], [-73.924, 40.5911], [-73.9286, 40.5886], [-73.9326, 40.5949], [-73.9313, 40.5868], [-73.9135, 40.5861], [-73.9125, 40.5834], [-73.9173, 40.5832], [-73.9115, 40.5818], [-73.9535, 40.583], [-73.9326, 40.5813], [-73.9311, 40.5762], [-74.0021, 40.5696], [-74.012, 40.5749], [-74.0119, 40.5797], [-74.006, 40.582], [-73.9884, 40.5788], [-73.986, 40.5817], [-73.9916, 40.5811], [-73.9903, 40.5846], [-74.0002, 40.5831], [-73.9941, 40.5887], [-74.0004, 40.5865], [-73.9984, 40.5935], [-74.036, 40.6093], [-74.0416, 40.6206], [-74.0368, 40.639], [-74.0388, 40.6396], [-74.0341, 40.6443], [-74.0282, 40.644], [-74.026, 40.6463], [-74.0294, 40.6488], [-74.0247, 40.6471], [-74.0261, 40.651], [-74.0229, 40.6512], [-74.0254, 40.6527], [-74.0212, 40.6508], [-74.0232, 40.6541], [-74.0179, 40.6541], [-74.0198, 40.6565], [-74.0167, 40.6553], [-74.0191, 40.6574], [-74.015, 40.657], [-74.0175, 40.6595], [-74.0155, 40.6608], [-74.0086, 40.6595], [-74.0096, 40.6633], [-74.0035, 40.6622], [-74.0077, 40.6648], [-73.9995, 40.6644], [-74.0029, 40.6665], [-73.9988, 40.6716], [-74.0029, 40.6673], [-74.007, 40.6661], [-74.0054, 40.6709], [-74.0075, 40.6671], [-74.0169, 40.6648], [-74.0193, 40.6716], [-74.0165, 40.6649], [-74.0103, 40.6691], [-74.0157, 40.671], [-74.013, 40.6733], [-74.0163, 40.6729], [-74.015, 40.6747], [-74.0188, 40.6723], [-74.0193, 40.6796], [-74.0128, 40.6836], [-74.013, 40.6804], [-74.0097, 40.6833], [-74.0119, 40.6839], [-74.001, 40.6901], [-73.9946, 40.7044], [-73.9783, 40.706], [-73.9757, 40.6996], [-73.9708, 40.7], [-73.9728, 40.7027], [-73.9695, 40.7005], [-73.9746, 40.7077], [-73.9711, 40.7059], [-73.9723, 40.7091], [-73.9675, 40.7034], [-73.97, 40.7105], [-73.9673, 40.717], [-73.9621, 40.7251], [-73.9579, 40.7246], [-73.9616, 40.7259], [-73.9623, 40.734], [-73.9544, 40.7391]], [[-73.9039, 40.6248], [-73.9039, 40.6248]]]}}, {"type": "Feature", "properties": {"name": "Staten Island"}, "geometry": {"type": "Polygon", "coordinates": [[[-74.0822, 40.6483], [-74.0717, 40.645], [-74.0703, 40.6425], [-74.0731, 40.6419], [-74.0702, 40.642], [-74.0729, 40.6409], [-74.07, 40.6411], [-74.0731, 40.6405], [-74.0735, 40.6372], [-74.0705, 40.6372], [-74.0734, 40.6369], [-74.073, 40.6303], [-74.068, 40.6288], [-74.0729, 40.63], [-74.0723, 40.6246], [-74.0538, 40.6059], [-74.0522, 40.5998], [-74.0734, 40.5783], [-74.091, 40.5667], [-74.1048, 40.553], [-74.1073, 40.5541], [-74.1128, 40.5479], [-74.1225, 40.5448], [-74.1369, 40.5293], [-74.1405, 40.535], [-74.1341, 40.5355], [-74.128, 40.5407], [-74.1307, 40.5463], [-74.1379, 40.546], [-74.1423, 40.5423], [-74.1413, 40.5371], [-74.1776, 40.5192], [-74.1848, 40.5193], [-74.1952, 40.51], [-74.1994, 40.513], [-74.2076, 40.5118], [-74.2176, 40.5033], [-74.2468, 40.4961], [-74.2532, 40.5001], [-74.2556, 40.5077], [-74.2535, 40.5117], [-74.2494, 40.517], [-74.2398, 40.5201], [-74.244, 40.5249], [-74.242, 40.5343], [-74.248, 40.5431], [-74.2307, 40.5556], [-74.2186, 40.5547], [-74.212, 40.5584], [-74.2046, 40.5893], [-74.1975, 40.5968], [-74.2028, 40.6083], [-74.2008, 40.6303], [-74.1946, 40.6374], [-74.18, 40.6453], [-74.1796, 40.6419], [-74.1744, 40.6451], [-74.1713, 40.6429], [-74.173, 40.6405], [-74.1661, 40.6424], [-74.1528, 40.6371], [-74.1514, 40.6394], [-74.1486, 40.6374], [-74.1344, 40.6419], [-74.127, 40.6393], [-74.1097, 40.6455], [-74.0822, 40.6483]]]}}, {"type": "Feature", "properties": {"name": "Bronx"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8729, 40.9044], [-73.8595, 40.9005], [-73.8511, 40.9104], [-73.8535, 40.9075], [-73.8414, 40.9042], [-73.8384, 40.8941], [-73.793, 40.8834], [-73.7974, 40.8751], [-73.8025, 40.8705], [-73.8034, 40.8725], [-73.803, 40.8692], [-73.8084, 40.8712], [-73.8031, 40.8658], [-73.7948, 40.8732], [-73.7929, 40.8793], [-73.7896, 40.8813], [-73.7844, 40.8784], [-73.7872, 40.8727], [-73.7836, 40.8738], [-73.7832, 40.8707], [-73.7914, 40.8681], [-73.7919, 40.8608], [-73.7987, 40.8549], [-73.8003, 40.8481], [-73.8042, 40.8533], [-73.8048, 40.8616], [-73.8077, 40.8585], [-73.8151, 40.8631], [-73.8123, 40.8542], [-73.8164, 40.8541], [-73.8171, 40.8513], [-73.815, 40.8455], [-73.8117, 40.8467], [-73.8144, 40.8431], [-73.8182, 40.8443], [-73.8147, 40.8414], [-73.8149, 40.831], [-73.8099, 40.8282], [-73.814, 40.8242], [-73.807, 40.8254], [-73.8046, 40.819], [-73.7974, 40.8158], [-73.803, 40.8124], [-73.807, 40.8165], [-73.8051, 40.8129], [-73.7909, 40.8073], [-73.7906, 40.8046], [-73.8162, 40.8138], [-73.8302, 40.8108], [-73.8316, 40.8049], [-73.8374, 40.8062], [-73.8423, 40.8291], [-73.8389, 40.8337], [-73.8397, 40.8396], [-73.8431, 40.8298], [-73.84, 40.8199], [-73.8462, 40.8107], [-73.8554, 40.8143], [-73.8491, 40.8123], [-73.8481, 40.8049], [-73.8561, 40.8046], [-73.8592, 40.8063], [-73.859, 40.8103], [-73.8594, 40.8082], [-73.8677, 40.8106], [-73.8765, 40.8161], [-73.8681, 40.8068], [-73.8723, 40.8002], [-73.8951, 40.8069], [-73.9022, 40.8049], [-73.9117, 40.7966], [-73.9276, 40.8027], [-73.9329, 40.8101], [-73.9331, 40.8352], [-73.9067, 40.8758], [-73.9103, 40.879], [-73.9178, 40.8757], [-73.9249, 40.8789], [-73.9115, 40.9138], [-73.8729, 40.9044]]]}}, {"type": "Feature", "properties": {"name": "Manhattan"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9264, 40.8776], [-73.9224, 40.8768], [-73.9213, 40.8731], [-73.9209, 40.8755], [-73.9104, 40.8715], [-73.9194, 40.8589], [-73.9216, 40.8601], [-73.9349, 40.8352], [-73.9343, 40.8096], [-73.929, 40.8011], [-73.9293, 40.7959], [-73.9432, 40.7833], [-73.9429, 40.7747], [-73.9714, 40.7438], [-73.9745, 40.7359], [-73.9715, 40.7274], [-73.9767, 40.7115], [-73.9981, 40.7085], [-74.0083, 40.7007], [-74.0151, 40.7003], [-74.0193, 40.7061], [-74.0167, 40.7186], [-74.0131, 40.7189], [-74.0117, 40.7259], [-74.0152, 40.7264], [-74.0115, 40.7264], [-74.0144, 40.7285], [-74.0109, 40.733], [-74.014, 40.7333], [-74.0107, 40.7334], [-74.0127, 40.7407], [-74.0095, 40.7407], [-74.0121, 40.7436], [-74.0089, 40.7439], [-74.0118, 40.7456], [-74.0095, 40.7458], [-74.0116, 40.7466], [-74.0092, 40.7468], [-74.0114, 40.7476], [-74.0091, 40.7478], [-74.01, 40.7529], [-74.0048, 40.7578], [-74.007, 40.7592], [-74.001, 40.7634], [-74.0031, 40.7647], [-73.9996, 40.7636], [-74.0023, 40.7656], [-73.9983, 40.7656], [-74.0016, 40.767], [-73.9981, 40.7659], [-74.0006, 40.7682], [-73.9972, 40.7671], [-73.9997, 40.7695], [-73.9971, 40.7687], [-73.999, 40.7705], [-73.9949, 40.7715], [-73.9967, 40.7735], [-73.9942, 40.7725], [-73.9962, 40.774], [-73.9923, 40.7751], [-73.9889, 40.7797], [-73.9916, 40.7796], [-73.9582, 40.8223], [-73.9461, 40.8439], [-73.947, 40.8505], [-73.9419, 40.8539], [-73.9264, 40.8776]]]}}, {"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.7667, 40.6143], [-73.7602, 40.6108], [-73.7616, 40.609], [-73.7458, 40.612], [-73.7382, 40.6027], [-73.7381, 40.5977], [-73.7418, 40.5967], [-73.7381, 40.5974], [-73.7376, 40.5944], [-73.8135, 40.5835], [-73.8703, 40.5642], [-73.9069, 40.5556], [-73.9407, 40.5418], [-73.9399, 40.5546], [-73.9262, 40.5616], [-73.912, 40.5659], [-73.9015, 40.563], [-73.8926, 40.5686], [-73.8778, 40.5688], [-73.8504, 40.5821], [-73.8393, 40.5819], [-73.8215, 40.5868], [-73.8096, 40.5936], [-73.8057, 40.5908], [-73.808, 40.5942], [-73.8024, 40.5926], [-73.8052, 40.5969], [-73.803, 40.5988], [-73.7864, 40.6032], [-73.7903, 40.5992], [-73.7898, 40.5947], [-73.7786, 40.6096], [-73.7742, 40.6089], [-73.7747, 40.6043], [-73.7813, 40.5978], [-73.775, 40.6017], [-73.7736, 40.5981], [-73.7681, 40.5978], [-73.7712, 40.5994], [-73.769, 40.6094], [-73.7742, 40.6118], [-73.7667, 40.6143]]]}}]}
# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, int]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, water_status) tuples.
  water_status: -1 = explicit not water, 0 = unset, 1 = water
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], row[2]) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], 0) for row in cursor.fetchall()]


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]], bool]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
        "is_water": is_water,
      }
      for qx, qy, corners, is_water in quadrant_polygons
    ]
  )

  # NYC boundary GeoJSON for the map
  nyc_boundary_json = json.dumps(NYC_BOUNDARY_GEOJSON)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.water {{
      background: rgba(59, 130, 246, 0.35);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch water"></div>
      <span>Water Tile</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state (red for land)
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state (land)
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for water tiles (blue)
    const waterStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.35,
      color: '#3b82f6',
      weight: 1.5,
      opacity: 0.7
    }};

    // Style for water hover state
    const waterHoverStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.6,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const style = q.is_water ? waterStyle : normalStyle;
      const hStyle = q.is_water ? waterHoverStyle : hoverStyle;
      const polygon = L.polygon(q.corners, style).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hStyle);
        const waterLabel = q.is_water ? ' <span style="color: #3b82f6;">üíß</span>' : '';
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
            ${{waterLabel}}
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(style);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    if (quadrants.length > 0) {{
      const allLatLngs = quadrants.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []
    water_count = 0

    for qx, qy, is_water in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners, is_water))

      if is_water:
        water_count += 1

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    if water_count > 0:
      print(f"   üíß {water_count} water tiles detected")

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")

  try:
    create_debug_map(generation_dir, output_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

```python
"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_nyc/e2e_generation/debug_map.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_nyc.e2e_generation.shared import calculate_offset

# Simplified NYC borough boundaries GeoJSON (all 5 boroughs)
# Source: NYC Open Data (dwillis/nyc-maps), simplified using Douglas-Peucker algorithm
# fmt: off
NYC_BOUNDARY_GEOJSON = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8205, 40.801], [-73.8137, 40.7971], [-73.7964, 40.7957], [-73.7928, 40.7888], [-73.7817, 40.7911], [-73.7833, 40.7949], [-73.7769, 40.7964], [-73.7706, 40.7885], [-73.7763, 40.7885], [-73.7668, 40.7798], [-73.7651, 40.7738], [-73.7447, 40.7566], [-73.7551, 40.7675], [-73.7555, 40.7777], [-73.7508, 40.7829], [-73.7013, 40.7508], [-73.7, 40.7392], [-73.7077, 40.7278], [-73.7303, 40.7222], [-73.7269, 40.71], [-73.7256, 40.6796], [-73.7283, 40.663], [-73.7252, 40.652], [-73.7414, 40.6469], [-73.74, 40.6351], [-73.7437, 40.639], [-73.747, 40.6369], [-73.7473, 40.6432], [-73.7548, 40.6478], [-73.7474, 40.6414], [-73.7486, 40.6354], [-73.765, 40.6294], [-73.7708, 40.62], [-73.7717, 40.6236], [-73.7752, 40.6193], [-73.7717, 40.6236], [-73.7792, 40.6273], [-73.7852, 40.6201], [-73.7809, 40.6136], [-73.7914, 40.6076], [-73.8008, 40.6119], [-73.7946, 40.6226], [-73.7897, 40.6226], [-73.7826, 40.6302], [-73.7895, 40.6343], [-73.7981, 40.631], [-73.7908, 40.6343], [-73.8212, 40.6491], [-73.8223, 40.6594], [-73.8113, 40.6606], [-73.8235, 40.6601], [-73.8231, 40.648], [-73.8309, 40.6516], [-73.8302, 40.6598], [-73.8319, 40.6549], [-73.831, 40.6582], [-73.8334, 40.6581], [-73.8311, 40.6486], [-73.8343, 40.6481], [-73.8387, 40.6625], [-73.8359, 40.6455], [-73.8495, 40.6441], [-73.8524, 40.6474], [-73.8494, 40.6514], [-73.8559, 40.6513], [-73.8614, 40.6564], [-73.8596, 40.6585], [-73.8632, 40.6583], [-73.8557, 40.6639], [-73.8576, 40.6717], [-73.8604, 40.6713], [-73.866, 40.6819], [-73.8689, 40.6952], [-73.8965, 40.6823], [-73.9058, 40.6941], [-73.9043, 40.6957], [-73.9219, 40.7094], [-73.9241, 40.7151], [-73.9206, 40.716], [-73.9252, 40.7223], [-73.9204, 40.7237], [-73.938, 40.7305], [-73.9459, 40.7375], [-73.9386, 40.7429], [-73.9472, 40.7379], [-73.9626, 40.7388], [-73.9568, 40.7488], [-73.9532, 40.7477], [-73.9562, 40.7497], [-73.9435, 40.7645], [-73.9349, 40.77], [-73.9378, 40.7736], [-73.9364, 40.7769], [-73.9286, 40.7766], [-73.9099, 40.7909], [-73.8959, 40.7856], [-73.9026, 40.7803], [-73.8944, 40.7842], [-73.8953, 40.7816], [-73.8917, 40.7822], [-73.8925, 40.7774], [-73.8918, 40.7749], [-73.8901, 40.7778], [-73.8895, 40.7735], [-73.8839, 40.7741], [-73.8849, 40.78], [-73.8787, 40.7806], [-73.8797, 40.7829], [-73.8752, 40.7815], [-73.8679, 40.7874], [-73.8726, 40.7808], [-73.8551, 40.7722], [-73.8582, 40.7703], [-73.8562, 40.7689], [-73.8628, 40.7668], [-73.8507, 40.7594], [-73.8391, 40.766], [-73.8478, 40.7668], [-73.8513, 40.7718], [-73.849, 40.778], [-73.8524, 40.7792], [-73.8492, 40.7823], [-73.8553, 40.782], [-73.8595, 40.7855], [-73.8528, 40.7882], [-73.8537, 40.794], [-73.8379, 40.7985], [-73.8403, 40.7976], [-73.8373, 40.789], [-73.8329, 40.7885], [-73.8279, 40.7929], [-73.8295, 40.7968], [-73.8205, 40.801]]]}}, {"type": "Feature", "properties": {"name": "Brooklyn"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9544, 40.7391], [-73.9292, 40.7274], [-73.9246, 40.7192], [-73.9322, 40.715], [-73.9333, 40.711], [-73.9304, 40.7087], [-73.9309, 40.7149], [-73.9236, 40.7173], [-73.9219, 40.7094], [-73.9043, 40.6957], [-73.9058, 40.6941], [-73.8965, 40.6823], [-73.8684, 40.6947], [-73.866, 40.6819], [-73.8604, 40.6713], [-73.8576, 40.6717], [-73.8557, 40.6639], [-73.8633, 40.6569], [-73.857, 40.6506], [-73.8572, 40.6437], [-73.8656, 40.6388], [-73.8793, 40.6546], [-73.868, 40.6381], [-73.8744, 40.6367], [-73.891, 40.6494], [-73.8771, 40.636], [-73.8836, 40.6309], [-73.8837, 40.6276], [-73.8875, 40.6283], [-73.8958, 40.6225], [-73.9175, 40.6314], [-73.8965, 40.6214], [-73.8959, 40.6145], [-73.891, 40.6128], [-73.894, 40.6112], [-73.8897, 40.6115], [-73.8933, 40.6067], [-73.8998, 40.6055], [-73.9013, 40.6117], [-73.9088, 40.6174], [-73.9016, 40.6058], [-73.9137, 40.604], [-73.9171, 40.6088], [-73.9142, 40.6149], [-73.9195, 40.6077], [-73.9089, 40.6016], [-73.884, 40.6056], [-73.8767, 40.5849], [-73.8797, 40.5801], [-73.8955, 40.5768], [-73.899, 40.5877], [-73.9115, 40.5861], [-73.9151, 40.5988], [-73.9215, 40.6019], [-73.9249, 40.5998], [-73.9302, 40.604], [-73.9321, 40.6027], [-73.9142, 40.5892], [-73.9248, 40.5856], [-73.9281, 40.5877], [-73.924, 40.5911], [-73.9286, 40.5886], [-73.9326, 40.5949], [-73.9313, 40.5868], [-73.9135, 40.5861], [-73.9125, 40.5834], [-73.9173, 40.5832], [-73.9115, 40.5818], [-73.9535, 40.583], [-73.9326, 40.5813], [-73.9311, 40.5762], [-74.0021, 40.5696], [-74.012, 40.5749], [-74.0119, 40.5797], [-74.006, 40.582], [-73.9884, 40.5788], [-73.986, 40.5817], [-73.9916, 40.5811], [-73.9903, 40.5846], [-74.0002, 40.5831], [-73.9941, 40.5887], [-74.0004, 40.5865], [-73.9984, 40.5935], [-74.036, 40.6093], [-74.0416, 40.6206], [-74.0368, 40.639], [-74.0388, 40.6396], [-74.0341, 40.6443], [-74.0282, 40.644], [-74.026, 40.6463], [-74.0294, 40.6488], [-74.0247, 40.6471], [-74.0261, 40.651], [-74.0229, 40.6512], [-74.0254, 40.6527], [-74.0212, 40.6508], [-74.0232, 40.6541], [-74.0179, 40.6541], [-74.0198, 40.6565], [-74.0167, 40.6553], [-74.0191, 40.6574], [-74.015, 40.657], [-74.0175, 40.6595], [-74.0155, 40.6608], [-74.0086, 40.6595], [-74.0096, 40.6633], [-74.0035, 40.6622], [-74.0077, 40.6648], [-73.9995, 40.6644], [-74.0029, 40.6665], [-73.9988, 40.6716], [-74.0029, 40.6673], [-74.007, 40.6661], [-74.0054, 40.6709], [-74.0075, 40.6671], [-74.0169, 40.6648], [-74.0193, 40.6716], [-74.0165, 40.6649], [-74.0103, 40.6691], [-74.0157, 40.671], [-74.013, 40.6733], [-74.0163, 40.6729], [-74.015, 40.6747], [-74.0188, 40.6723], [-74.0193, 40.6796], [-74.0128, 40.6836], [-74.013, 40.6804], [-74.0097, 40.6833], [-74.0119, 40.6839], [-74.001, 40.6901], [-73.9946, 40.7044], [-73.9783, 40.706], [-73.9757, 40.6996], [-73.9708, 40.7], [-73.9728, 40.7027], [-73.9695, 40.7005], [-73.9746, 40.7077], [-73.9711, 40.7059], [-73.9723, 40.7091], [-73.9675, 40.7034], [-73.97, 40.7105], [-73.9673, 40.717], [-73.9621, 40.7251], [-73.9579, 40.7246], [-73.9616, 40.7259], [-73.9623, 40.734], [-73.9544, 40.7391]], [[-73.9039, 40.6248], [-73.9039, 40.6248]]]}}, {"type": "Feature", "properties": {"name": "Staten Island"}, "geometry": {"type": "Polygon", "coordinates": [[[-74.0822, 40.6483], [-74.0717, 40.645], [-74.0703, 40.6425], [-74.0731, 40.6419], [-74.0702, 40.642], [-74.0729, 40.6409], [-74.07, 40.6411], [-74.0731, 40.6405], [-74.0735, 40.6372], [-74.0705, 40.6372], [-74.0734, 40.6369], [-74.073, 40.6303], [-74.068, 40.6288], [-74.0729, 40.63], [-74.0723, 40.6246], [-74.0538, 40.6059], [-74.0522, 40.5998], [-74.0734, 40.5783], [-74.091, 40.5667], [-74.1048, 40.553], [-74.1073, 40.5541], [-74.1128, 40.5479], [-74.1225, 40.5448], [-74.1369, 40.5293], [-74.1405, 40.535], [-74.1341, 40.5355], [-74.128, 40.5407], [-74.1307, 40.5463], [-74.1379, 40.546], [-74.1423, 40.5423], [-74.1413, 40.5371], [-74.1776, 40.5192], [-74.1848, 40.5193], [-74.1952, 40.51], [-74.1994, 40.513], [-74.2076, 40.5118], [-74.2176, 40.5033], [-74.2468, 40.4961], [-74.2532, 40.5001], [-74.2556, 40.5077], [-74.2535, 40.5117], [-74.2494, 40.517], [-74.2398, 40.5201], [-74.244, 40.5249], [-74.242, 40.5343], [-74.248, 40.5431], [-74.2307, 40.5556], [-74.2186, 40.5547], [-74.212, 40.5584], [-74.2046, 40.5893], [-74.1975, 40.5968], [-74.2028, 40.6083], [-74.2008, 40.6303], [-74.1946, 40.6374], [-74.18, 40.6453], [-74.1796, 40.6419], [-74.1744, 40.6451], [-74.1713, 40.6429], [-74.173, 40.6405], [-74.1661, 40.6424], [-74.1528, 40.6371], [-74.1514, 40.6394], [-74.1486, 40.6374], [-74.1344, 40.6419], [-74.127, 40.6393], [-74.1097, 40.6455], [-74.0822, 40.6483]]]}}, {"type": "Feature", "properties": {"name": "Bronx"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8729, 40.9044], [-73.8595, 40.9005], [-73.8511, 40.9104], [-73.8535, 40.9075], [-73.8414, 40.9042], [-73.8384, 40.8941], [-73.793, 40.8834], [-73.7974, 40.8751], [-73.8025, 40.8705], [-73.8034, 40.8725], [-73.803, 40.8692], [-73.8084, 40.8712], [-73.8031, 40.8658], [-73.7948, 40.8732], [-73.7929, 40.8793], [-73.7896, 40.8813], [-73.7844, 40.8784], [-73.7872, 40.8727], [-73.7836, 40.8738], [-73.7832, 40.8707], [-73.7914, 40.8681], [-73.7919, 40.8608], [-73.7987, 40.8549], [-73.8003, 40.8481], [-73.8042, 40.8533], [-73.8048, 40.8616], [-73.8077, 40.8585], [-73.8151, 40.8631], [-73.8123, 40.8542], [-73.8164, 40.8541], [-73.8171, 40.8513], [-73.815, 40.8455], [-73.8117, 40.8467], [-73.8144, 40.8431], [-73.8182, 40.8443], [-73.8147, 40.8414], [-73.8149, 40.831], [-73.8099, 40.8282], [-73.814, 40.8242], [-73.807, 40.8254], [-73.8046, 40.819], [-73.7974, 40.8158], [-73.803, 40.8124], [-73.807, 40.8165], [-73.8051, 40.8129], [-73.7909, 40.8073], [-73.7906, 40.8046], [-73.8162, 40.8138], [-73.8302, 40.8108], [-73.8316, 40.8049], [-73.8374, 40.8062], [-73.8423, 40.8291], [-73.8389, 40.8337], [-73.8397, 40.8396], [-73.8431, 40.8298], [-73.84, 40.8199], [-73.8462, 40.8107], [-73.8554, 40.8143], [-73.8491, 40.8123], [-73.8481, 40.8049], [-73.8561, 40.8046], [-73.8592, 40.8063], [-73.859, 40.8103], [-73.8594, 40.8082], [-73.8677, 40.8106], [-73.8765, 40.8161], [-73.8681, 40.8068], [-73.8723, 40.8002], [-73.8951, 40.8069], [-73.9022, 40.8049], [-73.9117, 40.7966], [-73.9276, 40.8027], [-73.9329, 40.8101], [-73.9331, 40.8352], [-73.9067, 40.8758], [-73.9103, 40.879], [-73.9178, 40.8757], [-73.9249, 40.8789], [-73.9115, 40.9138], [-73.8729, 40.9044]]]}}, {"type": "Feature", "properties": {"name": "Manhattan"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9264, 40.8776], [-73.9224, 40.8768], [-73.9213, 40.8731], [-73.9209, 40.8755], [-73.9104, 40.8715], [-73.9194, 40.8589], [-73.9216, 40.8601], [-73.9349, 40.8352], [-73.9343, 40.8096], [-73.929, 40.8011], [-73.9293, 40.7959], [-73.9432, 40.7833], [-73.9429, 40.7747], [-73.9714, 40.7438], [-73.9745, 40.7359], [-73.9715, 40.7274], [-73.9767, 40.7115], [-73.9981, 40.7085], [-74.0083, 40.7007], [-74.0151, 40.7003], [-74.0193, 40.7061], [-74.0167, 40.7186], [-74.0131, 40.7189], [-74.0117, 40.7259], [-74.0152, 40.7264], [-74.0115, 40.7264], [-74.0144, 40.7285], [-74.0109, 40.733], [-74.014, 40.7333], [-74.0107, 40.7334], [-74.0127, 40.7407], [-74.0095, 40.7407], [-74.0121, 40.7436], [-74.0089, 40.7439], [-74.0118, 40.7456], [-74.0095, 40.7458], [-74.0116, 40.7466], [-74.0092, 40.7468], [-74.0114, 40.7476], [-74.0091, 40.7478], [-74.01, 40.7529], [-74.0048, 40.7578], [-74.007, 40.7592], [-74.001, 40.7634], [-74.0031, 40.7647], [-73.9996, 40.7636], [-74.0023, 40.7656], [-73.9983, 40.7656], [-74.0016, 40.767], [-73.9981, 40.7659], [-74.0006, 40.7682], [-73.9972, 40.7671], [-73.9997, 40.7695], [-73.9971, 40.7687], [-73.999, 40.7705], [-73.9949, 40.7715], [-73.9967, 40.7735], [-73.9942, 40.7725], [-73.9962, 40.774], [-73.9923, 40.7751], [-73.9889, 40.7797], [-73.9916, 40.7796], [-73.9582, 40.8223], [-73.9461, 40.8439], [-73.947, 40.8505], [-73.9419, 40.8539], [-73.9264, 40.8776]]]}}, {"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.7667, 40.6143], [-73.7602, 40.6108], [-73.7616, 40.609], [-73.7458, 40.612], [-73.7382, 40.6027], [-73.7381, 40.5977], [-73.7418, 40.5967], [-73.7381, 40.5974], [-73.7376, 40.5944], [-73.8135, 40.5835], [-73.8703, 40.5642], [-73.9069, 40.5556], [-73.9407, 40.5418], [-73.9399, 40.5546], [-73.9262, 40.5616], [-73.912, 40.5659], [-73.9015, 40.563], [-73.8926, 40.5686], [-73.8778, 40.5688], [-73.8504, 40.5821], [-73.8393, 40.5819], [-73.8215, 40.5868], [-73.8096, 40.5936], [-73.8057, 40.5908], [-73.808, 40.5942], [-73.8024, 40.5926], [-73.8052, 40.5969], [-73.803, 40.5988], [-73.7864, 40.6032], [-73.7903, 40.5992], [-73.7898, 40.5947], [-73.7786, 40.6096], [-73.7742, 40.6089], [-73.7747, 40.6043], [-73.7813, 40.5978], [-73.775, 40.6017], [-73.7736, 40.5981], [-73.7681, 40.5978], [-73.7712, 40.5994], [-73.769, 40.6094], [-73.7742, 40.6118], [-73.7667, 40.6143]]]}}]}
# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, int]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, water_status) tuples.
  water_status: -1 = explicit not water, 0 = unset, 1 = water
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], row[2]) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], 0) for row in cursor.fetchall()]


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]], int]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  # water_status: -1 = explicit not water, 0 = unset, 1 = water
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
        "water_status": water_status,
      }
      for qx, qy, corners, water_status in quadrant_polygons
    ]
  )

  # NYC boundary GeoJSON for the map
  nyc_boundary_json = json.dumps(NYC_BOUNDARY_GEOJSON)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.water {{
      background: rgba(59, 130, 246, 0.35);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch water"></div>
      <span>Water Tile</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state (red for land)
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state (land)
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for water tiles (blue)
    const waterStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.35,
      color: '#3b82f6',
      weight: 1.5,
      opacity: 0.7
    }};

    // Style for water hover state
    const waterHoverStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.6,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const style = q.is_water ? waterStyle : normalStyle;
      const hStyle = q.is_water ? waterHoverStyle : hoverStyle;
      const polygon = L.polygon(q.corners, style).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hStyle);
        const waterLabel = q.is_water ? ' <span style="color: #3b82f6;">üíß</span>' : '';
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
            ${{waterLabel}}
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(style);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    if (quadrants.length > 0) {{
      const allLatLngs = quadrants.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []
    water_count = 0

    for qx, qy, is_water in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners, is_water))

      if is_water:
        water_count += 1

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    if water_count > 0:
      print(f"   üíß {water_count} water tiles detected")

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")

  try:
    create_debug_map(generation_dir, output_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

```python
"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_nyc/e2e_generation/debug_map.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_nyc.e2e_generation.shared import calculate_offset

# Simplified NYC borough boundaries GeoJSON (all 5 boroughs)
# Source: NYC Open Data (dwillis/nyc-maps), simplified using Douglas-Peucker algorithm
# fmt: off
NYC_BOUNDARY_GEOJSON = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8205, 40.801], [-73.8137, 40.7971], [-73.7964, 40.7957], [-73.7928, 40.7888], [-73.7817, 40.7911], [-73.7833, 40.7949], [-73.7769, 40.7964], [-73.7706, 40.7885], [-73.7763, 40.7885], [-73.7668, 40.7798], [-73.7651, 40.7738], [-73.7447, 40.7566], [-73.7551, 40.7675], [-73.7555, 40.7777], [-73.7508, 40.7829], [-73.7013, 40.7508], [-73.7, 40.7392], [-73.7077, 40.7278], [-73.7303, 40.7222], [-73.7269, 40.71], [-73.7256, 40.6796], [-73.7283, 40.663], [-73.7252, 40.652], [-73.7414, 40.6469], [-73.74, 40.6351], [-73.7437, 40.639], [-73.747, 40.6369], [-73.7473, 40.6432], [-73.7548, 40.6478], [-73.7474, 40.6414], [-73.7486, 40.6354], [-73.765, 40.6294], [-73.7708, 40.62], [-73.7717, 40.6236], [-73.7752, 40.6193], [-73.7717, 40.6236], [-73.7792, 40.6273], [-73.7852, 40.6201], [-73.7809, 40.6136], [-73.7914, 40.6076], [-73.8008, 40.6119], [-73.7946, 40.6226], [-73.7897, 40.6226], [-73.7826, 40.6302], [-73.7895, 40.6343], [-73.7981, 40.631], [-73.7908, 40.6343], [-73.8212, 40.6491], [-73.8223, 40.6594], [-73.8113, 40.6606], [-73.8235, 40.6601], [-73.8231, 40.648], [-73.8309, 40.6516], [-73.8302, 40.6598], [-73.8319, 40.6549], [-73.831, 40.6582], [-73.8334, 40.6581], [-73.8311, 40.6486], [-73.8343, 40.6481], [-73.8387, 40.6625], [-73.8359, 40.6455], [-73.8495, 40.6441], [-73.8524, 40.6474], [-73.8494, 40.6514], [-73.8559, 40.6513], [-73.8614, 40.6564], [-73.8596, 40.6585], [-73.8632, 40.6583], [-73.8557, 40.6639], [-73.8576, 40.6717], [-73.8604, 40.6713], [-73.866, 40.6819], [-73.8689, 40.6952], [-73.8965, 40.6823], [-73.9058, 40.6941], [-73.9043, 40.6957], [-73.9219, 40.7094], [-73.9241, 40.7151], [-73.9206, 40.716], [-73.9252, 40.7223], [-73.9204, 40.7237], [-73.938, 40.7305], [-73.9459, 40.7375], [-73.9386, 40.7429], [-73.9472, 40.7379], [-73.9626, 40.7388], [-73.9568, 40.7488], [-73.9532, 40.7477], [-73.9562, 40.7497], [-73.9435, 40.7645], [-73.9349, 40.77], [-73.9378, 40.7736], [-73.9364, 40.7769], [-73.9286, 40.7766], [-73.9099, 40.7909], [-73.8959, 40.7856], [-73.9026, 40.7803], [-73.8944, 40.7842], [-73.8953, 40.7816], [-73.8917, 40.7822], [-73.8925, 40.7774], [-73.8918, 40.7749], [-73.8901, 40.7778], [-73.8895, 40.7735], [-73.8839, 40.7741], [-73.8849, 40.78], [-73.8787, 40.7806], [-73.8797, 40.7829], [-73.8752, 40.7815], [-73.8679, 40.7874], [-73.8726, 40.7808], [-73.8551, 40.7722], [-73.8582, 40.7703], [-73.8562, 40.7689], [-73.8628, 40.7668], [-73.8507, 40.7594], [-73.8391, 40.766], [-73.8478, 40.7668], [-73.8513, 40.7718], [-73.849, 40.778], [-73.8524, 40.7792], [-73.8492, 40.7823], [-73.8553, 40.782], [-73.8595, 40.7855], [-73.8528, 40.7882], [-73.8537, 40.794], [-73.8379, 40.7985], [-73.8403, 40.7976], [-73.8373, 40.789], [-73.8329, 40.7885], [-73.8279, 40.7929], [-73.8295, 40.7968], [-73.8205, 40.801]]]}}, {"type": "Feature", "properties": {"name": "Brooklyn"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9544, 40.7391], [-73.9292, 40.7274], [-73.9246, 40.7192], [-73.9322, 40.715], [-73.9333, 40.711], [-73.9304, 40.7087], [-73.9309, 40.7149], [-73.9236, 40.7173], [-73.9219, 40.7094], [-73.9043, 40.6957], [-73.9058, 40.6941], [-73.8965, 40.6823], [-73.8684, 40.6947], [-73.866, 40.6819], [-73.8604, 40.6713], [-73.8576, 40.6717], [-73.8557, 40.6639], [-73.8633, 40.6569], [-73.857, 40.6506], [-73.8572, 40.6437], [-73.8656, 40.6388], [-73.8793, 40.6546], [-73.868, 40.6381], [-73.8744, 40.6367], [-73.891, 40.6494], [-73.8771, 40.636], [-73.8836, 40.6309], [-73.8837, 40.6276], [-73.8875, 40.6283], [-73.8958, 40.6225], [-73.9175, 40.6314], [-73.8965, 40.6214], [-73.8959, 40.6145], [-73.891, 40.6128], [-73.894, 40.6112], [-73.8897, 40.6115], [-73.8933, 40.6067], [-73.8998, 40.6055], [-73.9013, 40.6117], [-73.9088, 40.6174], [-73.9016, 40.6058], [-73.9137, 40.604], [-73.9171, 40.6088], [-73.9142, 40.6149], [-73.9195, 40.6077], [-73.9089, 40.6016], [-73.884, 40.6056], [-73.8767, 40.5849], [-73.8797, 40.5801], [-73.8955, 40.5768], [-73.899, 40.5877], [-73.9115, 40.5861], [-73.9151, 40.5988], [-73.9215, 40.6019], [-73.9249, 40.5998], [-73.9302, 40.604], [-73.9321, 40.6027], [-73.9142, 40.5892], [-73.9248, 40.5856], [-73.9281, 40.5877], [-73.924, 40.5911], [-73.9286, 40.5886], [-73.9326, 40.5949], [-73.9313, 40.5868], [-73.9135, 40.5861], [-73.9125, 40.5834], [-73.9173, 40.5832], [-73.9115, 40.5818], [-73.9535, 40.583], [-73.9326, 40.5813], [-73.9311, 40.5762], [-74.0021, 40.5696], [-74.012, 40.5749], [-74.0119, 40.5797], [-74.006, 40.582], [-73.9884, 40.5788], [-73.986, 40.5817], [-73.9916, 40.5811], [-73.9903, 40.5846], [-74.0002, 40.5831], [-73.9941, 40.5887], [-74.0004, 40.5865], [-73.9984, 40.5935], [-74.036, 40.6093], [-74.0416, 40.6206], [-74.0368, 40.639], [-74.0388, 40.6396], [-74.0341, 40.6443], [-74.0282, 40.644], [-74.026, 40.6463], [-74.0294, 40.6488], [-74.0247, 40.6471], [-74.0261, 40.651], [-74.0229, 40.6512], [-74.0254, 40.6527], [-74.0212, 40.6508], [-74.0232, 40.6541], [-74.0179, 40.6541], [-74.0198, 40.6565], [-74.0167, 40.6553], [-74.0191, 40.6574], [-74.015, 40.657], [-74.0175, 40.6595], [-74.0155, 40.6608], [-74.0086, 40.6595], [-74.0096, 40.6633], [-74.0035, 40.6622], [-74.0077, 40.6648], [-73.9995, 40.6644], [-74.0029, 40.6665], [-73.9988, 40.6716], [-74.0029, 40.6673], [-74.007, 40.6661], [-74.0054, 40.6709], [-74.0075, 40.6671], [-74.0169, 40.6648], [-74.0193, 40.6716], [-74.0165, 40.6649], [-74.0103, 40.6691], [-74.0157, 40.671], [-74.013, 40.6733], [-74.0163, 40.6729], [-74.015, 40.6747], [-74.0188, 40.6723], [-74.0193, 40.6796], [-74.0128, 40.6836], [-74.013, 40.6804], [-74.0097, 40.6833], [-74.0119, 40.6839], [-74.001, 40.6901], [-73.9946, 40.7044], [-73.9783, 40.706], [-73.9757, 40.6996], [-73.9708, 40.7], [-73.9728, 40.7027], [-73.9695, 40.7005], [-73.9746, 40.7077], [-73.9711, 40.7059], [-73.9723, 40.7091], [-73.9675, 40.7034], [-73.97, 40.7105], [-73.9673, 40.717], [-73.9621, 40.7251], [-73.9579, 40.7246], [-73.9616, 40.7259], [-73.9623, 40.734], [-73.9544, 40.7391]], [[-73.9039, 40.6248], [-73.9039, 40.6248]]]}}, {"type": "Feature", "properties": {"name": "Staten Island"}, "geometry": {"type": "Polygon", "coordinates": [[[-74.0822, 40.6483], [-74.0717, 40.645], [-74.0703, 40.6425], [-74.0731, 40.6419], [-74.0702, 40.642], [-74.0729, 40.6409], [-74.07, 40.6411], [-74.0731, 40.6405], [-74.0735, 40.6372], [-74.0705, 40.6372], [-74.0734, 40.6369], [-74.073, 40.6303], [-74.068, 40.6288], [-74.0729, 40.63], [-74.0723, 40.6246], [-74.0538, 40.6059], [-74.0522, 40.5998], [-74.0734, 40.5783], [-74.091, 40.5667], [-74.1048, 40.553], [-74.1073, 40.5541], [-74.1128, 40.5479], [-74.1225, 40.5448], [-74.1369, 40.5293], [-74.1405, 40.535], [-74.1341, 40.5355], [-74.128, 40.5407], [-74.1307, 40.5463], [-74.1379, 40.546], [-74.1423, 40.5423], [-74.1413, 40.5371], [-74.1776, 40.5192], [-74.1848, 40.5193], [-74.1952, 40.51], [-74.1994, 40.513], [-74.2076, 40.5118], [-74.2176, 40.5033], [-74.2468, 40.4961], [-74.2532, 40.5001], [-74.2556, 40.5077], [-74.2535, 40.5117], [-74.2494, 40.517], [-74.2398, 40.5201], [-74.244, 40.5249], [-74.242, 40.5343], [-74.248, 40.5431], [-74.2307, 40.5556], [-74.2186, 40.5547], [-74.212, 40.5584], [-74.2046, 40.5893], [-74.1975, 40.5968], [-74.2028, 40.6083], [-74.2008, 40.6303], [-74.1946, 40.6374], [-74.18, 40.6453], [-74.1796, 40.6419], [-74.1744, 40.6451], [-74.1713, 40.6429], [-74.173, 40.6405], [-74.1661, 40.6424], [-74.1528, 40.6371], [-74.1514, 40.6394], [-74.1486, 40.6374], [-74.1344, 40.6419], [-74.127, 40.6393], [-74.1097, 40.6455], [-74.0822, 40.6483]]]}}, {"type": "Feature", "properties": {"name": "Bronx"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8729, 40.9044], [-73.8595, 40.9005], [-73.8511, 40.9104], [-73.8535, 40.9075], [-73.8414, 40.9042], [-73.8384, 40.8941], [-73.793, 40.8834], [-73.7974, 40.8751], [-73.8025, 40.8705], [-73.8034, 40.8725], [-73.803, 40.8692], [-73.8084, 40.8712], [-73.8031, 40.8658], [-73.7948, 40.8732], [-73.7929, 40.8793], [-73.7896, 40.8813], [-73.7844, 40.8784], [-73.7872, 40.8727], [-73.7836, 40.8738], [-73.7832, 40.8707], [-73.7914, 40.8681], [-73.7919, 40.8608], [-73.7987, 40.8549], [-73.8003, 40.8481], [-73.8042, 40.8533], [-73.8048, 40.8616], [-73.8077, 40.8585], [-73.8151, 40.8631], [-73.8123, 40.8542], [-73.8164, 40.8541], [-73.8171, 40.8513], [-73.815, 40.8455], [-73.8117, 40.8467], [-73.8144, 40.8431], [-73.8182, 40.8443], [-73.8147, 40.8414], [-73.8149, 40.831], [-73.8099, 40.8282], [-73.814, 40.8242], [-73.807, 40.8254], [-73.8046, 40.819], [-73.7974, 40.8158], [-73.803, 40.8124], [-73.807, 40.8165], [-73.8051, 40.8129], [-73.7909, 40.8073], [-73.7906, 40.8046], [-73.8162, 40.8138], [-73.8302, 40.8108], [-73.8316, 40.8049], [-73.8374, 40.8062], [-73.8423, 40.8291], [-73.8389, 40.8337], [-73.8397, 40.8396], [-73.8431, 40.8298], [-73.84, 40.8199], [-73.8462, 40.8107], [-73.8554, 40.8143], [-73.8491, 40.8123], [-73.8481, 40.8049], [-73.8561, 40.8046], [-73.8592, 40.8063], [-73.859, 40.8103], [-73.8594, 40.8082], [-73.8677, 40.8106], [-73.8765, 40.8161], [-73.8681, 40.8068], [-73.8723, 40.8002], [-73.8951, 40.8069], [-73.9022, 40.8049], [-73.9117, 40.7966], [-73.9276, 40.8027], [-73.9329, 40.8101], [-73.9331, 40.8352], [-73.9067, 40.8758], [-73.9103, 40.879], [-73.9178, 40.8757], [-73.9249, 40.8789], [-73.9115, 40.9138], [-73.8729, 40.9044]]]}}, {"type": "Feature", "properties": {"name": "Manhattan"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9264, 40.8776], [-73.9224, 40.8768], [-73.9213, 40.8731], [-73.9209, 40.8755], [-73.9104, 40.8715], [-73.9194, 40.8589], [-73.9216, 40.8601], [-73.9349, 40.8352], [-73.9343, 40.8096], [-73.929, 40.8011], [-73.9293, 40.7959], [-73.9432, 40.7833], [-73.9429, 40.7747], [-73.9714, 40.7438], [-73.9745, 40.7359], [-73.9715, 40.7274], [-73.9767, 40.7115], [-73.9981, 40.7085], [-74.0083, 40.7007], [-74.0151, 40.7003], [-74.0193, 40.7061], [-74.0167, 40.7186], [-74.0131, 40.7189], [-74.0117, 40.7259], [-74.0152, 40.7264], [-74.0115, 40.7264], [-74.0144, 40.7285], [-74.0109, 40.733], [-74.014, 40.7333], [-74.0107, 40.7334], [-74.0127, 40.7407], [-74.0095, 40.7407], [-74.0121, 40.7436], [-74.0089, 40.7439], [-74.0118, 40.7456], [-74.0095, 40.7458], [-74.0116, 40.7466], [-74.0092, 40.7468], [-74.0114, 40.7476], [-74.0091, 40.7478], [-74.01, 40.7529], [-74.0048, 40.7578], [-74.007, 40.7592], [-74.001, 40.7634], [-74.0031, 40.7647], [-73.9996, 40.7636], [-74.0023, 40.7656], [-73.9983, 40.7656], [-74.0016, 40.767], [-73.9981, 40.7659], [-74.0006, 40.7682], [-73.9972, 40.7671], [-73.9997, 40.7695], [-73.9971, 40.7687], [-73.999, 40.7705], [-73.9949, 40.7715], [-73.9967, 40.7735], [-73.9942, 40.7725], [-73.9962, 40.774], [-73.9923, 40.7751], [-73.9889, 40.7797], [-73.9916, 40.7796], [-73.9582, 40.8223], [-73.9461, 40.8439], [-73.947, 40.8505], [-73.9419, 40.8539], [-73.9264, 40.8776]]]}}, {"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.7667, 40.6143], [-73.7602, 40.6108], [-73.7616, 40.609], [-73.7458, 40.612], [-73.7382, 40.6027], [-73.7381, 40.5977], [-73.7418, 40.5967], [-73.7381, 40.5974], [-73.7376, 40.5944], [-73.8135, 40.5835], [-73.8703, 40.5642], [-73.9069, 40.5556], [-73.9407, 40.5418], [-73.9399, 40.5546], [-73.9262, 40.5616], [-73.912, 40.5659], [-73.9015, 40.563], [-73.8926, 40.5686], [-73.8778, 40.5688], [-73.8504, 40.5821], [-73.8393, 40.5819], [-73.8215, 40.5868], [-73.8096, 40.5936], [-73.8057, 40.5908], [-73.808, 40.5942], [-73.8024, 40.5926], [-73.8052, 40.5969], [-73.803, 40.5988], [-73.7864, 40.6032], [-73.7903, 40.5992], [-73.7898, 40.5947], [-73.7786, 40.6096], [-73.7742, 40.6089], [-73.7747, 40.6043], [-73.7813, 40.5978], [-73.775, 40.6017], [-73.7736, 40.5981], [-73.7681, 40.5978], [-73.7712, 40.5994], [-73.769, 40.6094], [-73.7742, 40.6118], [-73.7667, 40.6143]]]}}]}
# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, int]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, water_status) tuples.
  water_status: -1 = explicit not water, 0 = unset, 1 = water
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], row[2]) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], 0) for row in cursor.fetchall()]


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]], int]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  # water_status: -1 = explicit not water, 0 = unset, 1 = water
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
        "water_status": water_status,
      }
      for qx, qy, corners, water_status in quadrant_polygons
    ]
  )

  # NYC boundary GeoJSON for the map
  nyc_boundary_json = json.dumps(NYC_BOUNDARY_GEOJSON)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.water {{
      background: rgba(59, 130, 246, 0.35);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}

    .legend-swatch.protected {{
      background: rgba(220, 38, 38, 0.25);
      border: 2px dashed rgba(220, 38, 38, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch water"></div>
      <span>Water Tile</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state (red for land)
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state (land)
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for water tiles (blue)
    const waterStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.35,
      color: '#3b82f6',
      weight: 1.5,
      opacity: 0.7
    }};

    // Style for water hover state
    const waterHoverStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.6,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const style = q.is_water ? waterStyle : normalStyle;
      const hStyle = q.is_water ? waterHoverStyle : hoverStyle;
      const polygon = L.polygon(q.corners, style).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hStyle);
        const waterLabel = q.is_water ? ' <span style="color: #3b82f6;">üíß</span>' : '';
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
            ${{waterLabel}}
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(style);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    if (quadrants.length > 0) {{
      const allLatLngs = quadrants.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []
    water_count = 0

    for qx, qy, is_water in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners, is_water))

      if is_water:
        water_count += 1

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    if water_count > 0:
      print(f"   üíß {water_count} water tiles detected")

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")

  try:
    create_debug_map(generation_dir, output_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

```python
"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_nyc/e2e_generation/debug_map.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_nyc.e2e_generation.shared import calculate_offset

# Simplified NYC borough boundaries GeoJSON (all 5 boroughs)
# Source: NYC Open Data (dwillis/nyc-maps), simplified using Douglas-Peucker algorithm
# fmt: off
NYC_BOUNDARY_GEOJSON = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8205, 40.801], [-73.8137, 40.7971], [-73.7964, 40.7957], [-73.7928, 40.7888], [-73.7817, 40.7911], [-73.7833, 40.7949], [-73.7769, 40.7964], [-73.7706, 40.7885], [-73.7763, 40.7885], [-73.7668, 40.7798], [-73.7651, 40.7738], [-73.7447, 40.7566], [-73.7551, 40.7675], [-73.7555, 40.7777], [-73.7508, 40.7829], [-73.7013, 40.7508], [-73.7, 40.7392], [-73.7077, 40.7278], [-73.7303, 40.7222], [-73.7269, 40.71], [-73.7256, 40.6796], [-73.7283, 40.663], [-73.7252, 40.652], [-73.7414, 40.6469], [-73.74, 40.6351], [-73.7437, 40.639], [-73.747, 40.6369], [-73.7473, 40.6432], [-73.7548, 40.6478], [-73.7474, 40.6414], [-73.7486, 40.6354], [-73.765, 40.6294], [-73.7708, 40.62], [-73.7717, 40.6236], [-73.7752, 40.6193], [-73.7717, 40.6236], [-73.7792, 40.6273], [-73.7852, 40.6201], [-73.7809, 40.6136], [-73.7914, 40.6076], [-73.8008, 40.6119], [-73.7946, 40.6226], [-73.7897, 40.6226], [-73.7826, 40.6302], [-73.7895, 40.6343], [-73.7981, 40.631], [-73.7908, 40.6343], [-73.8212, 40.6491], [-73.8223, 40.6594], [-73.8113, 40.6606], [-73.8235, 40.6601], [-73.8231, 40.648], [-73.8309, 40.6516], [-73.8302, 40.6598], [-73.8319, 40.6549], [-73.831, 40.6582], [-73.8334, 40.6581], [-73.8311, 40.6486], [-73.8343, 40.6481], [-73.8387, 40.6625], [-73.8359, 40.6455], [-73.8495, 40.6441], [-73.8524, 40.6474], [-73.8494, 40.6514], [-73.8559, 40.6513], [-73.8614, 40.6564], [-73.8596, 40.6585], [-73.8632, 40.6583], [-73.8557, 40.6639], [-73.8576, 40.6717], [-73.8604, 40.6713], [-73.866, 40.6819], [-73.8689, 40.6952], [-73.8965, 40.6823], [-73.9058, 40.6941], [-73.9043, 40.6957], [-73.9219, 40.7094], [-73.9241, 40.7151], [-73.9206, 40.716], [-73.9252, 40.7223], [-73.9204, 40.7237], [-73.938, 40.7305], [-73.9459, 40.7375], [-73.9386, 40.7429], [-73.9472, 40.7379], [-73.9626, 40.7388], [-73.9568, 40.7488], [-73.9532, 40.7477], [-73.9562, 40.7497], [-73.9435, 40.7645], [-73.9349, 40.77], [-73.9378, 40.7736], [-73.9364, 40.7769], [-73.9286, 40.7766], [-73.9099, 40.7909], [-73.8959, 40.7856], [-73.9026, 40.7803], [-73.8944, 40.7842], [-73.8953, 40.7816], [-73.8917, 40.7822], [-73.8925, 40.7774], [-73.8918, 40.7749], [-73.8901, 40.7778], [-73.8895, 40.7735], [-73.8839, 40.7741], [-73.8849, 40.78], [-73.8787, 40.7806], [-73.8797, 40.7829], [-73.8752, 40.7815], [-73.8679, 40.7874], [-73.8726, 40.7808], [-73.8551, 40.7722], [-73.8582, 40.7703], [-73.8562, 40.7689], [-73.8628, 40.7668], [-73.8507, 40.7594], [-73.8391, 40.766], [-73.8478, 40.7668], [-73.8513, 40.7718], [-73.849, 40.778], [-73.8524, 40.7792], [-73.8492, 40.7823], [-73.8553, 40.782], [-73.8595, 40.7855], [-73.8528, 40.7882], [-73.8537, 40.794], [-73.8379, 40.7985], [-73.8403, 40.7976], [-73.8373, 40.789], [-73.8329, 40.7885], [-73.8279, 40.7929], [-73.8295, 40.7968], [-73.8205, 40.801]]]}}, {"type": "Feature", "properties": {"name": "Brooklyn"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9544, 40.7391], [-73.9292, 40.7274], [-73.9246, 40.7192], [-73.9322, 40.715], [-73.9333, 40.711], [-73.9304, 40.7087], [-73.9309, 40.7149], [-73.9236, 40.7173], [-73.9219, 40.7094], [-73.9043, 40.6957], [-73.9058, 40.6941], [-73.8965, 40.6823], [-73.8684, 40.6947], [-73.866, 40.6819], [-73.8604, 40.6713], [-73.8576, 40.6717], [-73.8557, 40.6639], [-73.8633, 40.6569], [-73.857, 40.6506], [-73.8572, 40.6437], [-73.8656, 40.6388], [-73.8793, 40.6546], [-73.868, 40.6381], [-73.8744, 40.6367], [-73.891, 40.6494], [-73.8771, 40.636], [-73.8836, 40.6309], [-73.8837, 40.6276], [-73.8875, 40.6283], [-73.8958, 40.6225], [-73.9175, 40.6314], [-73.8965, 40.6214], [-73.8959, 40.6145], [-73.891, 40.6128], [-73.894, 40.6112], [-73.8897, 40.6115], [-73.8933, 40.6067], [-73.8998, 40.6055], [-73.9013, 40.6117], [-73.9088, 40.6174], [-73.9016, 40.6058], [-73.9137, 40.604], [-73.9171, 40.6088], [-73.9142, 40.6149], [-73.9195, 40.6077], [-73.9089, 40.6016], [-73.884, 40.6056], [-73.8767, 40.5849], [-73.8797, 40.5801], [-73.8955, 40.5768], [-73.899, 40.5877], [-73.9115, 40.5861], [-73.9151, 40.5988], [-73.9215, 40.6019], [-73.9249, 40.5998], [-73.9302, 40.604], [-73.9321, 40.6027], [-73.9142, 40.5892], [-73.9248, 40.5856], [-73.9281, 40.5877], [-73.924, 40.5911], [-73.9286, 40.5886], [-73.9326, 40.5949], [-73.9313, 40.5868], [-73.9135, 40.5861], [-73.9125, 40.5834], [-73.9173, 40.5832], [-73.9115, 40.5818], [-73.9535, 40.583], [-73.9326, 40.5813], [-73.9311, 40.5762], [-74.0021, 40.5696], [-74.012, 40.5749], [-74.0119, 40.5797], [-74.006, 40.582], [-73.9884, 40.5788], [-73.986, 40.5817], [-73.9916, 40.5811], [-73.9903, 40.5846], [-74.0002, 40.5831], [-73.9941, 40.5887], [-74.0004, 40.5865], [-73.9984, 40.5935], [-74.036, 40.6093], [-74.0416, 40.6206], [-74.0368, 40.639], [-74.0388, 40.6396], [-74.0341, 40.6443], [-74.0282, 40.644], [-74.026, 40.6463], [-74.0294, 40.6488], [-74.0247, 40.6471], [-74.0261, 40.651], [-74.0229, 40.6512], [-74.0254, 40.6527], [-74.0212, 40.6508], [-74.0232, 40.6541], [-74.0179, 40.6541], [-74.0198, 40.6565], [-74.0167, 40.6553], [-74.0191, 40.6574], [-74.015, 40.657], [-74.0175, 40.6595], [-74.0155, 40.6608], [-74.0086, 40.6595], [-74.0096, 40.6633], [-74.0035, 40.6622], [-74.0077, 40.6648], [-73.9995, 40.6644], [-74.0029, 40.6665], [-73.9988, 40.6716], [-74.0029, 40.6673], [-74.007, 40.6661], [-74.0054, 40.6709], [-74.0075, 40.6671], [-74.0169, 40.6648], [-74.0193, 40.6716], [-74.0165, 40.6649], [-74.0103, 40.6691], [-74.0157, 40.671], [-74.013, 40.6733], [-74.0163, 40.6729], [-74.015, 40.6747], [-74.0188, 40.6723], [-74.0193, 40.6796], [-74.0128, 40.6836], [-74.013, 40.6804], [-74.0097, 40.6833], [-74.0119, 40.6839], [-74.001, 40.6901], [-73.9946, 40.7044], [-73.9783, 40.706], [-73.9757, 40.6996], [-73.9708, 40.7], [-73.9728, 40.7027], [-73.9695, 40.7005], [-73.9746, 40.7077], [-73.9711, 40.7059], [-73.9723, 40.7091], [-73.9675, 40.7034], [-73.97, 40.7105], [-73.9673, 40.717], [-73.9621, 40.7251], [-73.9579, 40.7246], [-73.9616, 40.7259], [-73.9623, 40.734], [-73.9544, 40.7391]], [[-73.9039, 40.6248], [-73.9039, 40.6248]]]}}, {"type": "Feature", "properties": {"name": "Staten Island"}, "geometry": {"type": "Polygon", "coordinates": [[[-74.0822, 40.6483], [-74.0717, 40.645], [-74.0703, 40.6425], [-74.0731, 40.6419], [-74.0702, 40.642], [-74.0729, 40.6409], [-74.07, 40.6411], [-74.0731, 40.6405], [-74.0735, 40.6372], [-74.0705, 40.6372], [-74.0734, 40.6369], [-74.073, 40.6303], [-74.068, 40.6288], [-74.0729, 40.63], [-74.0723, 40.6246], [-74.0538, 40.6059], [-74.0522, 40.5998], [-74.0734, 40.5783], [-74.091, 40.5667], [-74.1048, 40.553], [-74.1073, 40.5541], [-74.1128, 40.5479], [-74.1225, 40.5448], [-74.1369, 40.5293], [-74.1405, 40.535], [-74.1341, 40.5355], [-74.128, 40.5407], [-74.1307, 40.5463], [-74.1379, 40.546], [-74.1423, 40.5423], [-74.1413, 40.5371], [-74.1776, 40.5192], [-74.1848, 40.5193], [-74.1952, 40.51], [-74.1994, 40.513], [-74.2076, 40.5118], [-74.2176, 40.5033], [-74.2468, 40.4961], [-74.2532, 40.5001], [-74.2556, 40.5077], [-74.2535, 40.5117], [-74.2494, 40.517], [-74.2398, 40.5201], [-74.244, 40.5249], [-74.242, 40.5343], [-74.248, 40.5431], [-74.2307, 40.5556], [-74.2186, 40.5547], [-74.212, 40.5584], [-74.2046, 40.5893], [-74.1975, 40.5968], [-74.2028, 40.6083], [-74.2008, 40.6303], [-74.1946, 40.6374], [-74.18, 40.6453], [-74.1796, 40.6419], [-74.1744, 40.6451], [-74.1713, 40.6429], [-74.173, 40.6405], [-74.1661, 40.6424], [-74.1528, 40.6371], [-74.1514, 40.6394], [-74.1486, 40.6374], [-74.1344, 40.6419], [-74.127, 40.6393], [-74.1097, 40.6455], [-74.0822, 40.6483]]]}}, {"type": "Feature", "properties": {"name": "Bronx"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8729, 40.9044], [-73.8595, 40.9005], [-73.8511, 40.9104], [-73.8535, 40.9075], [-73.8414, 40.9042], [-73.8384, 40.8941], [-73.793, 40.8834], [-73.7974, 40.8751], [-73.8025, 40.8705], [-73.8034, 40.8725], [-73.803, 40.8692], [-73.8084, 40.8712], [-73.8031, 40.8658], [-73.7948, 40.8732], [-73.7929, 40.8793], [-73.7896, 40.8813], [-73.7844, 40.8784], [-73.7872, 40.8727], [-73.7836, 40.8738], [-73.7832, 40.8707], [-73.7914, 40.8681], [-73.7919, 40.8608], [-73.7987, 40.8549], [-73.8003, 40.8481], [-73.8042, 40.8533], [-73.8048, 40.8616], [-73.8077, 40.8585], [-73.8151, 40.8631], [-73.8123, 40.8542], [-73.8164, 40.8541], [-73.8171, 40.8513], [-73.815, 40.8455], [-73.8117, 40.8467], [-73.8144, 40.8431], [-73.8182, 40.8443], [-73.8147, 40.8414], [-73.8149, 40.831], [-73.8099, 40.8282], [-73.814, 40.8242], [-73.807, 40.8254], [-73.8046, 40.819], [-73.7974, 40.8158], [-73.803, 40.8124], [-73.807, 40.8165], [-73.8051, 40.8129], [-73.7909, 40.8073], [-73.7906, 40.8046], [-73.8162, 40.8138], [-73.8302, 40.8108], [-73.8316, 40.8049], [-73.8374, 40.8062], [-73.8423, 40.8291], [-73.8389, 40.8337], [-73.8397, 40.8396], [-73.8431, 40.8298], [-73.84, 40.8199], [-73.8462, 40.8107], [-73.8554, 40.8143], [-73.8491, 40.8123], [-73.8481, 40.8049], [-73.8561, 40.8046], [-73.8592, 40.8063], [-73.859, 40.8103], [-73.8594, 40.8082], [-73.8677, 40.8106], [-73.8765, 40.8161], [-73.8681, 40.8068], [-73.8723, 40.8002], [-73.8951, 40.8069], [-73.9022, 40.8049], [-73.9117, 40.7966], [-73.9276, 40.8027], [-73.9329, 40.8101], [-73.9331, 40.8352], [-73.9067, 40.8758], [-73.9103, 40.879], [-73.9178, 40.8757], [-73.9249, 40.8789], [-73.9115, 40.9138], [-73.8729, 40.9044]]]}}, {"type": "Feature", "properties": {"name": "Manhattan"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9264, 40.8776], [-73.9224, 40.8768], [-73.9213, 40.8731], [-73.9209, 40.8755], [-73.9104, 40.8715], [-73.9194, 40.8589], [-73.9216, 40.8601], [-73.9349, 40.8352], [-73.9343, 40.8096], [-73.929, 40.8011], [-73.9293, 40.7959], [-73.9432, 40.7833], [-73.9429, 40.7747], [-73.9714, 40.7438], [-73.9745, 40.7359], [-73.9715, 40.7274], [-73.9767, 40.7115], [-73.9981, 40.7085], [-74.0083, 40.7007], [-74.0151, 40.7003], [-74.0193, 40.7061], [-74.0167, 40.7186], [-74.0131, 40.7189], [-74.0117, 40.7259], [-74.0152, 40.7264], [-74.0115, 40.7264], [-74.0144, 40.7285], [-74.0109, 40.733], [-74.014, 40.7333], [-74.0107, 40.7334], [-74.0127, 40.7407], [-74.0095, 40.7407], [-74.0121, 40.7436], [-74.0089, 40.7439], [-74.0118, 40.7456], [-74.0095, 40.7458], [-74.0116, 40.7466], [-74.0092, 40.7468], [-74.0114, 40.7476], [-74.0091, 40.7478], [-74.01, 40.7529], [-74.0048, 40.7578], [-74.007, 40.7592], [-74.001, 40.7634], [-74.0031, 40.7647], [-73.9996, 40.7636], [-74.0023, 40.7656], [-73.9983, 40.7656], [-74.0016, 40.767], [-73.9981, 40.7659], [-74.0006, 40.7682], [-73.9972, 40.7671], [-73.9997, 40.7695], [-73.9971, 40.7687], [-73.999, 40.7705], [-73.9949, 40.7715], [-73.9967, 40.7735], [-73.9942, 40.7725], [-73.9962, 40.774], [-73.9923, 40.7751], [-73.9889, 40.7797], [-73.9916, 40.7796], [-73.9582, 40.8223], [-73.9461, 40.8439], [-73.947, 40.8505], [-73.9419, 40.8539], [-73.9264, 40.8776]]]}}, {"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.7667, 40.6143], [-73.7602, 40.6108], [-73.7616, 40.609], [-73.7458, 40.612], [-73.7382, 40.6027], [-73.7381, 40.5977], [-73.7418, 40.5967], [-73.7381, 40.5974], [-73.7376, 40.5944], [-73.8135, 40.5835], [-73.8703, 40.5642], [-73.9069, 40.5556], [-73.9407, 40.5418], [-73.9399, 40.5546], [-73.9262, 40.5616], [-73.912, 40.5659], [-73.9015, 40.563], [-73.8926, 40.5686], [-73.8778, 40.5688], [-73.8504, 40.5821], [-73.8393, 40.5819], [-73.8215, 40.5868], [-73.8096, 40.5936], [-73.8057, 40.5908], [-73.808, 40.5942], [-73.8024, 40.5926], [-73.8052, 40.5969], [-73.803, 40.5988], [-73.7864, 40.6032], [-73.7903, 40.5992], [-73.7898, 40.5947], [-73.7786, 40.6096], [-73.7742, 40.6089], [-73.7747, 40.6043], [-73.7813, 40.5978], [-73.775, 40.6017], [-73.7736, 40.5981], [-73.7681, 40.5978], [-73.7712, 40.5994], [-73.769, 40.6094], [-73.7742, 40.6118], [-73.7667, 40.6143]]]}}]}
# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, int]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, water_status) tuples.
  water_status: -1 = explicit not water, 0 = unset, 1 = water
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], row[2]) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], 0) for row in cursor.fetchall()]


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]], int]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  # water_status: -1 = explicit not water, 0 = unset, 1 = water
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
        "water_status": water_status,
      }
      for qx, qy, corners, water_status in quadrant_polygons
    ]
  )

  # NYC boundary GeoJSON for the map
  nyc_boundary_json = json.dumps(NYC_BOUNDARY_GEOJSON)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.water {{
      background: rgba(59, 130, 246, 0.35);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}

    .legend-swatch.protected {{
      background: rgba(220, 38, 38, 0.25);
      border: 2px dashed rgba(220, 38, 38, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch water"></div>
      <span>Water Tile</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch protected"></div>
      <span>Protected (Not Water)</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state (red for land)
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state (land)
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for water tiles (blue)
    const waterStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.35,
      color: '#3b82f6',
      weight: 1.5,
      opacity: 0.7
    }};

    // Style for water hover state
    const waterHoverStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.6,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const style = q.is_water ? waterStyle : normalStyle;
      const hStyle = q.is_water ? waterHoverStyle : hoverStyle;
      const polygon = L.polygon(q.corners, style).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hStyle);
        const waterLabel = q.is_water ? ' <span style="color: #3b82f6;">üíß</span>' : '';
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
            ${{waterLabel}}
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(style);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    if (quadrants.length > 0) {{
      const allLatLngs = quadrants.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []
    water_count = 0

    for qx, qy, is_water in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners, is_water))

      if is_water:
        water_count += 1

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    if water_count > 0:
      print(f"   üíß {water_count} water tiles detected")

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")

  try:
    create_debug_map(generation_dir, output_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

```python
"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_nyc/e2e_generation/debug_map.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_nyc.e2e_generation.shared import calculate_offset

# Simplified NYC borough boundaries GeoJSON (all 5 boroughs)
# Source: NYC Open Data (dwillis/nyc-maps), simplified using Douglas-Peucker algorithm
# fmt: off
NYC_BOUNDARY_GEOJSON = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8205, 40.801], [-73.8137, 40.7971], [-73.7964, 40.7957], [-73.7928, 40.7888], [-73.7817, 40.7911], [-73.7833, 40.7949], [-73.7769, 40.7964], [-73.7706, 40.7885], [-73.7763, 40.7885], [-73.7668, 40.7798], [-73.7651, 40.7738], [-73.7447, 40.7566], [-73.7551, 40.7675], [-73.7555, 40.7777], [-73.7508, 40.7829], [-73.7013, 40.7508], [-73.7, 40.7392], [-73.7077, 40.7278], [-73.7303, 40.7222], [-73.7269, 40.71], [-73.7256, 40.6796], [-73.7283, 40.663], [-73.7252, 40.652], [-73.7414, 40.6469], [-73.74, 40.6351], [-73.7437, 40.639], [-73.747, 40.6369], [-73.7473, 40.6432], [-73.7548, 40.6478], [-73.7474, 40.6414], [-73.7486, 40.6354], [-73.765, 40.6294], [-73.7708, 40.62], [-73.7717, 40.6236], [-73.7752, 40.6193], [-73.7717, 40.6236], [-73.7792, 40.6273], [-73.7852, 40.6201], [-73.7809, 40.6136], [-73.7914, 40.6076], [-73.8008, 40.6119], [-73.7946, 40.6226], [-73.7897, 40.6226], [-73.7826, 40.6302], [-73.7895, 40.6343], [-73.7981, 40.631], [-73.7908, 40.6343], [-73.8212, 40.6491], [-73.8223, 40.6594], [-73.8113, 40.6606], [-73.8235, 40.6601], [-73.8231, 40.648], [-73.8309, 40.6516], [-73.8302, 40.6598], [-73.8319, 40.6549], [-73.831, 40.6582], [-73.8334, 40.6581], [-73.8311, 40.6486], [-73.8343, 40.6481], [-73.8387, 40.6625], [-73.8359, 40.6455], [-73.8495, 40.6441], [-73.8524, 40.6474], [-73.8494, 40.6514], [-73.8559, 40.6513], [-73.8614, 40.6564], [-73.8596, 40.6585], [-73.8632, 40.6583], [-73.8557, 40.6639], [-73.8576, 40.6717], [-73.8604, 40.6713], [-73.866, 40.6819], [-73.8689, 40.6952], [-73.8965, 40.6823], [-73.9058, 40.6941], [-73.9043, 40.6957], [-73.9219, 40.7094], [-73.9241, 40.7151], [-73.9206, 40.716], [-73.9252, 40.7223], [-73.9204, 40.7237], [-73.938, 40.7305], [-73.9459, 40.7375], [-73.9386, 40.7429], [-73.9472, 40.7379], [-73.9626, 40.7388], [-73.9568, 40.7488], [-73.9532, 40.7477], [-73.9562, 40.7497], [-73.9435, 40.7645], [-73.9349, 40.77], [-73.9378, 40.7736], [-73.9364, 40.7769], [-73.9286, 40.7766], [-73.9099, 40.7909], [-73.8959, 40.7856], [-73.9026, 40.7803], [-73.8944, 40.7842], [-73.8953, 40.7816], [-73.8917, 40.7822], [-73.8925, 40.7774], [-73.8918, 40.7749], [-73.8901, 40.7778], [-73.8895, 40.7735], [-73.8839, 40.7741], [-73.8849, 40.78], [-73.8787, 40.7806], [-73.8797, 40.7829], [-73.8752, 40.7815], [-73.8679, 40.7874], [-73.8726, 40.7808], [-73.8551, 40.7722], [-73.8582, 40.7703], [-73.8562, 40.7689], [-73.8628, 40.7668], [-73.8507, 40.7594], [-73.8391, 40.766], [-73.8478, 40.7668], [-73.8513, 40.7718], [-73.849, 40.778], [-73.8524, 40.7792], [-73.8492, 40.7823], [-73.8553, 40.782], [-73.8595, 40.7855], [-73.8528, 40.7882], [-73.8537, 40.794], [-73.8379, 40.7985], [-73.8403, 40.7976], [-73.8373, 40.789], [-73.8329, 40.7885], [-73.8279, 40.7929], [-73.8295, 40.7968], [-73.8205, 40.801]]]}}, {"type": "Feature", "properties": {"name": "Brooklyn"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9544, 40.7391], [-73.9292, 40.7274], [-73.9246, 40.7192], [-73.9322, 40.715], [-73.9333, 40.711], [-73.9304, 40.7087], [-73.9309, 40.7149], [-73.9236, 40.7173], [-73.9219, 40.7094], [-73.9043, 40.6957], [-73.9058, 40.6941], [-73.8965, 40.6823], [-73.8684, 40.6947], [-73.866, 40.6819], [-73.8604, 40.6713], [-73.8576, 40.6717], [-73.8557, 40.6639], [-73.8633, 40.6569], [-73.857, 40.6506], [-73.8572, 40.6437], [-73.8656, 40.6388], [-73.8793, 40.6546], [-73.868, 40.6381], [-73.8744, 40.6367], [-73.891, 40.6494], [-73.8771, 40.636], [-73.8836, 40.6309], [-73.8837, 40.6276], [-73.8875, 40.6283], [-73.8958, 40.6225], [-73.9175, 40.6314], [-73.8965, 40.6214], [-73.8959, 40.6145], [-73.891, 40.6128], [-73.894, 40.6112], [-73.8897, 40.6115], [-73.8933, 40.6067], [-73.8998, 40.6055], [-73.9013, 40.6117], [-73.9088, 40.6174], [-73.9016, 40.6058], [-73.9137, 40.604], [-73.9171, 40.6088], [-73.9142, 40.6149], [-73.9195, 40.6077], [-73.9089, 40.6016], [-73.884, 40.6056], [-73.8767, 40.5849], [-73.8797, 40.5801], [-73.8955, 40.5768], [-73.899, 40.5877], [-73.9115, 40.5861], [-73.9151, 40.5988], [-73.9215, 40.6019], [-73.9249, 40.5998], [-73.9302, 40.604], [-73.9321, 40.6027], [-73.9142, 40.5892], [-73.9248, 40.5856], [-73.9281, 40.5877], [-73.924, 40.5911], [-73.9286, 40.5886], [-73.9326, 40.5949], [-73.9313, 40.5868], [-73.9135, 40.5861], [-73.9125, 40.5834], [-73.9173, 40.5832], [-73.9115, 40.5818], [-73.9535, 40.583], [-73.9326, 40.5813], [-73.9311, 40.5762], [-74.0021, 40.5696], [-74.012, 40.5749], [-74.0119, 40.5797], [-74.006, 40.582], [-73.9884, 40.5788], [-73.986, 40.5817], [-73.9916, 40.5811], [-73.9903, 40.5846], [-74.0002, 40.5831], [-73.9941, 40.5887], [-74.0004, 40.5865], [-73.9984, 40.5935], [-74.036, 40.6093], [-74.0416, 40.6206], [-74.0368, 40.639], [-74.0388, 40.6396], [-74.0341, 40.6443], [-74.0282, 40.644], [-74.026, 40.6463], [-74.0294, 40.6488], [-74.0247, 40.6471], [-74.0261, 40.651], [-74.0229, 40.6512], [-74.0254, 40.6527], [-74.0212, 40.6508], [-74.0232, 40.6541], [-74.0179, 40.6541], [-74.0198, 40.6565], [-74.0167, 40.6553], [-74.0191, 40.6574], [-74.015, 40.657], [-74.0175, 40.6595], [-74.0155, 40.6608], [-74.0086, 40.6595], [-74.0096, 40.6633], [-74.0035, 40.6622], [-74.0077, 40.6648], [-73.9995, 40.6644], [-74.0029, 40.6665], [-73.9988, 40.6716], [-74.0029, 40.6673], [-74.007, 40.6661], [-74.0054, 40.6709], [-74.0075, 40.6671], [-74.0169, 40.6648], [-74.0193, 40.6716], [-74.0165, 40.6649], [-74.0103, 40.6691], [-74.0157, 40.671], [-74.013, 40.6733], [-74.0163, 40.6729], [-74.015, 40.6747], [-74.0188, 40.6723], [-74.0193, 40.6796], [-74.0128, 40.6836], [-74.013, 40.6804], [-74.0097, 40.6833], [-74.0119, 40.6839], [-74.001, 40.6901], [-73.9946, 40.7044], [-73.9783, 40.706], [-73.9757, 40.6996], [-73.9708, 40.7], [-73.9728, 40.7027], [-73.9695, 40.7005], [-73.9746, 40.7077], [-73.9711, 40.7059], [-73.9723, 40.7091], [-73.9675, 40.7034], [-73.97, 40.7105], [-73.9673, 40.717], [-73.9621, 40.7251], [-73.9579, 40.7246], [-73.9616, 40.7259], [-73.9623, 40.734], [-73.9544, 40.7391]], [[-73.9039, 40.6248], [-73.9039, 40.6248]]]}}, {"type": "Feature", "properties": {"name": "Staten Island"}, "geometry": {"type": "Polygon", "coordinates": [[[-74.0822, 40.6483], [-74.0717, 40.645], [-74.0703, 40.6425], [-74.0731, 40.6419], [-74.0702, 40.642], [-74.0729, 40.6409], [-74.07, 40.6411], [-74.0731, 40.6405], [-74.0735, 40.6372], [-74.0705, 40.6372], [-74.0734, 40.6369], [-74.073, 40.6303], [-74.068, 40.6288], [-74.0729, 40.63], [-74.0723, 40.6246], [-74.0538, 40.6059], [-74.0522, 40.5998], [-74.0734, 40.5783], [-74.091, 40.5667], [-74.1048, 40.553], [-74.1073, 40.5541], [-74.1128, 40.5479], [-74.1225, 40.5448], [-74.1369, 40.5293], [-74.1405, 40.535], [-74.1341, 40.5355], [-74.128, 40.5407], [-74.1307, 40.5463], [-74.1379, 40.546], [-74.1423, 40.5423], [-74.1413, 40.5371], [-74.1776, 40.5192], [-74.1848, 40.5193], [-74.1952, 40.51], [-74.1994, 40.513], [-74.2076, 40.5118], [-74.2176, 40.5033], [-74.2468, 40.4961], [-74.2532, 40.5001], [-74.2556, 40.5077], [-74.2535, 40.5117], [-74.2494, 40.517], [-74.2398, 40.5201], [-74.244, 40.5249], [-74.242, 40.5343], [-74.248, 40.5431], [-74.2307, 40.5556], [-74.2186, 40.5547], [-74.212, 40.5584], [-74.2046, 40.5893], [-74.1975, 40.5968], [-74.2028, 40.6083], [-74.2008, 40.6303], [-74.1946, 40.6374], [-74.18, 40.6453], [-74.1796, 40.6419], [-74.1744, 40.6451], [-74.1713, 40.6429], [-74.173, 40.6405], [-74.1661, 40.6424], [-74.1528, 40.6371], [-74.1514, 40.6394], [-74.1486, 40.6374], [-74.1344, 40.6419], [-74.127, 40.6393], [-74.1097, 40.6455], [-74.0822, 40.6483]]]}}, {"type": "Feature", "properties": {"name": "Bronx"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8729, 40.9044], [-73.8595, 40.9005], [-73.8511, 40.9104], [-73.8535, 40.9075], [-73.8414, 40.9042], [-73.8384, 40.8941], [-73.793, 40.8834], [-73.7974, 40.8751], [-73.8025, 40.8705], [-73.8034, 40.8725], [-73.803, 40.8692], [-73.8084, 40.8712], [-73.8031, 40.8658], [-73.7948, 40.8732], [-73.7929, 40.8793], [-73.7896, 40.8813], [-73.7844, 40.8784], [-73.7872, 40.8727], [-73.7836, 40.8738], [-73.7832, 40.8707], [-73.7914, 40.8681], [-73.7919, 40.8608], [-73.7987, 40.8549], [-73.8003, 40.8481], [-73.8042, 40.8533], [-73.8048, 40.8616], [-73.8077, 40.8585], [-73.8151, 40.8631], [-73.8123, 40.8542], [-73.8164, 40.8541], [-73.8171, 40.8513], [-73.815, 40.8455], [-73.8117, 40.8467], [-73.8144, 40.8431], [-73.8182, 40.8443], [-73.8147, 40.8414], [-73.8149, 40.831], [-73.8099, 40.8282], [-73.814, 40.8242], [-73.807, 40.8254], [-73.8046, 40.819], [-73.7974, 40.8158], [-73.803, 40.8124], [-73.807, 40.8165], [-73.8051, 40.8129], [-73.7909, 40.8073], [-73.7906, 40.8046], [-73.8162, 40.8138], [-73.8302, 40.8108], [-73.8316, 40.8049], [-73.8374, 40.8062], [-73.8423, 40.8291], [-73.8389, 40.8337], [-73.8397, 40.8396], [-73.8431, 40.8298], [-73.84, 40.8199], [-73.8462, 40.8107], [-73.8554, 40.8143], [-73.8491, 40.8123], [-73.8481, 40.8049], [-73.8561, 40.8046], [-73.8592, 40.8063], [-73.859, 40.8103], [-73.8594, 40.8082], [-73.8677, 40.8106], [-73.8765, 40.8161], [-73.8681, 40.8068], [-73.8723, 40.8002], [-73.8951, 40.8069], [-73.9022, 40.8049], [-73.9117, 40.7966], [-73.9276, 40.8027], [-73.9329, 40.8101], [-73.9331, 40.8352], [-73.9067, 40.8758], [-73.9103, 40.879], [-73.9178, 40.8757], [-73.9249, 40.8789], [-73.9115, 40.9138], [-73.8729, 40.9044]]]}}, {"type": "Feature", "properties": {"name": "Manhattan"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9264, 40.8776], [-73.9224, 40.8768], [-73.9213, 40.8731], [-73.9209, 40.8755], [-73.9104, 40.8715], [-73.9194, 40.8589], [-73.9216, 40.8601], [-73.9349, 40.8352], [-73.9343, 40.8096], [-73.929, 40.8011], [-73.9293, 40.7959], [-73.9432, 40.7833], [-73.9429, 40.7747], [-73.9714, 40.7438], [-73.9745, 40.7359], [-73.9715, 40.7274], [-73.9767, 40.7115], [-73.9981, 40.7085], [-74.0083, 40.7007], [-74.0151, 40.7003], [-74.0193, 40.7061], [-74.0167, 40.7186], [-74.0131, 40.7189], [-74.0117, 40.7259], [-74.0152, 40.7264], [-74.0115, 40.7264], [-74.0144, 40.7285], [-74.0109, 40.733], [-74.014, 40.7333], [-74.0107, 40.7334], [-74.0127, 40.7407], [-74.0095, 40.7407], [-74.0121, 40.7436], [-74.0089, 40.7439], [-74.0118, 40.7456], [-74.0095, 40.7458], [-74.0116, 40.7466], [-74.0092, 40.7468], [-74.0114, 40.7476], [-74.0091, 40.7478], [-74.01, 40.7529], [-74.0048, 40.7578], [-74.007, 40.7592], [-74.001, 40.7634], [-74.0031, 40.7647], [-73.9996, 40.7636], [-74.0023, 40.7656], [-73.9983, 40.7656], [-74.0016, 40.767], [-73.9981, 40.7659], [-74.0006, 40.7682], [-73.9972, 40.7671], [-73.9997, 40.7695], [-73.9971, 40.7687], [-73.999, 40.7705], [-73.9949, 40.7715], [-73.9967, 40.7735], [-73.9942, 40.7725], [-73.9962, 40.774], [-73.9923, 40.7751], [-73.9889, 40.7797], [-73.9916, 40.7796], [-73.9582, 40.8223], [-73.9461, 40.8439], [-73.947, 40.8505], [-73.9419, 40.8539], [-73.9264, 40.8776]]]}}, {"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.7667, 40.6143], [-73.7602, 40.6108], [-73.7616, 40.609], [-73.7458, 40.612], [-73.7382, 40.6027], [-73.7381, 40.5977], [-73.7418, 40.5967], [-73.7381, 40.5974], [-73.7376, 40.5944], [-73.8135, 40.5835], [-73.8703, 40.5642], [-73.9069, 40.5556], [-73.9407, 40.5418], [-73.9399, 40.5546], [-73.9262, 40.5616], [-73.912, 40.5659], [-73.9015, 40.563], [-73.8926, 40.5686], [-73.8778, 40.5688], [-73.8504, 40.5821], [-73.8393, 40.5819], [-73.8215, 40.5868], [-73.8096, 40.5936], [-73.8057, 40.5908], [-73.808, 40.5942], [-73.8024, 40.5926], [-73.8052, 40.5969], [-73.803, 40.5988], [-73.7864, 40.6032], [-73.7903, 40.5992], [-73.7898, 40.5947], [-73.7786, 40.6096], [-73.7742, 40.6089], [-73.7747, 40.6043], [-73.7813, 40.5978], [-73.775, 40.6017], [-73.7736, 40.5981], [-73.7681, 40.5978], [-73.7712, 40.5994], [-73.769, 40.6094], [-73.7742, 40.6118], [-73.7667, 40.6143]]]}}]}
# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, int]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, water_status) tuples.
  water_status: -1 = explicit not water, 0 = unset, 1 = water
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], row[2]) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], 0) for row in cursor.fetchall()]


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]], int]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  # water_status: -1 = explicit not water, 0 = unset, 1 = water
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
        "water_status": water_status,
      }
      for qx, qy, corners, water_status in quadrant_polygons
    ]
  )

  # NYC boundary GeoJSON for the map
  nyc_boundary_json = json.dumps(NYC_BOUNDARY_GEOJSON)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.water {{
      background: rgba(59, 130, 246, 0.35);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}

    .legend-swatch.protected {{
      background: rgba(220, 38, 38, 0.25);
      border: 2px dashed rgba(220, 38, 38, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch water"></div>
      <span>Water Tile</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch protected"></div>
      <span>Protected (Not Water)</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state (red for land)
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state (land)
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for water tiles (blue)
    const waterStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.35,
      color: '#3b82f6',
      weight: 1.5,
      opacity: 0.7
    }};

    // Style for water hover state
    const waterHoverStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.6,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for protected (explicit not water) tiles
    const protectedStyle = {{
      fillColor: '#dc2626',
      fillOpacity: 0.2,
      color: '#dc2626',
      weight: 1.5,
      opacity: 0.6,
      dashArray: '5, 5'
    }};

    // Style for protected hover state
    const protectedHoverStyle = {{
      fillColor: '#dc2626',
      fillOpacity: 0.4,
      color: '#fff',
      weight: 2,
      opacity: 1,
      dashArray: '5, 5'
    }};

    // Helper to get style based on water_status
    function getStyle(waterStatus) {{
      if (waterStatus === 1) return waterStyle;
      if (waterStatus === -1) return protectedStyle;
      return normalStyle;
    }}

    function getHoverStyle(waterStatus) {{
      if (waterStatus === 1) return waterHoverStyle;
      if (waterStatus === -1) return protectedHoverStyle;
      return hoverStyle;
    }}

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const style = getStyle(q.water_status);
      const hStyle = getHoverStyle(q.water_status);
      const polygon = L.polygon(q.corners, style).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hStyle);
        const waterLabel = q.is_water ? ' <span style="color: #3b82f6;">üíß</span>' : '';
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
            ${{waterLabel}}
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(style);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    if (quadrants.length > 0) {{
      const allLatLngs = quadrants.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []
    water_count = 0

    for qx, qy, is_water in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners, is_water))

      if is_water:
        water_count += 1

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    if water_count > 0:
      print(f"   üíß {water_count} water tiles detected")

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")

  try:
    create_debug_map(generation_dir, output_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

```python
"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_nyc/e2e_generation/debug_map.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_nyc.e2e_generation.shared import calculate_offset

# Simplified NYC borough boundaries GeoJSON (all 5 boroughs)
# Source: NYC Open Data (dwillis/nyc-maps), simplified using Douglas-Peucker algorithm
# fmt: off
NYC_BOUNDARY_GEOJSON = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8205, 40.801], [-73.8137, 40.7971], [-73.7964, 40.7957], [-73.7928, 40.7888], [-73.7817, 40.7911], [-73.7833, 40.7949], [-73.7769, 40.7964], [-73.7706, 40.7885], [-73.7763, 40.7885], [-73.7668, 40.7798], [-73.7651, 40.7738], [-73.7447, 40.7566], [-73.7551, 40.7675], [-73.7555, 40.7777], [-73.7508, 40.7829], [-73.7013, 40.7508], [-73.7, 40.7392], [-73.7077, 40.7278], [-73.7303, 40.7222], [-73.7269, 40.71], [-73.7256, 40.6796], [-73.7283, 40.663], [-73.7252, 40.652], [-73.7414, 40.6469], [-73.74, 40.6351], [-73.7437, 40.639], [-73.747, 40.6369], [-73.7473, 40.6432], [-73.7548, 40.6478], [-73.7474, 40.6414], [-73.7486, 40.6354], [-73.765, 40.6294], [-73.7708, 40.62], [-73.7717, 40.6236], [-73.7752, 40.6193], [-73.7717, 40.6236], [-73.7792, 40.6273], [-73.7852, 40.6201], [-73.7809, 40.6136], [-73.7914, 40.6076], [-73.8008, 40.6119], [-73.7946, 40.6226], [-73.7897, 40.6226], [-73.7826, 40.6302], [-73.7895, 40.6343], [-73.7981, 40.631], [-73.7908, 40.6343], [-73.8212, 40.6491], [-73.8223, 40.6594], [-73.8113, 40.6606], [-73.8235, 40.6601], [-73.8231, 40.648], [-73.8309, 40.6516], [-73.8302, 40.6598], [-73.8319, 40.6549], [-73.831, 40.6582], [-73.8334, 40.6581], [-73.8311, 40.6486], [-73.8343, 40.6481], [-73.8387, 40.6625], [-73.8359, 40.6455], [-73.8495, 40.6441], [-73.8524, 40.6474], [-73.8494, 40.6514], [-73.8559, 40.6513], [-73.8614, 40.6564], [-73.8596, 40.6585], [-73.8632, 40.6583], [-73.8557, 40.6639], [-73.8576, 40.6717], [-73.8604, 40.6713], [-73.866, 40.6819], [-73.8689, 40.6952], [-73.8965, 40.6823], [-73.9058, 40.6941], [-73.9043, 40.6957], [-73.9219, 40.7094], [-73.9241, 40.7151], [-73.9206, 40.716], [-73.9252, 40.7223], [-73.9204, 40.7237], [-73.938, 40.7305], [-73.9459, 40.7375], [-73.9386, 40.7429], [-73.9472, 40.7379], [-73.9626, 40.7388], [-73.9568, 40.7488], [-73.9532, 40.7477], [-73.9562, 40.7497], [-73.9435, 40.7645], [-73.9349, 40.77], [-73.9378, 40.7736], [-73.9364, 40.7769], [-73.9286, 40.7766], [-73.9099, 40.7909], [-73.8959, 40.7856], [-73.9026, 40.7803], [-73.8944, 40.7842], [-73.8953, 40.7816], [-73.8917, 40.7822], [-73.8925, 40.7774], [-73.8918, 40.7749], [-73.8901, 40.7778], [-73.8895, 40.7735], [-73.8839, 40.7741], [-73.8849, 40.78], [-73.8787, 40.7806], [-73.8797, 40.7829], [-73.8752, 40.7815], [-73.8679, 40.7874], [-73.8726, 40.7808], [-73.8551, 40.7722], [-73.8582, 40.7703], [-73.8562, 40.7689], [-73.8628, 40.7668], [-73.8507, 40.7594], [-73.8391, 40.766], [-73.8478, 40.7668], [-73.8513, 40.7718], [-73.849, 40.778], [-73.8524, 40.7792], [-73.8492, 40.7823], [-73.8553, 40.782], [-73.8595, 40.7855], [-73.8528, 40.7882], [-73.8537, 40.794], [-73.8379, 40.7985], [-73.8403, 40.7976], [-73.8373, 40.789], [-73.8329, 40.7885], [-73.8279, 40.7929], [-73.8295, 40.7968], [-73.8205, 40.801]]]}}, {"type": "Feature", "properties": {"name": "Brooklyn"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9544, 40.7391], [-73.9292, 40.7274], [-73.9246, 40.7192], [-73.9322, 40.715], [-73.9333, 40.711], [-73.9304, 40.7087], [-73.9309, 40.7149], [-73.9236, 40.7173], [-73.9219, 40.7094], [-73.9043, 40.6957], [-73.9058, 40.6941], [-73.8965, 40.6823], [-73.8684, 40.6947], [-73.866, 40.6819], [-73.8604, 40.6713], [-73.8576, 40.6717], [-73.8557, 40.6639], [-73.8633, 40.6569], [-73.857, 40.6506], [-73.8572, 40.6437], [-73.8656, 40.6388], [-73.8793, 40.6546], [-73.868, 40.6381], [-73.8744, 40.6367], [-73.891, 40.6494], [-73.8771, 40.636], [-73.8836, 40.6309], [-73.8837, 40.6276], [-73.8875, 40.6283], [-73.8958, 40.6225], [-73.9175, 40.6314], [-73.8965, 40.6214], [-73.8959, 40.6145], [-73.891, 40.6128], [-73.894, 40.6112], [-73.8897, 40.6115], [-73.8933, 40.6067], [-73.8998, 40.6055], [-73.9013, 40.6117], [-73.9088, 40.6174], [-73.9016, 40.6058], [-73.9137, 40.604], [-73.9171, 40.6088], [-73.9142, 40.6149], [-73.9195, 40.6077], [-73.9089, 40.6016], [-73.884, 40.6056], [-73.8767, 40.5849], [-73.8797, 40.5801], [-73.8955, 40.5768], [-73.899, 40.5877], [-73.9115, 40.5861], [-73.9151, 40.5988], [-73.9215, 40.6019], [-73.9249, 40.5998], [-73.9302, 40.604], [-73.9321, 40.6027], [-73.9142, 40.5892], [-73.9248, 40.5856], [-73.9281, 40.5877], [-73.924, 40.5911], [-73.9286, 40.5886], [-73.9326, 40.5949], [-73.9313, 40.5868], [-73.9135, 40.5861], [-73.9125, 40.5834], [-73.9173, 40.5832], [-73.9115, 40.5818], [-73.9535, 40.583], [-73.9326, 40.5813], [-73.9311, 40.5762], [-74.0021, 40.5696], [-74.012, 40.5749], [-74.0119, 40.5797], [-74.006, 40.582], [-73.9884, 40.5788], [-73.986, 40.5817], [-73.9916, 40.5811], [-73.9903, 40.5846], [-74.0002, 40.5831], [-73.9941, 40.5887], [-74.0004, 40.5865], [-73.9984, 40.5935], [-74.036, 40.6093], [-74.0416, 40.6206], [-74.0368, 40.639], [-74.0388, 40.6396], [-74.0341, 40.6443], [-74.0282, 40.644], [-74.026, 40.6463], [-74.0294, 40.6488], [-74.0247, 40.6471], [-74.0261, 40.651], [-74.0229, 40.6512], [-74.0254, 40.6527], [-74.0212, 40.6508], [-74.0232, 40.6541], [-74.0179, 40.6541], [-74.0198, 40.6565], [-74.0167, 40.6553], [-74.0191, 40.6574], [-74.015, 40.657], [-74.0175, 40.6595], [-74.0155, 40.6608], [-74.0086, 40.6595], [-74.0096, 40.6633], [-74.0035, 40.6622], [-74.0077, 40.6648], [-73.9995, 40.6644], [-74.0029, 40.6665], [-73.9988, 40.6716], [-74.0029, 40.6673], [-74.007, 40.6661], [-74.0054, 40.6709], [-74.0075, 40.6671], [-74.0169, 40.6648], [-74.0193, 40.6716], [-74.0165, 40.6649], [-74.0103, 40.6691], [-74.0157, 40.671], [-74.013, 40.6733], [-74.0163, 40.6729], [-74.015, 40.6747], [-74.0188, 40.6723], [-74.0193, 40.6796], [-74.0128, 40.6836], [-74.013, 40.6804], [-74.0097, 40.6833], [-74.0119, 40.6839], [-74.001, 40.6901], [-73.9946, 40.7044], [-73.9783, 40.706], [-73.9757, 40.6996], [-73.9708, 40.7], [-73.9728, 40.7027], [-73.9695, 40.7005], [-73.9746, 40.7077], [-73.9711, 40.7059], [-73.9723, 40.7091], [-73.9675, 40.7034], [-73.97, 40.7105], [-73.9673, 40.717], [-73.9621, 40.7251], [-73.9579, 40.7246], [-73.9616, 40.7259], [-73.9623, 40.734], [-73.9544, 40.7391]], [[-73.9039, 40.6248], [-73.9039, 40.6248]]]}}, {"type": "Feature", "properties": {"name": "Staten Island"}, "geometry": {"type": "Polygon", "coordinates": [[[-74.0822, 40.6483], [-74.0717, 40.645], [-74.0703, 40.6425], [-74.0731, 40.6419], [-74.0702, 40.642], [-74.0729, 40.6409], [-74.07, 40.6411], [-74.0731, 40.6405], [-74.0735, 40.6372], [-74.0705, 40.6372], [-74.0734, 40.6369], [-74.073, 40.6303], [-74.068, 40.6288], [-74.0729, 40.63], [-74.0723, 40.6246], [-74.0538, 40.6059], [-74.0522, 40.5998], [-74.0734, 40.5783], [-74.091, 40.5667], [-74.1048, 40.553], [-74.1073, 40.5541], [-74.1128, 40.5479], [-74.1225, 40.5448], [-74.1369, 40.5293], [-74.1405, 40.535], [-74.1341, 40.5355], [-74.128, 40.5407], [-74.1307, 40.5463], [-74.1379, 40.546], [-74.1423, 40.5423], [-74.1413, 40.5371], [-74.1776, 40.5192], [-74.1848, 40.5193], [-74.1952, 40.51], [-74.1994, 40.513], [-74.2076, 40.5118], [-74.2176, 40.5033], [-74.2468, 40.4961], [-74.2532, 40.5001], [-74.2556, 40.5077], [-74.2535, 40.5117], [-74.2494, 40.517], [-74.2398, 40.5201], [-74.244, 40.5249], [-74.242, 40.5343], [-74.248, 40.5431], [-74.2307, 40.5556], [-74.2186, 40.5547], [-74.212, 40.5584], [-74.2046, 40.5893], [-74.1975, 40.5968], [-74.2028, 40.6083], [-74.2008, 40.6303], [-74.1946, 40.6374], [-74.18, 40.6453], [-74.1796, 40.6419], [-74.1744, 40.6451], [-74.1713, 40.6429], [-74.173, 40.6405], [-74.1661, 40.6424], [-74.1528, 40.6371], [-74.1514, 40.6394], [-74.1486, 40.6374], [-74.1344, 40.6419], [-74.127, 40.6393], [-74.1097, 40.6455], [-74.0822, 40.6483]]]}}, {"type": "Feature", "properties": {"name": "Bronx"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8729, 40.9044], [-73.8595, 40.9005], [-73.8511, 40.9104], [-73.8535, 40.9075], [-73.8414, 40.9042], [-73.8384, 40.8941], [-73.793, 40.8834], [-73.7974, 40.8751], [-73.8025, 40.8705], [-73.8034, 40.8725], [-73.803, 40.8692], [-73.8084, 40.8712], [-73.8031, 40.8658], [-73.7948, 40.8732], [-73.7929, 40.8793], [-73.7896, 40.8813], [-73.7844, 40.8784], [-73.7872, 40.8727], [-73.7836, 40.8738], [-73.7832, 40.8707], [-73.7914, 40.8681], [-73.7919, 40.8608], [-73.7987, 40.8549], [-73.8003, 40.8481], [-73.8042, 40.8533], [-73.8048, 40.8616], [-73.8077, 40.8585], [-73.8151, 40.8631], [-73.8123, 40.8542], [-73.8164, 40.8541], [-73.8171, 40.8513], [-73.815, 40.8455], [-73.8117, 40.8467], [-73.8144, 40.8431], [-73.8182, 40.8443], [-73.8147, 40.8414], [-73.8149, 40.831], [-73.8099, 40.8282], [-73.814, 40.8242], [-73.807, 40.8254], [-73.8046, 40.819], [-73.7974, 40.8158], [-73.803, 40.8124], [-73.807, 40.8165], [-73.8051, 40.8129], [-73.7909, 40.8073], [-73.7906, 40.8046], [-73.8162, 40.8138], [-73.8302, 40.8108], [-73.8316, 40.8049], [-73.8374, 40.8062], [-73.8423, 40.8291], [-73.8389, 40.8337], [-73.8397, 40.8396], [-73.8431, 40.8298], [-73.84, 40.8199], [-73.8462, 40.8107], [-73.8554, 40.8143], [-73.8491, 40.8123], [-73.8481, 40.8049], [-73.8561, 40.8046], [-73.8592, 40.8063], [-73.859, 40.8103], [-73.8594, 40.8082], [-73.8677, 40.8106], [-73.8765, 40.8161], [-73.8681, 40.8068], [-73.8723, 40.8002], [-73.8951, 40.8069], [-73.9022, 40.8049], [-73.9117, 40.7966], [-73.9276, 40.8027], [-73.9329, 40.8101], [-73.9331, 40.8352], [-73.9067, 40.8758], [-73.9103, 40.879], [-73.9178, 40.8757], [-73.9249, 40.8789], [-73.9115, 40.9138], [-73.8729, 40.9044]]]}}, {"type": "Feature", "properties": {"name": "Manhattan"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9264, 40.8776], [-73.9224, 40.8768], [-73.9213, 40.8731], [-73.9209, 40.8755], [-73.9104, 40.8715], [-73.9194, 40.8589], [-73.9216, 40.8601], [-73.9349, 40.8352], [-73.9343, 40.8096], [-73.929, 40.8011], [-73.9293, 40.7959], [-73.9432, 40.7833], [-73.9429, 40.7747], [-73.9714, 40.7438], [-73.9745, 40.7359], [-73.9715, 40.7274], [-73.9767, 40.7115], [-73.9981, 40.7085], [-74.0083, 40.7007], [-74.0151, 40.7003], [-74.0193, 40.7061], [-74.0167, 40.7186], [-74.0131, 40.7189], [-74.0117, 40.7259], [-74.0152, 40.7264], [-74.0115, 40.7264], [-74.0144, 40.7285], [-74.0109, 40.733], [-74.014, 40.7333], [-74.0107, 40.7334], [-74.0127, 40.7407], [-74.0095, 40.7407], [-74.0121, 40.7436], [-74.0089, 40.7439], [-74.0118, 40.7456], [-74.0095, 40.7458], [-74.0116, 40.7466], [-74.0092, 40.7468], [-74.0114, 40.7476], [-74.0091, 40.7478], [-74.01, 40.7529], [-74.0048, 40.7578], [-74.007, 40.7592], [-74.001, 40.7634], [-74.0031, 40.7647], [-73.9996, 40.7636], [-74.0023, 40.7656], [-73.9983, 40.7656], [-74.0016, 40.767], [-73.9981, 40.7659], [-74.0006, 40.7682], [-73.9972, 40.7671], [-73.9997, 40.7695], [-73.9971, 40.7687], [-73.999, 40.7705], [-73.9949, 40.7715], [-73.9967, 40.7735], [-73.9942, 40.7725], [-73.9962, 40.774], [-73.9923, 40.7751], [-73.9889, 40.7797], [-73.9916, 40.7796], [-73.9582, 40.8223], [-73.9461, 40.8439], [-73.947, 40.8505], [-73.9419, 40.8539], [-73.9264, 40.8776]]]}}, {"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.7667, 40.6143], [-73.7602, 40.6108], [-73.7616, 40.609], [-73.7458, 40.612], [-73.7382, 40.6027], [-73.7381, 40.5977], [-73.7418, 40.5967], [-73.7381, 40.5974], [-73.7376, 40.5944], [-73.8135, 40.5835], [-73.8703, 40.5642], [-73.9069, 40.5556], [-73.9407, 40.5418], [-73.9399, 40.5546], [-73.9262, 40.5616], [-73.912, 40.5659], [-73.9015, 40.563], [-73.8926, 40.5686], [-73.8778, 40.5688], [-73.8504, 40.5821], [-73.8393, 40.5819], [-73.8215, 40.5868], [-73.8096, 40.5936], [-73.8057, 40.5908], [-73.808, 40.5942], [-73.8024, 40.5926], [-73.8052, 40.5969], [-73.803, 40.5988], [-73.7864, 40.6032], [-73.7903, 40.5992], [-73.7898, 40.5947], [-73.7786, 40.6096], [-73.7742, 40.6089], [-73.7747, 40.6043], [-73.7813, 40.5978], [-73.775, 40.6017], [-73.7736, 40.5981], [-73.7681, 40.5978], [-73.7712, 40.5994], [-73.769, 40.6094], [-73.7742, 40.6118], [-73.7667, 40.6143]]]}}]}
# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, int]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, water_status) tuples.
  water_status: -1 = explicit not water, 0 = unset, 1 = water
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], row[2]) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], 0) for row in cursor.fetchall()]


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]], int]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  # water_status: -1 = explicit not water, 0 = unset, 1 = water
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
        "water_status": water_status,
      }
      for qx, qy, corners, water_status in quadrant_polygons
    ]
  )

  # NYC boundary GeoJSON for the map
  nyc_boundary_json = json.dumps(NYC_BOUNDARY_GEOJSON)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.water {{
      background: rgba(59, 130, 246, 0.35);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}

    .legend-swatch.protected {{
      background: rgba(220, 38, 38, 0.25);
      border: 2px dashed rgba(220, 38, 38, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch water"></div>
      <span>Water Tile</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch protected"></div>
      <span>Protected (Not Water)</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state (red for land)
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state (land)
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for water tiles (blue)
    const waterStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.35,
      color: '#3b82f6',
      weight: 1.5,
      opacity: 0.7
    }};

    // Style for water hover state
    const waterHoverStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.6,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for protected (explicit not water) tiles
    const protectedStyle = {{
      fillColor: '#dc2626',
      fillOpacity: 0.2,
      color: '#dc2626',
      weight: 1.5,
      opacity: 0.6,
      dashArray: '5, 5'
    }};

    // Style for protected hover state
    const protectedHoverStyle = {{
      fillColor: '#dc2626',
      fillOpacity: 0.4,
      color: '#fff',
      weight: 2,
      opacity: 1,
      dashArray: '5, 5'
    }};

    // Helper to get style based on water_status
    function getStyle(waterStatus) {{
      if (waterStatus === 1) return waterStyle;
      if (waterStatus === -1) return protectedStyle;
      return normalStyle;
    }}

    function getHoverStyle(waterStatus) {{
      if (waterStatus === 1) return waterHoverStyle;
      if (waterStatus === -1) return protectedHoverStyle;
      return hoverStyle;
    }}

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const style = getStyle(q.water_status);
      const hStyle = getHoverStyle(q.water_status);
      const polygon = L.polygon(q.corners, style).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hStyle);
        let statusLabel = '';
        if (q.water_status === 1) {{
          statusLabel = ' <span style="color: #3b82f6;">üíß</span>';
        }} else if (q.water_status === -1) {{
          statusLabel = ' <span style="color: #dc2626;">üõ°Ô∏è</span>';
        }}
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
            ${{statusLabel}}
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(style);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    if (quadrants.length > 0) {{
      const allLatLngs = quadrants.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []
    water_count = 0

    for qx, qy, is_water in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners, is_water))

      if is_water:
        water_count += 1

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    if water_count > 0:
      print(f"   üíß {water_count} water tiles detected")

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")

  try:
    create_debug_map(generation_dir, output_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

```python
"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_nyc/e2e_generation/debug_map.py [generation_dir]

Arguments:
  generation_dir: Path to the generation directory (default: generations/v01)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_nyc.e2e_generation.shared import calculate_offset

# Simplified NYC borough boundaries GeoJSON (all 5 boroughs)
# Source: NYC Open Data (dwillis/nyc-maps), simplified using Douglas-Peucker algorithm
# fmt: off
NYC_BOUNDARY_GEOJSON = {"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8205, 40.801], [-73.8137, 40.7971], [-73.7964, 40.7957], [-73.7928, 40.7888], [-73.7817, 40.7911], [-73.7833, 40.7949], [-73.7769, 40.7964], [-73.7706, 40.7885], [-73.7763, 40.7885], [-73.7668, 40.7798], [-73.7651, 40.7738], [-73.7447, 40.7566], [-73.7551, 40.7675], [-73.7555, 40.7777], [-73.7508, 40.7829], [-73.7013, 40.7508], [-73.7, 40.7392], [-73.7077, 40.7278], [-73.7303, 40.7222], [-73.7269, 40.71], [-73.7256, 40.6796], [-73.7283, 40.663], [-73.7252, 40.652], [-73.7414, 40.6469], [-73.74, 40.6351], [-73.7437, 40.639], [-73.747, 40.6369], [-73.7473, 40.6432], [-73.7548, 40.6478], [-73.7474, 40.6414], [-73.7486, 40.6354], [-73.765, 40.6294], [-73.7708, 40.62], [-73.7717, 40.6236], [-73.7752, 40.6193], [-73.7717, 40.6236], [-73.7792, 40.6273], [-73.7852, 40.6201], [-73.7809, 40.6136], [-73.7914, 40.6076], [-73.8008, 40.6119], [-73.7946, 40.6226], [-73.7897, 40.6226], [-73.7826, 40.6302], [-73.7895, 40.6343], [-73.7981, 40.631], [-73.7908, 40.6343], [-73.8212, 40.6491], [-73.8223, 40.6594], [-73.8113, 40.6606], [-73.8235, 40.6601], [-73.8231, 40.648], [-73.8309, 40.6516], [-73.8302, 40.6598], [-73.8319, 40.6549], [-73.831, 40.6582], [-73.8334, 40.6581], [-73.8311, 40.6486], [-73.8343, 40.6481], [-73.8387, 40.6625], [-73.8359, 40.6455], [-73.8495, 40.6441], [-73.8524, 40.6474], [-73.8494, 40.6514], [-73.8559, 40.6513], [-73.8614, 40.6564], [-73.8596, 40.6585], [-73.8632, 40.6583], [-73.8557, 40.6639], [-73.8576, 40.6717], [-73.8604, 40.6713], [-73.866, 40.6819], [-73.8689, 40.6952], [-73.8965, 40.6823], [-73.9058, 40.6941], [-73.9043, 40.6957], [-73.9219, 40.7094], [-73.9241, 40.7151], [-73.9206, 40.716], [-73.9252, 40.7223], [-73.9204, 40.7237], [-73.938, 40.7305], [-73.9459, 40.7375], [-73.9386, 40.7429], [-73.9472, 40.7379], [-73.9626, 40.7388], [-73.9568, 40.7488], [-73.9532, 40.7477], [-73.9562, 40.7497], [-73.9435, 40.7645], [-73.9349, 40.77], [-73.9378, 40.7736], [-73.9364, 40.7769], [-73.9286, 40.7766], [-73.9099, 40.7909], [-73.8959, 40.7856], [-73.9026, 40.7803], [-73.8944, 40.7842], [-73.8953, 40.7816], [-73.8917, 40.7822], [-73.8925, 40.7774], [-73.8918, 40.7749], [-73.8901, 40.7778], [-73.8895, 40.7735], [-73.8839, 40.7741], [-73.8849, 40.78], [-73.8787, 40.7806], [-73.8797, 40.7829], [-73.8752, 40.7815], [-73.8679, 40.7874], [-73.8726, 40.7808], [-73.8551, 40.7722], [-73.8582, 40.7703], [-73.8562, 40.7689], [-73.8628, 40.7668], [-73.8507, 40.7594], [-73.8391, 40.766], [-73.8478, 40.7668], [-73.8513, 40.7718], [-73.849, 40.778], [-73.8524, 40.7792], [-73.8492, 40.7823], [-73.8553, 40.782], [-73.8595, 40.7855], [-73.8528, 40.7882], [-73.8537, 40.794], [-73.8379, 40.7985], [-73.8403, 40.7976], [-73.8373, 40.789], [-73.8329, 40.7885], [-73.8279, 40.7929], [-73.8295, 40.7968], [-73.8205, 40.801]]]}}, {"type": "Feature", "properties": {"name": "Brooklyn"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9544, 40.7391], [-73.9292, 40.7274], [-73.9246, 40.7192], [-73.9322, 40.715], [-73.9333, 40.711], [-73.9304, 40.7087], [-73.9309, 40.7149], [-73.9236, 40.7173], [-73.9219, 40.7094], [-73.9043, 40.6957], [-73.9058, 40.6941], [-73.8965, 40.6823], [-73.8684, 40.6947], [-73.866, 40.6819], [-73.8604, 40.6713], [-73.8576, 40.6717], [-73.8557, 40.6639], [-73.8633, 40.6569], [-73.857, 40.6506], [-73.8572, 40.6437], [-73.8656, 40.6388], [-73.8793, 40.6546], [-73.868, 40.6381], [-73.8744, 40.6367], [-73.891, 40.6494], [-73.8771, 40.636], [-73.8836, 40.6309], [-73.8837, 40.6276], [-73.8875, 40.6283], [-73.8958, 40.6225], [-73.9175, 40.6314], [-73.8965, 40.6214], [-73.8959, 40.6145], [-73.891, 40.6128], [-73.894, 40.6112], [-73.8897, 40.6115], [-73.8933, 40.6067], [-73.8998, 40.6055], [-73.9013, 40.6117], [-73.9088, 40.6174], [-73.9016, 40.6058], [-73.9137, 40.604], [-73.9171, 40.6088], [-73.9142, 40.6149], [-73.9195, 40.6077], [-73.9089, 40.6016], [-73.884, 40.6056], [-73.8767, 40.5849], [-73.8797, 40.5801], [-73.8955, 40.5768], [-73.899, 40.5877], [-73.9115, 40.5861], [-73.9151, 40.5988], [-73.9215, 40.6019], [-73.9249, 40.5998], [-73.9302, 40.604], [-73.9321, 40.6027], [-73.9142, 40.5892], [-73.9248, 40.5856], [-73.9281, 40.5877], [-73.924, 40.5911], [-73.9286, 40.5886], [-73.9326, 40.5949], [-73.9313, 40.5868], [-73.9135, 40.5861], [-73.9125, 40.5834], [-73.9173, 40.5832], [-73.9115, 40.5818], [-73.9535, 40.583], [-73.9326, 40.5813], [-73.9311, 40.5762], [-74.0021, 40.5696], [-74.012, 40.5749], [-74.0119, 40.5797], [-74.006, 40.582], [-73.9884, 40.5788], [-73.986, 40.5817], [-73.9916, 40.5811], [-73.9903, 40.5846], [-74.0002, 40.5831], [-73.9941, 40.5887], [-74.0004, 40.5865], [-73.9984, 40.5935], [-74.036, 40.6093], [-74.0416, 40.6206], [-74.0368, 40.639], [-74.0388, 40.6396], [-74.0341, 40.6443], [-74.0282, 40.644], [-74.026, 40.6463], [-74.0294, 40.6488], [-74.0247, 40.6471], [-74.0261, 40.651], [-74.0229, 40.6512], [-74.0254, 40.6527], [-74.0212, 40.6508], [-74.0232, 40.6541], [-74.0179, 40.6541], [-74.0198, 40.6565], [-74.0167, 40.6553], [-74.0191, 40.6574], [-74.015, 40.657], [-74.0175, 40.6595], [-74.0155, 40.6608], [-74.0086, 40.6595], [-74.0096, 40.6633], [-74.0035, 40.6622], [-74.0077, 40.6648], [-73.9995, 40.6644], [-74.0029, 40.6665], [-73.9988, 40.6716], [-74.0029, 40.6673], [-74.007, 40.6661], [-74.0054, 40.6709], [-74.0075, 40.6671], [-74.0169, 40.6648], [-74.0193, 40.6716], [-74.0165, 40.6649], [-74.0103, 40.6691], [-74.0157, 40.671], [-74.013, 40.6733], [-74.0163, 40.6729], [-74.015, 40.6747], [-74.0188, 40.6723], [-74.0193, 40.6796], [-74.0128, 40.6836], [-74.013, 40.6804], [-74.0097, 40.6833], [-74.0119, 40.6839], [-74.001, 40.6901], [-73.9946, 40.7044], [-73.9783, 40.706], [-73.9757, 40.6996], [-73.9708, 40.7], [-73.9728, 40.7027], [-73.9695, 40.7005], [-73.9746, 40.7077], [-73.9711, 40.7059], [-73.9723, 40.7091], [-73.9675, 40.7034], [-73.97, 40.7105], [-73.9673, 40.717], [-73.9621, 40.7251], [-73.9579, 40.7246], [-73.9616, 40.7259], [-73.9623, 40.734], [-73.9544, 40.7391]], [[-73.9039, 40.6248], [-73.9039, 40.6248]]]}}, {"type": "Feature", "properties": {"name": "Staten Island"}, "geometry": {"type": "Polygon", "coordinates": [[[-74.0822, 40.6483], [-74.0717, 40.645], [-74.0703, 40.6425], [-74.0731, 40.6419], [-74.0702, 40.642], [-74.0729, 40.6409], [-74.07, 40.6411], [-74.0731, 40.6405], [-74.0735, 40.6372], [-74.0705, 40.6372], [-74.0734, 40.6369], [-74.073, 40.6303], [-74.068, 40.6288], [-74.0729, 40.63], [-74.0723, 40.6246], [-74.0538, 40.6059], [-74.0522, 40.5998], [-74.0734, 40.5783], [-74.091, 40.5667], [-74.1048, 40.553], [-74.1073, 40.5541], [-74.1128, 40.5479], [-74.1225, 40.5448], [-74.1369, 40.5293], [-74.1405, 40.535], [-74.1341, 40.5355], [-74.128, 40.5407], [-74.1307, 40.5463], [-74.1379, 40.546], [-74.1423, 40.5423], [-74.1413, 40.5371], [-74.1776, 40.5192], [-74.1848, 40.5193], [-74.1952, 40.51], [-74.1994, 40.513], [-74.2076, 40.5118], [-74.2176, 40.5033], [-74.2468, 40.4961], [-74.2532, 40.5001], [-74.2556, 40.5077], [-74.2535, 40.5117], [-74.2494, 40.517], [-74.2398, 40.5201], [-74.244, 40.5249], [-74.242, 40.5343], [-74.248, 40.5431], [-74.2307, 40.5556], [-74.2186, 40.5547], [-74.212, 40.5584], [-74.2046, 40.5893], [-74.1975, 40.5968], [-74.2028, 40.6083], [-74.2008, 40.6303], [-74.1946, 40.6374], [-74.18, 40.6453], [-74.1796, 40.6419], [-74.1744, 40.6451], [-74.1713, 40.6429], [-74.173, 40.6405], [-74.1661, 40.6424], [-74.1528, 40.6371], [-74.1514, 40.6394], [-74.1486, 40.6374], [-74.1344, 40.6419], [-74.127, 40.6393], [-74.1097, 40.6455], [-74.0822, 40.6483]]]}}, {"type": "Feature", "properties": {"name": "Bronx"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.8729, 40.9044], [-73.8595, 40.9005], [-73.8511, 40.9104], [-73.8535, 40.9075], [-73.8414, 40.9042], [-73.8384, 40.8941], [-73.793, 40.8834], [-73.7974, 40.8751], [-73.8025, 40.8705], [-73.8034, 40.8725], [-73.803, 40.8692], [-73.8084, 40.8712], [-73.8031, 40.8658], [-73.7948, 40.8732], [-73.7929, 40.8793], [-73.7896, 40.8813], [-73.7844, 40.8784], [-73.7872, 40.8727], [-73.7836, 40.8738], [-73.7832, 40.8707], [-73.7914, 40.8681], [-73.7919, 40.8608], [-73.7987, 40.8549], [-73.8003, 40.8481], [-73.8042, 40.8533], [-73.8048, 40.8616], [-73.8077, 40.8585], [-73.8151, 40.8631], [-73.8123, 40.8542], [-73.8164, 40.8541], [-73.8171, 40.8513], [-73.815, 40.8455], [-73.8117, 40.8467], [-73.8144, 40.8431], [-73.8182, 40.8443], [-73.8147, 40.8414], [-73.8149, 40.831], [-73.8099, 40.8282], [-73.814, 40.8242], [-73.807, 40.8254], [-73.8046, 40.819], [-73.7974, 40.8158], [-73.803, 40.8124], [-73.807, 40.8165], [-73.8051, 40.8129], [-73.7909, 40.8073], [-73.7906, 40.8046], [-73.8162, 40.8138], [-73.8302, 40.8108], [-73.8316, 40.8049], [-73.8374, 40.8062], [-73.8423, 40.8291], [-73.8389, 40.8337], [-73.8397, 40.8396], [-73.8431, 40.8298], [-73.84, 40.8199], [-73.8462, 40.8107], [-73.8554, 40.8143], [-73.8491, 40.8123], [-73.8481, 40.8049], [-73.8561, 40.8046], [-73.8592, 40.8063], [-73.859, 40.8103], [-73.8594, 40.8082], [-73.8677, 40.8106], [-73.8765, 40.8161], [-73.8681, 40.8068], [-73.8723, 40.8002], [-73.8951, 40.8069], [-73.9022, 40.8049], [-73.9117, 40.7966], [-73.9276, 40.8027], [-73.9329, 40.8101], [-73.9331, 40.8352], [-73.9067, 40.8758], [-73.9103, 40.879], [-73.9178, 40.8757], [-73.9249, 40.8789], [-73.9115, 40.9138], [-73.8729, 40.9044]]]}}, {"type": "Feature", "properties": {"name": "Manhattan"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.9264, 40.8776], [-73.9224, 40.8768], [-73.9213, 40.8731], [-73.9209, 40.8755], [-73.9104, 40.8715], [-73.9194, 40.8589], [-73.9216, 40.8601], [-73.9349, 40.8352], [-73.9343, 40.8096], [-73.929, 40.8011], [-73.9293, 40.7959], [-73.9432, 40.7833], [-73.9429, 40.7747], [-73.9714, 40.7438], [-73.9745, 40.7359], [-73.9715, 40.7274], [-73.9767, 40.7115], [-73.9981, 40.7085], [-74.0083, 40.7007], [-74.0151, 40.7003], [-74.0193, 40.7061], [-74.0167, 40.7186], [-74.0131, 40.7189], [-74.0117, 40.7259], [-74.0152, 40.7264], [-74.0115, 40.7264], [-74.0144, 40.7285], [-74.0109, 40.733], [-74.014, 40.7333], [-74.0107, 40.7334], [-74.0127, 40.7407], [-74.0095, 40.7407], [-74.0121, 40.7436], [-74.0089, 40.7439], [-74.0118, 40.7456], [-74.0095, 40.7458], [-74.0116, 40.7466], [-74.0092, 40.7468], [-74.0114, 40.7476], [-74.0091, 40.7478], [-74.01, 40.7529], [-74.0048, 40.7578], [-74.007, 40.7592], [-74.001, 40.7634], [-74.0031, 40.7647], [-73.9996, 40.7636], [-74.0023, 40.7656], [-73.9983, 40.7656], [-74.0016, 40.767], [-73.9981, 40.7659], [-74.0006, 40.7682], [-73.9972, 40.7671], [-73.9997, 40.7695], [-73.9971, 40.7687], [-73.999, 40.7705], [-73.9949, 40.7715], [-73.9967, 40.7735], [-73.9942, 40.7725], [-73.9962, 40.774], [-73.9923, 40.7751], [-73.9889, 40.7797], [-73.9916, 40.7796], [-73.9582, 40.8223], [-73.9461, 40.8439], [-73.947, 40.8505], [-73.9419, 40.8539], [-73.9264, 40.8776]]]}}, {"type": "Feature", "properties": {"name": "Queens"}, "geometry": {"type": "Polygon", "coordinates": [[[-73.7667, 40.6143], [-73.7602, 40.6108], [-73.7616, 40.609], [-73.7458, 40.612], [-73.7382, 40.6027], [-73.7381, 40.5977], [-73.7418, 40.5967], [-73.7381, 40.5974], [-73.7376, 40.5944], [-73.8135, 40.5835], [-73.8703, 40.5642], [-73.9069, 40.5556], [-73.9407, 40.5418], [-73.9399, 40.5546], [-73.9262, 40.5616], [-73.912, 40.5659], [-73.9015, 40.563], [-73.8926, 40.5686], [-73.8778, 40.5688], [-73.8504, 40.5821], [-73.8393, 40.5819], [-73.8215, 40.5868], [-73.8096, 40.5936], [-73.8057, 40.5908], [-73.808, 40.5942], [-73.8024, 40.5926], [-73.8052, 40.5969], [-73.803, 40.5988], [-73.7864, 40.6032], [-73.7903, 40.5992], [-73.7898, 40.5947], [-73.7786, 40.6096], [-73.7742, 40.6089], [-73.7747, 40.6043], [-73.7813, 40.5978], [-73.775, 40.6017], [-73.7736, 40.5981], [-73.7681, 40.5978], [-73.7712, 40.5994], [-73.769, 40.6094], [-73.7742, 40.6118], [-73.7667, 40.6143]]]}}]}
# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, int]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, water_status) tuples.
  water_status: -1 = explicit not water, 0 = unset, 1 = water
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], row[2]) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], 0) for row in cursor.fetchall()]


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]], int]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  # water_status: -1 = explicit not water, 0 = unset, 1 = water
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
        "water_status": water_status,
      }
      for qx, qy, corners, water_status in quadrant_polygons
    ]
  )

  # NYC boundary GeoJSON for the map
  nyc_boundary_json = json.dumps(NYC_BOUNDARY_GEOJSON)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.water {{
      background: rgba(59, 130, 246, 0.35);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}

    .legend-swatch.protected {{
      background: rgba(220, 38, 38, 0.25);
      border: 2px dashed rgba(220, 38, 38, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch water"></div>
      <span>Water Tile</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch protected"></div>
      <span>Protected (Not Water)</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state (red for land)
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state (land)
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for water tiles (blue)
    const waterStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.35,
      color: '#3b82f6',
      weight: 1.5,
      opacity: 0.7
    }};

    // Style for water hover state
    const waterHoverStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.6,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for protected (explicit not water) tiles
    const protectedStyle = {{
      fillColor: '#dc2626',
      fillOpacity: 0.2,
      color: '#dc2626',
      weight: 1.5,
      opacity: 0.6,
      dashArray: '5, 5'
    }};

    // Style for protected hover state
    const protectedHoverStyle = {{
      fillColor: '#dc2626',
      fillOpacity: 0.4,
      color: '#fff',
      weight: 2,
      opacity: 1,
      dashArray: '5, 5'
    }};

    // Helper to get style based on water_status
    function getStyle(waterStatus) {{
      if (waterStatus === 1) return waterStyle;
      if (waterStatus === -1) return protectedStyle;
      return normalStyle;
    }}

    function getHoverStyle(waterStatus) {{
      if (waterStatus === 1) return waterHoverStyle;
      if (waterStatus === -1) return protectedHoverStyle;
      return hoverStyle;
    }}

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const style = getStyle(q.water_status);
      const hStyle = getHoverStyle(q.water_status);
      const polygon = L.polygon(q.corners, style).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hStyle);
        let statusLabel = '';
        if (q.water_status === 1) {{
          statusLabel = ' <span style="color: #3b82f6;">üíß</span>';
        }} else if (q.water_status === -1) {{
          statusLabel = ' <span style="color: #dc2626;">üõ°Ô∏è</span>';
        }}
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
            ${{statusLabel}}
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(style);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    if (quadrants.length > 0) {{
      const allLatLngs = quadrants.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []
    water_count = 0
    protected_count = 0

    for qx, qy, water_status in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners, water_status))

      if water_status == 1:
        water_count += 1
      elif water_status == -1:
        protected_count += 1

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    if water_count > 0:
      print(f"   üíß {water_count} water tiles")
    if protected_count > 0:
      print(f"   üõ°Ô∏è  {protected_count} protected tiles")

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/v01"),
    help="Path to the generation directory (default: generations/v01)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")

  try:
    create_debug_map(generation_dir, output_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())

```

