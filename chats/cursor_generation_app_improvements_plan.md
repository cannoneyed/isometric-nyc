# Generation app improvements plan
_Exported on 12/13/2025 at 22:04:53 EST from Cursor (2.1.39)_

---

**User**

Implement the plan in @tasks/023_generation_app_improvements.md 

---

**Cursor**

I'll implement the plan from the task file. Let me start by exploring the current codebase to understand the existing structure.

Now I have a comprehensive understanding of the codebase. Let me create a task list and implement these improvements.

Let me start implementing. First, I'll create a new module for the persistent queue and web renderer.

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    return {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)
  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates
    model_id: Optional model ID for generation

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  cursor.execute(
    """
    INSERT INTO generation_queue (item_type, quadrants, model_id, status, created_at)
    VALUES (?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(
  conn: sqlite3.Connection, item_id: int, error_message: str
) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount

```

```python
"""
Model configuration for the generation app.

Loads model configurations from app_config.json and provides
utilities for selecting and using different AI models.
"""

import json
import os
from dataclasses import dataclass
from pathlib import Path
from typing import Any


@dataclass
class ModelConfig:
  """Configuration for a single AI model."""

  name: str
  model_id: str
  api_key_env: str  # Environment variable name for the API key
  endpoint: str = "https://hub.oxen.ai/api/images/edit"
  num_inference_steps: int = 28

  @property
  def api_key(self) -> str | None:
    """Get the API key from environment variables."""
    return os.getenv(self.api_key_env)

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization (without API key)."""
    return {
      "name": self.name,
      "model_id": self.model_id,
      "endpoint": self.endpoint,
      "num_inference_steps": self.num_inference_steps,
    }


@dataclass
class AppConfig:
  """Full application configuration."""

  models: list[ModelConfig]
  default_model_id: str | None = None

  def get_model(self, model_id: str) -> ModelConfig | None:
    """Get a model configuration by its ID."""
    for model in self.models:
      if model.model_id == model_id:
        return model
    return None

  def get_default_model(self) -> ModelConfig | None:
    """Get the default model, or the first model if no default is set."""
    if self.default_model_id:
      return self.get_model(self.default_model_id)
    return self.models[0] if self.models else None

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    return {
      "models": [m.to_dict() for m in self.models],
      "default_model_id": self.default_model_id,
    }


def load_app_config(config_path: Path | None = None) -> AppConfig:
  """
  Load the application configuration from app_config.json.

  Args:
    config_path: Path to the config file. If None, looks in the generation dir.

  Returns:
    AppConfig object with model configurations

  If the config file doesn't exist, returns a default configuration
  with the legacy Oxen models.
  """
  if config_path is None:
    config_path = Path(__file__).parent / "app_config.json"

  if not config_path.exists():
    # Return default configuration with legacy models
    return get_default_config()

  with open(config_path) as f:
    data = json.load(f)

  models = []
  for model_data in data.get("models", []):
    models.append(
      ModelConfig(
        name=model_data["name"],
        model_id=model_data["model_id"],
        api_key_env=model_data["api_key_env"],
        endpoint=model_data.get("endpoint", "https://hub.oxen.ai/api/images/edit"),
        num_inference_steps=model_data.get("num_inference_steps", 28),
      )
    )

  return AppConfig(
    models=models,
    default_model_id=data.get("default_model_id"),
  )


def get_default_config() -> AppConfig:
  """
  Get the default configuration with legacy Oxen models.

  This is used when no app_config.json exists.
  """
  return AppConfig(
    models=[
      ModelConfig(
        name="Omni Water v1",
        model_id="cannoneyed-quiet-green-lamprey",
        api_key_env="OXEN_OMNI_v04_WATER_API_KEY",
      ),
      ModelConfig(
        name="Omni Water v2",
        model_id="cannoneyed-rural-rose-dingo",
        api_key_env="OXEN_OMNI_WATER_V2_API_KEY",
      ),
      ModelConfig(
        name="Omni (Original)",
        model_id="cannoneyed-gentle-gold-antlion",
        api_key_env="OXEN_OMNI_API_KEY",
      ),
    ],
    default_model_id="cannoneyed-quiet-green-lamprey",
  )


def save_app_config(config: AppConfig, config_path: Path | None = None) -> None:
  """
  Save the application configuration to app_config.json.

  Note: This does NOT save API keys - those should remain in environment variables.
  """
  if config_path is None:
    config_path = Path(__file__).parent / "app_config.json"

  data = {
    "models": [],
    "default_model_id": config.default_model_id,
  }

  for model in config.models:
    data["models"].append(
      {
        "name": model.name,
        "model_id": model.model_id,
        "api_key_env": model.api_key_env,
        "endpoint": model.endpoint,
        "num_inference_steps": model.num_inference_steps,
      }
    )

  with open(config_path, "w") as f:
    json.dump(data, f, indent=2)

```

Now let me create the persisted web renderer:

```python
"""
Persisted web renderer for tile generation.

This module manages a single web server process that stays running
for the lifetime of the application, with an internal queue for
handling render requests.
"""

import queue
import subprocess
import threading
import time
from dataclasses import dataclass
from io import BytesIO
from pathlib import Path
from typing import Any, Callable
from urllib.parse import urlencode

from PIL import Image
from playwright.sync_api import sync_playwright

from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  WEB_DIR,
  image_to_png_bytes,
  split_tile_into_quadrants,
  wait_for_server,
)


@dataclass
class RenderRequest:
  """A request to render a quadrant."""

  quadrant_x: int
  quadrant_y: int
  lat: float
  lng: float
  width_px: int
  height_px: int
  camera_azimuth_degrees: float
  camera_elevation_degrees: float
  view_height_meters: float
  callback: Callable[[dict[tuple[int, int], bytes] | None, str | None], None]


class WebRenderer:
  """
  Manages a persistent web server and render queue.

  This class:
  - Starts a web server (bun/vite) when initialized
  - Maintains an internal queue of render requests
  - Processes renders one at a time using Playwright
  - Provides thread-safe access to queue operations
  """

  def __init__(self, web_dir: Path = WEB_DIR, port: int = DEFAULT_WEB_PORT):
    self.web_dir = web_dir
    self.port = port
    self.web_process: subprocess.Popen | None = None
    self.render_queue: queue.Queue[RenderRequest | None] = queue.Queue()
    self.worker_thread: threading.Thread | None = None
    self.running = False
    self._lock = threading.Lock()

  def start(self) -> None:
    """Start the web server and render worker thread."""
    with self._lock:
      if self.running:
        return

      print(f"üåê Starting web renderer on port {self.port}...")

      # Start the web server
      self._start_web_server()

      # Start the worker thread
      self.running = True
      self.worker_thread = threading.Thread(target=self._worker_loop, daemon=True)
      self.worker_thread.start()

      print(f"‚úÖ Web renderer ready on http://localhost:{self.port}")

  def stop(self) -> None:
    """Stop the web server and worker thread."""
    with self._lock:
      if not self.running:
        return

      print("üõë Stopping web renderer...")
      self.running = False

      # Signal worker to stop
      self.render_queue.put(None)

      # Wait for worker to finish
      if self.worker_thread and self.worker_thread.is_alive():
        self.worker_thread.join(timeout=5.0)

      # Stop the web server
      if self.web_process:
        self.web_process.terminate()
        try:
          self.web_process.wait(timeout=5.0)
        except subprocess.TimeoutExpired:
          self.web_process.kill()
        self.web_process = None

      print("‚úÖ Web renderer stopped")

  def _start_web_server(self) -> None:
    """Start the web server subprocess."""
    if not self.web_dir.exists():
      raise RuntimeError(f"Web directory not found: {self.web_dir}")

    self.web_process = subprocess.Popen(
      ["bun", "run", "dev", "--port", str(self.port)],
      cwd=self.web_dir,
      stdout=subprocess.PIPE,
      stderr=subprocess.PIPE,
    )

    # Give the process a moment to start
    time.sleep(2)

    # Check if process died immediately
    if self.web_process.poll() is not None:
      stdout = self.web_process.stdout.read().decode() if self.web_process.stdout else ""
      stderr = self.web_process.stderr.read().decode() if self.web_process.stderr else ""
      raise RuntimeError(
        f"Web server failed to start.\nstdout: {stdout}\nstderr: {stderr}"
      )

    # Wait for server to be ready
    print("   ‚è≥ Waiting for web server to be ready...")
    if wait_for_server(self.port, timeout=30.0):
      print(f"   ‚úÖ Web server ready on http://localhost:{self.port}")
    else:
      if self.web_process.poll() is not None:
        stdout = self.web_process.stdout.read().decode() if self.web_process.stdout else ""
        stderr = self.web_process.stderr.read().decode() if self.web_process.stderr else ""
        raise RuntimeError(
          f"Web server died during startup.\nstdout: {stdout}\nstderr: {stderr}"
        )
      print("   ‚ö†Ô∏è  Web server may not be fully ready, continuing anyway...")

  def _ensure_web_server_running(self) -> bool:
    """Ensure the web server is still running, restart if needed."""
    if self.web_process is None or self.web_process.poll() is not None:
      print("   ‚ö†Ô∏è  Web server died, restarting...")
      try:
        self._start_web_server()
        return True
      except Exception as e:
        print(f"   ‚ùå Failed to restart web server: {e}")
        return False
    return True

  def _worker_loop(self) -> None:
    """Main worker loop that processes render requests."""
    print("üîÑ Render worker started")

    while self.running:
      try:
        # Wait for a request with timeout to allow checking running flag
        try:
          request = self.render_queue.get(timeout=1.0)
        except queue.Empty:
          continue

        # Check for stop signal
        if request is None:
          break

        # Ensure web server is running
        if not self._ensure_web_server_running():
          request.callback(None, "Web server not available")
          continue

        # Process the render request
        try:
          result = self._render_tile(request)
          request.callback(result, None)
        except Exception as e:
          print(f"   ‚ùå Render error: {e}")
          request.callback(None, str(e))

      except Exception as e:
        print(f"   ‚ùå Worker loop error: {e}")

    print("üõë Render worker stopped")

  def _render_tile(
    self, request: RenderRequest
  ) -> dict[tuple[int, int], bytes]:
    """
    Render a tile and return all 4 quadrants as PNG bytes.

    Returns a dict mapping (dx, dy) offset to PNG bytes.
    """
    # Build URL for rendering
    params = {
      "export": "true",
      "lat": request.lat,
      "lon": request.lng,
      "width": request.width_px,
      "height": request.height_px,
      "azimuth": request.camera_azimuth_degrees,
      "elevation": request.camera_elevation_degrees,
      "view_height": request.view_height_meters,
    }
    query_string = urlencode(params)
    url = f"http://localhost:{self.port}/?{query_string}"

    print(f"   üé® Rendering tile at ({request.lat:.6f}, {request.lng:.6f})...")

    # Render using Playwright
    with sync_playwright() as p:
      browser = p.chromium.launch(
        headless=True,
        args=[
          "--enable-webgl",
          "--use-gl=angle",
          "--ignore-gpu-blocklist",
        ],
      )

      context = browser.new_context(
        viewport={"width": request.width_px, "height": request.height_px},
        device_scale_factor=1,
      )
      page = context.new_page()

      page.goto(url, wait_until="networkidle")

      try:
        page.wait_for_function("window.TILES_LOADED === true", timeout=60000)
      except Exception:
        print("      ‚ö†Ô∏è  Timeout waiting for tiles, continuing anyway...")

      # Get screenshot as bytes
      screenshot_bytes = page.screenshot(type="png")

      page.close()
      context.close()
      browser.close()

    # Open as PIL image and split into quadrants
    full_tile = Image.open(BytesIO(screenshot_bytes))
    quadrant_images = split_tile_into_quadrants(full_tile)

    # Convert to bytes
    result = {}
    for offset, quad_img in quadrant_images.items():
      result[offset] = image_to_png_bytes(quad_img)

    return result

  def render_quadrant(
    self,
    quadrant_x: int,
    quadrant_y: int,
    lat: float,
    lng: float,
    width_px: int,
    height_px: int,
    camera_azimuth_degrees: float,
    camera_elevation_degrees: float,
    view_height_meters: float,
    timeout: float = 120.0,
  ) -> dict[tuple[int, int], bytes]:
    """
    Synchronously render a quadrant and wait for the result.

    This is a blocking call that waits for the render to complete.

    Args:
      quadrant_x, quadrant_y: Quadrant coordinates
      lat, lng: Geographic coordinates for the render
      width_px, height_px: Tile dimensions
      camera_azimuth_degrees, camera_elevation_degrees: Camera angles
      view_height_meters: View height
      timeout: Maximum time to wait for render

    Returns:
      Dict mapping (dx, dy) offset to PNG bytes for all 4 quadrants

    Raises:
      RuntimeError: If render fails or times out
    """
    result_event = threading.Event()
    result_data: dict[str, Any] = {"result": None, "error": None}

    def callback(result: dict[tuple[int, int], bytes] | None, error: str | None) -> None:
      result_data["result"] = result
      result_data["error"] = error
      result_event.set()

    request = RenderRequest(
      quadrant_x=quadrant_x,
      quadrant_y=quadrant_y,
      lat=lat,
      lng=lng,
      width_px=width_px,
      height_px=height_px,
      camera_azimuth_degrees=camera_azimuth_degrees,
      camera_elevation_degrees=camera_elevation_degrees,
      view_height_meters=view_height_meters,
      callback=callback,
    )

    self.render_queue.put(request)

    if not result_event.wait(timeout=timeout):
      raise RuntimeError(f"Render timed out after {timeout}s")

    if result_data["error"]:
      raise RuntimeError(result_data["error"])

    return result_data["result"]

  @property
  def queue_size(self) -> int:
    """Get the current size of the render queue."""
    return self.render_queue.qsize()

  @property
  def is_running(self) -> bool:
    """Check if the renderer is running."""
    return self.running


# Global singleton instance
_renderer: WebRenderer | None = None
_renderer_lock = threading.Lock()


def get_web_renderer(
  web_dir: Path = WEB_DIR, port: int = DEFAULT_WEB_PORT
) -> WebRenderer:
  """
  Get the global web renderer instance, creating it if necessary.

  This provides a singleton instance of the WebRenderer that can be
  shared across the application.
  """
  global _renderer

  with _renderer_lock:
    if _renderer is None:
      _renderer = WebRenderer(web_dir, port)
    return _renderer


def start_global_renderer(
  web_dir: Path = WEB_DIR, port: int = DEFAULT_WEB_PORT
) -> WebRenderer:
  """Start the global web renderer."""
  renderer = get_web_renderer(web_dir, port)
  renderer.start()
  return renderer


def stop_global_renderer() -> None:
  """Stop the global web renderer."""
  global _renderer

  with _renderer_lock:
    if _renderer is not None:
      _renderer.stop()
      _renderer = None

```

```json
{
  "models": [
    {
      "name": "Omni Water v1",
      "model_id": "cannoneyed-quiet-green-lamprey",
      "api_key_env": "OXEN_OMNI_v04_WATER_API_KEY",
      "endpoint": "https://hub.oxen.ai/api/images/edit",
      "num_inference_steps": 28
    },
    {
      "name": "Omni Water v2",
      "model_id": "cannoneyed-rural-rose-dingo",
      "api_key_env": "OXEN_OMNI_WATER_V2_API_KEY",
      "endpoint": "https://hub.oxen.ai/api/images/edit",
      "num_inference_steps": 28
    },
    {
      "name": "Omni (Original)",
      "model_id": "cannoneyed-gentle-gold-antlion",
      "api_key_env": "OXEN_OMNI_API_KEY",
      "endpoint": "https://hub.oxen.ai/api/images/edit",
      "num_inference_steps": 28
    }
  ],
  "default_model_id": "cannoneyed-quiet-green-lamprey"
}

```

Now let me update the main `app.py` to integrate all these new components:

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemStatus,
  QueueItemType,
  add_to_queue,
  cleanup_stale_processing,
  clear_completed_items,
  get_next_pending_item,
  get_pending_queue,
  get_processing_item,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  get_generation_config,
)
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = "starting" if item_type == QueueItemType.GENERATE else "rendering"
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}")
    if model_id:
      print(f"   Model: {model_id}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(conn, config, selected_quadrants, model_id)
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify({
    "models": [m.to_dict() for m in APP_CONFIG.models],
    "default_model_id": APP_CONFIG.default_model_id,
  })


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """API endpoint to generate tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id)
  return jsonify(result), 202  # 202 Accepted


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Clean up any stale processing items from previous runs
    stale_count = cleanup_stale_processing(conn)
    if stale_count > 0:
      print(f"‚ö†Ô∏è  Reset {stale_count} stale processing item(s) from previous run")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

Now let me update `generate_omni.py` to accept the model configuration:

```python
"""
Reusable library for generating pixel art using the Oxen.ai model.

This module provides the core generation logic that can be used by:
- view_generations.py (Flask web server)
- generate_tiles_omni.py (command-line script)
- automatic_generation.py (automated generation)

The main entry point is `run_generation_for_quadrants()` which handles:
1. Validating the quadrant selection
2. Rendering any missing quadrants
3. Building the template image
4. Uploading to GCS and calling the Oxen API
5. Saving the generated quadrants to the database
"""

import os
import re
import sqlite3
import tempfile
from io import BytesIO
from pathlib import Path
from typing import Callable
from urllib.parse import urlencode

import requests
from dotenv import load_dotenv
from PIL import Image
from playwright.sync_api import sync_playwright

from isometric_nyc.e2e_generation.infill_template import (
  QUADRANT_SIZE,
  InfillRegion,
  TemplateBuilder,
  validate_quadrant_selection,
)
from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  ensure_quadrant_exists,
  image_to_png_bytes,
  png_bytes_to_image,
  save_quadrant_generation,
  save_quadrant_render,
  split_tile_into_quadrants,
  upload_to_gcs,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_generation as shared_get_quadrant_generation,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_render as shared_get_quadrant_render,
)

# Load environment variables
load_dotenv()

# Oxen API configuration
OMNI_MODEL_ID = "cannoneyed-gentle-gold-antlion"
OMNI_WATER_MODEL_ID = "cannoneyed-quiet-green-lamprey"
OMNI_WATER_V2_MODEL_ID = "cannoneyed-rural-rose-dingo"

GCS_BUCKET_NAME = "isometric-nyc-infills"


# =============================================================================
# Quadrant Parsing Utilities
# =============================================================================


def parse_quadrant_tuple(s: str) -> tuple[int, int]:
  """
  Parse a quadrant tuple string like "(0,1)" or "0,1" into a tuple.

  Args:
      s: String in format "(x,y)" or "x,y"

  Returns:
      Tuple of (x, y) coordinates

  Raises:
      ValueError: If the format is invalid
  """
  s = s.strip()
  # Remove optional parentheses
  if s.startswith("(") and s.endswith(")"):
    s = s[1:-1]
  parts = s.split(",")
  if len(parts) != 2:
    raise ValueError(f"Invalid quadrant tuple format: {s}")
  return (int(parts[0].strip()), int(parts[1].strip()))


def parse_quadrant_list(s: str) -> list[tuple[int, int]]:
  """
  Parse a comma-separated list of quadrant tuples.

  Args:
      s: String like "(0,1),(0,2)" or "(0,1), (0,2)"

  Returns:
      List of (x, y) coordinate tuples

  Raises:
      ValueError: If the format is invalid
  """
  # Use regex to find all (x,y) patterns
  pattern = r"\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)"
  matches = re.findall(pattern, s)
  if not matches:
    raise ValueError(f"No valid quadrant tuples found in: {s}")
  return [(int(x), int(y)) for x, y in matches]


# =============================================================================
# Oxen API Functions
# =============================================================================


def call_oxen_api(
  image_url: str,
  model_config: "ModelConfig | None" = None,
) -> str:
  """
  Call the Oxen API to generate pixel art.

  Args:
      image_url: Public URL of the input template image
      model_config: Optional model configuration. If not provided, uses defaults.

  Returns:
      URL of the generated image

  Raises:
      requests.HTTPError: If the API call fails
      ValueError: If the response format is unexpected
  """
  from isometric_nyc.e2e_generation.model_config import ModelConfig

  # Use provided config or defaults
  if model_config is not None:
    endpoint = model_config.endpoint
    model_id = model_config.model_id
    api_key = model_config.api_key
    num_inference_steps = model_config.num_inference_steps
  else:
    endpoint = "https://hub.oxen.ai/api/images/edit"
    model_id = OMNI_WATER_MODEL_ID
    api_key = os.getenv("OXEN_OMNI_v04_WATER_API_KEY")
    num_inference_steps = 28

  if not api_key:
    raise ValueError(f"API key not found for model {model_id}")

  headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json",
  }

  prompt = (
    "Fill in the outlined section with the missing pixels corresponding to "
    "the <isometric nyc pixel art> style, removing the border and exactly "
    "following the shape/style/structure of the surrounding image (if present)."
  )

  payload = {
    "model": model_id,
    "input_image": image_url,
    "prompt": prompt,
    "num_inference_steps": num_inference_steps,
  }

  print(f"   ü§ñ Calling Oxen API with model {model_id}...")
  response = requests.post(endpoint, headers=headers, json=payload, timeout=300)
  response.raise_for_status()

  result = response.json()

  if "images" in result and len(result["images"]) > 0:
    return result["images"][0]["url"]
  elif "url" in result:
    return result["url"]
  elif "image_url" in result:
    return result["image_url"]
  elif "output" in result:
    return result["output"]
  else:
    raise ValueError(f"Unexpected API response format: {result}")


def download_image_to_pil(url: str) -> Image.Image:
  """
  Download an image from a URL and return as PIL Image.

  Args:
      url: URL of the image to download

  Returns:
      PIL Image object
  """
  response = requests.get(url, timeout=120)
  response.raise_for_status()
  return Image.open(BytesIO(response.content))


# =============================================================================
# Rendering Functions
# =============================================================================


def render_quadrant(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
  port: int,
) -> bytes | None:
  """
  Render a quadrant and save to database.

  This renders the tile containing the quadrant and saves all 4 quadrants.

  Args:
      conn: Database connection
      config: Generation config dict
      x: Quadrant x coordinate
      y: Quadrant y coordinate
      port: Web server port for rendering

  Returns:
      PNG bytes of the rendered quadrant, or None if failed
  """
  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  # Build URL for rendering
  params = {
    "export": "true",
    "lat": quadrant["lat"],
    "lon": quadrant["lng"],
    "width": config["width_px"],
    "height": config["height_px"],
    "azimuth": config["camera_azimuth_degrees"],
    "elevation": config["camera_elevation_degrees"],
    "view_height": config.get("view_height_meters", 200),
  }
  query_string = urlencode(params)
  url = f"http://localhost:{port}/?{query_string}"

  # Render using Playwright
  with sync_playwright() as p:
    browser = p.chromium.launch(
      headless=True,
      args=[
        "--enable-webgl",
        "--use-gl=angle",
        "--ignore-gpu-blocklist",
      ],
    )

    context = browser.new_context(
      viewport={"width": config["width_px"], "height": config["height_px"]},
      device_scale_factor=1,
    )
    page = context.new_page()

    page.goto(url, wait_until="networkidle")

    try:
      page.wait_for_function("window.TILES_LOADED === true", timeout=60000)
    except Exception:
      print("      ‚ö†Ô∏è  Timeout waiting for tiles, continuing anyway...")

    # Get screenshot as bytes
    screenshot_bytes = page.screenshot(type="png")

    page.close()
    context.close()
    browser.close()

  # Open as PIL image and split into quadrants
  full_tile = Image.open(BytesIO(screenshot_bytes))
  quadrant_images = split_tile_into_quadrants(full_tile)

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), quad_img in quadrant_images.items():
    qx, qy = x + dx, y + dy
    png_bytes = image_to_png_bytes(quad_img)
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


# =============================================================================
# Core Generation Logic
# =============================================================================


def run_generation_for_quadrants(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  port: int = DEFAULT_WEB_PORT,
  bucket_name: str = GCS_BUCKET_NAME,
  status_callback: Callable[[str, str], None] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is the main entry point for generation. It:
  1. Validates the quadrant selection
  2. Renders any missing quadrants
  3. Builds the template image with appropriate borders
  4. Uploads to GCS and calls the Oxen API
  5. Saves the generated quadrants to the database

  Args:
      conn: Database connection
      config: Generation config dict
      selected_quadrants: List of (x, y) quadrant coordinates to generate
      port: Web server port for rendering (default: 5173)
      bucket_name: GCS bucket name for uploads
      status_callback: Optional callback(status, message) for progress updates

  Returns:
      Dict with:
          - success: bool
          - message: str (on success)
          - error: str (on failure)
          - quadrants: list of generated quadrant coords (on success)
  """

  def update_status(status: str, message: str = "") -> None:
    if status_callback:
      status_callback(status, message)

  update_status("validating", "Checking API key...")

  # Create helper functions for validation
  def has_generation_in_db(qx: int, qy: int) -> bool:
    gen = shared_get_quadrant_generation(conn, qx, qy)
    return gen is not None

  def get_render_from_db_with_render(qx: int, qy: int) -> Image.Image | None:
    """Get render, rendering if it doesn't exist yet."""
    render_bytes = shared_get_quadrant_render(conn, qx, qy)
    if render_bytes:
      return png_bytes_to_image(render_bytes)

    # Need to render
    update_status("rendering", f"Rendering quadrant ({qx}, {qy})...")
    print(f"   üì¶ Rendering quadrant ({qx}, {qy})...")
    render_bytes = render_quadrant(conn, config, qx, qy, port)
    if render_bytes:
      return png_bytes_to_image(render_bytes)
    return None

  def get_generation_from_db(qx: int, qy: int) -> Image.Image | None:
    gen_bytes = shared_get_quadrant_generation(conn, qx, qy)
    if gen_bytes:
      return png_bytes_to_image(gen_bytes)
    return None

  update_status("validating", "Validating quadrant selection...")

  # Validate selection with auto-expansion
  is_valid, msg, placement = validate_quadrant_selection(
    selected_quadrants, has_generation_in_db, allow_expansion=True
  )

  if not is_valid:
    update_status("error", msg)
    return {"success": False, "error": msg}

  print(f"‚úÖ Validation: {msg}")

  # Get primary quadrants (the ones user selected, not padding)
  primary_quadrants = (
    placement.primary_quadrants if placement.primary_quadrants else selected_quadrants
  )
  padding_quadrants = placement.padding_quadrants if placement else []

  if padding_quadrants:
    print(f"   üì¶ Padding quadrants: {padding_quadrants}")

  # Create the infill region (may be expanded)
  if placement._expanded_region is not None:
    region = placement._expanded_region
  else:
    region = InfillRegion.from_quadrants(selected_quadrants)

  # Build the template
  update_status("rendering", "Building template image...")
  builder = TemplateBuilder(
    region, has_generation_in_db, get_render_from_db_with_render, get_generation_from_db
  )

  print("üìã Building template...")
  result = builder.build(border_width=2, allow_expansion=True)

  if result is None:
    error_msg = builder._last_validation_error or "Failed to build template"
    update_status("error", error_msg)
    return {
      "success": False,
      "error": error_msg,
    }

  template_image, placement = result

  # Save template to temp file and upload to GCS
  with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
    template_path = Path(tmp.name)
    template_image.save(template_path)

  try:
    update_status("uploading", "Uploading template to cloud...")
    print("üì§ Uploading template to GCS...")
    image_url = upload_to_gcs(template_path, bucket_name)

    update_status("generating", "Calling AI model (this may take a minute)...")
    print("ü§ñ Calling Oxen API...")
    generated_url = call_oxen_api(image_url)

    update_status("saving", "Downloading and saving results...")
    print("üì• Downloading generated image...")
    generated_image = download_image_to_pil(generated_url)

    # Extract quadrants from generated image and save to database
    print("üíæ Saving generated quadrants to database...")

    # Figure out what quadrants are in the infill region
    all_infill_quadrants = (
      placement.all_infill_quadrants
      if placement.all_infill_quadrants
      else region.overlapping_quadrants()
    )

    # For each infill quadrant, extract pixels from the generated image
    saved_count = 0
    for qx, qy in all_infill_quadrants:
      # Calculate position in the generated image
      quad_world_x = qx * QUADRANT_SIZE
      quad_world_y = qy * QUADRANT_SIZE

      template_x = quad_world_x - placement.world_offset_x
      template_y = quad_world_y - placement.world_offset_y

      # Crop this quadrant from the generated image
      crop_box = (
        template_x,
        template_y,
        template_x + QUADRANT_SIZE,
        template_y + QUADRANT_SIZE,
      )
      quad_img = generated_image.crop(crop_box)
      png_bytes = image_to_png_bytes(quad_img)

      # Only save primary quadrants (not padding)
      if (qx, qy) in primary_quadrants or (qx, qy) in [
        (q[0], q[1]) for q in primary_quadrants
      ]:
        if save_quadrant_generation(conn, config, qx, qy, png_bytes):
          print(f"   ‚úì Saved generation for ({qx}, {qy})")
          saved_count += 1
        else:
          print(f"   ‚ö†Ô∏è Failed to save generation for ({qx}, {qy})")
      else:
        print(f"   ‚è≠Ô∏è Skipped padding quadrant ({qx}, {qy})")

    update_status("complete", f"Generated {saved_count} quadrant(s)")
    return {
      "success": True,
      "message": f"Generated {saved_count} quadrant{'s' if saved_count != 1 else ''}",
      "quadrants": list(primary_quadrants),
    }

  finally:
    # Clean up temp file
    template_path.unlink(missing_ok=True)

```

```python
"""
Reusable library for generating pixel art using the Oxen.ai model.

This module provides the core generation logic that can be used by:
- view_generations.py (Flask web server)
- generate_tiles_omni.py (command-line script)
- automatic_generation.py (automated generation)

The main entry point is `run_generation_for_quadrants()` which handles:
1. Validating the quadrant selection
2. Rendering any missing quadrants
3. Building the template image
4. Uploading to GCS and calling the Oxen API
5. Saving the generated quadrants to the database
"""

import os
import re
import sqlite3
import tempfile
from io import BytesIO
from pathlib import Path
from typing import Callable
from urllib.parse import urlencode

import requests
from dotenv import load_dotenv
from PIL import Image
from playwright.sync_api import sync_playwright

from isometric_nyc.e2e_generation.infill_template import (
  QUADRANT_SIZE,
  InfillRegion,
  TemplateBuilder,
  validate_quadrant_selection,
)
from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  ensure_quadrant_exists,
  image_to_png_bytes,
  png_bytes_to_image,
  save_quadrant_generation,
  save_quadrant_render,
  split_tile_into_quadrants,
  upload_to_gcs,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_generation as shared_get_quadrant_generation,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_render as shared_get_quadrant_render,
)

# Load environment variables
load_dotenv()

# Oxen API configuration
OMNI_MODEL_ID = "cannoneyed-gentle-gold-antlion"
OMNI_WATER_MODEL_ID = "cannoneyed-quiet-green-lamprey"
OMNI_WATER_V2_MODEL_ID = "cannoneyed-rural-rose-dingo"

GCS_BUCKET_NAME = "isometric-nyc-infills"


# =============================================================================
# Quadrant Parsing Utilities
# =============================================================================


def parse_quadrant_tuple(s: str) -> tuple[int, int]:
  """
  Parse a quadrant tuple string like "(0,1)" or "0,1" into a tuple.

  Args:
      s: String in format "(x,y)" or "x,y"

  Returns:
      Tuple of (x, y) coordinates

  Raises:
      ValueError: If the format is invalid
  """
  s = s.strip()
  # Remove optional parentheses
  if s.startswith("(") and s.endswith(")"):
    s = s[1:-1]
  parts = s.split(",")
  if len(parts) != 2:
    raise ValueError(f"Invalid quadrant tuple format: {s}")
  return (int(parts[0].strip()), int(parts[1].strip()))


def parse_quadrant_list(s: str) -> list[tuple[int, int]]:
  """
  Parse a comma-separated list of quadrant tuples.

  Args:
      s: String like "(0,1),(0,2)" or "(0,1), (0,2)"

  Returns:
      List of (x, y) coordinate tuples

  Raises:
      ValueError: If the format is invalid
  """
  # Use regex to find all (x,y) patterns
  pattern = r"\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)"
  matches = re.findall(pattern, s)
  if not matches:
    raise ValueError(f"No valid quadrant tuples found in: {s}")
  return [(int(x), int(y)) for x, y in matches]


# =============================================================================
# Oxen API Functions
# =============================================================================


def call_oxen_api(
  image_url: str,
  model_config: "ModelConfig | None" = None,
) -> str:
  """
  Call the Oxen API to generate pixel art.

  Args:
      image_url: Public URL of the input template image
      model_config: Optional model configuration. If not provided, uses defaults.

  Returns:
      URL of the generated image

  Raises:
      requests.HTTPError: If the API call fails
      ValueError: If the response format is unexpected
  """
  from isometric_nyc.e2e_generation.model_config import ModelConfig

  # Use provided config or defaults
  if model_config is not None:
    endpoint = model_config.endpoint
    model_id = model_config.model_id
    api_key = model_config.api_key
    num_inference_steps = model_config.num_inference_steps
  else:
    endpoint = "https://hub.oxen.ai/api/images/edit"
    model_id = OMNI_WATER_MODEL_ID
    api_key = os.getenv("OXEN_OMNI_v04_WATER_API_KEY")
    num_inference_steps = 28

  if not api_key:
    raise ValueError(f"API key not found for model {model_id}")

  headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json",
  }

  prompt = (
    "Fill in the outlined section with the missing pixels corresponding to "
    "the <isometric nyc pixel art> style, removing the border and exactly "
    "following the shape/style/structure of the surrounding image (if present)."
  )

  payload = {
    "model": model_id,
    "input_image": image_url,
    "prompt": prompt,
    "num_inference_steps": num_inference_steps,
  }

  print(f"   ü§ñ Calling Oxen API with model {model_id}...")
  response = requests.post(endpoint, headers=headers, json=payload, timeout=300)
  response.raise_for_status()

  result = response.json()

  if "images" in result and len(result["images"]) > 0:
    return result["images"][0]["url"]
  elif "url" in result:
    return result["url"]
  elif "image_url" in result:
    return result["image_url"]
  elif "output" in result:
    return result["output"]
  else:
    raise ValueError(f"Unexpected API response format: {result}")


def download_image_to_pil(url: str) -> Image.Image:
  """
  Download an image from a URL and return as PIL Image.

  Args:
      url: URL of the image to download

  Returns:
      PIL Image object
  """
  response = requests.get(url, timeout=120)
  response.raise_for_status()
  return Image.open(BytesIO(response.content))


# =============================================================================
# Rendering Functions
# =============================================================================


def render_quadrant(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
  port: int,
) -> bytes | None:
  """
  Render a quadrant and save to database.

  This renders the tile containing the quadrant and saves all 4 quadrants.

  Args:
      conn: Database connection
      config: Generation config dict
      x: Quadrant x coordinate
      y: Quadrant y coordinate
      port: Web server port for rendering

  Returns:
      PNG bytes of the rendered quadrant, or None if failed
  """
  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  # Build URL for rendering
  params = {
    "export": "true",
    "lat": quadrant["lat"],
    "lon": quadrant["lng"],
    "width": config["width_px"],
    "height": config["height_px"],
    "azimuth": config["camera_azimuth_degrees"],
    "elevation": config["camera_elevation_degrees"],
    "view_height": config.get("view_height_meters", 200),
  }
  query_string = urlencode(params)
  url = f"http://localhost:{port}/?{query_string}"

  # Render using Playwright
  with sync_playwright() as p:
    browser = p.chromium.launch(
      headless=True,
      args=[
        "--enable-webgl",
        "--use-gl=angle",
        "--ignore-gpu-blocklist",
      ],
    )

    context = browser.new_context(
      viewport={"width": config["width_px"], "height": config["height_px"]},
      device_scale_factor=1,
    )
    page = context.new_page()

    page.goto(url, wait_until="networkidle")

    try:
      page.wait_for_function("window.TILES_LOADED === true", timeout=60000)
    except Exception:
      print("      ‚ö†Ô∏è  Timeout waiting for tiles, continuing anyway...")

    # Get screenshot as bytes
    screenshot_bytes = page.screenshot(type="png")

    page.close()
    context.close()
    browser.close()

  # Open as PIL image and split into quadrants
  full_tile = Image.open(BytesIO(screenshot_bytes))
  quadrant_images = split_tile_into_quadrants(full_tile)

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), quad_img in quadrant_images.items():
    qx, qy = x + dx, y + dy
    png_bytes = image_to_png_bytes(quad_img)
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


# =============================================================================
# Core Generation Logic
# =============================================================================


def run_generation_for_quadrants(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  port: int = DEFAULT_WEB_PORT,
  bucket_name: str = GCS_BUCKET_NAME,
  status_callback: Callable[[str, str], None] | None = None,
  model_config: "ModelConfig | None" = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is the main entry point for generation. It:
  1. Validates the quadrant selection
  2. Renders any missing quadrants
  3. Builds the template image with appropriate borders
  4. Uploads to GCS and calls the Oxen API
  5. Saves the generated quadrants to the database

  Args:
      conn: Database connection
      config: Generation config dict
      selected_quadrants: List of (x, y) quadrant coordinates to generate
      port: Web server port for rendering (default: 5173)
      bucket_name: GCS bucket name for uploads
      status_callback: Optional callback(status, message) for progress updates
      model_config: Optional model configuration for the Oxen API

  Returns:
      Dict with:
          - success: bool
          - message: str (on success)
          - error: str (on failure)
          - quadrants: list of generated quadrant coords (on success)
  """
  from isometric_nyc.e2e_generation.model_config import ModelConfig

  def update_status(status: str, message: str = "") -> None:
    if status_callback:
      status_callback(status, message)

  update_status("validating", "Checking API key...")

  # Create helper functions for validation
  def has_generation_in_db(qx: int, qy: int) -> bool:
    gen = shared_get_quadrant_generation(conn, qx, qy)
    return gen is not None

  def get_render_from_db_with_render(qx: int, qy: int) -> Image.Image | None:
    """Get render, rendering if it doesn't exist yet."""
    render_bytes = shared_get_quadrant_render(conn, qx, qy)
    if render_bytes:
      return png_bytes_to_image(render_bytes)

    # Need to render
    update_status("rendering", f"Rendering quadrant ({qx}, {qy})...")
    print(f"   üì¶ Rendering quadrant ({qx}, {qy})...")
    render_bytes = render_quadrant(conn, config, qx, qy, port)
    if render_bytes:
      return png_bytes_to_image(render_bytes)
    return None

  def get_generation_from_db(qx: int, qy: int) -> Image.Image | None:
    gen_bytes = shared_get_quadrant_generation(conn, qx, qy)
    if gen_bytes:
      return png_bytes_to_image(gen_bytes)
    return None

  update_status("validating", "Validating quadrant selection...")

  # Validate selection with auto-expansion
  is_valid, msg, placement = validate_quadrant_selection(
    selected_quadrants, has_generation_in_db, allow_expansion=True
  )

  if not is_valid:
    update_status("error", msg)
    return {"success": False, "error": msg}

  print(f"‚úÖ Validation: {msg}")

  # Get primary quadrants (the ones user selected, not padding)
  primary_quadrants = (
    placement.primary_quadrants if placement.primary_quadrants else selected_quadrants
  )
  padding_quadrants = placement.padding_quadrants if placement else []

  if padding_quadrants:
    print(f"   üì¶ Padding quadrants: {padding_quadrants}")

  # Create the infill region (may be expanded)
  if placement._expanded_region is not None:
    region = placement._expanded_region
  else:
    region = InfillRegion.from_quadrants(selected_quadrants)

  # Build the template
  update_status("rendering", "Building template image...")
  builder = TemplateBuilder(
    region, has_generation_in_db, get_render_from_db_with_render, get_generation_from_db
  )

  print("üìã Building template...")
  result = builder.build(border_width=2, allow_expansion=True)

  if result is None:
    error_msg = builder._last_validation_error or "Failed to build template"
    update_status("error", error_msg)
    return {
      "success": False,
      "error": error_msg,
    }

  template_image, placement = result

  # Save template to temp file and upload to GCS
  with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
    template_path = Path(tmp.name)
    template_image.save(template_path)

  try:
    update_status("uploading", "Uploading template to cloud...")
    print("üì§ Uploading template to GCS...")
    image_url = upload_to_gcs(template_path, bucket_name)

    update_status("generating", "Calling AI model (this may take a minute)...")
    print("ü§ñ Calling Oxen API...")
    generated_url = call_oxen_api(image_url)

    update_status("saving", "Downloading and saving results...")
    print("üì• Downloading generated image...")
    generated_image = download_image_to_pil(generated_url)

    # Extract quadrants from generated image and save to database
    print("üíæ Saving generated quadrants to database...")

    # Figure out what quadrants are in the infill region
    all_infill_quadrants = (
      placement.all_infill_quadrants
      if placement.all_infill_quadrants
      else region.overlapping_quadrants()
    )

    # For each infill quadrant, extract pixels from the generated image
    saved_count = 0
    for qx, qy in all_infill_quadrants:
      # Calculate position in the generated image
      quad_world_x = qx * QUADRANT_SIZE
      quad_world_y = qy * QUADRANT_SIZE

      template_x = quad_world_x - placement.world_offset_x
      template_y = quad_world_y - placement.world_offset_y

      # Crop this quadrant from the generated image
      crop_box = (
        template_x,
        template_y,
        template_x + QUADRANT_SIZE,
        template_y + QUADRANT_SIZE,
      )
      quad_img = generated_image.crop(crop_box)
      png_bytes = image_to_png_bytes(quad_img)

      # Only save primary quadrants (not padding)
      if (qx, qy) in primary_quadrants or (qx, qy) in [
        (q[0], q[1]) for q in primary_quadrants
      ]:
        if save_quadrant_generation(conn, config, qx, qy, png_bytes):
          print(f"   ‚úì Saved generation for ({qx}, {qy})")
          saved_count += 1
        else:
          print(f"   ‚ö†Ô∏è Failed to save generation for ({qx}, {qy})")
      else:
        print(f"   ‚è≠Ô∏è Skipped padding quadrant ({qx}, {qy})")

    update_status("complete", f"Generated {saved_count} quadrant(s)")
    return {
      "success": True,
      "message": f"Generated {saved_count} quadrant{'s' if saved_count != 1 else ''}",
      "quadrants": list(primary_quadrants),
    }

  finally:
    # Clean up temp file
    template_path.unlink(missing_ok=True)

```

```python
"""
Reusable library for generating pixel art using the Oxen.ai model.

This module provides the core generation logic that can be used by:
- view_generations.py (Flask web server)
- generate_tiles_omni.py (command-line script)
- automatic_generation.py (automated generation)

The main entry point is `run_generation_for_quadrants()` which handles:
1. Validating the quadrant selection
2. Rendering any missing quadrants
3. Building the template image
4. Uploading to GCS and calling the Oxen API
5. Saving the generated quadrants to the database
"""

import os
import re
import sqlite3
import tempfile
from io import BytesIO
from pathlib import Path
from typing import Callable
from urllib.parse import urlencode

import requests
from dotenv import load_dotenv
from PIL import Image
from playwright.sync_api import sync_playwright

from isometric_nyc.e2e_generation.infill_template import (
  QUADRANT_SIZE,
  InfillRegion,
  TemplateBuilder,
  validate_quadrant_selection,
)
from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  ensure_quadrant_exists,
  image_to_png_bytes,
  png_bytes_to_image,
  save_quadrant_generation,
  save_quadrant_render,
  split_tile_into_quadrants,
  upload_to_gcs,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_generation as shared_get_quadrant_generation,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_render as shared_get_quadrant_render,
)

# Load environment variables
load_dotenv()

# Oxen API configuration
OMNI_MODEL_ID = "cannoneyed-gentle-gold-antlion"
OMNI_WATER_MODEL_ID = "cannoneyed-quiet-green-lamprey"
OMNI_WATER_V2_MODEL_ID = "cannoneyed-rural-rose-dingo"

GCS_BUCKET_NAME = "isometric-nyc-infills"


# =============================================================================
# Quadrant Parsing Utilities
# =============================================================================


def parse_quadrant_tuple(s: str) -> tuple[int, int]:
  """
  Parse a quadrant tuple string like "(0,1)" or "0,1" into a tuple.

  Args:
      s: String in format "(x,y)" or "x,y"

  Returns:
      Tuple of (x, y) coordinates

  Raises:
      ValueError: If the format is invalid
  """
  s = s.strip()
  # Remove optional parentheses
  if s.startswith("(") and s.endswith(")"):
    s = s[1:-1]
  parts = s.split(",")
  if len(parts) != 2:
    raise ValueError(f"Invalid quadrant tuple format: {s}")
  return (int(parts[0].strip()), int(parts[1].strip()))


def parse_quadrant_list(s: str) -> list[tuple[int, int]]:
  """
  Parse a comma-separated list of quadrant tuples.

  Args:
      s: String like "(0,1),(0,2)" or "(0,1), (0,2)"

  Returns:
      List of (x, y) coordinate tuples

  Raises:
      ValueError: If the format is invalid
  """
  # Use regex to find all (x,y) patterns
  pattern = r"\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)"
  matches = re.findall(pattern, s)
  if not matches:
    raise ValueError(f"No valid quadrant tuples found in: {s}")
  return [(int(x), int(y)) for x, y in matches]


# =============================================================================
# Oxen API Functions
# =============================================================================


def call_oxen_api(
  image_url: str,
  model_config: "ModelConfig | None" = None,
) -> str:
  """
  Call the Oxen API to generate pixel art.

  Args:
      image_url: Public URL of the input template image
      model_config: Optional model configuration. If not provided, uses defaults.

  Returns:
      URL of the generated image

  Raises:
      requests.HTTPError: If the API call fails
      ValueError: If the response format is unexpected
  """
  from isometric_nyc.e2e_generation.model_config import ModelConfig

  # Use provided config or defaults
  if model_config is not None:
    endpoint = model_config.endpoint
    model_id = model_config.model_id
    api_key = model_config.api_key
    num_inference_steps = model_config.num_inference_steps
  else:
    endpoint = "https://hub.oxen.ai/api/images/edit"
    model_id = OMNI_WATER_MODEL_ID
    api_key = os.getenv("OXEN_OMNI_v04_WATER_API_KEY")
    num_inference_steps = 28

  if not api_key:
    raise ValueError(f"API key not found for model {model_id}")

  headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json",
  }

  prompt = (
    "Fill in the outlined section with the missing pixels corresponding to "
    "the <isometric nyc pixel art> style, removing the border and exactly "
    "following the shape/style/structure of the surrounding image (if present)."
  )

  payload = {
    "model": model_id,
    "input_image": image_url,
    "prompt": prompt,
    "num_inference_steps": num_inference_steps,
  }

  print(f"   ü§ñ Calling Oxen API with model {model_id}...")
  response = requests.post(endpoint, headers=headers, json=payload, timeout=300)
  response.raise_for_status()

  result = response.json()

  if "images" in result and len(result["images"]) > 0:
    return result["images"][0]["url"]
  elif "url" in result:
    return result["url"]
  elif "image_url" in result:
    return result["image_url"]
  elif "output" in result:
    return result["output"]
  else:
    raise ValueError(f"Unexpected API response format: {result}")


def download_image_to_pil(url: str) -> Image.Image:
  """
  Download an image from a URL and return as PIL Image.

  Args:
      url: URL of the image to download

  Returns:
      PIL Image object
  """
  response = requests.get(url, timeout=120)
  response.raise_for_status()
  return Image.open(BytesIO(response.content))


# =============================================================================
# Rendering Functions
# =============================================================================


def render_quadrant(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
  port: int,
) -> bytes | None:
  """
  Render a quadrant and save to database.

  This renders the tile containing the quadrant and saves all 4 quadrants.

  Args:
      conn: Database connection
      config: Generation config dict
      x: Quadrant x coordinate
      y: Quadrant y coordinate
      port: Web server port for rendering

  Returns:
      PNG bytes of the rendered quadrant, or None if failed
  """
  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  # Build URL for rendering
  params = {
    "export": "true",
    "lat": quadrant["lat"],
    "lon": quadrant["lng"],
    "width": config["width_px"],
    "height": config["height_px"],
    "azimuth": config["camera_azimuth_degrees"],
    "elevation": config["camera_elevation_degrees"],
    "view_height": config.get("view_height_meters", 200),
  }
  query_string = urlencode(params)
  url = f"http://localhost:{port}/?{query_string}"

  # Render using Playwright
  with sync_playwright() as p:
    browser = p.chromium.launch(
      headless=True,
      args=[
        "--enable-webgl",
        "--use-gl=angle",
        "--ignore-gpu-blocklist",
      ],
    )

    context = browser.new_context(
      viewport={"width": config["width_px"], "height": config["height_px"]},
      device_scale_factor=1,
    )
    page = context.new_page()

    page.goto(url, wait_until="networkidle")

    try:
      page.wait_for_function("window.TILES_LOADED === true", timeout=60000)
    except Exception:
      print("      ‚ö†Ô∏è  Timeout waiting for tiles, continuing anyway...")

    # Get screenshot as bytes
    screenshot_bytes = page.screenshot(type="png")

    page.close()
    context.close()
    browser.close()

  # Open as PIL image and split into quadrants
  full_tile = Image.open(BytesIO(screenshot_bytes))
  quadrant_images = split_tile_into_quadrants(full_tile)

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), quad_img in quadrant_images.items():
    qx, qy = x + dx, y + dy
    png_bytes = image_to_png_bytes(quad_img)
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


# =============================================================================
# Core Generation Logic
# =============================================================================


def run_generation_for_quadrants(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  port: int = DEFAULT_WEB_PORT,
  bucket_name: str = GCS_BUCKET_NAME,
  status_callback: Callable[[str, str], None] | None = None,
  model_config: "ModelConfig | None" = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is the main entry point for generation. It:
  1. Validates the quadrant selection
  2. Renders any missing quadrants
  3. Builds the template image with appropriate borders
  4. Uploads to GCS and calls the Oxen API
  5. Saves the generated quadrants to the database

  Args:
      conn: Database connection
      config: Generation config dict
      selected_quadrants: List of (x, y) quadrant coordinates to generate
      port: Web server port for rendering (default: 5173)
      bucket_name: GCS bucket name for uploads
      status_callback: Optional callback(status, message) for progress updates
      model_config: Optional model configuration for the Oxen API

  Returns:
      Dict with:
          - success: bool
          - message: str (on success)
          - error: str (on failure)
          - quadrants: list of generated quadrant coords (on success)
  """
  from isometric_nyc.e2e_generation.model_config import ModelConfig

  def update_status(status: str, message: str = "") -> None:
    if status_callback:
      status_callback(status, message)

  update_status("validating", "Checking API key...")

  # Create helper functions for validation
  def has_generation_in_db(qx: int, qy: int) -> bool:
    gen = shared_get_quadrant_generation(conn, qx, qy)
    return gen is not None

  def get_render_from_db_with_render(qx: int, qy: int) -> Image.Image | None:
    """Get render, rendering if it doesn't exist yet."""
    render_bytes = shared_get_quadrant_render(conn, qx, qy)
    if render_bytes:
      return png_bytes_to_image(render_bytes)

    # Need to render
    update_status("rendering", f"Rendering quadrant ({qx}, {qy})...")
    print(f"   üì¶ Rendering quadrant ({qx}, {qy})...")
    render_bytes = render_quadrant(conn, config, qx, qy, port)
    if render_bytes:
      return png_bytes_to_image(render_bytes)
    return None

  def get_generation_from_db(qx: int, qy: int) -> Image.Image | None:
    gen_bytes = shared_get_quadrant_generation(conn, qx, qy)
    if gen_bytes:
      return png_bytes_to_image(gen_bytes)
    return None

  update_status("validating", "Validating quadrant selection...")

  # Validate selection with auto-expansion
  is_valid, msg, placement = validate_quadrant_selection(
    selected_quadrants, has_generation_in_db, allow_expansion=True
  )

  if not is_valid:
    update_status("error", msg)
    return {"success": False, "error": msg}

  print(f"‚úÖ Validation: {msg}")

  # Get primary quadrants (the ones user selected, not padding)
  primary_quadrants = (
    placement.primary_quadrants if placement.primary_quadrants else selected_quadrants
  )
  padding_quadrants = placement.padding_quadrants if placement else []

  if padding_quadrants:
    print(f"   üì¶ Padding quadrants: {padding_quadrants}")

  # Create the infill region (may be expanded)
  if placement._expanded_region is not None:
    region = placement._expanded_region
  else:
    region = InfillRegion.from_quadrants(selected_quadrants)

  # Build the template
  update_status("rendering", "Building template image...")
  builder = TemplateBuilder(
    region, has_generation_in_db, get_render_from_db_with_render, get_generation_from_db
  )

  print("üìã Building template...")
  result = builder.build(border_width=2, allow_expansion=True)

  if result is None:
    error_msg = builder._last_validation_error or "Failed to build template"
    update_status("error", error_msg)
    return {
      "success": False,
      "error": error_msg,
    }

  template_image, placement = result

  # Save template to temp file and upload to GCS
  with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
    template_path = Path(tmp.name)
    template_image.save(template_path)

  try:
    update_status("uploading", "Uploading template to cloud...")
    print("üì§ Uploading template to GCS...")
    image_url = upload_to_gcs(template_path, bucket_name)

    update_status("generating", "Calling AI model (this may take a minute)...")
    print("ü§ñ Calling Oxen API...")
    generated_url = call_oxen_api(image_url, model_config)

    update_status("saving", "Downloading and saving results...")
    print("üì• Downloading generated image...")
    generated_image = download_image_to_pil(generated_url)

    # Extract quadrants from generated image and save to database
    print("üíæ Saving generated quadrants to database...")

    # Figure out what quadrants are in the infill region
    all_infill_quadrants = (
      placement.all_infill_quadrants
      if placement.all_infill_quadrants
      else region.overlapping_quadrants()
    )

    # For each infill quadrant, extract pixels from the generated image
    saved_count = 0
    for qx, qy in all_infill_quadrants:
      # Calculate position in the generated image
      quad_world_x = qx * QUADRANT_SIZE
      quad_world_y = qy * QUADRANT_SIZE

      template_x = quad_world_x - placement.world_offset_x
      template_y = quad_world_y - placement.world_offset_y

      # Crop this quadrant from the generated image
      crop_box = (
        template_x,
        template_y,
        template_x + QUADRANT_SIZE,
        template_y + QUADRANT_SIZE,
      )
      quad_img = generated_image.crop(crop_box)
      png_bytes = image_to_png_bytes(quad_img)

      # Only save primary quadrants (not padding)
      if (qx, qy) in primary_quadrants or (qx, qy) in [
        (q[0], q[1]) for q in primary_quadrants
      ]:
        if save_quadrant_generation(conn, config, qx, qy, png_bytes):
          print(f"   ‚úì Saved generation for ({qx}, {qy})")
          saved_count += 1
        else:
          print(f"   ‚ö†Ô∏è Failed to save generation for ({qx}, {qy})")
      else:
        print(f"   ‚è≠Ô∏è Skipped padding quadrant ({qx}, {qy})")

    update_status("complete", f"Generated {saved_count} quadrant(s)")
    return {
      "success": True,
      "message": f"Generated {saved_count} quadrant{'s' if saved_count != 1 else ''}",
      "quadrants": list(primary_quadrants),
    }

  finally:
    # Clean up temp file
    template_path.unlink(missing_ok=True)

```

Now let me update the frontend. First, let me update the HTML template:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Generated Tiles Viewer</title>
    <link rel="stylesheet" href="/static/viewer.css" />
    <style>
      /* Dynamic grid sizing based on template variables */
      .grid {
        grid-template-columns: repeat({{ nx }}, {{ size_px }}px);
        grid-auto-rows: {{ size_px }}px;
      }
      .tile.placeholder {
        min-width: {{ size_px }}px;
        min-height: {{ size_px }}px;
      }
    </style>
  </head>
  <body>
    <!-- Config data for JS -->
    <script
      id="app-config"
      type="application/json"
      data-config='{"x": {{ x }}, "y": {{ y }}, "nx": {{ nx }}, "ny": {{ ny }}, "size_px": {{ size_px }}, "models": {{ models_config | safe }}, "default_model_id": "{{ default_model_id }}"}'
    ></script>

    <!-- Toast notification container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Fixed toolbar -->
    <div class="toolbar">
      <div class="toolbar-row">
        <div class="controls">
          <label>X: <input type="number" id="x" value="{{ x }}" /></label>
          <label>Y: <input type="number" id="y" value="{{ y }}" /></label>
          <label
            >NX: <input type="number" id="nx" value="{{ nx }}" min="1" max="20"
          /></label>
          <label
            >NY: <input type="number" id="ny" value="{{ ny }}" min="1" max="20"
          /></label>
          <label
            >Size:
            <input type="number" id="sizePx" value="{{ size_px }}" step="32"
          /></label>
          <button onclick="goTo()">Go</button>
          <div class="toggle-group">
            <label
              ><input
                type="checkbox"
                id="showLines"
                {%
                if
                show_lines
                %}checked{%
                endif
                %}
                onchange="toggleLines()"
              />
              Lines</label
            >
            <label
              ><input
                type="checkbox"
                id="showCoords"
                {%
                if
                show_coords
                %}checked{%
                endif
                %}
                onchange="toggleCoords()"
              />
              Coords</label
            >
            <label
              ><input
                type="checkbox"
                id="showRender"
                {%
                if
                show_render
                %}checked{%
                endif
                %}
                onchange="toggleRender()"
              />
              Renders</label
            >
          </div>
          <div class="toggle-group tools-group">
            <span class="tools-label">Tools:</span>
            <button
              id="selectTool"
              class="tool-btn"
              onclick="toggleSelectTool()"
              title="Select quadrants (S)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path>
                <path d="M13 13l6 6"></path>
              </svg>
              Select
            </button>
            <button
              id="fixWaterTool"
              class="tool-btn"
              onclick="toggleFixWaterTool()"
              title="Fix water color (W)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
              </svg>
              Fix Water
            </button>
            <button
              id="waterFillTool"
              class="tool-btn"
              onclick="toggleWaterFillTool()"
              title="Fill quadrant with water (F)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <rect x="3" y="3" width="18" height="18" rx="2"></rect>
                <path d="M12 8v8"></path>
                <path d="M8 12h8"></path>
              </svg>
              Water Fill
            </button>
          </div>
        </div>
        <div class="toolbar-info">
          <span>({{ x }}, {{ y }}) ‚Üí ({{ x + nx - 1 }}, {{ y + ny - 1 }})</span>
          <span>{{ generation_dir }}</span>
        </div>
      </div>
      <div class="selection-status" id="selectionStatus">
        <span id="selectionCount">0 quadrants selected</span>
        <span class="selection-limit">(max 4)</span>
        <button
          id="deselectAllBtn"
          class="deselect-btn"
          onclick="deselectAll()"
          disabled
        >
          Deselect All
        </button>
        <button
          id="deleteBtn"
          class="delete-btn"
          onclick="deleteSelected()"
          disabled
        >
          Delete
        </button>
        <button
          id="renderBtn"
          class="render-btn"
          onclick="renderSelected()"
          disabled
        >
          Render
        </button>
        <button
          id="generateBtn"
          class="generate-btn"
          onclick="generateSelected()"
          disabled
        >
          Generate
        </button>
      </div>
      <div class="water-fix-status" id="waterFixStatus" style="display: none">
        <span class="water-fix-label">Target Color:</span>
        <span class="color-swatch" id="targetColorSwatch"></span>
        <span class="color-hex" id="targetColorHex"
          >Click a quadrant to pick color</span
        >
        <span class="water-fix-quadrant" id="waterFixQuadrant"></span>
        <button
          id="applyWaterFixBtn"
          class="apply-water-fix-btn"
          onclick="applyWaterFix()"
          disabled
        >
          Apply Fix
        </button>
        <button
          id="cancelWaterFixBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFix()"
        >
          Cancel
        </button>
      </div>
      <div class="water-fill-status" id="waterFillStatus" style="display: none">
        <span class="water-fill-label">Water Fill:</span>
        <span class="color-swatch water-color-preview"></span>
        <span class="water-fill-instruction" id="waterFillInstruction"
          >Click a quadrant to fill with water</span
        >
        <button
          id="cancelWaterFillBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFill()"
        >
          Cancel
        </button>
      </div>
    </div>

    <div
      class="grid-container {% if show_lines %}show-lines{% endif %} {% if show_coords %}show-coords{% endif %}"
      id="gridContainer"
    >
      <div class="grid">
        {% for dy in range(ny) %} {% for dx in range(nx) %} {% set qx = x + dx
        %} {% set qy = y + dy %} {% set has_gen = tiles.get((dx, dy), False) %}
        <div
          class="tile {% if not has_gen %}placeholder{% endif %}"
          data-coords="{{ qx }},{{ qy }}"
        >
          <span class="coords">({{ qx }}, {{ qy }})</span>
          {% if has_gen %}
          <img
            src="/tile/{{ qx }}/{{ qy }}?render={{ '1' if show_render else '0' }}"
            alt="Tile {{ qx }},{{ qy }}"
          />
          {% endif %}
        </div>
        {% endfor %} {% endfor %}
      </div>
    </div>

    <script src="/static/viewer.js"></script>
  </body>
</html>

```

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Generated Tiles Viewer</title>
    <link rel="stylesheet" href="/static/viewer.css" />
    <style>
      /* Dynamic grid sizing based on template variables */
      .grid {
        grid-template-columns: repeat({{ nx }}, {{ size_px }}px);
        grid-auto-rows: {{ size_px }}px;
      }
      .tile.placeholder {
        min-width: {{ size_px }}px;
        min-height: {{ size_px }}px;
      }
    </style>
  </head>
  <body>
    <!-- Config data for JS -->
    <script
      id="app-config"
      type="application/json"
      data-config='{"x": {{ x }}, "y": {{ y }}, "nx": {{ nx }}, "ny": {{ ny }}, "size_px": {{ size_px }}, "models": {{ models_config | safe }}, "default_model_id": "{{ default_model_id }}"}'
    ></script>

    <!-- Toast notification container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Fixed toolbar -->
    <div class="toolbar">
      <div class="toolbar-row">
        <div class="controls">
          <label>X: <input type="number" id="x" value="{{ x }}" /></label>
          <label>Y: <input type="number" id="y" value="{{ y }}" /></label>
          <label
            >NX: <input type="number" id="nx" value="{{ nx }}" min="1" max="20"
          /></label>
          <label
            >NY: <input type="number" id="ny" value="{{ ny }}" min="1" max="20"
          /></label>
          <label
            >Size:
            <input type="number" id="sizePx" value="{{ size_px }}" step="32"
          /></label>
          <button onclick="goTo()">Go</button>
          <div class="toggle-group">
            <label
              ><input
                type="checkbox"
                id="showLines"
                {%
                if
                show_lines
                %}checked{%
                endif
                %}
                onchange="toggleLines()"
              />
              Lines</label
            >
            <label
              ><input
                type="checkbox"
                id="showCoords"
                {%
                if
                show_coords
                %}checked{%
                endif
                %}
                onchange="toggleCoords()"
              />
              Coords</label
            >
            <label
              ><input
                type="checkbox"
                id="showRender"
                {%
                if
                show_render
                %}checked{%
                endif
                %}
                onchange="toggleRender()"
              />
              Renders</label
            >
          </div>
          <div class="toggle-group model-group">
            <label class="model-label">Model:
              <select id="modelSelect" class="model-select">
                <!-- Populated by JavaScript -->
              </select>
            </label>
          </div>
          <div class="toggle-group tools-group">
            <span class="tools-label">Tools:</span>
            <button
              id="selectTool"
              class="tool-btn"
              onclick="toggleSelectTool()"
              title="Select quadrants (S)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path>
                <path d="M13 13l6 6"></path>
              </svg>
              Select
            </button>
            <button
              id="fixWaterTool"
              class="tool-btn"
              onclick="toggleFixWaterTool()"
              title="Fix water color (W)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
              </svg>
              Fix Water
            </button>
            <button
              id="waterFillTool"
              class="tool-btn"
              onclick="toggleWaterFillTool()"
              title="Fill quadrant with water (F)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <rect x="3" y="3" width="18" height="18" rx="2"></rect>
                <path d="M12 8v8"></path>
                <path d="M8 12h8"></path>
              </svg>
              Water Fill
            </button>
          </div>
        </div>
        <div class="toolbar-info">
          <span>({{ x }}, {{ y }}) ‚Üí ({{ x + nx - 1 }}, {{ y + ny - 1 }})</span>
          <span>{{ generation_dir }}</span>
        </div>
      </div>
      <div class="selection-status" id="selectionStatus">
        <span id="selectionCount">0 quadrants selected</span>
        <span class="selection-limit">(max 4)</span>
        <button
          id="deselectAllBtn"
          class="deselect-btn"
          onclick="deselectAll()"
          disabled
        >
          Deselect All
        </button>
        <button
          id="deleteBtn"
          class="delete-btn"
          onclick="deleteSelected()"
          disabled
        >
          Delete
        </button>
        <button
          id="renderBtn"
          class="render-btn"
          onclick="renderSelected()"
          disabled
        >
          Render
        </button>
        <button
          id="generateBtn"
          class="generate-btn"
          onclick="generateSelected()"
          disabled
        >
          Generate
        </button>
      </div>
      <div class="water-fix-status" id="waterFixStatus" style="display: none">
        <span class="water-fix-label">Target Color:</span>
        <span class="color-swatch" id="targetColorSwatch"></span>
        <span class="color-hex" id="targetColorHex"
          >Click a quadrant to pick color</span
        >
        <span class="water-fix-quadrant" id="waterFixQuadrant"></span>
        <button
          id="applyWaterFixBtn"
          class="apply-water-fix-btn"
          onclick="applyWaterFix()"
          disabled
        >
          Apply Fix
        </button>
        <button
          id="cancelWaterFixBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFix()"
        >
          Cancel
        </button>
      </div>
      <div class="water-fill-status" id="waterFillStatus" style="display: none">
        <span class="water-fill-label">Water Fill:</span>
        <span class="color-swatch water-color-preview"></span>
        <span class="water-fill-instruction" id="waterFillInstruction"
          >Click a quadrant to fill with water</span
        >
        <button
          id="cancelWaterFillBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFill()"
        >
          Cancel
        </button>
      </div>
    </div>

    <div
      class="grid-container {% if show_lines %}show-lines{% endif %} {% if show_coords %}show-coords{% endif %}"
      id="gridContainer"
    >
      <div class="grid">
        {% for dy in range(ny) %} {% for dx in range(nx) %} {% set qx = x + dx
        %} {% set qy = y + dy %} {% set has_gen = tiles.get((dx, dy), False) %}
        <div
          class="tile {% if not has_gen %}placeholder{% endif %}"
          data-coords="{{ qx }},{{ qy }}"
        >
          <span class="coords">({{ qx }}, {{ qy }})</span>
          {% if has_gen %}
          <img
            src="/tile/{{ qx }}/{{ qy }}?render={{ '1' if show_render else '0' }}"
            alt="Tile {{ qx }},{{ qy }}"
          />
          {% endif %}
        </div>
        {% endfor %} {% endfor %}
      </div>
    </div>

    <script src="/static/viewer.js"></script>
  </body>
</html>

```

Now let me update the JavaScript to remove client-side queue state and add model selector:

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (serverStatus.is_generating && serverStatus.quadrants && serverStatus.quadrants.length > 0) {
      const action = serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants.map(([x, y]) => `(${x},${y})`).join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show queue count
    if (serverStatus.queue_length > 0) {
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing = serverStatus && (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function generateSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  const modelId = getSelectedModelId();

  console.log("Generate requested for:", coords, "with model:", modelId);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for generation`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        quadrants: coords,
        model_id: modelId,
      }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Generation queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (tileEl.classList.contains("locked") || tileEl.classList.contains("queued")) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update buttons based on state
    const generateBtn = document.getElementById("generateBtn");
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on appropriate button
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
        generateBtn.classList.remove("loading");
        generateBtn.innerHTML = "Generate";
      } else {
        generateBtn.classList.add("loading");
        generateBtn.innerHTML = 'Generating<span class="spinner"></span>';
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(".toast.loading .toast-message");
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset buttons
      generateBtn.classList.remove("loading");
      generateBtn.innerHTML = "Generate";
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        showToast(
          "info",
          "Processing queue",
          `${status.queue_length} more item(s) in queue...`
        );
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (status.status === "idle" && status.queue_length === 0 && !nowProcessing) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log("Processing in progress or queue non-empty, starting polling...");
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

Now let me add CSS styles for the model selector:

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
  font-size: 12px;
  background: #1a1a2e;
  color: #eee;
  min-height: 100vh;
  padding: 15px;
  padding-top: 95px; /* Space for fixed toolbar */
}

.toolbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: #1a1a2e;
  padding: 10px 15px;
  z-index: 100;
  border-bottom: 1px solid #333;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.toolbar-row {
  display: flex;
  align-items: center;
  gap: 15px;
  flex-wrap: wrap;
}

.toolbar-info {
  color: #666;
  font-size: 0.75rem;
}

.toolbar-info span + span {
  margin-left: 12px;
}

.controls {
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
}

.controls label {
  color: #888;
  font-size: 0.8rem;
}

.controls input[type="number"] {
  width: 50px;
  padding: 5px 6px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #16213e;
  color: #fff;
  font-family: inherit;
  font-size: 0.8rem;
}

.controls button {
  padding: 5px 12px;
  background: #00d9ff;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.75rem;
  font-weight: bold;
}

.controls button:hover {
  background: #00b8d4;
}

.toggle-group {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-left: 8px;
  padding-left: 12px;
  border-left: 1px solid #333;
}

.toggle-group label {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  user-select: none;
  font-size: 0.75rem;
}

.toggle-group input[type="checkbox"] {
  width: 14px;
  height: 14px;
  accent-color: #00d9ff;
  cursor: pointer;
}

.grid-container {
  display: inline-block;
  border-radius: 8px;
  overflow: hidden;
}

.grid-container.show-lines {
  border: 2px solid #333;
}

.grid {
  display: grid;
  background: #333;
}

.grid-container.show-lines .grid {
  gap: 2px;
}

.grid-container:not(.show-lines) .grid {
  gap: 0;
  background: transparent;
}

.grid-container:not(.show-lines) {
  border: none;
}

.tile {
  position: relative;
  background: #2a2a4a;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tile img {
  display: block;
  max-width: 100%;
  height: auto;
}

.tile.placeholder {
  background: #3a3a5a;
}

.tile .coords {
  position: absolute;
  top: 6px;
  left: 6px;
  background: rgba(0, 0, 0, 0.7);
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 0.65rem;
  color: #00d9ff;
  transition: opacity 0.2s;
}

.tile.placeholder .coords {
  color: #666;
}

.grid-container:not(.show-coords) .tile .coords {
  opacity: 0;
}

/* Tool button styles */
.tools-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.tools-label {
  color: #666;
  font-size: 0.7rem;
}

.tool-btn {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: #2a2a3e;
  color: #666;
  border: 1px solid #444;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  transition: all 0.15s ease;
}

.tool-btn:hover {
  background: #3a3a4e;
  color: #999;
  border-color: #555;
}

.tool-btn.active {
  background: #10b981;
  color: #fff;
  border-color: #10b981;
  box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
}

.tool-btn.active:hover {
  background: #059669;
  border-color: #059669;
}

.tool-btn svg {
  width: 12px;
  height: 12px;
}

/* Selection styles */
.tile.selected {
  outline: 3px solid #ff3333;
  outline-offset: -3px;
  z-index: 10;
}

.grid-container.show-lines .tile.selected {
  outline-color: #ff3333;
}

.tile.selectable {
  cursor: pointer;
}

.tile.placeholder.selected {
  background: rgba(255, 51, 51, 0.15);
}

/* Locked tiles (during generation) */
.tile.locked {
  outline: 3px solid #a855f7;
  outline-offset: -3px;
  z-index: 10;
}

.grid-container.show-lines .tile.locked {
  outline-color: #a855f7;
}

.tile.placeholder.locked {
  background: rgba(168, 85, 247, 0.2);
}

/* Queued tiles (in queue, waiting to be generated) */
.tile.queued {
  outline: 3px dashed #c084fc !important;
  outline-offset: -3px;
  z-index: 9;
  animation: pulse-queue 1.5s ease-in-out infinite;
  /* Fallback: box-shadow for browsers that don't render dashed outlines well */
  box-shadow: inset 0 0 0 3px rgba(192, 132, 252, 0.5);
}

@keyframes pulse-queue {
  0%,
  100% {
    outline-color: #c084fc;
    box-shadow: inset 0 0 0 3px rgba(192, 132, 252, 0.5);
  }
  50% {
    outline-color: #8b5cf6;
    box-shadow: inset 0 0 0 3px rgba(139, 92, 246, 0.7);
  }
}

.grid-container.show-lines .tile.queued {
  outline-color: #c084fc;
}

.tile.placeholder.queued {
  background: rgba(168, 85, 247, 0.3) !important;
}

/* Allow selection while generating - only disable clicking on locked/queued tiles */
body.generating .tile.locked.selectable,
body.generating .tile.queued.selectable {
  cursor: not-allowed;
}

/* Selection status bar */
.selection-status {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 10px;
  background: rgba(255, 51, 51, 0.1);
  border: 1px solid rgba(255, 51, 51, 0.3);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #ff6666;
  margin-top: 8px;
}

.selection-status.empty {
  background: transparent;
  border-color: #333;
  color: #666;
}

.selection-status.generating {
  background: rgba(168, 85, 247, 0.1);
  border-color: rgba(168, 85, 247, 0.4);
  color: #a855f7;
}

.selection-limit {
  color: #888;
  font-size: 0.65rem;
}

.deselect-btn {
  padding: 3px 8px;
  background: #ff3333;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  margin-left: auto;
  transition: all 0.2s;
}

.deselect-btn:hover:not(:disabled) {
  background: #ff5555;
}

.deselect-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
}

.delete-btn {
  padding: 3px 8px;
  background: #dc2626;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  transition: all 0.2s;
}

.delete-btn:hover:not(:disabled) {
  background: #b91c1c;
}

.delete-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
}

.render-btn {
  padding: 4px 12px;
  background: #f59e0b;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
}

.render-btn:hover:not(:disabled) {
  background: #d97706;
}

.render-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.render-btn.loading {
  background: #666;
  cursor: wait;
}

.render-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

.generate-btn {
  padding: 4px 12px;
  background: #00d9ff;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
}

.generate-btn:hover:not(:disabled) {
  background: #00b8d4;
}

.generate-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

/* Toast notification system */
.toast-container {
  position: fixed;
  bottom: 15px;
  right: 15px;
  z-index: 1000;
  display: flex;
  flex-direction: column-reverse;
  gap: 8px;
  max-width: 320px;
}

.toast {
  padding: 10px 14px;
  border-radius: 6px;
  font-size: 0.75rem;
  animation: slideIn 0.3s ease-out;
  display: flex;
  align-items: flex-start;
  gap: 10px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.toast.success {
  background: linear-gradient(135deg, #065f46 0%, #047857 100%);
  border: 1px solid #10b981;
  color: #d1fae5;
}

.toast.error {
  background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
  border: 1px solid #ef4444;
  color: #fee2e2;
}

.toast.info {
  background: linear-gradient(135deg, #1e3a5f 0%, #1e40af 100%);
  border: 1px solid #3b82f6;
  color: #dbeafe;
}

.toast.loading {
  background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
  border: 1px solid #6b7280;
  color: #e5e7eb;
}

.toast-icon {
  flex-shrink: 0;
  font-size: 1rem;
}

.toast-content {
  flex: 1;
}

.toast-title {
  font-weight: 600;
  margin-bottom: 2px;
}

.toast-message {
  opacity: 0.9;
  font-size: 0.7rem;
}

.toast-close {
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  opacity: 0.7;
  font-size: 1rem;
  padding: 0;
  line-height: 1;
}

.toast-close:hover {
  opacity: 1;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOut {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

.toast.removing {
  animation: slideOut 0.3s ease-in forwards;
}

/* Loading spinner for generate button */
.generate-btn.loading {
  background: #666;
  color: #fff;
  cursor: wait;
}

.generate-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Water fix tool styles */
.water-fix-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid rgba(59, 130, 246, 0.3);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #60a5fa;
  margin-top: 8px;
}

.water-fix-label {
  color: #93c5fd;
  font-weight: 500;
}

.color-swatch {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  border: 2px solid #fff;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3), inset 0 0 0 1px rgba(0, 0, 0, 0.1);
  background: #333;
}

.color-swatch.has-color {
  cursor: pointer;
}

.color-hex {
  font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
  font-size: 0.75rem;
  color: #93c5fd;
  min-width: 180px;
}

.water-fix-quadrant {
  color: #60a5fa;
  font-size: 0.7rem;
}

.apply-water-fix-btn {
  padding: 4px 12px;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
  margin-left: auto;
}

.apply-water-fix-btn:hover:not(:disabled) {
  background: #2563eb;
}

.apply-water-fix-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.apply-water-fix-btn.loading {
  background: #666;
  cursor: wait;
}

.cancel-water-fix-btn {
  padding: 4px 8px;
  background: #4b5563;
  color: #d1d5db;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  transition: all 0.2s;
}

.cancel-water-fix-btn:hover {
  background: #6b7280;
}

/* Fix water tool active state */
.tile.fix-water-selectable {
  cursor: crosshair;
}

.tile.fix-water-selectable:hover {
  outline: 2px solid #3b82f6;
  outline-offset: -2px;
}

.tile.water-fix-selected {
  outline: 3px solid #3b82f6;
  outline-offset: -3px;
  z-index: 10;
}

/* Water fill tool styles */
.water-fill-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(74, 99, 114, 0.15);
  border: 1px solid rgba(74, 99, 114, 0.4);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #7ba3b8;
  margin-top: 8px;
}

.water-fill-label {
  color: #93c5fd;
  font-weight: 500;
}

.water-color-preview {
  background: #4a6372 !important;
}

.water-fill-instruction {
  color: #7ba3b8;
}

.tile.water-fill-selectable {
  cursor: pointer;
}

.tile.water-fill-selectable:hover {
  outline: 2px solid #4a6372;
  outline-offset: -2px;
}

/* Model selector styles */
.model-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.model-label {
  display: flex;
  align-items: center;
  gap: 6px;
  color: #888;
  font-size: 0.75rem;
}

.model-select {
  padding: 4px 8px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #16213e;
  color: #fff;
  font-family: inherit;
  font-size: 0.75rem;
  cursor: pointer;
  min-width: 140px;
}

.model-select:hover {
  border-color: #00d9ff;
}

.model-select:focus {
  outline: none;
  border-color: #00d9ff;
  box-shadow: 0 0 0 2px rgba(0, 217, 255, 0.2);
}

.model-select option {
  background: #16213e;
  color: #fff;
  padding: 4px;
}

```

Now let me check for any linting errors in the Python files:

Let me run the linter to make sure everything is formatted correctly:

Let me fix these linting errors:

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cleanup_stale_processing,
  clear_completed_items,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  get_generation_config,
)
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = "starting" if item_type == QueueItemType.GENERATE else "rendering"
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}")
    if model_id:
      print(f"   Model: {model_id}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(conn, config, selected_quadrants, model_id)
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify({
    "models": [m.to_dict() for m in APP_CONFIG.models],
    "default_model_id": APP_CONFIG.default_model_id,
  })


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """API endpoint to generate tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id)
  return jsonify(result), 202  # 202 Accepted


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Clean up any stale processing items from previous runs
    stale_count = cleanup_stale_processing(conn)
    if stale_count > 0:
      print(f"‚ö†Ô∏è  Reset {stale_count} stale processing item(s) from previous run")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Reusable library for generating pixel art using the Oxen.ai model.

This module provides the core generation logic that can be used by:
- view_generations.py (Flask web server)
- generate_tiles_omni.py (command-line script)
- automatic_generation.py (automated generation)

The main entry point is `run_generation_for_quadrants()` which handles:
1. Validating the quadrant selection
2. Rendering any missing quadrants
3. Building the template image
4. Uploading to GCS and calling the Oxen API
5. Saving the generated quadrants to the database
"""

import os
import re
import sqlite3
import tempfile
from io import BytesIO
from pathlib import Path
from typing import Callable
from urllib.parse import urlencode

import requests
from dotenv import load_dotenv
from PIL import Image
from playwright.sync_api import sync_playwright

from isometric_nyc.e2e_generation.infill_template import (
  QUADRANT_SIZE,
  InfillRegion,
  TemplateBuilder,
  validate_quadrant_selection,
)
from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  ensure_quadrant_exists,
  image_to_png_bytes,
  png_bytes_to_image,
  save_quadrant_generation,
  save_quadrant_render,
  split_tile_into_quadrants,
  upload_to_gcs,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_generation as shared_get_quadrant_generation,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_render as shared_get_quadrant_render,
)

# Load environment variables
load_dotenv()

# Oxen API configuration
OMNI_MODEL_ID = "cannoneyed-gentle-gold-antlion"
OMNI_WATER_MODEL_ID = "cannoneyed-quiet-green-lamprey"
OMNI_WATER_V2_MODEL_ID = "cannoneyed-rural-rose-dingo"

GCS_BUCKET_NAME = "isometric-nyc-infills"


# =============================================================================
# Quadrant Parsing Utilities
# =============================================================================


def parse_quadrant_tuple(s: str) -> tuple[int, int]:
  """
  Parse a quadrant tuple string like "(0,1)" or "0,1" into a tuple.

  Args:
      s: String in format "(x,y)" or "x,y"

  Returns:
      Tuple of (x, y) coordinates

  Raises:
      ValueError: If the format is invalid
  """
  s = s.strip()
  # Remove optional parentheses
  if s.startswith("(") and s.endswith(")"):
    s = s[1:-1]
  parts = s.split(",")
  if len(parts) != 2:
    raise ValueError(f"Invalid quadrant tuple format: {s}")
  return (int(parts[0].strip()), int(parts[1].strip()))


def parse_quadrant_list(s: str) -> list[tuple[int, int]]:
  """
  Parse a comma-separated list of quadrant tuples.

  Args:
      s: String like "(0,1),(0,2)" or "(0,1), (0,2)"

  Returns:
      List of (x, y) coordinate tuples

  Raises:
      ValueError: If the format is invalid
  """
  # Use regex to find all (x,y) patterns
  pattern = r"\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)"
  matches = re.findall(pattern, s)
  if not matches:
    raise ValueError(f"No valid quadrant tuples found in: {s}")
  return [(int(x), int(y)) for x, y in matches]


# =============================================================================
# Oxen API Functions
# =============================================================================


def call_oxen_api(
  image_url: str,
  model_config: "ModelConfig | None" = None,  # noqa: F821
) -> str:
  """
  Call the Oxen API to generate pixel art.

  Args:
      image_url: Public URL of the input template image
      model_config: Optional model configuration (ModelConfig from model_config.py).
        If not provided, uses defaults.

  Returns:
      URL of the generated image

  Raises:
      requests.HTTPError: If the API call fails
      ValueError: If the response format is unexpected
  """
  # Use provided config or defaults
  if model_config is not None:
    endpoint = model_config.endpoint
    model_id = model_config.model_id
    api_key = model_config.api_key
    num_inference_steps = model_config.num_inference_steps
  else:
    endpoint = "https://hub.oxen.ai/api/images/edit"
    model_id = OMNI_WATER_MODEL_ID
    api_key = os.getenv("OXEN_OMNI_v04_WATER_API_KEY")
    num_inference_steps = 28

  if not api_key:
    raise ValueError(f"API key not found for model {model_id}")

  headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json",
  }

  prompt = (
    "Fill in the outlined section with the missing pixels corresponding to "
    "the <isometric nyc pixel art> style, removing the border and exactly "
    "following the shape/style/structure of the surrounding image (if present)."
  )

  payload = {
    "model": model_id,
    "input_image": image_url,
    "prompt": prompt,
    "num_inference_steps": num_inference_steps,
  }

  print(f"   ü§ñ Calling Oxen API with model {model_id}...")
  response = requests.post(endpoint, headers=headers, json=payload, timeout=300)
  response.raise_for_status()

  result = response.json()

  if "images" in result and len(result["images"]) > 0:
    return result["images"][0]["url"]
  elif "url" in result:
    return result["url"]
  elif "image_url" in result:
    return result["image_url"]
  elif "output" in result:
    return result["output"]
  else:
    raise ValueError(f"Unexpected API response format: {result}")


def download_image_to_pil(url: str) -> Image.Image:
  """
  Download an image from a URL and return as PIL Image.

  Args:
      url: URL of the image to download

  Returns:
      PIL Image object
  """
  response = requests.get(url, timeout=120)
  response.raise_for_status()
  return Image.open(BytesIO(response.content))


# =============================================================================
# Rendering Functions
# =============================================================================


def render_quadrant(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
  port: int,
) -> bytes | None:
  """
  Render a quadrant and save to database.

  This renders the tile containing the quadrant and saves all 4 quadrants.

  Args:
      conn: Database connection
      config: Generation config dict
      x: Quadrant x coordinate
      y: Quadrant y coordinate
      port: Web server port for rendering

  Returns:
      PNG bytes of the rendered quadrant, or None if failed
  """
  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  # Build URL for rendering
  params = {
    "export": "true",
    "lat": quadrant["lat"],
    "lon": quadrant["lng"],
    "width": config["width_px"],
    "height": config["height_px"],
    "azimuth": config["camera_azimuth_degrees"],
    "elevation": config["camera_elevation_degrees"],
    "view_height": config.get("view_height_meters", 200),
  }
  query_string = urlencode(params)
  url = f"http://localhost:{port}/?{query_string}"

  # Render using Playwright
  with sync_playwright() as p:
    browser = p.chromium.launch(
      headless=True,
      args=[
        "--enable-webgl",
        "--use-gl=angle",
        "--ignore-gpu-blocklist",
      ],
    )

    context = browser.new_context(
      viewport={"width": config["width_px"], "height": config["height_px"]},
      device_scale_factor=1,
    )
    page = context.new_page()

    page.goto(url, wait_until="networkidle")

    try:
      page.wait_for_function("window.TILES_LOADED === true", timeout=60000)
    except Exception:
      print("      ‚ö†Ô∏è  Timeout waiting for tiles, continuing anyway...")

    # Get screenshot as bytes
    screenshot_bytes = page.screenshot(type="png")

    page.close()
    context.close()
    browser.close()

  # Open as PIL image and split into quadrants
  full_tile = Image.open(BytesIO(screenshot_bytes))
  quadrant_images = split_tile_into_quadrants(full_tile)

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), quad_img in quadrant_images.items():
    qx, qy = x + dx, y + dy
    png_bytes = image_to_png_bytes(quad_img)
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


# =============================================================================
# Core Generation Logic
# =============================================================================


def run_generation_for_quadrants(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  port: int = DEFAULT_WEB_PORT,
  bucket_name: str = GCS_BUCKET_NAME,
  status_callback: Callable[[str, str], None] | None = None,
  model_config: "ModelConfig | None" = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is the main entry point for generation. It:
  1. Validates the quadrant selection
  2. Renders any missing quadrants
  3. Builds the template image with appropriate borders
  4. Uploads to GCS and calls the Oxen API
  5. Saves the generated quadrants to the database

  Args:
      conn: Database connection
      config: Generation config dict
      selected_quadrants: List of (x, y) quadrant coordinates to generate
      port: Web server port for rendering (default: 5173)
      bucket_name: GCS bucket name for uploads
      status_callback: Optional callback(status, message) for progress updates
      model_config: Optional model configuration for the Oxen API

  Returns:
      Dict with:
          - success: bool
          - message: str (on success)
          - error: str (on failure)
          - quadrants: list of generated quadrant coords (on success)
  """
  from isometric_nyc.e2e_generation.model_config import ModelConfig

  def update_status(status: str, message: str = "") -> None:
    if status_callback:
      status_callback(status, message)

  update_status("validating", "Checking API key...")

  # Create helper functions for validation
  def has_generation_in_db(qx: int, qy: int) -> bool:
    gen = shared_get_quadrant_generation(conn, qx, qy)
    return gen is not None

  def get_render_from_db_with_render(qx: int, qy: int) -> Image.Image | None:
    """Get render, rendering if it doesn't exist yet."""
    render_bytes = shared_get_quadrant_render(conn, qx, qy)
    if render_bytes:
      return png_bytes_to_image(render_bytes)

    # Need to render
    update_status("rendering", f"Rendering quadrant ({qx}, {qy})...")
    print(f"   üì¶ Rendering quadrant ({qx}, {qy})...")
    render_bytes = render_quadrant(conn, config, qx, qy, port)
    if render_bytes:
      return png_bytes_to_image(render_bytes)
    return None

  def get_generation_from_db(qx: int, qy: int) -> Image.Image | None:
    gen_bytes = shared_get_quadrant_generation(conn, qx, qy)
    if gen_bytes:
      return png_bytes_to_image(gen_bytes)
    return None

  update_status("validating", "Validating quadrant selection...")

  # Validate selection with auto-expansion
  is_valid, msg, placement = validate_quadrant_selection(
    selected_quadrants, has_generation_in_db, allow_expansion=True
  )

  if not is_valid:
    update_status("error", msg)
    return {"success": False, "error": msg}

  print(f"‚úÖ Validation: {msg}")

  # Get primary quadrants (the ones user selected, not padding)
  primary_quadrants = (
    placement.primary_quadrants if placement.primary_quadrants else selected_quadrants
  )
  padding_quadrants = placement.padding_quadrants if placement else []

  if padding_quadrants:
    print(f"   üì¶ Padding quadrants: {padding_quadrants}")

  # Create the infill region (may be expanded)
  if placement._expanded_region is not None:
    region = placement._expanded_region
  else:
    region = InfillRegion.from_quadrants(selected_quadrants)

  # Build the template
  update_status("rendering", "Building template image...")
  builder = TemplateBuilder(
    region, has_generation_in_db, get_render_from_db_with_render, get_generation_from_db
  )

  print("üìã Building template...")
  result = builder.build(border_width=2, allow_expansion=True)

  if result is None:
    error_msg = builder._last_validation_error or "Failed to build template"
    update_status("error", error_msg)
    return {
      "success": False,
      "error": error_msg,
    }

  template_image, placement = result

  # Save template to temp file and upload to GCS
  with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
    template_path = Path(tmp.name)
    template_image.save(template_path)

  try:
    update_status("uploading", "Uploading template to cloud...")
    print("üì§ Uploading template to GCS...")
    image_url = upload_to_gcs(template_path, bucket_name)

    update_status("generating", "Calling AI model (this may take a minute)...")
    print("ü§ñ Calling Oxen API...")
    generated_url = call_oxen_api(image_url, model_config)

    update_status("saving", "Downloading and saving results...")
    print("üì• Downloading generated image...")
    generated_image = download_image_to_pil(generated_url)

    # Extract quadrants from generated image and save to database
    print("üíæ Saving generated quadrants to database...")

    # Figure out what quadrants are in the infill region
    all_infill_quadrants = (
      placement.all_infill_quadrants
      if placement.all_infill_quadrants
      else region.overlapping_quadrants()
    )

    # For each infill quadrant, extract pixels from the generated image
    saved_count = 0
    for qx, qy in all_infill_quadrants:
      # Calculate position in the generated image
      quad_world_x = qx * QUADRANT_SIZE
      quad_world_y = qy * QUADRANT_SIZE

      template_x = quad_world_x - placement.world_offset_x
      template_y = quad_world_y - placement.world_offset_y

      # Crop this quadrant from the generated image
      crop_box = (
        template_x,
        template_y,
        template_x + QUADRANT_SIZE,
        template_y + QUADRANT_SIZE,
      )
      quad_img = generated_image.crop(crop_box)
      png_bytes = image_to_png_bytes(quad_img)

      # Only save primary quadrants (not padding)
      if (qx, qy) in primary_quadrants or (qx, qy) in [
        (q[0], q[1]) for q in primary_quadrants
      ]:
        if save_quadrant_generation(conn, config, qx, qy, png_bytes):
          print(f"   ‚úì Saved generation for ({qx}, {qy})")
          saved_count += 1
        else:
          print(f"   ‚ö†Ô∏è Failed to save generation for ({qx}, {qy})")
      else:
        print(f"   ‚è≠Ô∏è Skipped padding quadrant ({qx}, {qy})")

    update_status("complete", f"Generated {saved_count} quadrant(s)")
    return {
      "success": True,
      "message": f"Generated {saved_count} quadrant{'s' if saved_count != 1 else ''}",
      "quadrants": list(primary_quadrants),
    }

  finally:
    # Clean up temp file
    template_path.unlink(missing_ok=True)

```

```python
"""
Reusable library for generating pixel art using the Oxen.ai model.

This module provides the core generation logic that can be used by:
- view_generations.py (Flask web server)
- generate_tiles_omni.py (command-line script)
- automatic_generation.py (automated generation)

The main entry point is `run_generation_for_quadrants()` which handles:
1. Validating the quadrant selection
2. Rendering any missing quadrants
3. Building the template image
4. Uploading to GCS and calling the Oxen API
5. Saving the generated quadrants to the database
"""

import os
import re
import sqlite3
import tempfile
from io import BytesIO
from pathlib import Path
from typing import Callable
from urllib.parse import urlencode

import requests
from dotenv import load_dotenv
from PIL import Image
from playwright.sync_api import sync_playwright

from isometric_nyc.e2e_generation.infill_template import (
  QUADRANT_SIZE,
  InfillRegion,
  TemplateBuilder,
  validate_quadrant_selection,
)
from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  ensure_quadrant_exists,
  image_to_png_bytes,
  png_bytes_to_image,
  save_quadrant_generation,
  save_quadrant_render,
  split_tile_into_quadrants,
  upload_to_gcs,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_generation as shared_get_quadrant_generation,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_render as shared_get_quadrant_render,
)

# Load environment variables
load_dotenv()

# Oxen API configuration
OMNI_MODEL_ID = "cannoneyed-gentle-gold-antlion"
OMNI_WATER_MODEL_ID = "cannoneyed-quiet-green-lamprey"
OMNI_WATER_V2_MODEL_ID = "cannoneyed-rural-rose-dingo"

GCS_BUCKET_NAME = "isometric-nyc-infills"


# =============================================================================
# Quadrant Parsing Utilities
# =============================================================================


def parse_quadrant_tuple(s: str) -> tuple[int, int]:
  """
  Parse a quadrant tuple string like "(0,1)" or "0,1" into a tuple.

  Args:
      s: String in format "(x,y)" or "x,y"

  Returns:
      Tuple of (x, y) coordinates

  Raises:
      ValueError: If the format is invalid
  """
  s = s.strip()
  # Remove optional parentheses
  if s.startswith("(") and s.endswith(")"):
    s = s[1:-1]
  parts = s.split(",")
  if len(parts) != 2:
    raise ValueError(f"Invalid quadrant tuple format: {s}")
  return (int(parts[0].strip()), int(parts[1].strip()))


def parse_quadrant_list(s: str) -> list[tuple[int, int]]:
  """
  Parse a comma-separated list of quadrant tuples.

  Args:
      s: String like "(0,1),(0,2)" or "(0,1), (0,2)"

  Returns:
      List of (x, y) coordinate tuples

  Raises:
      ValueError: If the format is invalid
  """
  # Use regex to find all (x,y) patterns
  pattern = r"\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)"
  matches = re.findall(pattern, s)
  if not matches:
    raise ValueError(f"No valid quadrant tuples found in: {s}")
  return [(int(x), int(y)) for x, y in matches]


# =============================================================================
# Oxen API Functions
# =============================================================================


def call_oxen_api(
  image_url: str,
  model_config: "ModelConfig | None" = None,  # noqa: F821
) -> str:
  """
  Call the Oxen API to generate pixel art.

  Args:
      image_url: Public URL of the input template image
      model_config: Optional model configuration (ModelConfig from model_config.py).
        If not provided, uses defaults.

  Returns:
      URL of the generated image

  Raises:
      requests.HTTPError: If the API call fails
      ValueError: If the response format is unexpected
  """
  # Use provided config or defaults
  if model_config is not None:
    endpoint = model_config.endpoint
    model_id = model_config.model_id
    api_key = model_config.api_key
    num_inference_steps = model_config.num_inference_steps
  else:
    endpoint = "https://hub.oxen.ai/api/images/edit"
    model_id = OMNI_WATER_MODEL_ID
    api_key = os.getenv("OXEN_OMNI_v04_WATER_API_KEY")
    num_inference_steps = 28

  if not api_key:
    raise ValueError(f"API key not found for model {model_id}")

  headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json",
  }

  prompt = (
    "Fill in the outlined section with the missing pixels corresponding to "
    "the <isometric nyc pixel art> style, removing the border and exactly "
    "following the shape/style/structure of the surrounding image (if present)."
  )

  payload = {
    "model": model_id,
    "input_image": image_url,
    "prompt": prompt,
    "num_inference_steps": num_inference_steps,
  }

  print(f"   ü§ñ Calling Oxen API with model {model_id}...")
  response = requests.post(endpoint, headers=headers, json=payload, timeout=300)
  response.raise_for_status()

  result = response.json()

  if "images" in result and len(result["images"]) > 0:
    return result["images"][0]["url"]
  elif "url" in result:
    return result["url"]
  elif "image_url" in result:
    return result["image_url"]
  elif "output" in result:
    return result["output"]
  else:
    raise ValueError(f"Unexpected API response format: {result}")


def download_image_to_pil(url: str) -> Image.Image:
  """
  Download an image from a URL and return as PIL Image.

  Args:
      url: URL of the image to download

  Returns:
      PIL Image object
  """
  response = requests.get(url, timeout=120)
  response.raise_for_status()
  return Image.open(BytesIO(response.content))


# =============================================================================
# Rendering Functions
# =============================================================================


def render_quadrant(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
  port: int,
) -> bytes | None:
  """
  Render a quadrant and save to database.

  This renders the tile containing the quadrant and saves all 4 quadrants.

  Args:
      conn: Database connection
      config: Generation config dict
      x: Quadrant x coordinate
      y: Quadrant y coordinate
      port: Web server port for rendering

  Returns:
      PNG bytes of the rendered quadrant, or None if failed
  """
  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  # Build URL for rendering
  params = {
    "export": "true",
    "lat": quadrant["lat"],
    "lon": quadrant["lng"],
    "width": config["width_px"],
    "height": config["height_px"],
    "azimuth": config["camera_azimuth_degrees"],
    "elevation": config["camera_elevation_degrees"],
    "view_height": config.get("view_height_meters", 200),
  }
  query_string = urlencode(params)
  url = f"http://localhost:{port}/?{query_string}"

  # Render using Playwright
  with sync_playwright() as p:
    browser = p.chromium.launch(
      headless=True,
      args=[
        "--enable-webgl",
        "--use-gl=angle",
        "--ignore-gpu-blocklist",
      ],
    )

    context = browser.new_context(
      viewport={"width": config["width_px"], "height": config["height_px"]},
      device_scale_factor=1,
    )
    page = context.new_page()

    page.goto(url, wait_until="networkidle")

    try:
      page.wait_for_function("window.TILES_LOADED === true", timeout=60000)
    except Exception:
      print("      ‚ö†Ô∏è  Timeout waiting for tiles, continuing anyway...")

    # Get screenshot as bytes
    screenshot_bytes = page.screenshot(type="png")

    page.close()
    context.close()
    browser.close()

  # Open as PIL image and split into quadrants
  full_tile = Image.open(BytesIO(screenshot_bytes))
  quadrant_images = split_tile_into_quadrants(full_tile)

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), quad_img in quadrant_images.items():
    qx, qy = x + dx, y + dy
    png_bytes = image_to_png_bytes(quad_img)
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


# =============================================================================
# Core Generation Logic
# =============================================================================


def run_generation_for_quadrants(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  port: int = DEFAULT_WEB_PORT,
  bucket_name: str = GCS_BUCKET_NAME,
  status_callback: Callable[[str, str], None] | None = None,
  model_config: "ModelConfig | None" = None,  # noqa: F821
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is the main entry point for generation. It:
  1. Validates the quadrant selection
  2. Renders any missing quadrants
  3. Builds the template image with appropriate borders
  4. Uploads to GCS and calls the Oxen API
  5. Saves the generated quadrants to the database

  Args:
      conn: Database connection
      config: Generation config dict
      selected_quadrants: List of (x, y) quadrant coordinates to generate
      port: Web server port for rendering (default: 5173)
      bucket_name: GCS bucket name for uploads
      status_callback: Optional callback(status, message) for progress updates
      model_config: Optional model configuration for the Oxen API (ModelConfig from model_config.py)

  Returns:
      Dict with:
          - success: bool
          - message: str (on success)
          - error: str (on failure)
          - quadrants: list of generated quadrant coords (on success)
  """

  def update_status(status: str, message: str = "") -> None:
    if status_callback:
      status_callback(status, message)

  update_status("validating", "Checking API key...")

  # Create helper functions for validation
  def has_generation_in_db(qx: int, qy: int) -> bool:
    gen = shared_get_quadrant_generation(conn, qx, qy)
    return gen is not None

  def get_render_from_db_with_render(qx: int, qy: int) -> Image.Image | None:
    """Get render, rendering if it doesn't exist yet."""
    render_bytes = shared_get_quadrant_render(conn, qx, qy)
    if render_bytes:
      return png_bytes_to_image(render_bytes)

    # Need to render
    update_status("rendering", f"Rendering quadrant ({qx}, {qy})...")
    print(f"   üì¶ Rendering quadrant ({qx}, {qy})...")
    render_bytes = render_quadrant(conn, config, qx, qy, port)
    if render_bytes:
      return png_bytes_to_image(render_bytes)
    return None

  def get_generation_from_db(qx: int, qy: int) -> Image.Image | None:
    gen_bytes = shared_get_quadrant_generation(conn, qx, qy)
    if gen_bytes:
      return png_bytes_to_image(gen_bytes)
    return None

  update_status("validating", "Validating quadrant selection...")

  # Validate selection with auto-expansion
  is_valid, msg, placement = validate_quadrant_selection(
    selected_quadrants, has_generation_in_db, allow_expansion=True
  )

  if not is_valid:
    update_status("error", msg)
    return {"success": False, "error": msg}

  print(f"‚úÖ Validation: {msg}")

  # Get primary quadrants (the ones user selected, not padding)
  primary_quadrants = (
    placement.primary_quadrants if placement.primary_quadrants else selected_quadrants
  )
  padding_quadrants = placement.padding_quadrants if placement else []

  if padding_quadrants:
    print(f"   üì¶ Padding quadrants: {padding_quadrants}")

  # Create the infill region (may be expanded)
  if placement._expanded_region is not None:
    region = placement._expanded_region
  else:
    region = InfillRegion.from_quadrants(selected_quadrants)

  # Build the template
  update_status("rendering", "Building template image...")
  builder = TemplateBuilder(
    region, has_generation_in_db, get_render_from_db_with_render, get_generation_from_db
  )

  print("üìã Building template...")
  result = builder.build(border_width=2, allow_expansion=True)

  if result is None:
    error_msg = builder._last_validation_error or "Failed to build template"
    update_status("error", error_msg)
    return {
      "success": False,
      "error": error_msg,
    }

  template_image, placement = result

  # Save template to temp file and upload to GCS
  with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
    template_path = Path(tmp.name)
    template_image.save(template_path)

  try:
    update_status("uploading", "Uploading template to cloud...")
    print("üì§ Uploading template to GCS...")
    image_url = upload_to_gcs(template_path, bucket_name)

    update_status("generating", "Calling AI model (this may take a minute)...")
    print("ü§ñ Calling Oxen API...")
    generated_url = call_oxen_api(image_url, model_config)

    update_status("saving", "Downloading and saving results...")
    print("üì• Downloading generated image...")
    generated_image = download_image_to_pil(generated_url)

    # Extract quadrants from generated image and save to database
    print("üíæ Saving generated quadrants to database...")

    # Figure out what quadrants are in the infill region
    all_infill_quadrants = (
      placement.all_infill_quadrants
      if placement.all_infill_quadrants
      else region.overlapping_quadrants()
    )

    # For each infill quadrant, extract pixels from the generated image
    saved_count = 0
    for qx, qy in all_infill_quadrants:
      # Calculate position in the generated image
      quad_world_x = qx * QUADRANT_SIZE
      quad_world_y = qy * QUADRANT_SIZE

      template_x = quad_world_x - placement.world_offset_x
      template_y = quad_world_y - placement.world_offset_y

      # Crop this quadrant from the generated image
      crop_box = (
        template_x,
        template_y,
        template_x + QUADRANT_SIZE,
        template_y + QUADRANT_SIZE,
      )
      quad_img = generated_image.crop(crop_box)
      png_bytes = image_to_png_bytes(quad_img)

      # Only save primary quadrants (not padding)
      if (qx, qy) in primary_quadrants or (qx, qy) in [
        (q[0], q[1]) for q in primary_quadrants
      ]:
        if save_quadrant_generation(conn, config, qx, qy, png_bytes):
          print(f"   ‚úì Saved generation for ({qx}, {qy})")
          saved_count += 1
        else:
          print(f"   ‚ö†Ô∏è Failed to save generation for ({qx}, {qy})")
      else:
        print(f"   ‚è≠Ô∏è Skipped padding quadrant ({qx}, {qy})")

    update_status("complete", f"Generated {saved_count} quadrant(s)")
    return {
      "success": True,
      "message": f"Generated {saved_count} quadrant{'s' if saved_count != 1 else ''}",
      "quadrants": list(primary_quadrants),
    }

  finally:
    # Clean up temp file
    template_path.unlink(missing_ok=True)

```

Now let me run the tests to make sure nothing is broken:

All tests pass. Let me update the task file to mark it as completed and provide a summary:

```markdown
# Generation App Improvements

**Status: ‚úÖ COMPLETED**

## 1. Ensure queue robustness ‚úÖ

We want to make sure that the current queue system for generations is robust.
Rather than keeping the queue completely in memory, let's create a generations
db table that keeps track of an ordered queue of the generations to be
processed.

Let's also make sure that the generation queue is maintained completely server
side, that is - there's no local storage or client side memory of checking the
queue.

We can also add generation plans to the queue from other sources/scripts.

**Implementation:**
- Created `queue_db.py` with a SQLite-backed queue (`generation_queue` table)
- Queue supports pending, processing, complete, and error states
- Includes automatic cleanup of stale processing items on restart
- Frontend now polls server for queue status instead of using localStorage

## 2. Multiple models ‚úÖ

When we boot the app up, we shoul read from an `app_config.json` what model or
models to use. Each model will have a `name`, `model_id` and an `api_key` param,
and that model will be used for generation - all queue entries should also
contain a `model_id` so that we can use that model for generation.

The frontend needs to have a dropdown select added to the controls that lets the
user pick which model is to be used for generation. The model `name` \ `ids` in
this list should be bootstrapped into the page when served, and the selected
model id should be sent to the generate request to be added to the generation
queue.

**Implementation:**
- Created `model_config.py` with `ModelConfig` and `AppConfig` dataclasses
- Created `app_config.json` with 3 pre-configured models (Omni Water v1/v2, Omni Original)
- Model selector dropdown added to the toolbar
- Queue entries now include `model_id` field
- `generate_omni.py` updated to accept model configuration

## 3. Persisted web renderer ‚úÖ

Since every single generation request needs to create a new node/web server to
render the web view of tile, we should have one single web renderer process
that's started when the app server loads - the app server should make requests
to this web_renderer subprocess through a simple interface, and this interface
must account for the fact that multiple requests may come in at onece, so it
needs a queue manager for handling those requests to render specific tiles in
the order they're received.

**Implementation:**
- Created `web_renderer.py` with `WebRenderer` class
- Singleton pattern for global renderer instance
- Internal queue for render requests with callback-based results
- Auto-restarts web server if it crashes
- Started automatically when app server boots

```

I've completed implementing all three improvements from the task. Here's a summary of what was created and modified:

## Summary of Changes

### 1. Database-Backed Queue (`queue_db.py`)
- Created a new `generation_queue` table in the SQLite database
- Supports pending, processing, complete, and error states
- Includes automatic cleanup of stale items on server restart
- Queue entries now include `model_id` for multi-model support

### 2. Multi-Model Support
**New files:**
- `model_config.py` - Defines `ModelConfig` and `AppConfig` classes
- `app_config.json` - Configuration file with 3 pre-configured models:
  - Omni Water v1 (default)
  - Omni Water v2
  - Omni (Original)

**Changes to `generate_omni.py`:**
- Updated `call_oxen_api()` to accept a `model_config` parameter
- Updated `run_generation_for_quadrants()` to pass model config to the API

### 3. Persisted Web Renderer (`web_renderer.py`)
- Created `WebRenderer` class with internal render queue
- Singleton pattern via `get_web_renderer()` function
- Auto-restarts web server if it crashes
- Started automatically when the app server boots

### 4. Frontend Updates
**Template (`viewer.html`):**
- Added model selector dropdown in the toolbar
- Models are bootstrapped into the page config on load

**JavaScript (`viewer.js`):**
- Removed all localStorage-based queue tracking
- Now relies entirely on server-side queue status
- Added model selector initialization and selection

**CSS (`viewer.css`):**
- Added styles for the model selector dropdown

### 5. App Server Updates (`app.py`)
- Integrated the database-backed queue system
- Starts the global web renderer on boot
- All API endpoints now use the database queue
- Loads and exposes model configuration to the frontend

---

**User**

Please update the queue logic so that an in-progress queued generation is restarted if the server/app is shut down in the middle of generation (ie only remove the queue entry if/when the generation succeeds/fails)

---

**Cursor**

I'll update the queue logic to ensure in-progress items are properly restarted if the server shuts down mid-generation. The key is to reset all processing items to pending on server startup, not just "stale" ones.

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    return {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)
  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates
    model_id: Optional model ID for generation

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  cursor.execute(
    """
    INSERT INTO generation_queue (item_type, quadrants, model_id, status, created_at)
    VALUES (?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount

```

Now let me update `app.py` to use the new function on startup:

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  clear_completed_items,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(conn, config, selected_quadrants, model_id)
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """API endpoint to generate tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id)
  return jsonify(result), 202  # 202 Accepted


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Clean up any stale processing items from previous runs
    stale_count = cleanup_stale_processing(conn)
    if stale_count > 0:
      print(f"‚ö†Ô∏è  Reset {stale_count} stale processing item(s) from previous run")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  clear_completed_items,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(conn, config, selected_quadrants, model_id)
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """API endpoint to generate tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id)
  return jsonify(result), 202  # 202 Accepted


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

Done! I've updated the queue logic so that interrupted generations are automatically restarted when the server comes back up.

## Changes Made

### `queue_db.py`
Added a new function `reset_all_processing_items()` that resets ALL items currently in "processing" state back to "pending", regardless of how long ago they started. This is specifically designed for server startup to recover from interrupted generations.

```python
def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.
  """
```

### `app.py`
- Replaced the import of `cleanup_stale_processing` with `reset_all_processing_items`
- On server startup, now calls `reset_all_processing_items()` which will:
  - Find any queue items that were in "processing" state (from a previous run)
  - Reset them to "pending" so they get picked up by the queue worker
  - Print a message like `üîÑ Reset 2 interrupted generation(s) - will be retried`

## How It Works

1. **Before**: Queue items were only marked complete/error after the generation finished. If the server crashed mid-generation, the item would be stuck in "processing" forever (or until the 1-hour stale timeout).

2. **After**: On every server startup, all "processing" items are immediately reset to "pending". This means:
   - If you shut down the server during a generation, that generation will restart when the server comes back up
   - No generation is ever lost - they'll keep retrying until they succeed or fail
   - The queue worker will pick up these items and process them in order

```python
def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.
  """
```

---

**User**

Awesome, now add a "clear generation queue" button to the frontend that has a confirmation dialog, and an API route that will clear out the generation queue

---

**Cursor**

I'll add the clear queue functionality. Let me start with the API and then update the frontend.

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    return {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)
  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates
    model_id: Optional model ID for generation

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  cursor.execute(
    """
    INSERT INTO generation_queue (item_type, quadrants, model_id, status, created_at)
    VALUES (?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(conn, config, selected_quadrants, model_id)
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """API endpoint to generate tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(conn, config, selected_quadrants, model_id)
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all pending items from the generation queue.

  Does NOT affect items that are currently processing.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "message": "Cleared N pending item(s) from queue"
    }
  """
  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    cleared_count = clear_pending_queue(conn)

    if cleared_count > 0:
      print(f"‚úÖ Cleared {cleared_count} pending item(s) from queue")
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "message": f"Cleared {cleared_count} pending item(s) from queue",
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """API endpoint to generate tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

Now let me update the frontend HTML to add the button:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Generated Tiles Viewer</title>
    <link rel="stylesheet" href="/static/viewer.css" />
    <style>
      /* Dynamic grid sizing based on template variables */
      .grid {
        grid-template-columns: repeat({{ nx }}, {{ size_px }}px);
        grid-auto-rows: {{ size_px }}px;
      }
      .tile.placeholder {
        min-width: {{ size_px }}px;
        min-height: {{ size_px }}px;
      }
    </style>
  </head>
  <body>
    <!-- Config data for JS -->
    <script
      id="app-config"
      type="application/json"
      data-config='{"x": {{ x }}, "y": {{ y }}, "nx": {{ nx }}, "ny": {{ ny }}, "size_px": {{ size_px }}, "models": {{ models_config | safe }}, "default_model_id": "{{ default_model_id }}"}'
    ></script>

    <!-- Toast notification container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Fixed toolbar -->
    <div class="toolbar">
      <div class="toolbar-row">
        <div class="controls">
          <label>X: <input type="number" id="x" value="{{ x }}" /></label>
          <label>Y: <input type="number" id="y" value="{{ y }}" /></label>
          <label
            >NX: <input type="number" id="nx" value="{{ nx }}" min="1" max="20"
          /></label>
          <label
            >NY: <input type="number" id="ny" value="{{ ny }}" min="1" max="20"
          /></label>
          <label
            >Size:
            <input type="number" id="sizePx" value="{{ size_px }}" step="32"
          /></label>
          <button onclick="goTo()">Go</button>
          <div class="toggle-group">
            <label
              ><input
                type="checkbox"
                id="showLines"
                {%
                if
                show_lines
                %}checked{%
                endif
                %}
                onchange="toggleLines()"
              />
              Lines</label
            >
            <label
              ><input
                type="checkbox"
                id="showCoords"
                {%
                if
                show_coords
                %}checked{%
                endif
                %}
                onchange="toggleCoords()"
              />
              Coords</label
            >
            <label
              ><input
                type="checkbox"
                id="showRender"
                {%
                if
                show_render
                %}checked{%
                endif
                %}
                onchange="toggleRender()"
              />
              Renders</label
            >
          </div>
          <div class="toggle-group model-group">
            <label class="model-label"
              >Model:
              <select id="modelSelect" class="model-select">
                <!-- Populated by JavaScript -->
              </select>
            </label>
          </div>
          <div class="toggle-group tools-group">
            <span class="tools-label">Tools:</span>
            <button
              id="selectTool"
              class="tool-btn"
              onclick="toggleSelectTool()"
              title="Select quadrants (S)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path>
                <path d="M13 13l6 6"></path>
              </svg>
              Select
            </button>
            <button
              id="fixWaterTool"
              class="tool-btn"
              onclick="toggleFixWaterTool()"
              title="Fix water color (W)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
              </svg>
              Fix Water
            </button>
            <button
              id="waterFillTool"
              class="tool-btn"
              onclick="toggleWaterFillTool()"
              title="Fill quadrant with water (F)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <rect x="3" y="3" width="18" height="18" rx="2"></rect>
                <path d="M12 8v8"></path>
                <path d="M8 12h8"></path>
              </svg>
              Water Fill
            </button>
          </div>
        </div>
        <div class="toolbar-info">
          <span>({{ x }}, {{ y }}) ‚Üí ({{ x + nx - 1 }}, {{ y + ny - 1 }})</span>
          <span>{{ generation_dir }}</span>
        </div>
      </div>
      <div class="selection-status" id="selectionStatus">
        <span id="selectionCount">0 quadrants selected</span>
        <span class="selection-limit">(max 4)</span>
        <button
          id="deselectAllBtn"
          class="deselect-btn"
          onclick="deselectAll()"
          disabled
        >
          Deselect All
        </button>
        <button
          id="deleteBtn"
          class="delete-btn"
          onclick="deleteSelected()"
          disabled
        >
          Delete
        </button>
        <button
          id="renderBtn"
          class="render-btn"
          onclick="renderSelected()"
          disabled
        >
          Render
        </button>
        <button
          id="generateBtn"
          class="generate-btn"
          onclick="generateSelected()"
          disabled
        >
          Generate
        </button>
        <button
          id="generateRectBtn"
          class="generate-rect-btn"
          onclick="generateRectangle()"
          disabled
          title="Select exactly 2 quadrants to define rectangle corners"
        >
          Generate Rectangle
        </button>
        <button
          id="clearQueueBtn"
          class="clear-queue-btn"
          onclick="clearQueue()"
          title="Clear all pending items from the generation queue"
        >
          Clear Queue
        </button>
      </div>
      <div class="water-fix-status" id="waterFixStatus" style="display: none">
        <span class="water-fix-label">Target Color:</span>
        <span class="color-swatch" id="targetColorSwatch"></span>
        <span class="color-hex" id="targetColorHex"
          >Click a quadrant to pick color</span
        >
        <span class="water-fix-quadrant" id="waterFixQuadrant"></span>
        <button
          id="applyWaterFixBtn"
          class="apply-water-fix-btn"
          onclick="applyWaterFix()"
          disabled
        >
          Apply Fix
        </button>
        <button
          id="cancelWaterFixBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFix()"
        >
          Cancel
        </button>
      </div>
      <div class="water-fill-status" id="waterFillStatus" style="display: none">
        <span class="water-fill-label">Water Fill:</span>
        <span class="color-swatch water-color-preview"></span>
        <span class="water-fill-instruction" id="waterFillInstruction"
          >Click a quadrant to fill with water</span
        >
        <button
          id="cancelWaterFillBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFill()"
        >
          Cancel
        </button>
      </div>
    </div>

    <div
      class="grid-container {% if show_lines %}show-lines{% endif %} {% if show_coords %}show-coords{% endif %}"
      id="gridContainer"
    >
      <div class="grid">
        {% for dy in range(ny) %} {% for dx in range(nx) %} {% set qx = x + dx
        %} {% set qy = y + dy %} {% set has_gen = tiles.get((dx, dy), False) %}
        <div
          class="tile {% if not has_gen %}placeholder{% endif %}"
          data-coords="{{ qx }},{{ qy }}"
        >
          <span class="coords">({{ qx }}, {{ qy }})</span>
          {% if has_gen %}
          <img
            src="/tile/{{ qx }}/{{ qy }}?render={{ '1' if show_render else '0' }}"
            alt="Tile {{ qx }},{{ qy }}"
          />
          {% endif %}
        </div>
        {% endfor %} {% endfor %}
      </div>
    </div>

    <script src="/static/viewer.js"></script>
  </body>
</html>

```

Now let me add the JavaScript function:

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show queue count
    if (serverStatus.queue_length > 0) {
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;

    if (queueLength === 0) {
      showToast("info", "Queue empty", "There are no pending items in the queue.");
      return;
    }

    // Confirm with user
    const confirmMessage = `Are you sure you want to clear ${queueLength} pending item(s) from the queue?\n\nThis will NOT affect any generation currently in progress.`;
    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast("error", "Failed to clear queue", result.error || "Unknown error");
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

async function generateSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  const modelId = getSelectedModelId();

  console.log("Generate requested for:", coords, "with model:", modelId);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for generation`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        quadrants: coords,
        model_id: modelId,
      }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Generation queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update buttons based on state
    const generateBtn = document.getElementById("generateBtn");
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on appropriate button
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
        generateBtn.classList.remove("loading");
        generateBtn.innerHTML = "Generate";
      } else {
        generateBtn.classList.add("loading");
        generateBtn.innerHTML = 'Generating<span class="spinner"></span>';
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset buttons
      generateBtn.classList.remove("loading");
      generateBtn.innerHTML = "Generate";
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        showToast(
          "info",
          "Processing queue",
          `${status.queue_length} more item(s) in queue...`
        );
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

Now let me add CSS styling for the button:

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
  font-size: 12px;
  background: #1a1a2e;
  color: #eee;
  min-height: 100vh;
  padding: 15px;
  padding-top: 95px; /* Space for fixed toolbar */
}

.toolbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: #1a1a2e;
  padding: 10px 15px;
  z-index: 100;
  border-bottom: 1px solid #333;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.toolbar-row {
  display: flex;
  align-items: center;
  gap: 15px;
  flex-wrap: wrap;
}

.toolbar-info {
  color: #666;
  font-size: 0.75rem;
}

.toolbar-info span + span {
  margin-left: 12px;
}

.controls {
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
}

.controls label {
  color: #888;
  font-size: 0.8rem;
}

.controls input[type="number"] {
  width: 50px;
  padding: 5px 6px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #16213e;
  color: #fff;
  font-family: inherit;
  font-size: 0.8rem;
}

.controls button {
  padding: 5px 12px;
  background: #00d9ff;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.75rem;
  font-weight: bold;
}

.controls button:hover {
  background: #00b8d4;
}

.toggle-group {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-left: 8px;
  padding-left: 12px;
  border-left: 1px solid #333;
}

.toggle-group label {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  user-select: none;
  font-size: 0.75rem;
}

.toggle-group input[type="checkbox"] {
  width: 14px;
  height: 14px;
  accent-color: #00d9ff;
  cursor: pointer;
}

.grid-container {
  display: inline-block;
  border-radius: 8px;
  overflow: hidden;
}

.grid-container.show-lines {
  border: 2px solid #333;
}

.grid {
  display: grid;
  background: #333;
}

.grid-container.show-lines .grid {
  gap: 2px;
}

.grid-container:not(.show-lines) .grid {
  gap: 0;
  background: transparent;
}

.grid-container:not(.show-lines) {
  border: none;
}

.tile {
  position: relative;
  background: #2a2a4a;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tile img {
  display: block;
  max-width: 100%;
  height: auto;
}

.tile.placeholder {
  background: #3a3a5a;
}

.tile .coords {
  position: absolute;
  top: 6px;
  left: 6px;
  background: rgba(0, 0, 0, 0.7);
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 0.65rem;
  color: #00d9ff;
  transition: opacity 0.2s;
}

.tile.placeholder .coords {
  color: #666;
}

.grid-container:not(.show-coords) .tile .coords {
  opacity: 0;
}

/* Tool button styles */
.tools-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.tools-label {
  color: #666;
  font-size: 0.7rem;
}

.tool-btn {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: #2a2a3e;
  color: #666;
  border: 1px solid #444;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  transition: all 0.15s ease;
}

.tool-btn:hover {
  background: #3a3a4e;
  color: #999;
  border-color: #555;
}

.tool-btn.active {
  background: #10b981;
  color: #fff;
  border-color: #10b981;
  box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
}

.tool-btn.active:hover {
  background: #059669;
  border-color: #059669;
}

.tool-btn svg {
  width: 12px;
  height: 12px;
}

/* Selection styles */
.tile.selected {
  outline: 3px solid #ff3333;
  outline-offset: -3px;
  z-index: 10;
}

.grid-container.show-lines .tile.selected {
  outline-color: #ff3333;
}

.tile.selectable {
  cursor: pointer;
}

.tile.placeholder.selected {
  background: rgba(255, 51, 51, 0.15);
}

/* Locked tiles (during generation) */
.tile.locked {
  outline: 3px solid #a855f7;
  outline-offset: -3px;
  z-index: 10;
}

.grid-container.show-lines .tile.locked {
  outline-color: #a855f7;
}

.tile.placeholder.locked {
  background: rgba(168, 85, 247, 0.2);
}

/* Queued tiles (in queue, waiting to be generated) */
.tile.queued {
  outline: 3px dashed #c084fc !important;
  outline-offset: -3px;
  z-index: 9;
  animation: pulse-queue 1.5s ease-in-out infinite;
  /* Fallback: box-shadow for browsers that don't render dashed outlines well */
  box-shadow: inset 0 0 0 3px rgba(192, 132, 252, 0.5);
}

@keyframes pulse-queue {
  0%,
  100% {
    outline-color: #c084fc;
    box-shadow: inset 0 0 0 3px rgba(192, 132, 252, 0.5);
  }
  50% {
    outline-color: #8b5cf6;
    box-shadow: inset 0 0 0 3px rgba(139, 92, 246, 0.7);
  }
}

.grid-container.show-lines .tile.queued {
  outline-color: #c084fc;
}

.tile.placeholder.queued {
  background: rgba(168, 85, 247, 0.3) !important;
}

/* Allow selection while generating - only disable clicking on locked/queued tiles */
body.generating .tile.locked.selectable,
body.generating .tile.queued.selectable {
  cursor: not-allowed;
}

/* Selection status bar */
.selection-status {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 10px;
  background: rgba(255, 51, 51, 0.1);
  border: 1px solid rgba(255, 51, 51, 0.3);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #ff6666;
  margin-top: 8px;
}

.selection-status.empty {
  background: transparent;
  border-color: #333;
  color: #666;
}

.selection-status.generating {
  background: rgba(168, 85, 247, 0.1);
  border-color: rgba(168, 85, 247, 0.4);
  color: #a855f7;
}

.selection-limit {
  color: #888;
  font-size: 0.65rem;
}

.deselect-btn {
  padding: 3px 8px;
  background: #ff3333;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  margin-left: auto;
  transition: all 0.2s;
}

.deselect-btn:hover:not(:disabled) {
  background: #ff5555;
}

.deselect-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
}

.delete-btn {
  padding: 3px 8px;
  background: #dc2626;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  transition: all 0.2s;
}

.delete-btn:hover:not(:disabled) {
  background: #b91c1c;
}

.delete-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
}

.render-btn {
  padding: 4px 12px;
  background: #f59e0b;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
}

.render-btn:hover:not(:disabled) {
  background: #d97706;
}

.render-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.render-btn.loading {
  background: #666;
  cursor: wait;
}

.render-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

.generate-btn {
  padding: 4px 12px;
  background: #00d9ff;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
}

.generate-btn:hover:not(:disabled) {
  background: #00b8d4;
}

.generate-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

/* Generate Rectangle button */
.generate-rect-btn {
  padding: 4px 12px;
  background: #8b5cf6;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
}

.generate-rect-btn:hover:not(:disabled) {
  background: #7c3aed;
}

.generate-rect-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.generate-rect-btn.loading {
  background: #666;
  cursor: wait;
}

.generate-rect-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

/* Clear Queue button */
.clear-queue-btn {
  padding: 4px 10px;
  background: #6b7280;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  font-weight: 500;
  transition: all 0.2s;
  margin-left: 8px;
}

.clear-queue-btn:hover {
  background: #ef4444;
}

.clear-queue-btn:active {
  background: #dc2626;
}

/* Toast notification system */
.toast-container {
  position: fixed;
  bottom: 15px;
  right: 15px;
  z-index: 1000;
  display: flex;
  flex-direction: column-reverse;
  gap: 8px;
  max-width: 320px;
}

.toast {
  padding: 10px 14px;
  border-radius: 6px;
  font-size: 0.75rem;
  animation: slideIn 0.3s ease-out;
  display: flex;
  align-items: flex-start;
  gap: 10px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.toast.success {
  background: linear-gradient(135deg, #065f46 0%, #047857 100%);
  border: 1px solid #10b981;
  color: #d1fae5;
}

.toast.error {
  background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
  border: 1px solid #ef4444;
  color: #fee2e2;
}

.toast.info {
  background: linear-gradient(135deg, #1e3a5f 0%, #1e40af 100%);
  border: 1px solid #3b82f6;
  color: #dbeafe;
}

.toast.loading {
  background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
  border: 1px solid #6b7280;
  color: #e5e7eb;
}

.toast-icon {
  flex-shrink: 0;
  font-size: 1rem;
}

.toast-content {
  flex: 1;
}

.toast-title {
  font-weight: 600;
  margin-bottom: 2px;
}

.toast-message {
  opacity: 0.9;
  font-size: 0.7rem;
}

.toast-close {
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  opacity: 0.7;
  font-size: 1rem;
  padding: 0;
  line-height: 1;
}

.toast-close:hover {
  opacity: 1;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOut {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

.toast.removing {
  animation: slideOut 0.3s ease-in forwards;
}

/* Loading spinner for generate button */
.generate-btn.loading {
  background: #666;
  color: #fff;
  cursor: wait;
}

.generate-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Water fix tool styles */
.water-fix-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid rgba(59, 130, 246, 0.3);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #60a5fa;
  margin-top: 8px;
}

.water-fix-label {
  color: #93c5fd;
  font-weight: 500;
}

.color-swatch {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  border: 2px solid #fff;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3), inset 0 0 0 1px rgba(0, 0, 0, 0.1);
  background: #333;
}

.color-swatch.has-color {
  cursor: pointer;
}

.color-hex {
  font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
  font-size: 0.75rem;
  color: #93c5fd;
  min-width: 180px;
}

.water-fix-quadrant {
  color: #60a5fa;
  font-size: 0.7rem;
}

.apply-water-fix-btn {
  padding: 4px 12px;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
  margin-left: auto;
}

.apply-water-fix-btn:hover:not(:disabled) {
  background: #2563eb;
}

.apply-water-fix-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.apply-water-fix-btn.loading {
  background: #666;
  cursor: wait;
}

.cancel-water-fix-btn {
  padding: 4px 8px;
  background: #4b5563;
  color: #d1d5db;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  transition: all 0.2s;
}

.cancel-water-fix-btn:hover {
  background: #6b7280;
}

/* Fix water tool active state */
.tile.fix-water-selectable {
  cursor: crosshair;
}

.tile.fix-water-selectable:hover {
  outline: 2px solid #3b82f6;
  outline-offset: -2px;
}

.tile.water-fix-selected {
  outline: 3px solid #3b82f6;
  outline-offset: -3px;
  z-index: 10;
}

/* Water fill tool styles */
.water-fill-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(74, 99, 114, 0.15);
  border: 1px solid rgba(74, 99, 114, 0.4);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #7ba3b8;
  margin-top: 8px;
}

.water-fill-label {
  color: #93c5fd;
  font-weight: 500;
}

.water-color-preview {
  background: #4a6372 !important;
}

.water-fill-instruction {
  color: #7ba3b8;
}

.tile.water-fill-selectable {
  cursor: pointer;
}

.tile.water-fill-selectable:hover {
  outline: 2px solid #4a6372;
  outline-offset: -2px;
}

/* Model selector styles */
.model-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.model-label {
  display: flex;
  align-items: center;
  gap: 6px;
  color: #888;
  font-size: 0.75rem;
}

.model-select {
  padding: 4px 8px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #16213e;
  color: #fff;
  font-family: inherit;
  font-size: 0.75rem;
  cursor: pointer;
  min-width: 140px;
}

.model-select:hover {
  border-color: #00d9ff;
}

.model-select:focus {
  outline: none;
  border-color: #00d9ff;
  box-shadow: 0 0 0 2px rgba(0, 217, 255, 0.2);
}

.model-select option {
  background: #16213e;
  color: #fff;
  padding: 4px;
}

```

Let me verify everything is working:

All tests pass. Here's a summary of the changes:

## Changes Made

### `queue_db.py`
Added two new functions:
- `clear_pending_queue()` - Clears only pending items (doesn't affect currently processing items)
- `clear_all_queue_items()` - Clears everything (for future use if needed)

### `app.py`
Added new API endpoint:
- `POST /api/queue/clear` - Clears all pending items from the queue, returns the count of items cleared

### `viewer.html`
Added a "Clear Queue" button in the selection status bar, next to the Generate Rectangle button.

### `viewer.js`
Added `clearQueue()` function that:
1. Fetches current queue status to get the count
2. Shows a confirmation dialog: "Are you sure you want to clear N pending item(s) from the queue? This will NOT affect any generation currently in progress."
3. Calls the API to clear the queue
4. Shows success/error toast notification
5. Refreshes the status display

### `viewer.css`
Added styling for the clear queue button:
- Gray background by default
- Turns red on hover (to indicate destructive action)
- Compact size to fit nicely in the toolbar

---

**User**

OK - now let's add a new feature to the app - when generating, i want to be able to define the context which is used to generate the quadrant. So if the user selects a 2x2 tile of quadrants, and one of those quadrants is empty, then we should create a template with the 3 other quadrants populated by the generated pixels and the empty quadrant populated with the render content - this "context" should be an additional param to the `generate` api method in @src/isometric_nyc/e2e_generation/app.py 

---

**Cursor**

I'll implement this feature by adding a `context` parameter that specifies which quadrants should provide surrounding context for the generation. Let me update the code step by step.

Let me update the queue_db.py to support context quadrants:

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle both old (10 columns) and new (11 columns) schema
    context = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)
  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates
    model_id: Optional model ID for generation

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  cursor.execute(
    """
    INSERT INTO generation_queue (item_type, quadrants, model_id, status, created_at)
    VALUES (?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle both old (10 columns) and new (11 columns) schema
    context = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add context_quadrants column if it doesn't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates
    model_id: Optional model ID for generation

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  cursor.execute(
    """
    INSERT INTO generation_queue (item_type, quadrants, model_id, status, created_at)
    VALUES (?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle both old (10 columns) and new (11 columns) schema
    context = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add context_quadrants column if it doesn't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants)
    VALUES (?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle both old (10 columns) and new (11 columns) schema
    context = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add context_quadrants column if it doesn't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants)
    VALUES (?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle both old (10 columns) and new (11 columns) schema
    context = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add context_quadrants column if it doesn't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants)
    VALUES (?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

Now let me update `app.py` to handle the context parameter:

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(conn, config, selected_quadrants, model_id)
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all pending items from the generation queue.

  Does NOT affect items that are currently processing.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "message": "Cleared N pending item(s) from queue"
    }
  """
  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    cleared_count = clear_pending_queue(conn)

    if cleared_count > 0:
      print(f"‚úÖ Cleared {cleared_count} pending item(s) from queue")
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "message": f"Cleared {cleared_count} pending item(s) from queue",
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """API endpoint to generate tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw]
      if context_quadrants_raw
      else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(conn, config, selected_quadrants, model_id)
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all pending items from the generation queue.

  Does NOT affect items that are currently processing.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "message": "Cleared N pending item(s) from queue"
    }
  """
  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    cleared_count = clear_pending_queue(conn)

    if cleared_count > 0:
      print(f"‚úÖ Cleared {cleared_count} pending item(s) from queue")
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "message": f"Cleared {cleared_count} pending item(s) from queue",
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """API endpoint to generate tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw]
      if context_quadrants_raw
      else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all pending items from the generation queue.

  Does NOT affect items that are currently processing.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "message": "Cleared N pending item(s) from queue"
    }
  """
  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    cleared_count = clear_pending_queue(conn)

    if cleared_count > 0:
      print(f"‚úÖ Cleared {cleared_count} pending item(s) from queue")
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "message": f"Cleared {cleared_count} pending item(s) from queue",
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """API endpoint to generate tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw]
      if context_quadrants_raw
      else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all pending items from the generation queue.

  Does NOT affect items that are currently processing.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "message": "Cleared N pending item(s) from queue"
    }
  """
  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    cleared_count = clear_pending_queue(conn)

    if cleared_count > 0:
      print(f"‚úÖ Cleared {cleared_count} pending item(s) from queue")
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "message": f"Cleared {cleared_count} pending item(s) from queue",
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """API endpoint to generate tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw]
      if context_quadrants_raw
      else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all pending items from the generation queue.

  Does NOT affect items that are currently processing.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "message": "Cleared N pending item(s) from queue"
    }
  """
  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    cleared_count = clear_pending_queue(conn)

    if cleared_count > 0:
      print(f"‚úÖ Cleared {cleared_count} pending item(s) from queue")
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "message": f"Cleared {cleared_count} pending item(s) from queue",
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

Now let me update `generate_omni.py` to use the context quadrants:

```python
"""
Reusable library for generating pixel art using the Oxen.ai model.

This module provides the core generation logic that can be used by:
- view_generations.py (Flask web server)
- generate_tiles_omni.py (command-line script)
- automatic_generation.py (automated generation)

The main entry point is `run_generation_for_quadrants()` which handles:
1. Validating the quadrant selection
2. Rendering any missing quadrants
3. Building the template image
4. Uploading to GCS and calling the Oxen API
5. Saving the generated quadrants to the database
"""

import os
import re
import sqlite3
import tempfile
from io import BytesIO
from pathlib import Path
from typing import Callable
from urllib.parse import urlencode

import requests
from dotenv import load_dotenv
from PIL import Image
from playwright.sync_api import sync_playwright

from isometric_nyc.e2e_generation.infill_template import (
  QUADRANT_SIZE,
  InfillRegion,
  TemplateBuilder,
  validate_quadrant_selection,
)
from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  ensure_quadrant_exists,
  image_to_png_bytes,
  png_bytes_to_image,
  save_quadrant_generation,
  save_quadrant_render,
  split_tile_into_quadrants,
  upload_to_gcs,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_generation as shared_get_quadrant_generation,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_render as shared_get_quadrant_render,
)

# Load environment variables
load_dotenv()

# Oxen API configuration
OMNI_MODEL_ID = "cannoneyed-gentle-gold-antlion"
OMNI_WATER_MODEL_ID = "cannoneyed-quiet-green-lamprey"
OMNI_WATER_V2_MODEL_ID = "cannoneyed-rural-rose-dingo"

GCS_BUCKET_NAME = "isometric-nyc-infills"


# =============================================================================
# Quadrant Parsing Utilities
# =============================================================================


def parse_quadrant_tuple(s: str) -> tuple[int, int]:
  """
  Parse a quadrant tuple string like "(0,1)" or "0,1" into a tuple.

  Args:
      s: String in format "(x,y)" or "x,y"

  Returns:
      Tuple of (x, y) coordinates

  Raises:
      ValueError: If the format is invalid
  """
  s = s.strip()
  # Remove optional parentheses
  if s.startswith("(") and s.endswith(")"):
    s = s[1:-1]
  parts = s.split(",")
  if len(parts) != 2:
    raise ValueError(f"Invalid quadrant tuple format: {s}")
  return (int(parts[0].strip()), int(parts[1].strip()))


def parse_quadrant_list(s: str) -> list[tuple[int, int]]:
  """
  Parse a comma-separated list of quadrant tuples.

  Args:
      s: String like "(0,1),(0,2)" or "(0,1), (0,2)"

  Returns:
      List of (x, y) coordinate tuples

  Raises:
      ValueError: If the format is invalid
  """
  # Use regex to find all (x,y) patterns
  pattern = r"\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)"
  matches = re.findall(pattern, s)
  if not matches:
    raise ValueError(f"No valid quadrant tuples found in: {s}")
  return [(int(x), int(y)) for x, y in matches]


# =============================================================================
# Oxen API Functions
# =============================================================================


def call_oxen_api(
  image_url: str,
  model_config: "ModelConfig | None" = None,  # noqa: F821
) -> str:
  """
  Call the Oxen API to generate pixel art.

  Args:
      image_url: Public URL of the input template image
      model_config: Optional model configuration (ModelConfig from model_config.py).
        If not provided, uses defaults.

  Returns:
      URL of the generated image

  Raises:
      requests.HTTPError: If the API call fails
      ValueError: If the response format is unexpected
  """
  # Use provided config or defaults
  if model_config is not None:
    endpoint = model_config.endpoint
    model_id = model_config.model_id
    api_key = model_config.api_key
    num_inference_steps = model_config.num_inference_steps
  else:
    endpoint = "https://hub.oxen.ai/api/images/edit"
    model_id = OMNI_WATER_MODEL_ID
    api_key = os.getenv("OXEN_OMNI_v04_WATER_API_KEY")
    num_inference_steps = 28

  if not api_key:
    raise ValueError(f"API key not found for model {model_id}")

  headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json",
  }

  prompt = (
    "Fill in the outlined section with the missing pixels corresponding to "
    "the <isometric nyc pixel art> style, removing the border and exactly "
    "following the shape/style/structure of the surrounding image (if present)."
  )

  payload = {
    "model": model_id,
    "input_image": image_url,
    "prompt": prompt,
    "num_inference_steps": num_inference_steps,
  }

  print(f"   ü§ñ Calling Oxen API with model {model_id}...")
  response = requests.post(endpoint, headers=headers, json=payload, timeout=300)
  response.raise_for_status()

  result = response.json()

  if "images" in result and len(result["images"]) > 0:
    return result["images"][0]["url"]
  elif "url" in result:
    return result["url"]
  elif "image_url" in result:
    return result["image_url"]
  elif "output" in result:
    return result["output"]
  else:
    raise ValueError(f"Unexpected API response format: {result}")


def download_image_to_pil(url: str) -> Image.Image:
  """
  Download an image from a URL and return as PIL Image.

  Args:
      url: URL of the image to download

  Returns:
      PIL Image object
  """
  response = requests.get(url, timeout=120)
  response.raise_for_status()
  return Image.open(BytesIO(response.content))


# =============================================================================
# Rendering Functions
# =============================================================================


def render_quadrant(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
  port: int,
) -> bytes | None:
  """
  Render a quadrant and save to database.

  This renders the tile containing the quadrant and saves all 4 quadrants.

  Args:
      conn: Database connection
      config: Generation config dict
      x: Quadrant x coordinate
      y: Quadrant y coordinate
      port: Web server port for rendering

  Returns:
      PNG bytes of the rendered quadrant, or None if failed
  """
  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  # Build URL for rendering
  params = {
    "export": "true",
    "lat": quadrant["lat"],
    "lon": quadrant["lng"],
    "width": config["width_px"],
    "height": config["height_px"],
    "azimuth": config["camera_azimuth_degrees"],
    "elevation": config["camera_elevation_degrees"],
    "view_height": config.get("view_height_meters", 200),
  }
  query_string = urlencode(params)
  url = f"http://localhost:{port}/?{query_string}"

  # Render using Playwright
  with sync_playwright() as p:
    browser = p.chromium.launch(
      headless=True,
      args=[
        "--enable-webgl",
        "--use-gl=angle",
        "--ignore-gpu-blocklist",
      ],
    )

    context = browser.new_context(
      viewport={"width": config["width_px"], "height": config["height_px"]},
      device_scale_factor=1,
    )
    page = context.new_page()

    page.goto(url, wait_until="networkidle")

    try:
      page.wait_for_function("window.TILES_LOADED === true", timeout=60000)
    except Exception:
      print("      ‚ö†Ô∏è  Timeout waiting for tiles, continuing anyway...")

    # Get screenshot as bytes
    screenshot_bytes = page.screenshot(type="png")

    page.close()
    context.close()
    browser.close()

  # Open as PIL image and split into quadrants
  full_tile = Image.open(BytesIO(screenshot_bytes))
  quadrant_images = split_tile_into_quadrants(full_tile)

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), quad_img in quadrant_images.items():
    qx, qy = x + dx, y + dy
    png_bytes = image_to_png_bytes(quad_img)
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


# =============================================================================
# Core Generation Logic
# =============================================================================


def run_generation_for_quadrants(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  port: int = DEFAULT_WEB_PORT,
  bucket_name: str = GCS_BUCKET_NAME,
  status_callback: Callable[[str, str], None] | None = None,
  model_config: "ModelConfig | None" = None,  # noqa: F821
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is the main entry point for generation. It:
  1. Validates the quadrant selection
  2. Renders any missing quadrants
  3. Builds the template image with appropriate borders
  4. Uploads to GCS and calls the Oxen API
  5. Saves the generated quadrants to the database

  Args:
      conn: Database connection
      config: Generation config dict
      selected_quadrants: List of (x, y) quadrant coordinates to generate
      port: Web server port for rendering (default: 5173)
      bucket_name: GCS bucket name for uploads
      status_callback: Optional callback(status, message) for progress updates
      model_config: Optional model configuration for the Oxen API (ModelConfig from model_config.py)
      context_quadrants: Optional list of (x, y) quadrant coordinates to use as
        context. These quadrants provide surrounding pixel art context for the
        generation. If a context quadrant has a generation, that will be used;
        otherwise the render will be used.

  Returns:
      Dict with:
          - success: bool
          - message: str (on success)
          - error: str (on failure)
          - quadrants: list of generated quadrant coords (on success)
  """
  # Convert context quadrants to a set for fast lookup
  context_set: set[tuple[int, int]] = set(context_quadrants) if context_quadrants else set()
  if context_set:
    print(f"   üìã Using {len(context_set)} context quadrant(s): {list(context_set)}")

  def update_status(status: str, message: str = "") -> None:
    if status_callback:
      status_callback(status, message)

  update_status("validating", "Checking API key...")

  # Create helper functions for validation
  # These are modified to treat context quadrants as "generated" if they have
  # either a generation or a render
  def has_generation_in_db(qx: int, qy: int) -> bool:
    # Check if this quadrant has an actual generation
    gen = shared_get_quadrant_generation(conn, qx, qy)
    if gen is not None:
      return True

    # For context quadrants, treat them as "generated" if they have a render
    # This allows context quadrants to provide surrounding content even if
    # they don't have generations yet
    if (qx, qy) in context_set:
      render = shared_get_quadrant_render(conn, qx, qy)
      return render is not None

    return False

  def get_render_from_db_with_render(qx: int, qy: int) -> Image.Image | None:
    """Get render, rendering if it doesn't exist yet."""
    render_bytes = shared_get_quadrant_render(conn, qx, qy)
    if render_bytes:
      return png_bytes_to_image(render_bytes)

    # Need to render
    update_status("rendering", f"Rendering quadrant ({qx}, {qy})...")
    print(f"   üì¶ Rendering quadrant ({qx}, {qy})...")
    render_bytes = render_quadrant(conn, config, qx, qy, port)
    if render_bytes:
      return png_bytes_to_image(render_bytes)
    return None

  def get_generation_from_db(qx: int, qy: int) -> Image.Image | None:
    """Get generation, falling back to render for context quadrants."""
    gen_bytes = shared_get_quadrant_generation(conn, qx, qy)
    if gen_bytes:
      return png_bytes_to_image(gen_bytes)

    # For context quadrants, fall back to render if no generation exists
    # This allows context quadrants to provide surrounding pixel art context
    # even if they only have renders
    if (qx, qy) in context_set:
      render_bytes = shared_get_quadrant_render(conn, qx, qy)
      if render_bytes:
        print(f"   üìã Using render as context for ({qx}, {qy})")
        return png_bytes_to_image(render_bytes)

    return None

  update_status("validating", "Validating quadrant selection...")

  # Validate selection with auto-expansion
  is_valid, msg, placement = validate_quadrant_selection(
    selected_quadrants, has_generation_in_db, allow_expansion=True
  )

  if not is_valid:
    update_status("error", msg)
    return {"success": False, "error": msg}

  print(f"‚úÖ Validation: {msg}")

  # Get primary quadrants (the ones user selected, not padding)
  primary_quadrants = (
    placement.primary_quadrants if placement.primary_quadrants else selected_quadrants
  )
  padding_quadrants = placement.padding_quadrants if placement else []

  if padding_quadrants:
    print(f"   üì¶ Padding quadrants: {padding_quadrants}")

  # Create the infill region (may be expanded)
  if placement._expanded_region is not None:
    region = placement._expanded_region
  else:
    region = InfillRegion.from_quadrants(selected_quadrants)

  # Build the template
  update_status("rendering", "Building template image...")
  builder = TemplateBuilder(
    region, has_generation_in_db, get_render_from_db_with_render, get_generation_from_db
  )

  print("üìã Building template...")
  result = builder.build(border_width=2, allow_expansion=True)

  if result is None:
    error_msg = builder._last_validation_error or "Failed to build template"
    update_status("error", error_msg)
    return {
      "success": False,
      "error": error_msg,
    }

  template_image, placement = result

  # Save template to temp file and upload to GCS
  with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
    template_path = Path(tmp.name)
    template_image.save(template_path)

  try:
    update_status("uploading", "Uploading template to cloud...")
    print("üì§ Uploading template to GCS...")
    image_url = upload_to_gcs(template_path, bucket_name)

    update_status("generating", "Calling AI model (this may take a minute)...")
    print("ü§ñ Calling Oxen API...")
    generated_url = call_oxen_api(image_url, model_config)

    update_status("saving", "Downloading and saving results...")
    print("üì• Downloading generated image...")
    generated_image = download_image_to_pil(generated_url)

    # Extract quadrants from generated image and save to database
    print("üíæ Saving generated quadrants to database...")

    # Figure out what quadrants are in the infill region
    all_infill_quadrants = (
      placement.all_infill_quadrants
      if placement.all_infill_quadrants
      else region.overlapping_quadrants()
    )

    # For each infill quadrant, extract pixels from the generated image
    saved_count = 0
    for qx, qy in all_infill_quadrants:
      # Calculate position in the generated image
      quad_world_x = qx * QUADRANT_SIZE
      quad_world_y = qy * QUADRANT_SIZE

      template_x = quad_world_x - placement.world_offset_x
      template_y = quad_world_y - placement.world_offset_y

      # Crop this quadrant from the generated image
      crop_box = (
        template_x,
        template_y,
        template_x + QUADRANT_SIZE,
        template_y + QUADRANT_SIZE,
      )
      quad_img = generated_image.crop(crop_box)
      png_bytes = image_to_png_bytes(quad_img)

      # Only save primary quadrants (not padding)
      if (qx, qy) in primary_quadrants or (qx, qy) in [
        (q[0], q[1]) for q in primary_quadrants
      ]:
        if save_quadrant_generation(conn, config, qx, qy, png_bytes):
          print(f"   ‚úì Saved generation for ({qx}, {qy})")
          saved_count += 1
        else:
          print(f"   ‚ö†Ô∏è Failed to save generation for ({qx}, {qy})")
      else:
        print(f"   ‚è≠Ô∏è Skipped padding quadrant ({qx}, {qy})")

    update_status("complete", f"Generated {saved_count} quadrant(s)")
    return {
      "success": True,
      "message": f"Generated {saved_count} quadrant{'s' if saved_count != 1 else ''}",
      "quadrants": list(primary_quadrants),
    }

  finally:
    # Clean up temp file
    template_path.unlink(missing_ok=True)

```

Let me check for linting errors:

All tests pass. Here's a summary of the context feature implementation:

## Summary of Changes

### `queue_db.py`
- Added `context_quadrants` field to the `QueueItem` dataclass
- Updated `init_queue_table()` to add the new column (with migration for existing dbs)
- Updated `add_to_queue()` to accept and store context quadrants
- Updated all SELECT queries to include the new column

### `app.py`
- Updated `add_to_queue_db()` to accept `context_quadrants` parameter
- Updated `run_generation()` to accept and pass `context_quadrants`
- Updated `process_queue_item_from_db()` to read context from the queue item and pass it to generation
- Updated `/api/generate` endpoint to accept a new `context` parameter

### `generate_omni.py`
- Updated `run_generation_for_quadrants()` to accept `context_quadrants` parameter
- Modified the helper functions to treat context quadrants specially:
  - `has_generation_in_db()`: Returns `True` for context quadrants that have either a generation OR a render
  - `get_generation_from_db()`: Falls back to render content for context quadrants that don't have generations

## How to Use

When calling the `/api/generate` endpoint, you can now include a `context` parameter:

```json
{
  "quadrants": [[5, 5]],
  "context": [[4, 5], [5, 4], [4, 4]],
  "model_id": "optional-model-id"
}
```

This tells the generation system:
- Generate quadrant (5, 5)
- Use quadrants (4, 5), (5, 4), and (4, 4) as context
- For context quadrants: use their generation if available, otherwise use their render

This allows you to select a 2x2 tile where one quadrant is empty and the other 3 are populated, and have those 3 quadrants provide the surrounding pixel art context for the generation.

```json
{
  "quadrants": [[5, 5]],
  "context": [[4, 5], [5, 4], [4, 4]],
  "model_id": "optional-model-id"
}
```

---

**User**

OK - when "clear queue" is pressed, we want to cancel any existing generations as well

---

**Cursor**

I'll update the clear queue functionality to also cancel any in-progress generation. This involves:
1. Adding a function to cancel processing items
2. Updating the API endpoint to reset generation state
3. Adding a cancellation flag the worker can check

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle both old (10 columns) and new (11 columns) schema
    context = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add context_quadrants column if it doesn't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants)
    VALUES (?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def cancel_processing_items(conn: sqlite3.Connection) -> int:
  """
  Mark all processing items as cancelled (error status).

  This is used when the user wants to cancel everything, including
  items that are currently being processed.

  Returns the number of items cancelled.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE status = ?
    """,
    (
      QueueItemStatus.ERROR.value,
      time.time(),
      "Cancelled by user",
      QueueItemStatus.PROCESSING.value,
    ),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all pending items from the generation queue.

  Does NOT affect items that are currently processing.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "message": "Cleared N pending item(s) from queue"
    }
  """
  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    cleared_count = clear_pending_queue(conn)

    if cleared_count > 0:
      print(f"‚úÖ Cleared {cleared_count} pending item(s) from queue")
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "message": f"Cleared {cleared_count} pending item(s) from queue",
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel the current generation
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all pending items from the generation queue.

  Does NOT affect items that are currently processing.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "message": "Cleared N pending item(s) from queue"
    }
  """
  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    cleared_count = clear_pending_queue(conn)

    if cleared_count > 0:
      print(f"‚úÖ Cleared {cleared_count} pending item(s) from queue")
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "message": f"Cleared {cleared_count} pending item(s) from queue",
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel the current generation
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress")
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

Now let me update the queue worker to check for cancellation:

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel the current generation
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flag...")
        generation_cancelled = False
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Reset cancellation flag before starting new item
      generation_cancelled = False

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          # Check cancellation one more time before processing
          if generation_cancelled:
            print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
            continue

          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress")
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

Now let me update the JavaScript to show the cancelled count in the toast:

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show queue count
    if (serverStatus.queue_length > 0) {
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(" and ")}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

async function generateSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  const modelId = getSelectedModelId();

  console.log("Generate requested for:", coords, "with model:", modelId);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for generation`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        quadrants: coords,
        model_id: modelId,
      }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Generation queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update buttons based on state
    const generateBtn = document.getElementById("generateBtn");
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on appropriate button
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
        generateBtn.classList.remove("loading");
        generateBtn.innerHTML = "Generate";
      } else {
        generateBtn.classList.add("loading");
        generateBtn.innerHTML = 'Generating<span class="spinner"></span>';
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset buttons
      generateBtn.classList.remove("loading");
      generateBtn.innerHTML = "Generate";
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        showToast(
          "info",
          "Processing queue",
          `${status.queue_length} more item(s) in queue...`
        );
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

Let me run the linter to check for any issues:

Let me also run the tests to make sure everything still works:

All tests pass. Here's a summary of the changes:

**`queue_db.py`** - Added `cancel_processing_items()` function:
- Marks all items in 'processing' status as 'error' with message "Cancelled by user"
- Returns the count of cancelled items

**`app.py`** - Updated to handle cancellation:
- Added `generation_cancelled` global flag
- Updated `api_clear_queue()` to:
  - Clear pending items
  - Cancel in-progress items using the new function
  - Set the cancellation flag
  - Reset the generation state immediately
- Updated `queue_worker()` to check the cancellation flag and reset gracefully

**`viewer.js`** - Improved UX:
- Now checks if there's an active generation in addition to pending items
- Shows a more descriptive confirmation message (e.g., "cancel 3 pending item(s) and the current generation in progress")
- Handles the response which now includes `cancelled_count`

When "Clear Queue" is clicked, it will now:
1. Remove all pending items from the database
2. Mark any currently processing item as cancelled
3. Signal the worker to stop the current operation
4. Reset the UI state immediately

---

**User**

OK - I just selected four quadrants in the app (3 of which were already generated) and the message came up in a toast saying "four quadrants queued for generation" - is the app going to re-generate all four quadrants (incorrect) or is it going to use the surrounding 3 previously geenrated quadrants for context (correct)?

---

**Cursor**

Good question - let me check the current implementation. The issue is likely that the frontend is sending all 4 quadrants for generation without properly separating which ones need generation vs which ones should be used as context.

I see the issue! The frontend is sending ALL 4 selected quadrants for generation, but it should:
1. Filter out quadrants that are already generated
2. Only queue the non-generated ones for generation
3. Pass the already-generated ones as `context_quadrants`

Let me check how the app tracks which quadrants have generations:

I see the issue now. Looking at line 262-264 of the HTML template, tiles without generation have the `placeholder` class. I need to update `generateSelected()` to:
1. Check which selected tiles already have generation (no `placeholder` class)
2. Only queue the tiles that need generation
3. Pass already-generated tiles as `context_quadrants`

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show queue count
    if (serverStatus.queue_length > 0) {
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

async function generateSelected() {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context_quadrants = contextQuadrants;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Generation queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update buttons based on state
    const generateBtn = document.getElementById("generateBtn");
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on appropriate button
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
        generateBtn.classList.remove("loading");
        generateBtn.innerHTML = "Generate";
      } else {
        generateBtn.classList.add("loading");
        generateBtn.innerHTML = 'Generating<span class="spinner"></span>';
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset buttons
      generateBtn.classList.remove("loading");
      generateBtn.innerHTML = "Generate";
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        showToast(
          "info",
          "Processing queue",
          `${status.queue_length} more item(s) in queue...`
        );
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

Now let me also update the success toast to be more informative:

The app was **incorrectly** going to regenerate all 4 quadrants. I've fixed it!

Here's what was happening before:
- User selected 4 quadrants (3 already generated, 1 empty)
- Frontend sent ALL 4 to `/api/generate`
- Backend queued all 4 for regeneration ‚ùå

Here's what happens now:
- User selects 4 quadrants (3 already generated, 1 empty)
- Frontend checks each tile for the `placeholder` class (indicates no generation)
- Frontend separates: **1 quadrant to generate** + **3 quadrants as context**
- API call: `{ quadrants: [[empty_x, empty_y]], context_quadrants: [[x1,y1], [x2,y2], [x3,y3]] }`
- Backend queues only the 1 empty quadrant for generation, using the 3 others as context ‚úÖ

The toast will now say something like "Queueing 1 quadrant(s) for generation (using 3 as context)" instead of "4 quadrants queued for generation".

---

**User**

OK great - can you remove the HTTP logging from the python app for simple tile requests, and ensure you log the generation parameters (e.g. context) for the generation requests? Finally, ensure you log the temporary image path of the template image that's being uploaded to google cloud for sending to the generation request

---

**Cursor**

I'll make those logging changes. Let me find the relevant sections:

Good, I see the generation logging is already there. Now let me find the template upload code in `generate_omni.py`:

Now let me make the changes:

```python
import logging
import os
import sqlite3
import threading
import time
import traceback
from argparse import ArgumentParser
from pathlib import Path
```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request
import werkzeug.serving

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel the current generation
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flag...")
        generation_cancelled = False
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Reset cancellation flag before starting new item
      generation_cancelled = False

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          # Check cancellation one more time before processing
          if generation_cancelled:
            print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
            continue

          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request
import werkzeug.serving

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_status,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel the current generation
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flag...")
        generation_cancelled = False
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Reset cancellation flag before starting new item
      generation_cancelled = False

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          # Check cancellation one more time before processing
          if generation_cancelled:
            print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
            continue

          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

Now let me update the template upload logging in `generate_omni.py`:

```python
"""
Reusable library for generating pixel art using the Oxen.ai model.

This module provides the core generation logic that can be used by:
- view_generations.py (Flask web server)
- generate_tiles_omni.py (command-line script)
- automatic_generation.py (automated generation)

The main entry point is `run_generation_for_quadrants()` which handles:
1. Validating the quadrant selection
2. Rendering any missing quadrants
3. Building the template image
4. Uploading to GCS and calling the Oxen API
5. Saving the generated quadrants to the database
"""

import os
import re
import sqlite3
import tempfile
from io import BytesIO
from pathlib import Path
from typing import Callable
from urllib.parse import urlencode

import requests
from dotenv import load_dotenv
from PIL import Image
from playwright.sync_api import sync_playwright

from isometric_nyc.e2e_generation.infill_template import (
  QUADRANT_SIZE,
  InfillRegion,
  TemplateBuilder,
  validate_quadrant_selection,
)
from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  ensure_quadrant_exists,
  image_to_png_bytes,
  png_bytes_to_image,
  save_quadrant_generation,
  save_quadrant_render,
  split_tile_into_quadrants,
  upload_to_gcs,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_generation as shared_get_quadrant_generation,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_render as shared_get_quadrant_render,
)

# Load environment variables
load_dotenv()

# Oxen API configuration
OMNI_MODEL_ID = "cannoneyed-gentle-gold-antlion"
OMNI_WATER_MODEL_ID = "cannoneyed-quiet-green-lamprey"
OMNI_WATER_V2_MODEL_ID = "cannoneyed-rural-rose-dingo"

GCS_BUCKET_NAME = "isometric-nyc-infills"


# =============================================================================
# Quadrant Parsing Utilities
# =============================================================================


def parse_quadrant_tuple(s: str) -> tuple[int, int]:
  """
  Parse a quadrant tuple string like "(0,1)" or "0,1" into a tuple.

  Args:
      s: String in format "(x,y)" or "x,y"

  Returns:
      Tuple of (x, y) coordinates

  Raises:
      ValueError: If the format is invalid
  """
  s = s.strip()
  # Remove optional parentheses
  if s.startswith("(") and s.endswith(")"):
    s = s[1:-1]
  parts = s.split(",")
  if len(parts) != 2:
    raise ValueError(f"Invalid quadrant tuple format: {s}")
  return (int(parts[0].strip()), int(parts[1].strip()))


def parse_quadrant_list(s: str) -> list[tuple[int, int]]:
  """
  Parse a comma-separated list of quadrant tuples.

  Args:
      s: String like "(0,1),(0,2)" or "(0,1), (0,2)"

  Returns:
      List of (x, y) coordinate tuples

  Raises:
      ValueError: If the format is invalid
  """
  # Use regex to find all (x,y) patterns
  pattern = r"\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)"
  matches = re.findall(pattern, s)
  if not matches:
    raise ValueError(f"No valid quadrant tuples found in: {s}")
  return [(int(x), int(y)) for x, y in matches]


# =============================================================================
# Oxen API Functions
# =============================================================================


def call_oxen_api(
  image_url: str,
  model_config: "ModelConfig | None" = None,  # noqa: F821
) -> str:
  """
  Call the Oxen API to generate pixel art.

  Args:
      image_url: Public URL of the input template image
      model_config: Optional model configuration (ModelConfig from model_config.py).
        If not provided, uses defaults.

  Returns:
      URL of the generated image

  Raises:
      requests.HTTPError: If the API call fails
      ValueError: If the response format is unexpected
  """
  # Use provided config or defaults
  if model_config is not None:
    endpoint = model_config.endpoint
    model_id = model_config.model_id
    api_key = model_config.api_key
    num_inference_steps = model_config.num_inference_steps
  else:
    endpoint = "https://hub.oxen.ai/api/images/edit"
    model_id = OMNI_WATER_MODEL_ID
    api_key = os.getenv("OXEN_OMNI_v04_WATER_API_KEY")
    num_inference_steps = 28

  if not api_key:
    raise ValueError(f"API key not found for model {model_id}")

  headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json",
  }

  prompt = (
    "Fill in the outlined section with the missing pixels corresponding to "
    "the <isometric nyc pixel art> style, removing the border and exactly "
    "following the shape/style/structure of the surrounding image (if present)."
  )

  payload = {
    "model": model_id,
    "input_image": image_url,
    "prompt": prompt,
    "num_inference_steps": num_inference_steps,
  }

  print(f"   ü§ñ Calling Oxen API with model {model_id}...")
  response = requests.post(endpoint, headers=headers, json=payload, timeout=300)
  response.raise_for_status()

  result = response.json()

  if "images" in result and len(result["images"]) > 0:
    return result["images"][0]["url"]
  elif "url" in result:
    return result["url"]
  elif "image_url" in result:
    return result["image_url"]
  elif "output" in result:
    return result["output"]
  else:
    raise ValueError(f"Unexpected API response format: {result}")


def download_image_to_pil(url: str) -> Image.Image:
  """
  Download an image from a URL and return as PIL Image.

  Args:
      url: URL of the image to download

  Returns:
      PIL Image object
  """
  response = requests.get(url, timeout=120)
  response.raise_for_status()
  return Image.open(BytesIO(response.content))


# =============================================================================
# Rendering Functions
# =============================================================================


def render_quadrant(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
  port: int,
) -> bytes | None:
  """
  Render a quadrant and save to database.

  This renders the tile containing the quadrant and saves all 4 quadrants.

  Args:
      conn: Database connection
      config: Generation config dict
      x: Quadrant x coordinate
      y: Quadrant y coordinate
      port: Web server port for rendering

  Returns:
      PNG bytes of the rendered quadrant, or None if failed
  """
  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  # Build URL for rendering
  params = {
    "export": "true",
    "lat": quadrant["lat"],
    "lon": quadrant["lng"],
    "width": config["width_px"],
    "height": config["height_px"],
    "azimuth": config["camera_azimuth_degrees"],
    "elevation": config["camera_elevation_degrees"],
    "view_height": config.get("view_height_meters", 200),
  }
  query_string = urlencode(params)
  url = f"http://localhost:{port}/?{query_string}"

  # Render using Playwright
  with sync_playwright() as p:
    browser = p.chromium.launch(
      headless=True,
      args=[
        "--enable-webgl",
        "--use-gl=angle",
        "--ignore-gpu-blocklist",
      ],
    )

    context = browser.new_context(
      viewport={"width": config["width_px"], "height": config["height_px"]},
      device_scale_factor=1,
    )
    page = context.new_page()

    page.goto(url, wait_until="networkidle")

    try:
      page.wait_for_function("window.TILES_LOADED === true", timeout=60000)
    except Exception:
      print("      ‚ö†Ô∏è  Timeout waiting for tiles, continuing anyway...")

    # Get screenshot as bytes
    screenshot_bytes = page.screenshot(type="png")

    page.close()
    context.close()
    browser.close()

  # Open as PIL image and split into quadrants
  full_tile = Image.open(BytesIO(screenshot_bytes))
  quadrant_images = split_tile_into_quadrants(full_tile)

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), quad_img in quadrant_images.items():
    qx, qy = x + dx, y + dy
    png_bytes = image_to_png_bytes(quad_img)
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


# =============================================================================
# Core Generation Logic
# =============================================================================


def run_generation_for_quadrants(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  port: int = DEFAULT_WEB_PORT,
  bucket_name: str = GCS_BUCKET_NAME,
  status_callback: Callable[[str, str], None] | None = None,
  model_config: "ModelConfig | None" = None,  # noqa: F821
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is the main entry point for generation. It:
  1. Validates the quadrant selection
  2. Renders any missing quadrants
  3. Builds the template image with appropriate borders
  4. Uploads to GCS and calls the Oxen API
  5. Saves the generated quadrants to the database

  Args:
      conn: Database connection
      config: Generation config dict
      selected_quadrants: List of (x, y) quadrant coordinates to generate
      port: Web server port for rendering (default: 5173)
      bucket_name: GCS bucket name for uploads
      status_callback: Optional callback(status, message) for progress updates
      model_config: Optional model configuration for the Oxen API (ModelConfig from model_config.py)
      context_quadrants: Optional list of (x, y) quadrant coordinates to use as
        context. These quadrants provide surrounding pixel art context for the
        generation. If a context quadrant has a generation, that will be used;
        otherwise the render will be used.

  Returns:
      Dict with:
          - success: bool
          - message: str (on success)
          - error: str (on failure)
          - quadrants: list of generated quadrant coords (on success)
  """
  # Convert context quadrants to a set for fast lookup
  context_set: set[tuple[int, int]] = (
    set(context_quadrants) if context_quadrants else set()
  )
  if context_set:
    print(f"   üìã Using {len(context_set)} context quadrant(s): {list(context_set)}")

  def update_status(status: str, message: str = "") -> None:
    if status_callback:
      status_callback(status, message)

  update_status("validating", "Checking API key...")

  # Create helper functions for validation
  # These are modified to treat context quadrants as "generated" if they have
  # either a generation or a render
  def has_generation_in_db(qx: int, qy: int) -> bool:
    # Check if this quadrant has an actual generation
    gen = shared_get_quadrant_generation(conn, qx, qy)
    if gen is not None:
      return True

    # For context quadrants, treat them as "generated" if they have a render
    # This allows context quadrants to provide surrounding content even if
    # they don't have generations yet
    if (qx, qy) in context_set:
      render = shared_get_quadrant_render(conn, qx, qy)
      return render is not None

    return False

  def get_render_from_db_with_render(qx: int, qy: int) -> Image.Image | None:
    """Get render, rendering if it doesn't exist yet."""
    render_bytes = shared_get_quadrant_render(conn, qx, qy)
    if render_bytes:
      return png_bytes_to_image(render_bytes)

    # Need to render
    update_status("rendering", f"Rendering quadrant ({qx}, {qy})...")
    print(f"   üì¶ Rendering quadrant ({qx}, {qy})...")
    render_bytes = render_quadrant(conn, config, qx, qy, port)
    if render_bytes:
      return png_bytes_to_image(render_bytes)
    return None

  def get_generation_from_db(qx: int, qy: int) -> Image.Image | None:
    """Get generation, falling back to render for context quadrants."""
    gen_bytes = shared_get_quadrant_generation(conn, qx, qy)
    if gen_bytes:
      return png_bytes_to_image(gen_bytes)

    # For context quadrants, fall back to render if no generation exists
    # This allows context quadrants to provide surrounding pixel art context
    # even if they only have renders
    if (qx, qy) in context_set:
      render_bytes = shared_get_quadrant_render(conn, qx, qy)
      if render_bytes:
        print(f"   üìã Using render as context for ({qx}, {qy})")
        return png_bytes_to_image(render_bytes)

    return None

  update_status("validating", "Validating quadrant selection...")

  # Validate selection with auto-expansion
  is_valid, msg, placement = validate_quadrant_selection(
    selected_quadrants, has_generation_in_db, allow_expansion=True
  )

  if not is_valid:
    update_status("error", msg)
    return {"success": False, "error": msg}

  print(f"‚úÖ Validation: {msg}")

  # Get primary quadrants (the ones user selected, not padding)
  primary_quadrants = (
    placement.primary_quadrants if placement.primary_quadrants else selected_quadrants
  )
  padding_quadrants = placement.padding_quadrants if placement else []

  if padding_quadrants:
    print(f"   üì¶ Padding quadrants: {padding_quadrants}")

  # Create the infill region (may be expanded)
  if placement._expanded_region is not None:
    region = placement._expanded_region
  else:
    region = InfillRegion.from_quadrants(selected_quadrants)

  # Build the template
  update_status("rendering", "Building template image...")
  builder = TemplateBuilder(
    region, has_generation_in_db, get_render_from_db_with_render, get_generation_from_db
  )

  print("üìã Building template...")
  result = builder.build(border_width=2, allow_expansion=True)

  if result is None:
    error_msg = builder._last_validation_error or "Failed to build template"
    update_status("error", error_msg)
    return {
      "success": False,
      "error": error_msg,
    }

  template_image, placement = result

  # Save template to temp file and upload to GCS
  with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
    template_path = Path(tmp.name)
    template_image.save(template_path)

  try:
    update_status("uploading", "Uploading template to cloud...")
    print(f"üì§ Uploading template to GCS...")
    print(f"   Template path: {template_path}")
    print(f"   Template size: {template_image.size[0]}x{template_image.size[1]}")
    image_url = upload_to_gcs(template_path, bucket_name)
    print(f"   Uploaded URL: {image_url}")

    update_status("generating", "Calling AI model (this may take a minute)...")
    print("ü§ñ Calling Oxen API...")
    generated_url = call_oxen_api(image_url, model_config)

    update_status("saving", "Downloading and saving results...")
    print("üì• Downloading generated image...")
    generated_image = download_image_to_pil(generated_url)

    # Extract quadrants from generated image and save to database
    print("üíæ Saving generated quadrants to database...")

    # Figure out what quadrants are in the infill region
    all_infill_quadrants = (
      placement.all_infill_quadrants
      if placement.all_infill_quadrants
      else region.overlapping_quadrants()
    )

    # For each infill quadrant, extract pixels from the generated image
    saved_count = 0
    for qx, qy in all_infill_quadrants:
      # Calculate position in the generated image
      quad_world_x = qx * QUADRANT_SIZE
      quad_world_y = qy * QUADRANT_SIZE

      template_x = quad_world_x - placement.world_offset_x
      template_y = quad_world_y - placement.world_offset_y

      # Crop this quadrant from the generated image
      crop_box = (
        template_x,
        template_y,
        template_x + QUADRANT_SIZE,
        template_y + QUADRANT_SIZE,
      )
      quad_img = generated_image.crop(crop_box)
      png_bytes = image_to_png_bytes(quad_img)

      # Only save primary quadrants (not padding)
      if (qx, qy) in primary_quadrants or (qx, qy) in [
        (q[0], q[1]) for q in primary_quadrants
      ]:
        if save_quadrant_generation(conn, config, qx, qy, png_bytes):
          print(f"   ‚úì Saved generation for ({qx}, {qy})")
          saved_count += 1
        else:
          print(f"   ‚ö†Ô∏è Failed to save generation for ({qx}, {qy})")
      else:
        print(f"   ‚è≠Ô∏è Skipped padding quadrant ({qx}, {qy})")

    update_status("complete", f"Generated {saved_count} quadrant(s)")
    return {
      "success": True,
      "message": f"Generated {saved_count} quadrant{'s' if saved_count != 1 else ''}",
      "quadrants": list(primary_quadrants),
    }

  finally:
    # Clean up temp file
    template_path.unlink(missing_ok=True)

```

Done! Here's a summary of the logging changes:

**1. Suppressed noisy HTTP request logs** (`app.py`):
- Added a `TileRequestFilter` class that filters out:
  - `/tile/` requests
  - `/static/` requests  
  - `/api/status` polling requests
- Applied this filter to the werkzeug (Flask HTTP) logger

**2. Generation parameters are already logged** (`app.py` lines 1031-1037):

```python
print(f"üéØ Generation request: {selected_quadrants}")
if model_id:
  print(f"   Model: {model_id}")
if context_quadrants:
  print(f"   Context: {context_quadrants}")
```

**3. Added template upload path logging** (`generate_omni.py`):

```python
print("üì§ Uploading template to GCS...")
print(f"   Template path: {template_path}")
print(f"   Template size: {template_image.size[0]}x{template_image.size[1]}")
image_url = upload_to_gcs(template_path, bucket_name)
print(f"   Uploaded URL: {image_url}")
```

Now when you run a generation, you'll see clean logs like:
```
============================================================
üéØ Generation request: [(5, 3)]
   Model: omni-water-v2
   Context: [(4, 3), (5, 2), (4, 2)]
============================================================
üì§ Uploading template to GCS...
   Template path: /var/folders/.../tmpxyz123.png
   Template size: 512x512
   Uploaded URL: https://storage.googleapis.com/...
ü§ñ Calling Oxen API...
```

```python
print(f"üéØ Generation request: {selected_quadrants}")
if model_id:
  print(f"   Model: {model_id}")
if context_quadrants:
  print(f"   Context: {context_quadrants}")
```

```python
print("üì§ Uploading template to GCS...")
print(f"   Template path: {template_path}")
print(f"   Template size: {template_image.size[0]}x{template_image.size[1]}")
image_url = upload_to_gcs(template_path, bucket_name)
print(f"   Uploaded URL: {image_url}")
```

```plaintext
============================================================
üéØ Generation request: [(5, 3)]
   Model: omni-water-v2
   Context: [(4, 3), (5, 2), (4, 2)]
============================================================
üì§ Uploading template to GCS...
   Template path: /var/folders/.../tmpxyz123.png
   Template size: 512x512
   Uploaded URL: https://storage.googleapis.com/...
ü§ñ Calling Oxen API...
```

---

**User**

OK - next remove the "generating" spinner on the generate button, we already know that the app is generating tiles in the rest of the toolbar

---

**Cursor**

I see the spinner logic. Let me remove it from the generate button while keeping it for render (which makes sense since render is a different action):

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show queue count
    if (serverStatus.queue_length > 0) {
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

async function generateSelected() {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context_quadrants = contextQuadrants;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Generation queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update buttons based on state
    const generateBtn = document.getElementById("generateBtn");
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset buttons
      generateBtn.classList.remove("loading");
      generateBtn.innerHTML = "Generate";
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        showToast(
          "info",
          "Processing queue",
          `${status.queue_length} more item(s) in queue...`
        );
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show queue count
    if (serverStatus.queue_length > 0) {
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

async function generateSelected() {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context_quadrants = contextQuadrants;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Generation queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update buttons based on state
    const generateBtn = document.getElementById("generateBtn");
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        showToast(
          "info",
          "Processing queue",
          `${status.queue_length} more item(s) in queue...`
        );
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

Let me also check if the `generateBtn` variable is still needed after this change:

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show queue count
    if (serverStatus.queue_length > 0) {
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

async function generateSelected() {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context_quadrants = contextQuadrants;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Generation queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        showToast(
          "info",
          "Processing queue",
          `${status.queue_length} more item(s) in queue...`
        );
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

Done! Removed the "Generating..." spinner from the generate button. The render button still shows its spinner when rendering is in progress, but the generate button now stays as "Generate" since the generation status is already visible in the toolbar/toasts.

---

**User**

OK - now I'm looking at the tile template that was generated for a 2x2 tile - the empty (render) quadrant is fine, and quadrants (1,0) and (1,1) are also fine, but the quadrant in (0,0) is *the top left corner of the quadrant* - somehow the tile template is not getting constructed correctly - can you figure out what caused this?

---

**Cursor**

Let me look at the template building code to understand how the template is constructed:

```python
# Calculate crop region if quadrant extends outside template
crop_left = max(0, -template_x)
crop_top = max(0, -template_y)
crop_right = min(QUADRANT_SIZE, TEMPLATE_SIZE - template_x)
crop_bottom = min(QUADRANT_SIZE, TEMPLATE_SIZE - template_y)

if crop_left < crop_right and crop_top < crop_bottom:
  cropped = quad_img.crop((crop_left, crop_top, crop_right, crop_bottom))
  paste_x = max(0, template_x)
  paste_y = max(0, template_y)
  template.paste(cropped, (paste_x, paste_y))
```

Let me search for where context_quadrants is handled in the builder initialization:

```plaintext
crop_bottom = min(QUADRANT_SIZE, TEMPLATE_SIZE - template_y)
```

```python
if (qx, qy) in infill_quadrants:  quad_img = self.get_render(qx, qy)
else:  quad_img = self.get_generation(qx, qy)
...# Calculate crop region if quadrant extends outside template
crop_left = max(0, -template_x)crop_top = max(0, -template_y)crop_right = min(QUADRANT_SIZE, TEMPLATE_SIZE - template_x)
crop_bottom = min(QUADRANT_SIZE, TEMPLATE_SIZE - template_y)if crop_left < crop_right and crop_top < crop_bottom:
  cropped = quad_img.crop((crop_left, crop_top, crop_right, crop_bottom))
  paste_x = max(0, template_x)  paste_y = max(0, template_y)
  template.paste(cropped, (paste_x, paste_y)) crop uses QUADRANT_SIZE (512) as the maximum crop size. If quad_img is larger than 512x512, then the crop would only take the top-left 512x512 pixels.BUT, the issue the user is describing is that (0,0) shows "the top left corner of the quadrant" - meaning it's smaller than expected. If the image was too large and got cropped, it would look like a full quadrant but with the WRONG content (content from a different part of the tile).Wait, let me re-read the user's message: "the quadrant in (0,0) is *the top left corner of the quadrant*"


I suspect the generation process might be extracting only a partial view of the intended image. The phrasing suggests the quadrant is not fully rendered, potentially due to an offset or cropping mechanism that's inadvertently capturing just a corner section instead of the complete 512x512 area.

The context quadrants feature could be introducing unexpected behavior, especially if a specific quadrant lacks a stored generation. This might trigger a fallback rendering mechanism that doesn't correctly populate the entire image space.

I'll investigate how the generation retrieval handles missing quadrant data, focusing on the potential gaps in the rendering logic that could result in incomplete image representation.

The frontend's tile classification method seems critical here - its placeholder class determination might not perfectly align with the actual generation state, potentially creating a mismatch between expected and actual image content.

I'm tracking a potential discrepancy in how quadrant generations are identified, with the current logic possibly introducing subtle rendering inconsistencies. The key observation centers on how tile generation status gets communicated between frontend and backend systems.

The investigation suggests examining the precise mechanics of how quadrant generation and rendering get determined, especially around the `has_gen` variable and its relationship to the placeholder class logic.

My current focus is on understanding whether the image storage and generation process might introduce unexpected positioning or identification challenges across different template placements.

I'm carefully examining the crop logic, particularly how boundary calculations determine image extraction. The key insight involves how crop boundaries are mathematically defined relative to template positioning, which could reveal subtle positioning discrepancies.

The crop calculation uses maximum and minimum coordinate constraints, suggesting a precise but potentially complex method of image segment extraction that depends on template coordinates and predefined size constants.

By analyzing specific coordinate scenarios, I'm uncovering nuanced details about how quadrant images might be segmented, with particular attention to how the (0,0) template position interacts with source image boundaries.

The key insight emerges: when `get_generation_from_db` potentially returns a full 1024x1024 tile instead of a 512x512 quadrant, the cropping mechanism reveals unexpected pixel selection behavior. This suggests the source image generation process might produce larger images than initially expected, which could explain the visual discrepancies observed.

The critical next step involves investigating why a full-sized image would be retrieved for what should be a specific quadrant context. I investigate the quadrant generation storage carefully. The save logic clearly crops a precise 512x512 section from the generated image, which suggests the stored generations should be the correct size. However, the possibility remains that prior generations might have been saved incorrectly before the current cropping mechanism was implemented. 

The critical insight is that these context quadrants contain generations from previous runs, predating the new context feature. This historical context could potentially explain any size discrepancies in the stored image data.

I'll need to verify the actual stored generation sizes to confirm whether the existing generations match the expected 512x512 dimensions. I'll calculate quadrant coordinates by multiplying quadrant indices by the standard size, then subtract world offsets to determine precise template positioning. This adjustment aims to correctly map generated image sections into the template space. I'll investigate potential discrepancies in context quadrant placement and template construction, focusing on understanding how world offsets impact image extraction accuracy.

The debug approach involves logging quadrant image sizes during template assembly, which should reveal any unexpected scaling or positioning anomalies. By examining these details, I can pinpoint whether the extraction issue stems from coordinate calculation or template generation logic.
```

Let me add debug logging to understand what's happening with the quadrant sizes:

```python
"""
Generic infill template generation for arbitrary rectangular regions.

This module handles creating template images for infill generation where:
- The infill region is an arbitrary rectangle (up to 50% of tile area)
- Context is maximized by optimal placement within the template
- Edge constraints ensure no seams with generated neighbors

Key concepts:
- InfillRegion: A rectangular region to be filled with generated pixels
- TemplateSpec: Specification for how to build the template
- The template is always 1024x1024 pixels
- Quadrants (512x512) are the storage unit in the database

Usage:
  from isometric_nyc.e2e_generation.infill_template import (
      InfillRegion,
      TemplateBuilder,
  )

  # Create an infill region (e.g., a single quadrant)
  region = InfillRegion.from_quadrant(x=2, y=3)

  # Or create a custom rectangle
  region = InfillRegion(x=256, y=256, width=512, height=512)

  # Build template
  builder = TemplateBuilder(region, get_generation_func)
  template, bounds = builder.build()
"""

from dataclasses import dataclass
from typing import Callable

from PIL import Image, ImageDraw

# Template and quadrant dimensions
TEMPLATE_SIZE = 1024
QUADRANT_SIZE = 512
MAX_INFILL_AREA = TEMPLATE_SIZE * TEMPLATE_SIZE // 2  # 50% of template


@dataclass
class InfillRegion:
  """
  A rectangular region to be infilled.

  Coordinates are in "world" pixel space, where:
  - (0, 0) is the top-left of quadrant (0, 0)
  - x increases to the right
  - y increases downward
  - Each quadrant is 512x512 pixels
  """

  x: int  # World x coordinate (top-left of region)
  y: int  # World y coordinate (top-left of region)
  width: int  # Width in pixels
  height: int  # Height in pixels

  @classmethod
  def from_quadrant(cls, qx: int, qy: int) -> "InfillRegion":
    """Create an infill region for a single quadrant."""
    return cls(
      x=qx * QUADRANT_SIZE,
      y=qy * QUADRANT_SIZE,
      width=QUADRANT_SIZE,
      height=QUADRANT_SIZE,
    )

  @classmethod
  def from_quadrants(cls, quadrants: list[tuple[int, int]]) -> "InfillRegion":
    """
    Create an infill region covering multiple quadrants.

    The quadrants must form a contiguous rectangle.
    """
    if not quadrants:
      raise ValueError("At least one quadrant required")

    min_qx = min(q[0] for q in quadrants)
    max_qx = max(q[0] for q in quadrants)
    min_qy = min(q[1] for q in quadrants)
    max_qy = max(q[1] for q in quadrants)

    return cls(
      x=min_qx * QUADRANT_SIZE,
      y=min_qy * QUADRANT_SIZE,
      width=(max_qx - min_qx + 1) * QUADRANT_SIZE,
      height=(max_qy - min_qy + 1) * QUADRANT_SIZE,
    )

  @property
  def area(self) -> int:
    """Total area in pixels."""
    return self.width * self.height

  @property
  def right(self) -> int:
    """Right edge x coordinate."""
    return self.x + self.width

  @property
  def bottom(self) -> int:
    """Bottom edge y coordinate."""
    return self.y + self.height

  def is_valid_size(self) -> bool:
    """Check if the region is within the allowed size (‚â§50% or exactly 100% of template)."""
    # Allow up to 50% OR exactly 100% (full tile)
    # Full tile is valid only if there are no generated neighbors (checked separately)
    return self.area <= MAX_INFILL_AREA or self.is_full_tile()

  def is_full_tile(self) -> bool:
    """Check if this region is exactly a full tile (1024x1024)."""
    return self.width == TEMPLATE_SIZE and self.height == TEMPLATE_SIZE

  def overlapping_quadrants(self) -> list[tuple[int, int]]:
    """Get list of quadrant (qx, qy) positions that overlap with this region."""
    quadrants = []

    # Find quadrant range
    start_qx = self.x // QUADRANT_SIZE
    end_qx = (self.right - 1) // QUADRANT_SIZE
    start_qy = self.y // QUADRANT_SIZE
    end_qy = (self.bottom - 1) // QUADRANT_SIZE

    for qx in range(start_qx, end_qx + 1):
      for qy in range(start_qy, end_qy + 1):
        quadrants.append((qx, qy))

    return quadrants

  def __str__(self) -> str:
    return f"InfillRegion(x={self.x}, y={self.y}, w={self.width}, h={self.height})"


@dataclass
class TemplatePlacement:
  """
  Describes where to place the infill region within the template.

  The template is always 1024x1024. This specifies:
  - Where the infill region should be placed within it
  - The world coordinate offset for context pixels
  - Which quadrants are primary (user selected) vs padding (auto-expanded)
  """

  # Position of infill region within template (0-1024)
  infill_x: int
  infill_y: int

  # World coordinate of template's top-left corner
  world_offset_x: int
  world_offset_y: int

  @property
  def infill_right(self) -> int:
    return self.infill_x + self._infill_width

  @property
  def infill_bottom(self) -> int:
    return self.infill_y + self._infill_height

  def __post_init__(self):
    # These will be set by the builder
    self._infill_width = 0
    self._infill_height = 0
    # Primary quadrants are the user-selected ones
    # Padding quadrants are auto-added to cover missing context
    self._primary_quadrants: list[tuple[int, int]] = []
    self._padding_quadrants: list[tuple[int, int]] = []
    # The expanded infill region (if different from primary)
    self._expanded_region: InfillRegion | None = None

  @property
  def primary_quadrants(self) -> list[tuple[int, int]]:
    """Quadrants originally selected by user."""
    return self._primary_quadrants

  @property
  def padding_quadrants(self) -> list[tuple[int, int]]:
    """Quadrants auto-added to cover missing context."""
    return self._padding_quadrants

  @property
  def all_infill_quadrants(self) -> list[tuple[int, int]]:
    """All quadrants that will be filled with render pixels."""
    return self._primary_quadrants + self._padding_quadrants

  @property
  def is_expanded(self) -> bool:
    """Whether the infill region was expanded to cover missing context."""
    return len(self._padding_quadrants) > 0


class TemplateBuilder:
  """
  Builds template images for infill generation.

  Handles:
  - Optimal placement of infill region to maximize context
  - Validation of edge constraints
  - Assembly of template from quadrant data
  """

  def __init__(
    self,
    infill_region: InfillRegion,
    has_generation: Callable[[int, int], bool],
    get_render: Callable[[int, int], Image.Image | None] | None = None,
    get_generation: Callable[[int, int], Image.Image | None] | None = None,
  ):
    """
    Initialize the template builder.

    Args:
      infill_region: The region to be infilled
      has_generation: Callable(qx, qy) -> bool to check if quadrant has generation
      get_render: Callable(qx, qy) -> Image to get render for quadrant
      get_generation: Callable(qx, qy) -> Image to get generation for quadrant
    """
    self.region = infill_region
    self.has_generation = has_generation
    self.get_render = get_render
    self.get_generation = get_generation
    self._last_validation_error = ""

    # Validate region size
    if not infill_region.is_valid_size():
      raise ValueError(
        f"Infill region too large: {infill_region.area} pixels (max: {MAX_INFILL_AREA})"
      )

  def find_optimal_placement(
    self, allow_expansion: bool = False
  ) -> TemplatePlacement | None:
    """
    Find the optimal placement for the infill region within the template.

    Args:
      allow_expansion: If True, automatically expand infill region to cover
                       missing context quadrants (they'll be filled with render
                       pixels and discarded after generation)

    Returns None if no valid placement exists (would create seams).

    The strategy:
    1. Try to maximize context by checking generated neighbors
    2. Position infill to include as much context as possible
    3. Validate that edges touching template boundary have no generated neighbors
    4. If placement has missing context, try alternative placements
    5. If allow_expansion and context quadrants are still missing, expand the infill
    """
    # Try multiple placement strategies
    # Strategy 1: Maximize context (original approach)
    # Strategy 2+: Exclude problematic sides that would pull in non-generated quadrants

    placement = self._try_placement_with_context_preferences(
      include_left=True,
      include_right=True,
      include_top=True,
      include_bottom=True,
    )

    if placement is not None:
      missing = self._find_missing_context_quadrants(placement)
      if not missing:
        return placement

      # There are missing context quadrants - try alternative placements
      # that exclude the sides causing the problem
      alternative = self._try_alternative_placements(missing, allow_expansion)
      if alternative is not None:
        return alternative

      # All alternatives failed, try expansion on the original placement
      if allow_expansion:
        expanded_placement = self._expand_to_cover_missing(placement, missing)
        if expanded_placement is not None:
          return expanded_placement

      # Everything failed
      missing_str = ", ".join(f"({qx}, {qy})" for qx, qy in missing)
      self._last_validation_error = (
        f"Context quadrants missing generations: {missing_str}"
      )
      return None

    return placement

  def _try_placement_with_context_preferences(
    self,
    include_left: bool,
    include_right: bool,
    include_top: bool,
    include_bottom: bool,
  ) -> TemplatePlacement | None:
    """
    Try to find a valid placement with given context preferences.

    Args:
      include_left: Whether to try to include left context
      include_right: Whether to try to include right context
      include_top: Whether to try to include top context
      include_bottom: Whether to try to include bottom context

    Returns:
      TemplatePlacement if valid (passes seam check), None otherwise
    """
    # Calculate available margin on each side
    margin_x = TEMPLATE_SIZE - self.region.width
    margin_y = TEMPLATE_SIZE - self.region.height

    # Check for generated context on each side of the infill region
    has_left_gen = self._has_generated_context("left") if include_left else False
    has_right_gen = self._has_generated_context("right") if include_right else False
    has_top_gen = self._has_generated_context("top") if include_top else False
    has_bottom_gen = self._has_generated_context("bottom") if include_bottom else False

    # Determine infill position based on context preferences
    # Horizontal positioning
    if has_left_gen and has_right_gen:
      infill_x = margin_x // 2
    elif has_left_gen:
      infill_x = margin_x
    elif has_right_gen:
      infill_x = 0
    else:
      # No horizontal context to include - position to avoid seams
      # If we're NOT including left but there IS generated content on left,
      # push infill to include right side (avoid left seam)
      actual_left_gen = self._has_generated_context("left")
      actual_right_gen = self._has_generated_context("right")
      if actual_right_gen and not actual_left_gen:
        infill_x = 0
      elif actual_left_gen and not actual_right_gen:
        infill_x = margin_x
      else:
        infill_x = 0

    # Vertical positioning
    if has_top_gen and has_bottom_gen:
      infill_y = margin_y // 2
    elif has_top_gen:
      infill_y = margin_y
    elif has_bottom_gen:
      infill_y = 0
    else:
      # No vertical context to include - position to avoid seams
      actual_top_gen = self._has_generated_context("top")
      actual_bottom_gen = self._has_generated_context("bottom")
      if actual_bottom_gen and not actual_top_gen:
        infill_y = 0
      elif actual_top_gen and not actual_bottom_gen:
        infill_y = margin_y
      else:
        infill_y = 0

    # Calculate world offset
    world_offset_x = self.region.x - infill_x
    world_offset_y = self.region.y - infill_y

    placement = TemplatePlacement(
      infill_x=infill_x,
      infill_y=infill_y,
      world_offset_x=world_offset_x,
      world_offset_y=world_offset_y,
    )
    placement._infill_width = self.region.width
    placement._infill_height = self.region.height

    # Validate the placement (seams check)
    is_valid, error = self._validate_placement_seams(placement)
    if not is_valid:
      self._last_validation_error = error
      return None

    return placement

  def _try_alternative_placements(
    self,
    missing: list[tuple[int, int]],
    allow_expansion: bool,
  ) -> TemplatePlacement | None:
    """
    Try alternative placements that avoid missing context quadrants.

    When the optimal placement would include non-generated context quadrants,
    we try placements that exclude certain sides to avoid those quadrants.
    """
    # Determine which sides are causing problems
    # Missing quadrants are in certain positions relative to the infill
    infill_quadrants = set(self.region.overlapping_quadrants())
    infill_min_qx = min(q[0] for q in infill_quadrants)
    infill_max_qx = max(q[0] for q in infill_quadrants)
    infill_min_qy = min(q[1] for q in infill_quadrants)
    infill_max_qy = max(q[1] for q in infill_quadrants)

    problem_sides = set()
    for qx, qy in missing:
      if qx < infill_min_qx:
        problem_sides.add("left")
      if qx > infill_max_qx:
        problem_sides.add("right")
      if qy < infill_min_qy:
        problem_sides.add("top")
      if qy > infill_max_qy:
        problem_sides.add("bottom")

    # Try placements that exclude problem sides
    # Generate combinations of sides to exclude
    side_combinations = []

    # First, try excluding just the problem sides
    if problem_sides:
      side_combinations.append(problem_sides)

    # Then try excluding individual problem sides
    for side in problem_sides:
      side_combinations.append({side})

    # Try each combination
    for exclude_sides in side_combinations:
      placement = self._try_placement_with_context_preferences(
        include_left="left" not in exclude_sides,
        include_right="right" not in exclude_sides,
        include_top="top" not in exclude_sides,
        include_bottom="bottom" not in exclude_sides,
      )

      if placement is None:
        continue

      # Check if this placement has any missing context quadrants
      new_missing = self._find_missing_context_quadrants(placement)

      if not new_missing:
        # Found a valid placement!
        return placement

      # If allow_expansion and fewer missing quadrants, try expansion
      if allow_expansion and len(new_missing) < len(missing):
        expanded = self._expand_to_cover_missing(placement, new_missing)
        if expanded is not None:
          return expanded

    # Last resort: try placements that sacrifice context to avoid missing quadrants
    # This may create seams but is better than not being able to generate at all
    best_placement = self._try_seam_tolerant_placement(problem_sides)
    if best_placement is not None:
      return best_placement

    return None

  def _try_seam_tolerant_placement(
    self, problem_sides: set[str]
  ) -> TemplatePlacement | None:
    """
    Try to find a placement that avoids missing context quadrants,
    even if it might create seams with generated neighbors.

    This is a last resort when no seam-free placement exists.
    """
    margin_x = TEMPLATE_SIZE - self.region.width
    margin_y = TEMPLATE_SIZE - self.region.height

    # Determine which sides have generated content
    has_left_gen = self._has_generated_context("left")
    has_right_gen = self._has_generated_context("right")
    has_top_gen = self._has_generated_context("top")
    has_bottom_gen = self._has_generated_context("bottom")

    # For each problem side, we want to position to EXCLUDE that side's context
    # even if it means creating a seam

    # Try different positions that avoid problem sides
    positions_to_try = []

    # If left is problematic, push infill to left (exclude left context)
    if "left" in problem_sides:
      # Position infill at left, include right context if available
      infill_x = 0
      if has_top_gen and "top" not in problem_sides:
        infill_y = margin_y  # Include top
      elif has_bottom_gen and "bottom" not in problem_sides:
        infill_y = 0  # Include bottom
      else:
        infill_y = 0
      positions_to_try.append((infill_x, infill_y))

    # If right is problematic, push infill to right (exclude right context)
    if "right" in problem_sides:
      infill_x = margin_x
      if has_top_gen and "top" not in problem_sides:
        infill_y = margin_y
      elif has_bottom_gen and "bottom" not in problem_sides:
        infill_y = 0
      else:
        infill_y = 0
      positions_to_try.append((infill_x, infill_y))

    # If top is problematic, push infill to top (exclude top context)
    if "top" in problem_sides:
      infill_y = 0
      if has_right_gen and "right" not in problem_sides:
        infill_x = 0  # Include right
      elif has_left_gen and "left" not in problem_sides:
        infill_x = margin_x  # Include left
      else:
        infill_x = 0
      positions_to_try.append((infill_x, infill_y))

    # If bottom is problematic, push infill to bottom
    if "bottom" in problem_sides:
      infill_y = margin_y
      if has_right_gen and "right" not in problem_sides:
        infill_x = 0
      elif has_left_gen and "left" not in problem_sides:
        infill_x = margin_x
      else:
        infill_x = 0
      positions_to_try.append((infill_x, infill_y))

    # Also try all four corners to maximize options
    corners = [
      (0, 0),  # Top-left
      (margin_x, 0),  # Top-right
      (0, margin_y),  # Bottom-left
      (margin_x, margin_y),  # Bottom-right
    ]
    positions_to_try.extend(corners)

    # Try each position
    for infill_x, infill_y in positions_to_try:
      world_offset_x = self.region.x - infill_x
      world_offset_y = self.region.y - infill_y

      placement = TemplatePlacement(
        infill_x=infill_x,
        infill_y=infill_y,
        world_offset_x=world_offset_x,
        world_offset_y=world_offset_y,
      )
      placement._infill_width = self.region.width
      placement._infill_height = self.region.height

      # Check for missing context quadrants (skip seam check)
      missing = self._find_missing_context_quadrants(placement)

      if not missing:
        # Found a valid placement (may have seams but no missing context)
        return placement

    return None

  def _has_generated_context(self, side: str) -> bool:
    """Check if there are generated pixels adjacent to the infill region on the given side."""
    # Note: Python's // does floor division, so negative coords work correctly
    # e.g., -1 // 512 = -1, -512 // 512 = -1, -513 // 512 = -2

    if side == "left":
      # Check quadrants to the left of the region
      check_x = self.region.x - 1
      qx = check_x // QUADRANT_SIZE
      # Check all quadrants along the left edge
      start_qy = self.region.y // QUADRANT_SIZE
      end_qy = (self.region.bottom - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qy in range(start_qy, end_qy + 1))

    elif side == "right":
      check_x = self.region.right
      qx = check_x // QUADRANT_SIZE
      start_qy = self.region.y // QUADRANT_SIZE
      end_qy = (self.region.bottom - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qy in range(start_qy, end_qy + 1))

    elif side == "top":
      check_y = self.region.y - 1
      qy = check_y // QUADRANT_SIZE
      start_qx = self.region.x // QUADRANT_SIZE
      end_qx = (self.region.right - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qx in range(start_qx, end_qx + 1))

    elif side == "bottom":
      check_y = self.region.bottom
      qy = check_y // QUADRANT_SIZE
      start_qx = self.region.x // QUADRANT_SIZE
      end_qx = (self.region.right - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qx in range(start_qx, end_qx + 1))

    return False

  def _validate_placement_seams(self, placement: TemplatePlacement) -> tuple[bool, str]:
    """
    Validate that a placement doesn't create seams.

    A seam would occur if the infill region touches the template edge
    AND there are generated pixels beyond that edge.

    Returns:
      Tuple of (is_valid, error_message)
    """
    # Check left edge
    if placement.infill_x == 0:
      if self._has_generated_context("left"):
        return False, "Would create seam with generated pixels on left"

    # Check right edge
    if placement.infill_x + self.region.width == TEMPLATE_SIZE:
      if self._has_generated_context("right"):
        return False, "Would create seam with generated pixels on right"

    # Check top edge
    if placement.infill_y == 0:
      if self._has_generated_context("top"):
        return False, "Would create seam with generated pixels on top"

    # Check bottom edge
    if placement.infill_y + self.region.height == TEMPLATE_SIZE:
      if self._has_generated_context("bottom"):
        return False, "Would create seam with generated pixels on bottom"

    return True, ""

  def _find_missing_context_quadrants(
    self, placement: TemplatePlacement
  ) -> list[tuple[int, int]]:
    """
    Find context quadrants that don't have generated pixels.

    Returns list of (qx, qy) positions that are in the template but not
    in the infill region and don't have generations.
    """
    missing = []

    # Calculate which quadrants the template covers
    template_world_left = placement.world_offset_x
    template_world_right = placement.world_offset_x + TEMPLATE_SIZE
    template_world_top = placement.world_offset_y
    template_world_bottom = placement.world_offset_y + TEMPLATE_SIZE

    start_qx = template_world_left // QUADRANT_SIZE
    end_qx = (template_world_right - 1) // QUADRANT_SIZE
    start_qy = template_world_top // QUADRANT_SIZE
    end_qy = (template_world_bottom - 1) // QUADRANT_SIZE

    # Infill quadrants
    infill_quadrants = set(self.region.overlapping_quadrants())

    for qx in range(start_qx, end_qx + 1):
      for qy in range(start_qy, end_qy + 1):
        if (qx, qy) not in infill_quadrants:
          # This is a context quadrant - must have generation
          if not self.has_generation(qx, qy):
            missing.append((qx, qy))

    return missing

  def _expand_to_cover_missing(
    self,
    placement: TemplatePlacement,
    missing: list[tuple[int, int]],
  ) -> TemplatePlacement | None:
    """
    Try to expand the infill region to cover missing context quadrants.

    The expanded region must still fit within the template and not exceed
    the maximum allowed size.

    Returns:
      New TemplatePlacement with expanded infill, or None if expansion not possible
    """
    # Get current infill quadrants
    primary_quadrants = self.region.overlapping_quadrants()

    # Combine primary and missing to get all quadrants we need to cover
    all_quadrants = set(primary_quadrants + missing)

    # Find bounds of expanded region
    min_qx = min(q[0] for q in all_quadrants)
    max_qx = max(q[0] for q in all_quadrants)
    min_qy = min(q[1] for q in all_quadrants)
    max_qy = max(q[1] for q in all_quadrants)

    # Create expanded region
    expanded_region = InfillRegion(
      x=min_qx * QUADRANT_SIZE,
      y=min_qy * QUADRANT_SIZE,
      width=(max_qx - min_qx + 1) * QUADRANT_SIZE,
      height=(max_qy - min_qy + 1) * QUADRANT_SIZE,
    )

    # Check if expanded region is valid size
    if not expanded_region.is_valid_size():
      self._last_validation_error = (
        f"Cannot expand infill to cover missing quadrants: "
        f"expanded region would be {expanded_region.area} pixels "
        f"(max: {MAX_INFILL_AREA})"
      )
      return None

    # Create a new builder for the expanded region to find its placement
    expanded_builder = TemplateBuilder(expanded_region, self.has_generation)
    expanded_placement = expanded_builder.find_optimal_placement(allow_expansion=False)

    if expanded_placement is None:
      self._last_validation_error = expanded_builder._last_validation_error
      return None

    # Track primary vs padding quadrants
    expanded_placement._primary_quadrants = list(primary_quadrants)
    expanded_placement._padding_quadrants = list(missing)
    expanded_placement._expanded_region = expanded_region

    return expanded_placement

  def build(
    self,
    border_width: int = 2,
    allow_expansion: bool = False,
  ) -> tuple[Image.Image, TemplatePlacement] | None:
    """
    Build the template image.

    Args:
      border_width: Width of the red border around the infill region
      allow_expansion: If True, automatically expand infill region to cover
                       missing context quadrants

    Returns:
      Tuple of (template_image, placement) or None if no valid placement exists
    """
    if self.get_render is None or self.get_generation is None:
      raise ValueError("get_render and get_generation must be provided to build")

    placement = self.find_optimal_placement(allow_expansion=allow_expansion)
    if placement is None:
      return None

    # Determine the effective infill region (may be expanded)
    if placement._expanded_region is not None:
      effective_region = placement._expanded_region
    else:
      effective_region = self.region

    # Create template image
    template = Image.new("RGBA", (TEMPLATE_SIZE, TEMPLATE_SIZE), (0, 0, 0, 0))

    # Determine which quadrants we need to fetch
    # The template covers world coordinates:
    #   x: [world_offset_x, world_offset_x + 1024)
    #   y: [world_offset_y, world_offset_y + 1024)

    template_world_left = placement.world_offset_x
    template_world_right = placement.world_offset_x + TEMPLATE_SIZE
    template_world_top = placement.world_offset_y
    template_world_bottom = placement.world_offset_y + TEMPLATE_SIZE

    # Find all quadrants that overlap with the template
    start_qx = template_world_left // QUADRANT_SIZE
    end_qx = (template_world_right - 1) // QUADRANT_SIZE
    start_qy = template_world_top // QUADRANT_SIZE
    end_qy = (template_world_bottom - 1) // QUADRANT_SIZE

    # Infill quadrants (will use render) - use effective region for expanded infills
    infill_quadrants = set(effective_region.overlapping_quadrants())

    # Fill in the template
    for qx in range(start_qx, end_qx + 1):
      for qy in range(start_qy, end_qy + 1):
        # Calculate where this quadrant appears in the template
        quad_world_x = qx * QUADRANT_SIZE
        quad_world_y = qy * QUADRANT_SIZE

        # Position in template coordinates
        template_x = quad_world_x - template_world_left
        template_y = quad_world_y - template_world_top

        # Determine source image
        if (qx, qy) in infill_quadrants:
          # Use render for infill quadrants
          quad_img = self.get_render(qx, qy)
          source_type = "render"
          if quad_img is None:
            continue
        else:
          # Use generation for context quadrants
          quad_img = self.get_generation(qx, qy)
          source_type = "generation"
          if quad_img is None:
            continue

        # Debug: Log quadrant image size
        print(
          f"   üì¶ Quadrant ({qx}, {qy}) [{source_type}]: "
          f"size={quad_img.size}, template_pos=({template_x}, {template_y})"
        )

        if quad_img.mode != "RGBA":
          quad_img = quad_img.convert("RGBA")

        # Calculate crop region if quadrant extends outside template
        crop_left = max(0, -template_x)
        crop_top = max(0, -template_y)
        crop_right = min(QUADRANT_SIZE, TEMPLATE_SIZE - template_x)
        crop_bottom = min(QUADRANT_SIZE, TEMPLATE_SIZE - template_y)

        if crop_left < crop_right and crop_top < crop_bottom:
          cropped = quad_img.crop((crop_left, crop_top, crop_right, crop_bottom))
          paste_x = max(0, template_x)
          paste_y = max(0, template_y)
          template.paste(cropped, (paste_x, paste_y))

    # Now we need to handle partial quadrant overlaps with the infill region
    # If the infill region doesn't align with quadrant boundaries,
    # we need to carefully composite render pixels only in the infill area
    self._apply_infill_mask(template, placement)

    # Draw red border around infill region
    template = self._draw_border(template, placement, border_width)

    return template, placement

  def _apply_infill_mask(
    self, template: Image.Image, placement: TemplatePlacement
  ) -> None:
    """
    Apply a mask to ensure only the infill region has render pixels.

    For quadrants that partially overlap the infill region, we need to
    composite render pixels (infill area) with generation pixels (context area).
    """
    # This is already handled by the quadrant-based approach when infill aligns
    # with quadrant boundaries. For non-aligned infills, we'd need more complex
    # masking. For now, we assume quadrant-aligned infills.
    pass

  def _draw_border(
    self,
    template: Image.Image,
    placement: TemplatePlacement,
    border_width: int,
  ) -> Image.Image:
    """Draw a red border around the infill region."""
    result = template.copy()
    draw = ImageDraw.Draw(result)

    red = (255, 0, 0, 255)

    left = placement.infill_x
    top = placement.infill_y
    right = placement.infill_x + self.region.width
    bottom = placement.infill_y + self.region.height

    for i in range(border_width):
      draw.rectangle(
        [left + i, top + i, right - 1 - i, bottom - 1 - i],
        outline=red,
        fill=None,
      )

    return result

  def get_validation_info(self) -> dict:
    """Get detailed validation information for debugging."""
    return {
      "region": str(self.region),
      "area": self.region.area,
      "max_area": MAX_INFILL_AREA,
      "valid_size": self.region.is_valid_size(),
      "has_left_gen": self._has_generated_context("left"),
      "has_right_gen": self._has_generated_context("right"),
      "has_top_gen": self._has_generated_context("top"),
      "has_bottom_gen": self._has_generated_context("bottom"),
      "overlapping_quadrants": self.region.overlapping_quadrants(),
      "last_validation_error": self._last_validation_error,
    }


def validate_quadrant_selection(
  quadrants: list[tuple[int, int]],
  has_generation: Callable[[int, int], bool],
  allow_expansion: bool = False,
) -> tuple[bool, str, TemplatePlacement | None]:
  """
  Validate a quadrant selection and find optimal placement.

  This is a convenience function for the common case of selecting
  whole quadrants for infill.

  Special handling for full tiles (2x2):
  - If some quadrants already have generations, reduce to just the missing ones
  - The generated quadrants become context for the missing ones

  Args:
    quadrants: List of (qx, qy) quadrant positions to infill
    has_generation: Callable to check if a quadrant has generation
    allow_expansion: If True, automatically expand infill region to cover
                     missing context quadrants (they'll be filled with render
                     pixels and discarded after generation)

  Returns:
    Tuple of (is_valid, message, placement)
  """
  if not quadrants:
    return False, "No quadrants selected", None

  # Check that quadrants form a rectangle
  min_qx = min(q[0] for q in quadrants)
  max_qx = max(q[0] for q in quadrants)
  min_qy = min(q[1] for q in quadrants)
  max_qy = max(q[1] for q in quadrants)

  expected_count = (max_qx - min_qx + 1) * (max_qy - min_qy + 1)
  if len(quadrants) != expected_count:
    return False, "Quadrants must form a contiguous rectangle", None

  # Check all expected positions are present
  expected = set()
  for qx in range(min_qx, max_qx + 1):
    for qy in range(min_qy, max_qy + 1):
      expected.add((qx, qy))

  if set(quadrants) != expected:
    return False, "Quadrants must form a contiguous rectangle", None

  # Create infill region and builder
  region = InfillRegion.from_quadrants(quadrants)

  if not region.is_valid_size():
    return (
      False,
      f"Selection too large: {region.area} pixels (max: {MAX_INFILL_AREA} or full tile)",
      None,
    )

  # For full tiles (2x2), check if some quadrants are already generated
  # If so, reduce the selection to just the non-generated quadrants
  if region.is_full_tile():
    # Check which quadrants already have generations
    generated_quadrants = [q for q in quadrants if has_generation(q[0], q[1])]
    non_generated_quadrants = [q for q in quadrants if not has_generation(q[0], q[1])]

    if len(generated_quadrants) == 4:
      # All quadrants already generated - nothing to do
      return False, "All quadrants already have generations", None

    if len(generated_quadrants) > 0:
      # Some quadrants are generated - reduce selection to just the missing ones
      # The generated quadrants will serve as context
      print(
        f"   üìã {len(generated_quadrants)} of 4 quadrants already generated, "
        f"will generate remaining {len(non_generated_quadrants)}"
      )

      # Recursively validate the reduced selection
      return validate_quadrant_selection(
        non_generated_quadrants, has_generation, allow_expansion
      )

    # No quadrants generated yet - check for external neighbors
    has_any_gen_neighbor = False
    for qx, qy in quadrants:
      # Check all 4 sides of each edge quadrant
      if qx == min(q[0] for q in quadrants):  # Left edge
        if has_generation(qx - 1, qy):
          has_any_gen_neighbor = True
          break
      if qx == max(q[0] for q in quadrants):  # Right edge
        if has_generation(qx + 1, qy):
          has_any_gen_neighbor = True
          break
      if qy == min(q[1] for q in quadrants):  # Top edge
        if has_generation(qx, qy - 1):
          has_any_gen_neighbor = True
          break
      if qy == max(q[1] for q in quadrants):  # Bottom edge
        if has_generation(qx, qy + 1):
          has_any_gen_neighbor = True
          break

    if has_any_gen_neighbor:
      return (
        False,
        "Full tile (2x2) selection cannot have generated neighbors (would create seams)",
        None,
      )

    # Full tile with no neighbors - valid, place at origin
    placement = TemplatePlacement(
      infill_x=0,
      infill_y=0,
      world_offset_x=region.x,
      world_offset_y=region.y,
    )
    placement._infill_width = region.width
    placement._infill_height = region.height
    placement._primary_quadrants = list(quadrants)
    return True, "Valid selection (full tile)", placement

  builder = TemplateBuilder(region, has_generation)
  placement = builder.find_optimal_placement(allow_expansion=allow_expansion)

  if placement is None:
    # Use the specific error from the builder if available
    info = builder.get_validation_info()
    if info["last_validation_error"]:
      return False, info["last_validation_error"], None
    # Fallback to generic messages
    if info["has_left_gen"]:
      return False, "Would create seam with generated pixels on left", None
    if info["has_right_gen"]:
      return False, "Would create seam with generated pixels on right", None
    if info["has_top_gen"]:
      return False, "Would create seam with generated pixels on top", None
    if info["has_bottom_gen"]:
      return False, "Would create seam with generated pixels on bottom", None
    return False, "No valid placement found", None

  # Set primary quadrants if not already set (by expansion)
  if not placement._primary_quadrants:
    placement._primary_quadrants = list(quadrants)

  # Build appropriate message
  if placement.is_expanded:
    padding_str = ", ".join(f"({qx}, {qy})" for qx, qy in placement._padding_quadrants)
    return True, f"Valid selection (expanded to cover: {padding_str})", placement

  return True, "Valid selection", placement


# =============================================================================
# Testing
# =============================================================================


def _test_basic():
  """Run basic tests."""
  print("=" * 60)
  print("Testing InfillRegion")
  print("=" * 60)

  # Test single quadrant
  r1 = InfillRegion.from_quadrant(0, 0)
  print(f"\nSingle quadrant (0,0): {r1}")
  print(f"  Area: {r1.area} (valid: {r1.is_valid_size()})")
  print(f"  Overlapping quadrants: {r1.overlapping_quadrants()}")

  # Test 2x1 quadrants
  r2 = InfillRegion.from_quadrants([(0, 0), (1, 0)])
  print(f"\n2x1 quadrants: {r2}")
  print(f"  Area: {r2.area} (valid: {r2.is_valid_size()})")
  print(f"  Overlapping quadrants: {r2.overlapping_quadrants()}")

  # Test 2x2 quadrants (should be invalid - 100% of tile)
  r3 = InfillRegion.from_quadrants([(0, 0), (1, 0), (0, 1), (1, 1)])
  print(f"\n2x2 quadrants: {r3}")
  print(f"  Area: {r3.area} (valid: {r3.is_valid_size()})")

  print("\n" + "=" * 60)
  print("Testing TemplateBuilder")
  print("=" * 60)

  # Create a mock has_generation function
  # Simulate: quadrants (0,0) and (1,0) are NOT generated, (0,1) and (1,1) ARE generated
  generated = {(0, 1), (1, 1), (2, 0), (2, 1)}

  def has_gen(qx, qy):
    return (qx, qy) in generated

  # Test 1: Select quadrant (1, 0) with generated neighbor below
  region = InfillRegion.from_quadrant(1, 0)
  builder = TemplateBuilder(region, has_gen)
  info = builder.get_validation_info()
  placement = builder.find_optimal_placement()

  print("\nTest 1: Select quadrant (1, 0)")
  print(f"  Info: {info}")
  print(f"  Placement: {placement}")
  if placement:
    print(f"    Infill at: ({placement.infill_x}, {placement.infill_y})")
    print(f"    World offset: ({placement.world_offset_x}, {placement.world_offset_y})")

  # Test 2: Select quadrant (0, 1) surrounded by generated
  region2 = InfillRegion.from_quadrant(0, 1)
  builder2 = TemplateBuilder(region2, has_gen)
  info2 = builder2.get_validation_info()
  placement2 = builder2.find_optimal_placement()

  print("\nTest 2: Select quadrant (0, 1) - has generated neighbor to right")
  print(f"  Info: {info2}")
  print(f"  Placement: {placement2}")
  if placement2:
    print(f"    Infill at: ({placement2.infill_x}, {placement2.infill_y})")

  # Test 3: Validation convenience function
  print("\n" + "=" * 60)
  print("Testing validate_quadrant_selection")
  print("=" * 60)

  # Valid selection
  valid, msg, p = validate_quadrant_selection([(1, 0)], has_gen)
  print(f"\nSelect (1,0): valid={valid}, msg='{msg}'")

  # Invalid - non-contiguous
  valid, msg, p = validate_quadrant_selection([(0, 0), (1, 1)], has_gen)
  print(f"Select (0,0), (1,1) [diagonal]: valid={valid}, msg='{msg}'")

  # Valid 2x1
  valid, msg, p = validate_quadrant_selection([(0, 0), (1, 0)], has_gen)
  print(f"Select (0,0), (1,0) [2x1]: valid={valid}, msg='{msg}'")

  print("\n" + "=" * 60)
  print("All tests complete!")
  print("=" * 60)


if __name__ == "__main__":
  _test_basic()

```

```python
"""
Generic infill template generation for arbitrary rectangular regions.

This module handles creating template images for infill generation where:
- The infill region is an arbitrary rectangle (up to 50% of tile area)
- Context is maximized by optimal placement within the template
- Edge constraints ensure no seams with generated neighbors

Key concepts:
- InfillRegion: A rectangular region to be filled with generated pixels
- TemplateSpec: Specification for how to build the template
- The template is always 1024x1024 pixels
- Quadrants (512x512) are the storage unit in the database

Usage:
  from isometric_nyc.e2e_generation.infill_template import (
      InfillRegion,
      TemplateBuilder,
  )

  # Create an infill region (e.g., a single quadrant)
  region = InfillRegion.from_quadrant(x=2, y=3)

  # Or create a custom rectangle
  region = InfillRegion(x=256, y=256, width=512, height=512)

  # Build template
  builder = TemplateBuilder(region, get_generation_func)
  template, bounds = builder.build()
"""

from dataclasses import dataclass
from typing import Callable

from PIL import Image, ImageDraw

# Template and quadrant dimensions
TEMPLATE_SIZE = 1024
QUADRANT_SIZE = 512
MAX_INFILL_AREA = TEMPLATE_SIZE * TEMPLATE_SIZE // 2  # 50% of template


@dataclass
class InfillRegion:
  """
  A rectangular region to be infilled.

  Coordinates are in "world" pixel space, where:
  - (0, 0) is the top-left of quadrant (0, 0)
  - x increases to the right
  - y increases downward
  - Each quadrant is 512x512 pixels
  """

  x: int  # World x coordinate (top-left of region)
  y: int  # World y coordinate (top-left of region)
  width: int  # Width in pixels
  height: int  # Height in pixels

  @classmethod
  def from_quadrant(cls, qx: int, qy: int) -> "InfillRegion":
    """Create an infill region for a single quadrant."""
    return cls(
      x=qx * QUADRANT_SIZE,
      y=qy * QUADRANT_SIZE,
      width=QUADRANT_SIZE,
      height=QUADRANT_SIZE,
    )

  @classmethod
  def from_quadrants(cls, quadrants: list[tuple[int, int]]) -> "InfillRegion":
    """
    Create an infill region covering multiple quadrants.

    The quadrants must form a contiguous rectangle.
    """
    if not quadrants:
      raise ValueError("At least one quadrant required")

    min_qx = min(q[0] for q in quadrants)
    max_qx = max(q[0] for q in quadrants)
    min_qy = min(q[1] for q in quadrants)
    max_qy = max(q[1] for q in quadrants)

    return cls(
      x=min_qx * QUADRANT_SIZE,
      y=min_qy * QUADRANT_SIZE,
      width=(max_qx - min_qx + 1) * QUADRANT_SIZE,
      height=(max_qy - min_qy + 1) * QUADRANT_SIZE,
    )

  @property
  def area(self) -> int:
    """Total area in pixels."""
    return self.width * self.height

  @property
  def right(self) -> int:
    """Right edge x coordinate."""
    return self.x + self.width

  @property
  def bottom(self) -> int:
    """Bottom edge y coordinate."""
    return self.y + self.height

  def is_valid_size(self) -> bool:
    """Check if the region is within the allowed size (‚â§50% or exactly 100% of template)."""
    # Allow up to 50% OR exactly 100% (full tile)
    # Full tile is valid only if there are no generated neighbors (checked separately)
    return self.area <= MAX_INFILL_AREA or self.is_full_tile()

  def is_full_tile(self) -> bool:
    """Check if this region is exactly a full tile (1024x1024)."""
    return self.width == TEMPLATE_SIZE and self.height == TEMPLATE_SIZE

  def overlapping_quadrants(self) -> list[tuple[int, int]]:
    """Get list of quadrant (qx, qy) positions that overlap with this region."""
    quadrants = []

    # Find quadrant range
    start_qx = self.x // QUADRANT_SIZE
    end_qx = (self.right - 1) // QUADRANT_SIZE
    start_qy = self.y // QUADRANT_SIZE
    end_qy = (self.bottom - 1) // QUADRANT_SIZE

    for qx in range(start_qx, end_qx + 1):
      for qy in range(start_qy, end_qy + 1):
        quadrants.append((qx, qy))

    return quadrants

  def __str__(self) -> str:
    return f"InfillRegion(x={self.x}, y={self.y}, w={self.width}, h={self.height})"


@dataclass
class TemplatePlacement:
  """
  Describes where to place the infill region within the template.

  The template is always 1024x1024. This specifies:
  - Where the infill region should be placed within it
  - The world coordinate offset for context pixels
  - Which quadrants are primary (user selected) vs padding (auto-expanded)
  """

  # Position of infill region within template (0-1024)
  infill_x: int
  infill_y: int

  # World coordinate of template's top-left corner
  world_offset_x: int
  world_offset_y: int

  @property
  def infill_right(self) -> int:
    return self.infill_x + self._infill_width

  @property
  def infill_bottom(self) -> int:
    return self.infill_y + self._infill_height

  def __post_init__(self):
    # These will be set by the builder
    self._infill_width = 0
    self._infill_height = 0
    # Primary quadrants are the user-selected ones
    # Padding quadrants are auto-added to cover missing context
    self._primary_quadrants: list[tuple[int, int]] = []
    self._padding_quadrants: list[tuple[int, int]] = []
    # The expanded infill region (if different from primary)
    self._expanded_region: InfillRegion | None = None

  @property
  def primary_quadrants(self) -> list[tuple[int, int]]:
    """Quadrants originally selected by user."""
    return self._primary_quadrants

  @property
  def padding_quadrants(self) -> list[tuple[int, int]]:
    """Quadrants auto-added to cover missing context."""
    return self._padding_quadrants

  @property
  def all_infill_quadrants(self) -> list[tuple[int, int]]:
    """All quadrants that will be filled with render pixels."""
    return self._primary_quadrants + self._padding_quadrants

  @property
  def is_expanded(self) -> bool:
    """Whether the infill region was expanded to cover missing context."""
    return len(self._padding_quadrants) > 0


class TemplateBuilder:
  """
  Builds template images for infill generation.

  Handles:
  - Optimal placement of infill region to maximize context
  - Validation of edge constraints
  - Assembly of template from quadrant data
  """

  def __init__(
    self,
    infill_region: InfillRegion,
    has_generation: Callable[[int, int], bool],
    get_render: Callable[[int, int], Image.Image | None] | None = None,
    get_generation: Callable[[int, int], Image.Image | None] | None = None,
  ):
    """
    Initialize the template builder.

    Args:
      infill_region: The region to be infilled
      has_generation: Callable(qx, qy) -> bool to check if quadrant has generation
      get_render: Callable(qx, qy) -> Image to get render for quadrant
      get_generation: Callable(qx, qy) -> Image to get generation for quadrant
    """
    self.region = infill_region
    self.has_generation = has_generation
    self.get_render = get_render
    self.get_generation = get_generation
    self._last_validation_error = ""

    # Validate region size
    if not infill_region.is_valid_size():
      raise ValueError(
        f"Infill region too large: {infill_region.area} pixels (max: {MAX_INFILL_AREA})"
      )

  def find_optimal_placement(
    self, allow_expansion: bool = False
  ) -> TemplatePlacement | None:
    """
    Find the optimal placement for the infill region within the template.

    Args:
      allow_expansion: If True, automatically expand infill region to cover
                       missing context quadrants (they'll be filled with render
                       pixels and discarded after generation)

    Returns None if no valid placement exists (would create seams).

    The strategy:
    1. Try to maximize context by checking generated neighbors
    2. Position infill to include as much context as possible
    3. Validate that edges touching template boundary have no generated neighbors
    4. If placement has missing context, try alternative placements
    5. If allow_expansion and context quadrants are still missing, expand the infill
    """
    # Try multiple placement strategies
    # Strategy 1: Maximize context (original approach)
    # Strategy 2+: Exclude problematic sides that would pull in non-generated quadrants

    placement = self._try_placement_with_context_preferences(
      include_left=True,
      include_right=True,
      include_top=True,
      include_bottom=True,
    )

    if placement is not None:
      missing = self._find_missing_context_quadrants(placement)
      if not missing:
        return placement

      # There are missing context quadrants - try alternative placements
      # that exclude the sides causing the problem
      alternative = self._try_alternative_placements(missing, allow_expansion)
      if alternative is not None:
        return alternative

      # All alternatives failed, try expansion on the original placement
      if allow_expansion:
        expanded_placement = self._expand_to_cover_missing(placement, missing)
        if expanded_placement is not None:
          return expanded_placement

      # Everything failed
      missing_str = ", ".join(f"({qx}, {qy})" for qx, qy in missing)
      self._last_validation_error = (
        f"Context quadrants missing generations: {missing_str}"
      )
      return None

    return placement

  def _try_placement_with_context_preferences(
    self,
    include_left: bool,
    include_right: bool,
    include_top: bool,
    include_bottom: bool,
  ) -> TemplatePlacement | None:
    """
    Try to find a valid placement with given context preferences.

    Args:
      include_left: Whether to try to include left context
      include_right: Whether to try to include right context
      include_top: Whether to try to include top context
      include_bottom: Whether to try to include bottom context

    Returns:
      TemplatePlacement if valid (passes seam check), None otherwise
    """
    # Calculate available margin on each side
    margin_x = TEMPLATE_SIZE - self.region.width
    margin_y = TEMPLATE_SIZE - self.region.height

    # Check for generated context on each side of the infill region
    has_left_gen = self._has_generated_context("left") if include_left else False
    has_right_gen = self._has_generated_context("right") if include_right else False
    has_top_gen = self._has_generated_context("top") if include_top else False
    has_bottom_gen = self._has_generated_context("bottom") if include_bottom else False

    # Determine infill position based on context preferences
    # Horizontal positioning
    if has_left_gen and has_right_gen:
      infill_x = margin_x // 2
    elif has_left_gen:
      infill_x = margin_x
    elif has_right_gen:
      infill_x = 0
    else:
      # No horizontal context to include - position to avoid seams
      # If we're NOT including left but there IS generated content on left,
      # push infill to include right side (avoid left seam)
      actual_left_gen = self._has_generated_context("left")
      actual_right_gen = self._has_generated_context("right")
      if actual_right_gen and not actual_left_gen:
        infill_x = 0
      elif actual_left_gen and not actual_right_gen:
        infill_x = margin_x
      else:
        infill_x = 0

    # Vertical positioning
    if has_top_gen and has_bottom_gen:
      infill_y = margin_y // 2
    elif has_top_gen:
      infill_y = margin_y
    elif has_bottom_gen:
      infill_y = 0
    else:
      # No vertical context to include - position to avoid seams
      actual_top_gen = self._has_generated_context("top")
      actual_bottom_gen = self._has_generated_context("bottom")
      if actual_bottom_gen and not actual_top_gen:
        infill_y = 0
      elif actual_top_gen and not actual_bottom_gen:
        infill_y = margin_y
      else:
        infill_y = 0

    # Calculate world offset
    world_offset_x = self.region.x - infill_x
    world_offset_y = self.region.y - infill_y

    placement = TemplatePlacement(
      infill_x=infill_x,
      infill_y=infill_y,
      world_offset_x=world_offset_x,
      world_offset_y=world_offset_y,
    )
    placement._infill_width = self.region.width
    placement._infill_height = self.region.height

    # Validate the placement (seams check)
    is_valid, error = self._validate_placement_seams(placement)
    if not is_valid:
      self._last_validation_error = error
      return None

    return placement

  def _try_alternative_placements(
    self,
    missing: list[tuple[int, int]],
    allow_expansion: bool,
  ) -> TemplatePlacement | None:
    """
    Try alternative placements that avoid missing context quadrants.

    When the optimal placement would include non-generated context quadrants,
    we try placements that exclude certain sides to avoid those quadrants.
    """
    # Determine which sides are causing problems
    # Missing quadrants are in certain positions relative to the infill
    infill_quadrants = set(self.region.overlapping_quadrants())
    infill_min_qx = min(q[0] for q in infill_quadrants)
    infill_max_qx = max(q[0] for q in infill_quadrants)
    infill_min_qy = min(q[1] for q in infill_quadrants)
    infill_max_qy = max(q[1] for q in infill_quadrants)

    problem_sides = set()
    for qx, qy in missing:
      if qx < infill_min_qx:
        problem_sides.add("left")
      if qx > infill_max_qx:
        problem_sides.add("right")
      if qy < infill_min_qy:
        problem_sides.add("top")
      if qy > infill_max_qy:
        problem_sides.add("bottom")

    # Try placements that exclude problem sides
    # Generate combinations of sides to exclude
    side_combinations = []

    # First, try excluding just the problem sides
    if problem_sides:
      side_combinations.append(problem_sides)

    # Then try excluding individual problem sides
    for side in problem_sides:
      side_combinations.append({side})

    # Try each combination
    for exclude_sides in side_combinations:
      placement = self._try_placement_with_context_preferences(
        include_left="left" not in exclude_sides,
        include_right="right" not in exclude_sides,
        include_top="top" not in exclude_sides,
        include_bottom="bottom" not in exclude_sides,
      )

      if placement is None:
        continue

      # Check if this placement has any missing context quadrants
      new_missing = self._find_missing_context_quadrants(placement)

      if not new_missing:
        # Found a valid placement!
        return placement

      # If allow_expansion and fewer missing quadrants, try expansion
      if allow_expansion and len(new_missing) < len(missing):
        expanded = self._expand_to_cover_missing(placement, new_missing)
        if expanded is not None:
          return expanded

    # Last resort: try placements that sacrifice context to avoid missing quadrants
    # This may create seams but is better than not being able to generate at all
    best_placement = self._try_seam_tolerant_placement(problem_sides)
    if best_placement is not None:
      return best_placement

    return None

  def _try_seam_tolerant_placement(
    self, problem_sides: set[str]
  ) -> TemplatePlacement | None:
    """
    Try to find a placement that avoids missing context quadrants,
    even if it might create seams with generated neighbors.

    This is a last resort when no seam-free placement exists.
    """
    margin_x = TEMPLATE_SIZE - self.region.width
    margin_y = TEMPLATE_SIZE - self.region.height

    # Determine which sides have generated content
    has_left_gen = self._has_generated_context("left")
    has_right_gen = self._has_generated_context("right")
    has_top_gen = self._has_generated_context("top")
    has_bottom_gen = self._has_generated_context("bottom")

    # For each problem side, we want to position to EXCLUDE that side's context
    # even if it means creating a seam

    # Try different positions that avoid problem sides
    positions_to_try = []

    # If left is problematic, push infill to left (exclude left context)
    if "left" in problem_sides:
      # Position infill at left, include right context if available
      infill_x = 0
      if has_top_gen and "top" not in problem_sides:
        infill_y = margin_y  # Include top
      elif has_bottom_gen and "bottom" not in problem_sides:
        infill_y = 0  # Include bottom
      else:
        infill_y = 0
      positions_to_try.append((infill_x, infill_y))

    # If right is problematic, push infill to right (exclude right context)
    if "right" in problem_sides:
      infill_x = margin_x
      if has_top_gen and "top" not in problem_sides:
        infill_y = margin_y
      elif has_bottom_gen and "bottom" not in problem_sides:
        infill_y = 0
      else:
        infill_y = 0
      positions_to_try.append((infill_x, infill_y))

    # If top is problematic, push infill to top (exclude top context)
    if "top" in problem_sides:
      infill_y = 0
      if has_right_gen and "right" not in problem_sides:
        infill_x = 0  # Include right
      elif has_left_gen and "left" not in problem_sides:
        infill_x = margin_x  # Include left
      else:
        infill_x = 0
      positions_to_try.append((infill_x, infill_y))

    # If bottom is problematic, push infill to bottom
    if "bottom" in problem_sides:
      infill_y = margin_y
      if has_right_gen and "right" not in problem_sides:
        infill_x = 0
      elif has_left_gen and "left" not in problem_sides:
        infill_x = margin_x
      else:
        infill_x = 0
      positions_to_try.append((infill_x, infill_y))

    # Also try all four corners to maximize options
    corners = [
      (0, 0),  # Top-left
      (margin_x, 0),  # Top-right
      (0, margin_y),  # Bottom-left
      (margin_x, margin_y),  # Bottom-right
    ]
    positions_to_try.extend(corners)

    # Try each position
    for infill_x, infill_y in positions_to_try:
      world_offset_x = self.region.x - infill_x
      world_offset_y = self.region.y - infill_y

      placement = TemplatePlacement(
        infill_x=infill_x,
        infill_y=infill_y,
        world_offset_x=world_offset_x,
        world_offset_y=world_offset_y,
      )
      placement._infill_width = self.region.width
      placement._infill_height = self.region.height

      # Check for missing context quadrants (skip seam check)
      missing = self._find_missing_context_quadrants(placement)

      if not missing:
        # Found a valid placement (may have seams but no missing context)
        return placement

    return None

  def _has_generated_context(self, side: str) -> bool:
    """Check if there are generated pixels adjacent to the infill region on the given side."""
    # Note: Python's // does floor division, so negative coords work correctly
    # e.g., -1 // 512 = -1, -512 // 512 = -1, -513 // 512 = -2

    if side == "left":
      # Check quadrants to the left of the region
      check_x = self.region.x - 1
      qx = check_x // QUADRANT_SIZE
      # Check all quadrants along the left edge
      start_qy = self.region.y // QUADRANT_SIZE
      end_qy = (self.region.bottom - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qy in range(start_qy, end_qy + 1))

    elif side == "right":
      check_x = self.region.right
      qx = check_x // QUADRANT_SIZE
      start_qy = self.region.y // QUADRANT_SIZE
      end_qy = (self.region.bottom - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qy in range(start_qy, end_qy + 1))

    elif side == "top":
      check_y = self.region.y - 1
      qy = check_y // QUADRANT_SIZE
      start_qx = self.region.x // QUADRANT_SIZE
      end_qx = (self.region.right - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qx in range(start_qx, end_qx + 1))

    elif side == "bottom":
      check_y = self.region.bottom
      qy = check_y // QUADRANT_SIZE
      start_qx = self.region.x // QUADRANT_SIZE
      end_qx = (self.region.right - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qx in range(start_qx, end_qx + 1))

    return False

  def _validate_placement_seams(self, placement: TemplatePlacement) -> tuple[bool, str]:
    """
    Validate that a placement doesn't create seams.

    A seam would occur if the infill region touches the template edge
    AND there are generated pixels beyond that edge.

    Returns:
      Tuple of (is_valid, error_message)
    """
    # Check left edge
    if placement.infill_x == 0:
      if self._has_generated_context("left"):
        return False, "Would create seam with generated pixels on left"

    # Check right edge
    if placement.infill_x + self.region.width == TEMPLATE_SIZE:
      if self._has_generated_context("right"):
        return False, "Would create seam with generated pixels on right"

    # Check top edge
    if placement.infill_y == 0:
      if self._has_generated_context("top"):
        return False, "Would create seam with generated pixels on top"

    # Check bottom edge
    if placement.infill_y + self.region.height == TEMPLATE_SIZE:
      if self._has_generated_context("bottom"):
        return False, "Would create seam with generated pixels on bottom"

    return True, ""

  def _find_missing_context_quadrants(
    self, placement: TemplatePlacement
  ) -> list[tuple[int, int]]:
    """
    Find context quadrants that don't have generated pixels.

    Returns list of (qx, qy) positions that are in the template but not
    in the infill region and don't have generations.
    """
    missing = []

    # Calculate which quadrants the template covers
    template_world_left = placement.world_offset_x
    template_world_right = placement.world_offset_x + TEMPLATE_SIZE
    template_world_top = placement.world_offset_y
    template_world_bottom = placement.world_offset_y + TEMPLATE_SIZE

    start_qx = template_world_left // QUADRANT_SIZE
    end_qx = (template_world_right - 1) // QUADRANT_SIZE
    start_qy = template_world_top // QUADRANT_SIZE
    end_qy = (template_world_bottom - 1) // QUADRANT_SIZE

    # Infill quadrants
    infill_quadrants = set(self.region.overlapping_quadrants())

    for qx in range(start_qx, end_qx + 1):
      for qy in range(start_qy, end_qy + 1):
        if (qx, qy) not in infill_quadrants:
          # This is a context quadrant - must have generation
          if not self.has_generation(qx, qy):
            missing.append((qx, qy))

    return missing

  def _expand_to_cover_missing(
    self,
    placement: TemplatePlacement,
    missing: list[tuple[int, int]],
  ) -> TemplatePlacement | None:
    """
    Try to expand the infill region to cover missing context quadrants.

    The expanded region must still fit within the template and not exceed
    the maximum allowed size.

    Returns:
      New TemplatePlacement with expanded infill, or None if expansion not possible
    """
    # Get current infill quadrants
    primary_quadrants = self.region.overlapping_quadrants()

    # Combine primary and missing to get all quadrants we need to cover
    all_quadrants = set(primary_quadrants + missing)

    # Find bounds of expanded region
    min_qx = min(q[0] for q in all_quadrants)
    max_qx = max(q[0] for q in all_quadrants)
    min_qy = min(q[1] for q in all_quadrants)
    max_qy = max(q[1] for q in all_quadrants)

    # Create expanded region
    expanded_region = InfillRegion(
      x=min_qx * QUADRANT_SIZE,
      y=min_qy * QUADRANT_SIZE,
      width=(max_qx - min_qx + 1) * QUADRANT_SIZE,
      height=(max_qy - min_qy + 1) * QUADRANT_SIZE,
    )

    # Check if expanded region is valid size
    if not expanded_region.is_valid_size():
      self._last_validation_error = (
        f"Cannot expand infill to cover missing quadrants: "
        f"expanded region would be {expanded_region.area} pixels "
        f"(max: {MAX_INFILL_AREA})"
      )
      return None

    # Create a new builder for the expanded region to find its placement
    expanded_builder = TemplateBuilder(expanded_region, self.has_generation)
    expanded_placement = expanded_builder.find_optimal_placement(allow_expansion=False)

    if expanded_placement is None:
      self._last_validation_error = expanded_builder._last_validation_error
      return None

    # Track primary vs padding quadrants
    expanded_placement._primary_quadrants = list(primary_quadrants)
    expanded_placement._padding_quadrants = list(missing)
    expanded_placement._expanded_region = expanded_region

    return expanded_placement

  def build(
    self,
    border_width: int = 2,
    allow_expansion: bool = False,
  ) -> tuple[Image.Image, TemplatePlacement] | None:
    """
    Build the template image.

    Args:
      border_width: Width of the red border around the infill region
      allow_expansion: If True, automatically expand infill region to cover
                       missing context quadrants

    Returns:
      Tuple of (template_image, placement) or None if no valid placement exists
    """
    if self.get_render is None or self.get_generation is None:
      raise ValueError("get_render and get_generation must be provided to build")

    placement = self.find_optimal_placement(allow_expansion=allow_expansion)
    if placement is None:
      return None

    # Determine the effective infill region (may be expanded)
    if placement._expanded_region is not None:
      effective_region = placement._expanded_region
    else:
      effective_region = self.region

    # Create template image
    template = Image.new("RGBA", (TEMPLATE_SIZE, TEMPLATE_SIZE), (0, 0, 0, 0))

    # Determine which quadrants we need to fetch
    # The template covers world coordinates:
    #   x: [world_offset_x, world_offset_x + 1024)
    #   y: [world_offset_y, world_offset_y + 1024)

    template_world_left = placement.world_offset_x
    template_world_right = placement.world_offset_x + TEMPLATE_SIZE
    template_world_top = placement.world_offset_y
    template_world_bottom = placement.world_offset_y + TEMPLATE_SIZE

    # Find all quadrants that overlap with the template
    start_qx = template_world_left // QUADRANT_SIZE
    end_qx = (template_world_right - 1) // QUADRANT_SIZE
    start_qy = template_world_top // QUADRANT_SIZE
    end_qy = (template_world_bottom - 1) // QUADRANT_SIZE

    # Infill quadrants (will use render) - use effective region for expanded infills
    infill_quadrants = set(effective_region.overlapping_quadrants())

    # Fill in the template
    for qx in range(start_qx, end_qx + 1):
      for qy in range(start_qy, end_qy + 1):
        # Calculate where this quadrant appears in the template
        quad_world_x = qx * QUADRANT_SIZE
        quad_world_y = qy * QUADRANT_SIZE

        # Position in template coordinates
        template_x = quad_world_x - template_world_left
        template_y = quad_world_y - template_world_top

        # Determine source image
        if (qx, qy) in infill_quadrants:
          # Use render for infill quadrants
          quad_img = self.get_render(qx, qy)
          source_type = "render"
          if quad_img is None:
            continue
        else:
          # Use generation for context quadrants
          quad_img = self.get_generation(qx, qy)
          source_type = "generation"
          if quad_img is None:
            continue

        # Debug: Log quadrant image size and warn if unexpected
        img_w, img_h = quad_img.size
        expected_size = (QUADRANT_SIZE, QUADRANT_SIZE)
        if (img_w, img_h) != expected_size:
          print(
            f"   ‚ö†Ô∏è Quadrant ({qx}, {qy}) [{source_type}]: "
            f"UNEXPECTED size={quad_img.size} (expected {expected_size}), "
            f"template_pos=({template_x}, {template_y})"
          )
        else:
          print(
            f"   üì¶ Quadrant ({qx}, {qy}) [{source_type}]: "
            f"size={quad_img.size}, template_pos=({template_x}, {template_y})"
          )

        if quad_img.mode != "RGBA":
          quad_img = quad_img.convert("RGBA")

        # Calculate crop region if quadrant extends outside template
        crop_left = max(0, -template_x)
        crop_top = max(0, -template_y)
        crop_right = min(QUADRANT_SIZE, TEMPLATE_SIZE - template_x)
        crop_bottom = min(QUADRANT_SIZE, TEMPLATE_SIZE - template_y)

        if crop_left < crop_right and crop_top < crop_bottom:
          cropped = quad_img.crop((crop_left, crop_top, crop_right, crop_bottom))
          paste_x = max(0, template_x)
          paste_y = max(0, template_y)
          template.paste(cropped, (paste_x, paste_y))

    # Now we need to handle partial quadrant overlaps with the infill region
    # If the infill region doesn't align with quadrant boundaries,
    # we need to carefully composite render pixels only in the infill area
    self._apply_infill_mask(template, placement)

    # Draw red border around infill region
    template = self._draw_border(template, placement, border_width)

    return template, placement

  def _apply_infill_mask(
    self, template: Image.Image, placement: TemplatePlacement
  ) -> None:
    """
    Apply a mask to ensure only the infill region has render pixels.

    For quadrants that partially overlap the infill region, we need to
    composite render pixels (infill area) with generation pixels (context area).
    """
    # This is already handled by the quadrant-based approach when infill aligns
    # with quadrant boundaries. For non-aligned infills, we'd need more complex
    # masking. For now, we assume quadrant-aligned infills.
    pass

  def _draw_border(
    self,
    template: Image.Image,
    placement: TemplatePlacement,
    border_width: int,
  ) -> Image.Image:
    """Draw a red border around the infill region."""
    result = template.copy()
    draw = ImageDraw.Draw(result)

    red = (255, 0, 0, 255)

    left = placement.infill_x
    top = placement.infill_y
    right = placement.infill_x + self.region.width
    bottom = placement.infill_y + self.region.height

    for i in range(border_width):
      draw.rectangle(
        [left + i, top + i, right - 1 - i, bottom - 1 - i],
        outline=red,
        fill=None,
      )

    return result

  def get_validation_info(self) -> dict:
    """Get detailed validation information for debugging."""
    return {
      "region": str(self.region),
      "area": self.region.area,
      "max_area": MAX_INFILL_AREA,
      "valid_size": self.region.is_valid_size(),
      "has_left_gen": self._has_generated_context("left"),
      "has_right_gen": self._has_generated_context("right"),
      "has_top_gen": self._has_generated_context("top"),
      "has_bottom_gen": self._has_generated_context("bottom"),
      "overlapping_quadrants": self.region.overlapping_quadrants(),
      "last_validation_error": self._last_validation_error,
    }


def validate_quadrant_selection(
  quadrants: list[tuple[int, int]],
  has_generation: Callable[[int, int], bool],
  allow_expansion: bool = False,
) -> tuple[bool, str, TemplatePlacement | None]:
  """
  Validate a quadrant selection and find optimal placement.

  This is a convenience function for the common case of selecting
  whole quadrants for infill.

  Special handling for full tiles (2x2):
  - If some quadrants already have generations, reduce to just the missing ones
  - The generated quadrants become context for the missing ones

  Args:
    quadrants: List of (qx, qy) quadrant positions to infill
    has_generation: Callable to check if a quadrant has generation
    allow_expansion: If True, automatically expand infill region to cover
                     missing context quadrants (they'll be filled with render
                     pixels and discarded after generation)

  Returns:
    Tuple of (is_valid, message, placement)
  """
  if not quadrants:
    return False, "No quadrants selected", None

  # Check that quadrants form a rectangle
  min_qx = min(q[0] for q in quadrants)
  max_qx = max(q[0] for q in quadrants)
  min_qy = min(q[1] for q in quadrants)
  max_qy = max(q[1] for q in quadrants)

  expected_count = (max_qx - min_qx + 1) * (max_qy - min_qy + 1)
  if len(quadrants) != expected_count:
    return False, "Quadrants must form a contiguous rectangle", None

  # Check all expected positions are present
  expected = set()
  for qx in range(min_qx, max_qx + 1):
    for qy in range(min_qy, max_qy + 1):
      expected.add((qx, qy))

  if set(quadrants) != expected:
    return False, "Quadrants must form a contiguous rectangle", None

  # Create infill region and builder
  region = InfillRegion.from_quadrants(quadrants)

  if not region.is_valid_size():
    return (
      False,
      f"Selection too large: {region.area} pixels (max: {MAX_INFILL_AREA} or full tile)",
      None,
    )

  # For full tiles (2x2), check if some quadrants are already generated
  # If so, reduce the selection to just the non-generated quadrants
  if region.is_full_tile():
    # Check which quadrants already have generations
    generated_quadrants = [q for q in quadrants if has_generation(q[0], q[1])]
    non_generated_quadrants = [q for q in quadrants if not has_generation(q[0], q[1])]

    if len(generated_quadrants) == 4:
      # All quadrants already generated - nothing to do
      return False, "All quadrants already have generations", None

    if len(generated_quadrants) > 0:
      # Some quadrants are generated - reduce selection to just the missing ones
      # The generated quadrants will serve as context
      print(
        f"   üìã {len(generated_quadrants)} of 4 quadrants already generated, "
        f"will generate remaining {len(non_generated_quadrants)}"
      )

      # Recursively validate the reduced selection
      return validate_quadrant_selection(
        non_generated_quadrants, has_generation, allow_expansion
      )

    # No quadrants generated yet - check for external neighbors
    has_any_gen_neighbor = False
    for qx, qy in quadrants:
      # Check all 4 sides of each edge quadrant
      if qx == min(q[0] for q in quadrants):  # Left edge
        if has_generation(qx - 1, qy):
          has_any_gen_neighbor = True
          break
      if qx == max(q[0] for q in quadrants):  # Right edge
        if has_generation(qx + 1, qy):
          has_any_gen_neighbor = True
          break
      if qy == min(q[1] for q in quadrants):  # Top edge
        if has_generation(qx, qy - 1):
          has_any_gen_neighbor = True
          break
      if qy == max(q[1] for q in quadrants):  # Bottom edge
        if has_generation(qx, qy + 1):
          has_any_gen_neighbor = True
          break

    if has_any_gen_neighbor:
      return (
        False,
        "Full tile (2x2) selection cannot have generated neighbors (would create seams)",
        None,
      )

    # Full tile with no neighbors - valid, place at origin
    placement = TemplatePlacement(
      infill_x=0,
      infill_y=0,
      world_offset_x=region.x,
      world_offset_y=region.y,
    )
    placement._infill_width = region.width
    placement._infill_height = region.height
    placement._primary_quadrants = list(quadrants)
    return True, "Valid selection (full tile)", placement

  builder = TemplateBuilder(region, has_generation)
  placement = builder.find_optimal_placement(allow_expansion=allow_expansion)

  if placement is None:
    # Use the specific error from the builder if available
    info = builder.get_validation_info()
    if info["last_validation_error"]:
      return False, info["last_validation_error"], None
    # Fallback to generic messages
    if info["has_left_gen"]:
      return False, "Would create seam with generated pixels on left", None
    if info["has_right_gen"]:
      return False, "Would create seam with generated pixels on right", None
    if info["has_top_gen"]:
      return False, "Would create seam with generated pixels on top", None
    if info["has_bottom_gen"]:
      return False, "Would create seam with generated pixels on bottom", None
    return False, "No valid placement found", None

  # Set primary quadrants if not already set (by expansion)
  if not placement._primary_quadrants:
    placement._primary_quadrants = list(quadrants)

  # Build appropriate message
  if placement.is_expanded:
    padding_str = ", ".join(f"({qx}, {qy})" for qx, qy in placement._padding_quadrants)
    return True, f"Valid selection (expanded to cover: {padding_str})", placement

  return True, "Valid selection", placement


# =============================================================================
# Testing
# =============================================================================


def _test_basic():
  """Run basic tests."""
  print("=" * 60)
  print("Testing InfillRegion")
  print("=" * 60)

  # Test single quadrant
  r1 = InfillRegion.from_quadrant(0, 0)
  print(f"\nSingle quadrant (0,0): {r1}")
  print(f"  Area: {r1.area} (valid: {r1.is_valid_size()})")
  print(f"  Overlapping quadrants: {r1.overlapping_quadrants()}")

  # Test 2x1 quadrants
  r2 = InfillRegion.from_quadrants([(0, 0), (1, 0)])
  print(f"\n2x1 quadrants: {r2}")
  print(f"  Area: {r2.area} (valid: {r2.is_valid_size()})")
  print(f"  Overlapping quadrants: {r2.overlapping_quadrants()}")

  # Test 2x2 quadrants (should be invalid - 100% of tile)
  r3 = InfillRegion.from_quadrants([(0, 0), (1, 0), (0, 1), (1, 1)])
  print(f"\n2x2 quadrants: {r3}")
  print(f"  Area: {r3.area} (valid: {r3.is_valid_size()})")

  print("\n" + "=" * 60)
  print("Testing TemplateBuilder")
  print("=" * 60)

  # Create a mock has_generation function
  # Simulate: quadrants (0,0) and (1,0) are NOT generated, (0,1) and (1,1) ARE generated
  generated = {(0, 1), (1, 1), (2, 0), (2, 1)}

  def has_gen(qx, qy):
    return (qx, qy) in generated

  # Test 1: Select quadrant (1, 0) with generated neighbor below
  region = InfillRegion.from_quadrant(1, 0)
  builder = TemplateBuilder(region, has_gen)
  info = builder.get_validation_info()
  placement = builder.find_optimal_placement()

  print("\nTest 1: Select quadrant (1, 0)")
  print(f"  Info: {info}")
  print(f"  Placement: {placement}")
  if placement:
    print(f"    Infill at: ({placement.infill_x}, {placement.infill_y})")
    print(f"    World offset: ({placement.world_offset_x}, {placement.world_offset_y})")

  # Test 2: Select quadrant (0, 1) surrounded by generated
  region2 = InfillRegion.from_quadrant(0, 1)
  builder2 = TemplateBuilder(region2, has_gen)
  info2 = builder2.get_validation_info()
  placement2 = builder2.find_optimal_placement()

  print("\nTest 2: Select quadrant (0, 1) - has generated neighbor to right")
  print(f"  Info: {info2}")
  print(f"  Placement: {placement2}")
  if placement2:
    print(f"    Infill at: ({placement2.infill_x}, {placement2.infill_y})")

  # Test 3: Validation convenience function
  print("\n" + "=" * 60)
  print("Testing validate_quadrant_selection")
  print("=" * 60)

  # Valid selection
  valid, msg, p = validate_quadrant_selection([(1, 0)], has_gen)
  print(f"\nSelect (1,0): valid={valid}, msg='{msg}'")

  # Invalid - non-contiguous
  valid, msg, p = validate_quadrant_selection([(0, 0), (1, 1)], has_gen)
  print(f"Select (0,0), (1,1) [diagonal]: valid={valid}, msg='{msg}'")

  # Valid 2x1
  valid, msg, p = validate_quadrant_selection([(0, 0), (1, 0)], has_gen)
  print(f"Select (0,0), (1,0) [2x1]: valid={valid}, msg='{msg}'")

  print("\n" + "=" * 60)
  print("All tests complete!")
  print("=" * 60)


if __name__ == "__main__":
  _test_basic()

```

I've added debug logging to the template builder. When you run the next generation, the logs will show each quadrant's source and size. If you see something like:

```
‚ö†Ô∏è Quadrant (5, 3) [generation]: UNEXPECTED size=(1024, 1024) (expected (512, 512)), template_pos=(0, 0)
```

That would confirm the issue is with how that quadrant's generation was saved.

But let me also check - is there any code path that might save a full tile (1024x1024) as a single quadrant? Let me search for any potential issues:

```plaintext
‚ö†Ô∏è Quadrant (5, 3) [generation]: UNEXPECTED size=(1024, 1024) (expected (512, 512)), template_pos=(0, 0)
```

I've added debug logging to `infill_template.py` that will print the size of each quadrant image being placed into the template. When you run the next generation, look for output like:

```
üì¶ Quadrant (5, 2) [generation]: size=(512, 512), template_pos=(512, 0)
üì¶ Quadrant (4, 3) [generation]: size=(512, 512), template_pos=(0, 512)
üì¶ Quadrant (5, 3) [render]: size=(512, 512), template_pos=(512, 512)
```

If there's a size mismatch, you'll see a warning:
```
‚ö†Ô∏è Quadrant (4, 2) [generation]: UNEXPECTED size=(1024, 1024) (expected (512, 512)), template_pos=(0, 0)
```

This would indicate that a previously saved generation was stored at the wrong size (e.g., a full tile instead of a quadrant), which would explain why only the top-left corner appears - the crop logic correctly crops 512x512 from position (0,0), but if the source image is 1024x1024, that's only the top-left quarter.

Can you run the generation again and share the console output?

```plaintext
üì¶ Quadrant (5, 2) [generation]: size=(512, 512), template_pos=(512, 0)
üì¶ Quadrant (4, 3) [generation]: size=(512, 512), template_pos=(0, 512)
üì¶ Quadrant (5, 3) [render]: size=(512, 512), template_pos=(512, 512)
```

```plaintext
üì¶ Quadrant (5, 2) [generation]: size=(512, 512), template_pos=(512, 0)
üì¶ Quadrant (4, 3) [generation]: size=(512, 512), template_pos=(0, 512)
üì¶ Quadrant (5, 3) [render]: size=(512, 512), template_pos=(512, 512)
```

```plaintext
‚ö†Ô∏è Quadrant (4, 2) [generation]: UNEXPECTED size=(1024, 1024) (expected (512, 512)), template_pos=(0, 0)
```

---

**User**

I'm not seeing any logs in @src/isometric_nyc/e2e_generation/app.py ...

---

**Cursor**

The debug logging I added is in `infill_template.py`, which gets called when building the template. Let me also add logging directly in `generate_omni.py` where the builder is used, so you can see what's happening with context quadrants:

```python
context_raw = data.get("context")
```

```javascript
requestBody.context_quadrants = contextQuadrants;
```

I found the bug! The frontend sends `context_quadrants` but the backend looks for `context`. Let me check and fix this:

```javascript
requestBody.context_quadrants = contextQuadrants;
```

Found it! The frontend sends `context_quadrants` but the backend expects `context`. Let me fix the frontend to match the API:

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show queue count
    if (serverStatus.queue_length > 0) {
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

async function generateSelected() {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Generation queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        showToast(
          "info",
          "Processing queue",
          `${status.queue_length} more item(s) in queue...`
        );
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```python
Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    } when the user runs the generation again, the context quadrants should be properly parsed and used!
```

That was the bug! The frontend was sending `context_quadrants` but the API expects `context`. Now when you run a generation with context, you should see:

1. The "Context:" line in the logs showing the context quadrants
2. The debug output from `infill_template.py` showing each quadrant's size

Try generating again - the context should now be properly passed and used!

---

**User**

@uv (475-481) 

---

**Cursor**

Found it! Quadrant (-32, 43) has a 1024x1024 image stored instead of the expected 512x512. This is why only the top-left corner shows - the crop takes (0, 0, 512, 512) from a 1024x1024 image.

This quadrant was likely saved incorrectly at some point (maybe a full tile was saved instead of just the quadrant). Let me add a fix to handle oversized images by using the correct portion:

```python
"""
Generic infill template generation for arbitrary rectangular regions.

This module handles creating template images for infill generation where:
- The infill region is an arbitrary rectangle (up to 50% of tile area)
- Context is maximized by optimal placement within the template
- Edge constraints ensure no seams with generated neighbors

Key concepts:
- InfillRegion: A rectangular region to be filled with generated pixels
- TemplateSpec: Specification for how to build the template
- The template is always 1024x1024 pixels
- Quadrants (512x512) are the storage unit in the database

Usage:
  from isometric_nyc.e2e_generation.infill_template import (
      InfillRegion,
      TemplateBuilder,
  )

  # Create an infill region (e.g., a single quadrant)
  region = InfillRegion.from_quadrant(x=2, y=3)

  # Or create a custom rectangle
  region = InfillRegion(x=256, y=256, width=512, height=512)

  # Build template
  builder = TemplateBuilder(region, get_generation_func)
  template, bounds = builder.build()
"""

from dataclasses import dataclass
from typing import Callable

from PIL import Image, ImageDraw

# Template and quadrant dimensions
TEMPLATE_SIZE = 1024
QUADRANT_SIZE = 512
MAX_INFILL_AREA = TEMPLATE_SIZE * TEMPLATE_SIZE // 2  # 50% of template


@dataclass
class InfillRegion:
  """
  A rectangular region to be infilled.

  Coordinates are in "world" pixel space, where:
  - (0, 0) is the top-left of quadrant (0, 0)
  - x increases to the right
  - y increases downward
  - Each quadrant is 512x512 pixels
  """

  x: int  # World x coordinate (top-left of region)
  y: int  # World y coordinate (top-left of region)
  width: int  # Width in pixels
  height: int  # Height in pixels

  @classmethod
  def from_quadrant(cls, qx: int, qy: int) -> "InfillRegion":
    """Create an infill region for a single quadrant."""
    return cls(
      x=qx * QUADRANT_SIZE,
      y=qy * QUADRANT_SIZE,
      width=QUADRANT_SIZE,
      height=QUADRANT_SIZE,
    )

  @classmethod
  def from_quadrants(cls, quadrants: list[tuple[int, int]]) -> "InfillRegion":
    """
    Create an infill region covering multiple quadrants.

    The quadrants must form a contiguous rectangle.
    """
    if not quadrants:
      raise ValueError("At least one quadrant required")

    min_qx = min(q[0] for q in quadrants)
    max_qx = max(q[0] for q in quadrants)
    min_qy = min(q[1] for q in quadrants)
    max_qy = max(q[1] for q in quadrants)

    return cls(
      x=min_qx * QUADRANT_SIZE,
      y=min_qy * QUADRANT_SIZE,
      width=(max_qx - min_qx + 1) * QUADRANT_SIZE,
      height=(max_qy - min_qy + 1) * QUADRANT_SIZE,
    )

  @property
  def area(self) -> int:
    """Total area in pixels."""
    return self.width * self.height

  @property
  def right(self) -> int:
    """Right edge x coordinate."""
    return self.x + self.width

  @property
  def bottom(self) -> int:
    """Bottom edge y coordinate."""
    return self.y + self.height

  def is_valid_size(self) -> bool:
    """Check if the region is within the allowed size (‚â§50% or exactly 100% of template)."""
    # Allow up to 50% OR exactly 100% (full tile)
    # Full tile is valid only if there are no generated neighbors (checked separately)
    return self.area <= MAX_INFILL_AREA or self.is_full_tile()

  def is_full_tile(self) -> bool:
    """Check if this region is exactly a full tile (1024x1024)."""
    return self.width == TEMPLATE_SIZE and self.height == TEMPLATE_SIZE

  def overlapping_quadrants(self) -> list[tuple[int, int]]:
    """Get list of quadrant (qx, qy) positions that overlap with this region."""
    quadrants = []

    # Find quadrant range
    start_qx = self.x // QUADRANT_SIZE
    end_qx = (self.right - 1) // QUADRANT_SIZE
    start_qy = self.y // QUADRANT_SIZE
    end_qy = (self.bottom - 1) // QUADRANT_SIZE

    for qx in range(start_qx, end_qx + 1):
      for qy in range(start_qy, end_qy + 1):
        quadrants.append((qx, qy))

    return quadrants

  def __str__(self) -> str:
    return f"InfillRegion(x={self.x}, y={self.y}, w={self.width}, h={self.height})"


@dataclass
class TemplatePlacement:
  """
  Describes where to place the infill region within the template.

  The template is always 1024x1024. This specifies:
  - Where the infill region should be placed within it
  - The world coordinate offset for context pixels
  - Which quadrants are primary (user selected) vs padding (auto-expanded)
  """

  # Position of infill region within template (0-1024)
  infill_x: int
  infill_y: int

  # World coordinate of template's top-left corner
  world_offset_x: int
  world_offset_y: int

  @property
  def infill_right(self) -> int:
    return self.infill_x + self._infill_width

  @property
  def infill_bottom(self) -> int:
    return self.infill_y + self._infill_height

  def __post_init__(self):
    # These will be set by the builder
    self._infill_width = 0
    self._infill_height = 0
    # Primary quadrants are the user-selected ones
    # Padding quadrants are auto-added to cover missing context
    self._primary_quadrants: list[tuple[int, int]] = []
    self._padding_quadrants: list[tuple[int, int]] = []
    # The expanded infill region (if different from primary)
    self._expanded_region: InfillRegion | None = None

  @property
  def primary_quadrants(self) -> list[tuple[int, int]]:
    """Quadrants originally selected by user."""
    return self._primary_quadrants

  @property
  def padding_quadrants(self) -> list[tuple[int, int]]:
    """Quadrants auto-added to cover missing context."""
    return self._padding_quadrants

  @property
  def all_infill_quadrants(self) -> list[tuple[int, int]]:
    """All quadrants that will be filled with render pixels."""
    return self._primary_quadrants + self._padding_quadrants

  @property
  def is_expanded(self) -> bool:
    """Whether the infill region was expanded to cover missing context."""
    return len(self._padding_quadrants) > 0


class TemplateBuilder:
  """
  Builds template images for infill generation.

  Handles:
  - Optimal placement of infill region to maximize context
  - Validation of edge constraints
  - Assembly of template from quadrant data
  """

  def __init__(
    self,
    infill_region: InfillRegion,
    has_generation: Callable[[int, int], bool],
    get_render: Callable[[int, int], Image.Image | None] | None = None,
    get_generation: Callable[[int, int], Image.Image | None] | None = None,
  ):
    """
    Initialize the template builder.

    Args:
      infill_region: The region to be infilled
      has_generation: Callable(qx, qy) -> bool to check if quadrant has generation
      get_render: Callable(qx, qy) -> Image to get render for quadrant
      get_generation: Callable(qx, qy) -> Image to get generation for quadrant
    """
    self.region = infill_region
    self.has_generation = has_generation
    self.get_render = get_render
    self.get_generation = get_generation
    self._last_validation_error = ""

    # Validate region size
    if not infill_region.is_valid_size():
      raise ValueError(
        f"Infill region too large: {infill_region.area} pixels (max: {MAX_INFILL_AREA})"
      )

  def find_optimal_placement(
    self, allow_expansion: bool = False
  ) -> TemplatePlacement | None:
    """
    Find the optimal placement for the infill region within the template.

    Args:
      allow_expansion: If True, automatically expand infill region to cover
                       missing context quadrants (they'll be filled with render
                       pixels and discarded after generation)

    Returns None if no valid placement exists (would create seams).

    The strategy:
    1. Try to maximize context by checking generated neighbors
    2. Position infill to include as much context as possible
    3. Validate that edges touching template boundary have no generated neighbors
    4. If placement has missing context, try alternative placements
    5. If allow_expansion and context quadrants are still missing, expand the infill
    """
    # Try multiple placement strategies
    # Strategy 1: Maximize context (original approach)
    # Strategy 2+: Exclude problematic sides that would pull in non-generated quadrants

    placement = self._try_placement_with_context_preferences(
      include_left=True,
      include_right=True,
      include_top=True,
      include_bottom=True,
    )

    if placement is not None:
      missing = self._find_missing_context_quadrants(placement)
      if not missing:
        return placement

      # There are missing context quadrants - try alternative placements
      # that exclude the sides causing the problem
      alternative = self._try_alternative_placements(missing, allow_expansion)
      if alternative is not None:
        return alternative

      # All alternatives failed, try expansion on the original placement
      if allow_expansion:
        expanded_placement = self._expand_to_cover_missing(placement, missing)
        if expanded_placement is not None:
          return expanded_placement

      # Everything failed
      missing_str = ", ".join(f"({qx}, {qy})" for qx, qy in missing)
      self._last_validation_error = (
        f"Context quadrants missing generations: {missing_str}"
      )
      return None

    return placement

  def _try_placement_with_context_preferences(
    self,
    include_left: bool,
    include_right: bool,
    include_top: bool,
    include_bottom: bool,
  ) -> TemplatePlacement | None:
    """
    Try to find a valid placement with given context preferences.

    Args:
      include_left: Whether to try to include left context
      include_right: Whether to try to include right context
      include_top: Whether to try to include top context
      include_bottom: Whether to try to include bottom context

    Returns:
      TemplatePlacement if valid (passes seam check), None otherwise
    """
    # Calculate available margin on each side
    margin_x = TEMPLATE_SIZE - self.region.width
    margin_y = TEMPLATE_SIZE - self.region.height

    # Check for generated context on each side of the infill region
    has_left_gen = self._has_generated_context("left") if include_left else False
    has_right_gen = self._has_generated_context("right") if include_right else False
    has_top_gen = self._has_generated_context("top") if include_top else False
    has_bottom_gen = self._has_generated_context("bottom") if include_bottom else False

    # Determine infill position based on context preferences
    # Horizontal positioning
    if has_left_gen and has_right_gen:
      infill_x = margin_x // 2
    elif has_left_gen:
      infill_x = margin_x
    elif has_right_gen:
      infill_x = 0
    else:
      # No horizontal context to include - position to avoid seams
      # If we're NOT including left but there IS generated content on left,
      # push infill to include right side (avoid left seam)
      actual_left_gen = self._has_generated_context("left")
      actual_right_gen = self._has_generated_context("right")
      if actual_right_gen and not actual_left_gen:
        infill_x = 0
      elif actual_left_gen and not actual_right_gen:
        infill_x = margin_x
      else:
        infill_x = 0

    # Vertical positioning
    if has_top_gen and has_bottom_gen:
      infill_y = margin_y // 2
    elif has_top_gen:
      infill_y = margin_y
    elif has_bottom_gen:
      infill_y = 0
    else:
      # No vertical context to include - position to avoid seams
      actual_top_gen = self._has_generated_context("top")
      actual_bottom_gen = self._has_generated_context("bottom")
      if actual_bottom_gen and not actual_top_gen:
        infill_y = 0
      elif actual_top_gen and not actual_bottom_gen:
        infill_y = margin_y
      else:
        infill_y = 0

    # Calculate world offset
    world_offset_x = self.region.x - infill_x
    world_offset_y = self.region.y - infill_y

    placement = TemplatePlacement(
      infill_x=infill_x,
      infill_y=infill_y,
      world_offset_x=world_offset_x,
      world_offset_y=world_offset_y,
    )
    placement._infill_width = self.region.width
    placement._infill_height = self.region.height

    # Validate the placement (seams check)
    is_valid, error = self._validate_placement_seams(placement)
    if not is_valid:
      self._last_validation_error = error
      return None

    return placement

  def _try_alternative_placements(
    self,
    missing: list[tuple[int, int]],
    allow_expansion: bool,
  ) -> TemplatePlacement | None:
    """
    Try alternative placements that avoid missing context quadrants.

    When the optimal placement would include non-generated context quadrants,
    we try placements that exclude certain sides to avoid those quadrants.
    """
    # Determine which sides are causing problems
    # Missing quadrants are in certain positions relative to the infill
    infill_quadrants = set(self.region.overlapping_quadrants())
    infill_min_qx = min(q[0] for q in infill_quadrants)
    infill_max_qx = max(q[0] for q in infill_quadrants)
    infill_min_qy = min(q[1] for q in infill_quadrants)
    infill_max_qy = max(q[1] for q in infill_quadrants)

    problem_sides = set()
    for qx, qy in missing:
      if qx < infill_min_qx:
        problem_sides.add("left")
      if qx > infill_max_qx:
        problem_sides.add("right")
      if qy < infill_min_qy:
        problem_sides.add("top")
      if qy > infill_max_qy:
        problem_sides.add("bottom")

    # Try placements that exclude problem sides
    # Generate combinations of sides to exclude
    side_combinations = []

    # First, try excluding just the problem sides
    if problem_sides:
      side_combinations.append(problem_sides)

    # Then try excluding individual problem sides
    for side in problem_sides:
      side_combinations.append({side})

    # Try each combination
    for exclude_sides in side_combinations:
      placement = self._try_placement_with_context_preferences(
        include_left="left" not in exclude_sides,
        include_right="right" not in exclude_sides,
        include_top="top" not in exclude_sides,
        include_bottom="bottom" not in exclude_sides,
      )

      if placement is None:
        continue

      # Check if this placement has any missing context quadrants
      new_missing = self._find_missing_context_quadrants(placement)

      if not new_missing:
        # Found a valid placement!
        return placement

      # If allow_expansion and fewer missing quadrants, try expansion
      if allow_expansion and len(new_missing) < len(missing):
        expanded = self._expand_to_cover_missing(placement, new_missing)
        if expanded is not None:
          return expanded

    # Last resort: try placements that sacrifice context to avoid missing quadrants
    # This may create seams but is better than not being able to generate at all
    best_placement = self._try_seam_tolerant_placement(problem_sides)
    if best_placement is not None:
      return best_placement

    return None

  def _try_seam_tolerant_placement(
    self, problem_sides: set[str]
  ) -> TemplatePlacement | None:
    """
    Try to find a placement that avoids missing context quadrants,
    even if it might create seams with generated neighbors.

    This is a last resort when no seam-free placement exists.
    """
    margin_x = TEMPLATE_SIZE - self.region.width
    margin_y = TEMPLATE_SIZE - self.region.height

    # Determine which sides have generated content
    has_left_gen = self._has_generated_context("left")
    has_right_gen = self._has_generated_context("right")
    has_top_gen = self._has_generated_context("top")
    has_bottom_gen = self._has_generated_context("bottom")

    # For each problem side, we want to position to EXCLUDE that side's context
    # even if it means creating a seam

    # Try different positions that avoid problem sides
    positions_to_try = []

    # If left is problematic, push infill to left (exclude left context)
    if "left" in problem_sides:
      # Position infill at left, include right context if available
      infill_x = 0
      if has_top_gen and "top" not in problem_sides:
        infill_y = margin_y  # Include top
      elif has_bottom_gen and "bottom" not in problem_sides:
        infill_y = 0  # Include bottom
      else:
        infill_y = 0
      positions_to_try.append((infill_x, infill_y))

    # If right is problematic, push infill to right (exclude right context)
    if "right" in problem_sides:
      infill_x = margin_x
      if has_top_gen and "top" not in problem_sides:
        infill_y = margin_y
      elif has_bottom_gen and "bottom" not in problem_sides:
        infill_y = 0
      else:
        infill_y = 0
      positions_to_try.append((infill_x, infill_y))

    # If top is problematic, push infill to top (exclude top context)
    if "top" in problem_sides:
      infill_y = 0
      if has_right_gen and "right" not in problem_sides:
        infill_x = 0  # Include right
      elif has_left_gen and "left" not in problem_sides:
        infill_x = margin_x  # Include left
      else:
        infill_x = 0
      positions_to_try.append((infill_x, infill_y))

    # If bottom is problematic, push infill to bottom
    if "bottom" in problem_sides:
      infill_y = margin_y
      if has_right_gen and "right" not in problem_sides:
        infill_x = 0
      elif has_left_gen and "left" not in problem_sides:
        infill_x = margin_x
      else:
        infill_x = 0
      positions_to_try.append((infill_x, infill_y))

    # Also try all four corners to maximize options
    corners = [
      (0, 0),  # Top-left
      (margin_x, 0),  # Top-right
      (0, margin_y),  # Bottom-left
      (margin_x, margin_y),  # Bottom-right
    ]
    positions_to_try.extend(corners)

    # Try each position
    for infill_x, infill_y in positions_to_try:
      world_offset_x = self.region.x - infill_x
      world_offset_y = self.region.y - infill_y

      placement = TemplatePlacement(
        infill_x=infill_x,
        infill_y=infill_y,
        world_offset_x=world_offset_x,
        world_offset_y=world_offset_y,
      )
      placement._infill_width = self.region.width
      placement._infill_height = self.region.height

      # Check for missing context quadrants (skip seam check)
      missing = self._find_missing_context_quadrants(placement)

      if not missing:
        # Found a valid placement (may have seams but no missing context)
        return placement

    return None

  def _has_generated_context(self, side: str) -> bool:
    """Check if there are generated pixels adjacent to the infill region on the given side."""
    # Note: Python's // does floor division, so negative coords work correctly
    # e.g., -1 // 512 = -1, -512 // 512 = -1, -513 // 512 = -2

    if side == "left":
      # Check quadrants to the left of the region
      check_x = self.region.x - 1
      qx = check_x // QUADRANT_SIZE
      # Check all quadrants along the left edge
      start_qy = self.region.y // QUADRANT_SIZE
      end_qy = (self.region.bottom - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qy in range(start_qy, end_qy + 1))

    elif side == "right":
      check_x = self.region.right
      qx = check_x // QUADRANT_SIZE
      start_qy = self.region.y // QUADRANT_SIZE
      end_qy = (self.region.bottom - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qy in range(start_qy, end_qy + 1))

    elif side == "top":
      check_y = self.region.y - 1
      qy = check_y // QUADRANT_SIZE
      start_qx = self.region.x // QUADRANT_SIZE
      end_qx = (self.region.right - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qx in range(start_qx, end_qx + 1))

    elif side == "bottom":
      check_y = self.region.bottom
      qy = check_y // QUADRANT_SIZE
      start_qx = self.region.x // QUADRANT_SIZE
      end_qx = (self.region.right - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qx in range(start_qx, end_qx + 1))

    return False

  def _validate_placement_seams(self, placement: TemplatePlacement) -> tuple[bool, str]:
    """
    Validate that a placement doesn't create seams.

    A seam would occur if the infill region touches the template edge
    AND there are generated pixels beyond that edge.

    Returns:
      Tuple of (is_valid, error_message)
    """
    # Check left edge
    if placement.infill_x == 0:
      if self._has_generated_context("left"):
        return False, "Would create seam with generated pixels on left"

    # Check right edge
    if placement.infill_x + self.region.width == TEMPLATE_SIZE:
      if self._has_generated_context("right"):
        return False, "Would create seam with generated pixels on right"

    # Check top edge
    if placement.infill_y == 0:
      if self._has_generated_context("top"):
        return False, "Would create seam with generated pixels on top"

    # Check bottom edge
    if placement.infill_y + self.region.height == TEMPLATE_SIZE:
      if self._has_generated_context("bottom"):
        return False, "Would create seam with generated pixels on bottom"

    return True, ""

  def _find_missing_context_quadrants(
    self, placement: TemplatePlacement
  ) -> list[tuple[int, int]]:
    """
    Find context quadrants that don't have generated pixels.

    Returns list of (qx, qy) positions that are in the template but not
    in the infill region and don't have generations.
    """
    missing = []

    # Calculate which quadrants the template covers
    template_world_left = placement.world_offset_x
    template_world_right = placement.world_offset_x + TEMPLATE_SIZE
    template_world_top = placement.world_offset_y
    template_world_bottom = placement.world_offset_y + TEMPLATE_SIZE

    start_qx = template_world_left // QUADRANT_SIZE
    end_qx = (template_world_right - 1) // QUADRANT_SIZE
    start_qy = template_world_top // QUADRANT_SIZE
    end_qy = (template_world_bottom - 1) // QUADRANT_SIZE

    # Infill quadrants
    infill_quadrants = set(self.region.overlapping_quadrants())

    for qx in range(start_qx, end_qx + 1):
      for qy in range(start_qy, end_qy + 1):
        if (qx, qy) not in infill_quadrants:
          # This is a context quadrant - must have generation
          if not self.has_generation(qx, qy):
            missing.append((qx, qy))

    return missing

  def _expand_to_cover_missing(
    self,
    placement: TemplatePlacement,
    missing: list[tuple[int, int]],
  ) -> TemplatePlacement | None:
    """
    Try to expand the infill region to cover missing context quadrants.

    The expanded region must still fit within the template and not exceed
    the maximum allowed size.

    Returns:
      New TemplatePlacement with expanded infill, or None if expansion not possible
    """
    # Get current infill quadrants
    primary_quadrants = self.region.overlapping_quadrants()

    # Combine primary and missing to get all quadrants we need to cover
    all_quadrants = set(primary_quadrants + missing)

    # Find bounds of expanded region
    min_qx = min(q[0] for q in all_quadrants)
    max_qx = max(q[0] for q in all_quadrants)
    min_qy = min(q[1] for q in all_quadrants)
    max_qy = max(q[1] for q in all_quadrants)

    # Create expanded region
    expanded_region = InfillRegion(
      x=min_qx * QUADRANT_SIZE,
      y=min_qy * QUADRANT_SIZE,
      width=(max_qx - min_qx + 1) * QUADRANT_SIZE,
      height=(max_qy - min_qy + 1) * QUADRANT_SIZE,
    )

    # Check if expanded region is valid size
    if not expanded_region.is_valid_size():
      self._last_validation_error = (
        f"Cannot expand infill to cover missing quadrants: "
        f"expanded region would be {expanded_region.area} pixels "
        f"(max: {MAX_INFILL_AREA})"
      )
      return None

    # Create a new builder for the expanded region to find its placement
    expanded_builder = TemplateBuilder(expanded_region, self.has_generation)
    expanded_placement = expanded_builder.find_optimal_placement(allow_expansion=False)

    if expanded_placement is None:
      self._last_validation_error = expanded_builder._last_validation_error
      return None

    # Track primary vs padding quadrants
    expanded_placement._primary_quadrants = list(primary_quadrants)
    expanded_placement._padding_quadrants = list(missing)
    expanded_placement._expanded_region = expanded_region

    return expanded_placement

  def build(
    self,
    border_width: int = 2,
    allow_expansion: bool = False,
  ) -> tuple[Image.Image, TemplatePlacement] | None:
    """
    Build the template image.

    Args:
      border_width: Width of the red border around the infill region
      allow_expansion: If True, automatically expand infill region to cover
                       missing context quadrants

    Returns:
      Tuple of (template_image, placement) or None if no valid placement exists
    """
    if self.get_render is None or self.get_generation is None:
      raise ValueError("get_render and get_generation must be provided to build")

    placement = self.find_optimal_placement(allow_expansion=allow_expansion)
    if placement is None:
      return None

    # Determine the effective infill region (may be expanded)
    if placement._expanded_region is not None:
      effective_region = placement._expanded_region
    else:
      effective_region = self.region

    # Create template image
    template = Image.new("RGBA", (TEMPLATE_SIZE, TEMPLATE_SIZE), (0, 0, 0, 0))

    # Determine which quadrants we need to fetch
    # The template covers world coordinates:
    #   x: [world_offset_x, world_offset_x + 1024)
    #   y: [world_offset_y, world_offset_y + 1024)

    template_world_left = placement.world_offset_x
    template_world_right = placement.world_offset_x + TEMPLATE_SIZE
    template_world_top = placement.world_offset_y
    template_world_bottom = placement.world_offset_y + TEMPLATE_SIZE

    # Find all quadrants that overlap with the template
    start_qx = template_world_left // QUADRANT_SIZE
    end_qx = (template_world_right - 1) // QUADRANT_SIZE
    start_qy = template_world_top // QUADRANT_SIZE
    end_qy = (template_world_bottom - 1) // QUADRANT_SIZE

    # Infill quadrants (will use render) - use effective region for expanded infills
    infill_quadrants = set(effective_region.overlapping_quadrants())

    # Fill in the template
    for qx in range(start_qx, end_qx + 1):
      for qy in range(start_qy, end_qy + 1):
        # Calculate where this quadrant appears in the template
        quad_world_x = qx * QUADRANT_SIZE
        quad_world_y = qy * QUADRANT_SIZE

        # Position in template coordinates
        template_x = quad_world_x - template_world_left
        template_y = quad_world_y - template_world_top

        # Determine source image
        if (qx, qy) in infill_quadrants:
          # Use render for infill quadrants
          quad_img = self.get_render(qx, qy)
          source_type = "render"
          if quad_img is None:
            continue
        else:
          # Use generation for context quadrants
          quad_img = self.get_generation(qx, qy)
          source_type = "generation"
          if quad_img is None:
            continue

        # Check quadrant image size and fix if needed
        img_w, img_h = quad_img.size
        expected_size = (QUADRANT_SIZE, QUADRANT_SIZE)

        if (img_w, img_h) != expected_size:
          # Handle oversized images (e.g., full tiles saved as quadrants)
          if img_w == QUADRANT_SIZE * 2 and img_h == QUADRANT_SIZE * 2:
            # This is a full tile (1024x1024) - extract the correct quadrant
            # Determine which quadrant of the tile this should be
            # based on quadrant coordinates (even/odd)
            dx = qx % 2  # 0 for left, 1 for right
            dy = qy % 2  # 0 for top, 1 for bottom
            crop_x = dx * QUADRANT_SIZE
            crop_y = dy * QUADRANT_SIZE
            print(
              f"   ‚ö†Ô∏è Quadrant ({qx}, {qy}) [{source_type}]: "
              f"FIXING oversized {quad_img.size} -> extracting ({dx},{dy}) portion"
            )
            quad_img = quad_img.crop(
              (crop_x, crop_y, crop_x + QUADRANT_SIZE, crop_y + QUADRANT_SIZE)
            )
          else:
            print(
              f"   ‚ö†Ô∏è Quadrant ({qx}, {qy}) [{source_type}]: "
              f"UNEXPECTED size={quad_img.size} (expected {expected_size}), "
              f"template_pos=({template_x}, {template_y})"
            )
        else:
          print(
            f"   üì¶ Quadrant ({qx}, {qy}) [{source_type}]: "
            f"size={quad_img.size}, template_pos=({template_x}, {template_y})"
          )

        if quad_img.mode != "RGBA":
          quad_img = quad_img.convert("RGBA")

        # Calculate crop region if quadrant extends outside template
        crop_left = max(0, -template_x)
        crop_top = max(0, -template_y)
        crop_right = min(QUADRANT_SIZE, TEMPLATE_SIZE - template_x)
        crop_bottom = min(QUADRANT_SIZE, TEMPLATE_SIZE - template_y)

        if crop_left < crop_right and crop_top < crop_bottom:
          cropped = quad_img.crop((crop_left, crop_top, crop_right, crop_bottom))
          paste_x = max(0, template_x)
          paste_y = max(0, template_y)
          template.paste(cropped, (paste_x, paste_y))

    # Now we need to handle partial quadrant overlaps with the infill region
    # If the infill region doesn't align with quadrant boundaries,
    # we need to carefully composite render pixels only in the infill area
    self._apply_infill_mask(template, placement)

    # Draw red border around infill region
    template = self._draw_border(template, placement, border_width)

    return template, placement

  def _apply_infill_mask(
    self, template: Image.Image, placement: TemplatePlacement
  ) -> None:
    """
    Apply a mask to ensure only the infill region has render pixels.

    For quadrants that partially overlap the infill region, we need to
    composite render pixels (infill area) with generation pixels (context area).
    """
    # This is already handled by the quadrant-based approach when infill aligns
    # with quadrant boundaries. For non-aligned infills, we'd need more complex
    # masking. For now, we assume quadrant-aligned infills.
    pass

  def _draw_border(
    self,
    template: Image.Image,
    placement: TemplatePlacement,
    border_width: int,
  ) -> Image.Image:
    """Draw a red border around the infill region."""
    result = template.copy()
    draw = ImageDraw.Draw(result)

    red = (255, 0, 0, 255)

    left = placement.infill_x
    top = placement.infill_y
    right = placement.infill_x + self.region.width
    bottom = placement.infill_y + self.region.height

    for i in range(border_width):
      draw.rectangle(
        [left + i, top + i, right - 1 - i, bottom - 1 - i],
        outline=red,
        fill=None,
      )

    return result

  def get_validation_info(self) -> dict:
    """Get detailed validation information for debugging."""
    return {
      "region": str(self.region),
      "area": self.region.area,
      "max_area": MAX_INFILL_AREA,
      "valid_size": self.region.is_valid_size(),
      "has_left_gen": self._has_generated_context("left"),
      "has_right_gen": self._has_generated_context("right"),
      "has_top_gen": self._has_generated_context("top"),
      "has_bottom_gen": self._has_generated_context("bottom"),
      "overlapping_quadrants": self.region.overlapping_quadrants(),
      "last_validation_error": self._last_validation_error,
    }


def validate_quadrant_selection(
  quadrants: list[tuple[int, int]],
  has_generation: Callable[[int, int], bool],
  allow_expansion: bool = False,
) -> tuple[bool, str, TemplatePlacement | None]:
  """
  Validate a quadrant selection and find optimal placement.

  This is a convenience function for the common case of selecting
  whole quadrants for infill.

  Special handling for full tiles (2x2):
  - If some quadrants already have generations, reduce to just the missing ones
  - The generated quadrants become context for the missing ones

  Args:
    quadrants: List of (qx, qy) quadrant positions to infill
    has_generation: Callable to check if a quadrant has generation
    allow_expansion: If True, automatically expand infill region to cover
                     missing context quadrants (they'll be filled with render
                     pixels and discarded after generation)

  Returns:
    Tuple of (is_valid, message, placement)
  """
  if not quadrants:
    return False, "No quadrants selected", None

  # Check that quadrants form a rectangle
  min_qx = min(q[0] for q in quadrants)
  max_qx = max(q[0] for q in quadrants)
  min_qy = min(q[1] for q in quadrants)
  max_qy = max(q[1] for q in quadrants)

  expected_count = (max_qx - min_qx + 1) * (max_qy - min_qy + 1)
  if len(quadrants) != expected_count:
    return False, "Quadrants must form a contiguous rectangle", None

  # Check all expected positions are present
  expected = set()
  for qx in range(min_qx, max_qx + 1):
    for qy in range(min_qy, max_qy + 1):
      expected.add((qx, qy))

  if set(quadrants) != expected:
    return False, "Quadrants must form a contiguous rectangle", None

  # Create infill region and builder
  region = InfillRegion.from_quadrants(quadrants)

  if not region.is_valid_size():
    return (
      False,
      f"Selection too large: {region.area} pixels (max: {MAX_INFILL_AREA} or full tile)",
      None,
    )

  # For full tiles (2x2), check if some quadrants are already generated
  # If so, reduce the selection to just the non-generated quadrants
  if region.is_full_tile():
    # Check which quadrants already have generations
    generated_quadrants = [q for q in quadrants if has_generation(q[0], q[1])]
    non_generated_quadrants = [q for q in quadrants if not has_generation(q[0], q[1])]

    if len(generated_quadrants) == 4:
      # All quadrants already generated - nothing to do
      return False, "All quadrants already have generations", None

    if len(generated_quadrants) > 0:
      # Some quadrants are generated - reduce selection to just the missing ones
      # The generated quadrants will serve as context
      print(
        f"   üìã {len(generated_quadrants)} of 4 quadrants already generated, "
        f"will generate remaining {len(non_generated_quadrants)}"
      )

      # Recursively validate the reduced selection
      return validate_quadrant_selection(
        non_generated_quadrants, has_generation, allow_expansion
      )

    # No quadrants generated yet - check for external neighbors
    has_any_gen_neighbor = False
    for qx, qy in quadrants:
      # Check all 4 sides of each edge quadrant
      if qx == min(q[0] for q in quadrants):  # Left edge
        if has_generation(qx - 1, qy):
          has_any_gen_neighbor = True
          break
      if qx == max(q[0] for q in quadrants):  # Right edge
        if has_generation(qx + 1, qy):
          has_any_gen_neighbor = True
          break
      if qy == min(q[1] for q in quadrants):  # Top edge
        if has_generation(qx, qy - 1):
          has_any_gen_neighbor = True
          break
      if qy == max(q[1] for q in quadrants):  # Bottom edge
        if has_generation(qx, qy + 1):
          has_any_gen_neighbor = True
          break

    if has_any_gen_neighbor:
      return (
        False,
        "Full tile (2x2) selection cannot have generated neighbors (would create seams)",
        None,
      )

    # Full tile with no neighbors - valid, place at origin
    placement = TemplatePlacement(
      infill_x=0,
      infill_y=0,
      world_offset_x=region.x,
      world_offset_y=region.y,
    )
    placement._infill_width = region.width
    placement._infill_height = region.height
    placement._primary_quadrants = list(quadrants)
    return True, "Valid selection (full tile)", placement

  builder = TemplateBuilder(region, has_generation)
  placement = builder.find_optimal_placement(allow_expansion=allow_expansion)

  if placement is None:
    # Use the specific error from the builder if available
    info = builder.get_validation_info()
    if info["last_validation_error"]:
      return False, info["last_validation_error"], None
    # Fallback to generic messages
    if info["has_left_gen"]:
      return False, "Would create seam with generated pixels on left", None
    if info["has_right_gen"]:
      return False, "Would create seam with generated pixels on right", None
    if info["has_top_gen"]:
      return False, "Would create seam with generated pixels on top", None
    if info["has_bottom_gen"]:
      return False, "Would create seam with generated pixels on bottom", None
    return False, "No valid placement found", None

  # Set primary quadrants if not already set (by expansion)
  if not placement._primary_quadrants:
    placement._primary_quadrants = list(quadrants)

  # Build appropriate message
  if placement.is_expanded:
    padding_str = ", ".join(f"({qx}, {qy})" for qx, qy in placement._padding_quadrants)
    return True, f"Valid selection (expanded to cover: {padding_str})", placement

  return True, "Valid selection", placement


# =============================================================================
# Testing
# =============================================================================


def _test_basic():
  """Run basic tests."""
  print("=" * 60)
  print("Testing InfillRegion")
  print("=" * 60)

  # Test single quadrant
  r1 = InfillRegion.from_quadrant(0, 0)
  print(f"\nSingle quadrant (0,0): {r1}")
  print(f"  Area: {r1.area} (valid: {r1.is_valid_size()})")
  print(f"  Overlapping quadrants: {r1.overlapping_quadrants()}")

  # Test 2x1 quadrants
  r2 = InfillRegion.from_quadrants([(0, 0), (1, 0)])
  print(f"\n2x1 quadrants: {r2}")
  print(f"  Area: {r2.area} (valid: {r2.is_valid_size()})")
  print(f"  Overlapping quadrants: {r2.overlapping_quadrants()}")

  # Test 2x2 quadrants (should be invalid - 100% of tile)
  r3 = InfillRegion.from_quadrants([(0, 0), (1, 0), (0, 1), (1, 1)])
  print(f"\n2x2 quadrants: {r3}")
  print(f"  Area: {r3.area} (valid: {r3.is_valid_size()})")

  print("\n" + "=" * 60)
  print("Testing TemplateBuilder")
  print("=" * 60)

  # Create a mock has_generation function
  # Simulate: quadrants (0,0) and (1,0) are NOT generated, (0,1) and (1,1) ARE generated
  generated = {(0, 1), (1, 1), (2, 0), (2, 1)}

  def has_gen(qx, qy):
    return (qx, qy) in generated

  # Test 1: Select quadrant (1, 0) with generated neighbor below
  region = InfillRegion.from_quadrant(1, 0)
  builder = TemplateBuilder(region, has_gen)
  info = builder.get_validation_info()
  placement = builder.find_optimal_placement()

  print("\nTest 1: Select quadrant (1, 0)")
  print(f"  Info: {info}")
  print(f"  Placement: {placement}")
  if placement:
    print(f"    Infill at: ({placement.infill_x}, {placement.infill_y})")
    print(f"    World offset: ({placement.world_offset_x}, {placement.world_offset_y})")

  # Test 2: Select quadrant (0, 1) surrounded by generated
  region2 = InfillRegion.from_quadrant(0, 1)
  builder2 = TemplateBuilder(region2, has_gen)
  info2 = builder2.get_validation_info()
  placement2 = builder2.find_optimal_placement()

  print("\nTest 2: Select quadrant (0, 1) - has generated neighbor to right")
  print(f"  Info: {info2}")
  print(f"  Placement: {placement2}")
  if placement2:
    print(f"    Infill at: ({placement2.infill_x}, {placement2.infill_y})")

  # Test 3: Validation convenience function
  print("\n" + "=" * 60)
  print("Testing validate_quadrant_selection")
  print("=" * 60)

  # Valid selection
  valid, msg, p = validate_quadrant_selection([(1, 0)], has_gen)
  print(f"\nSelect (1,0): valid={valid}, msg='{msg}'")

  # Invalid - non-contiguous
  valid, msg, p = validate_quadrant_selection([(0, 0), (1, 1)], has_gen)
  print(f"Select (0,0), (1,1) [diagonal]: valid={valid}, msg='{msg}'")

  # Valid 2x1
  valid, msg, p = validate_quadrant_selection([(0, 0), (1, 0)], has_gen)
  print(f"Select (0,0), (1,0) [2x1]: valid={valid}, msg='{msg}'")

  print("\n" + "=" * 60)
  print("All tests complete!")
  print("=" * 60)


if __name__ == "__main__":
  _test_basic()

```

I've added a fix that automatically handles oversized quadrant images. When a 1024x1024 image is detected (a full tile stored as a quadrant by mistake), it now extracts the correct 512x512 portion based on the quadrant's position.

For quadrant (-32, 43):
- `-32 % 2 = 0` ‚Üí left half of tile
- `43 % 2 = 1` ‚Üí bottom half of tile
- So it extracts the **bottom-left** 512x512 portion

Try running the generation again - you should see:
```
‚ö†Ô∏è Quadrant (-32, 43) [generation]: FIXING oversized (1024, 1024) -> extracting (0,1) portion
```

The template should now be built correctly with the right portion of that quadrant.

```plaintext
‚ö†Ô∏è Quadrant (-32, 43) [generation]: FIXING oversized (1024, 1024) -> extracting (0,1) portion
```

---

**User**

no - the quadrant is 1024x1024, we're not taking the top quarter of the quadrant we're resizing it to 512x512

---

**Cursor**

Got it! The quadrant image is just at the wrong resolution - it should be resized, not cropped. Let me fix that:

```python
"""
Generic infill template generation for arbitrary rectangular regions.

This module handles creating template images for infill generation where:
- The infill region is an arbitrary rectangle (up to 50% of tile area)
- Context is maximized by optimal placement within the template
- Edge constraints ensure no seams with generated neighbors

Key concepts:
- InfillRegion: A rectangular region to be filled with generated pixels
- TemplateSpec: Specification for how to build the template
- The template is always 1024x1024 pixels
- Quadrants (512x512) are the storage unit in the database

Usage:
  from isometric_nyc.e2e_generation.infill_template import (
      InfillRegion,
      TemplateBuilder,
  )

  # Create an infill region (e.g., a single quadrant)
  region = InfillRegion.from_quadrant(x=2, y=3)

  # Or create a custom rectangle
  region = InfillRegion(x=256, y=256, width=512, height=512)

  # Build template
  builder = TemplateBuilder(region, get_generation_func)
  template, bounds = builder.build()
"""

from dataclasses import dataclass
from typing import Callable

from PIL import Image, ImageDraw

# Template and quadrant dimensions
TEMPLATE_SIZE = 1024
QUADRANT_SIZE = 512
MAX_INFILL_AREA = TEMPLATE_SIZE * TEMPLATE_SIZE // 2  # 50% of template


@dataclass
class InfillRegion:
  """
  A rectangular region to be infilled.

  Coordinates are in "world" pixel space, where:
  - (0, 0) is the top-left of quadrant (0, 0)
  - x increases to the right
  - y increases downward
  - Each quadrant is 512x512 pixels
  """

  x: int  # World x coordinate (top-left of region)
  y: int  # World y coordinate (top-left of region)
  width: int  # Width in pixels
  height: int  # Height in pixels

  @classmethod
  def from_quadrant(cls, qx: int, qy: int) -> "InfillRegion":
    """Create an infill region for a single quadrant."""
    return cls(
      x=qx * QUADRANT_SIZE,
      y=qy * QUADRANT_SIZE,
      width=QUADRANT_SIZE,
      height=QUADRANT_SIZE,
    )

  @classmethod
  def from_quadrants(cls, quadrants: list[tuple[int, int]]) -> "InfillRegion":
    """
    Create an infill region covering multiple quadrants.

    The quadrants must form a contiguous rectangle.
    """
    if not quadrants:
      raise ValueError("At least one quadrant required")

    min_qx = min(q[0] for q in quadrants)
    max_qx = max(q[0] for q in quadrants)
    min_qy = min(q[1] for q in quadrants)
    max_qy = max(q[1] for q in quadrants)

    return cls(
      x=min_qx * QUADRANT_SIZE,
      y=min_qy * QUADRANT_SIZE,
      width=(max_qx - min_qx + 1) * QUADRANT_SIZE,
      height=(max_qy - min_qy + 1) * QUADRANT_SIZE,
    )

  @property
  def area(self) -> int:
    """Total area in pixels."""
    return self.width * self.height

  @property
  def right(self) -> int:
    """Right edge x coordinate."""
    return self.x + self.width

  @property
  def bottom(self) -> int:
    """Bottom edge y coordinate."""
    return self.y + self.height

  def is_valid_size(self) -> bool:
    """Check if the region is within the allowed size (‚â§50% or exactly 100% of template)."""
    # Allow up to 50% OR exactly 100% (full tile)
    # Full tile is valid only if there are no generated neighbors (checked separately)
    return self.area <= MAX_INFILL_AREA or self.is_full_tile()

  def is_full_tile(self) -> bool:
    """Check if this region is exactly a full tile (1024x1024)."""
    return self.width == TEMPLATE_SIZE and self.height == TEMPLATE_SIZE

  def overlapping_quadrants(self) -> list[tuple[int, int]]:
    """Get list of quadrant (qx, qy) positions that overlap with this region."""
    quadrants = []

    # Find quadrant range
    start_qx = self.x // QUADRANT_SIZE
    end_qx = (self.right - 1) // QUADRANT_SIZE
    start_qy = self.y // QUADRANT_SIZE
    end_qy = (self.bottom - 1) // QUADRANT_SIZE

    for qx in range(start_qx, end_qx + 1):
      for qy in range(start_qy, end_qy + 1):
        quadrants.append((qx, qy))

    return quadrants

  def __str__(self) -> str:
    return f"InfillRegion(x={self.x}, y={self.y}, w={self.width}, h={self.height})"


@dataclass
class TemplatePlacement:
  """
  Describes where to place the infill region within the template.

  The template is always 1024x1024. This specifies:
  - Where the infill region should be placed within it
  - The world coordinate offset for context pixels
  - Which quadrants are primary (user selected) vs padding (auto-expanded)
  """

  # Position of infill region within template (0-1024)
  infill_x: int
  infill_y: int

  # World coordinate of template's top-left corner
  world_offset_x: int
  world_offset_y: int

  @property
  def infill_right(self) -> int:
    return self.infill_x + self._infill_width

  @property
  def infill_bottom(self) -> int:
    return self.infill_y + self._infill_height

  def __post_init__(self):
    # These will be set by the builder
    self._infill_width = 0
    self._infill_height = 0
    # Primary quadrants are the user-selected ones
    # Padding quadrants are auto-added to cover missing context
    self._primary_quadrants: list[tuple[int, int]] = []
    self._padding_quadrants: list[tuple[int, int]] = []
    # The expanded infill region (if different from primary)
    self._expanded_region: InfillRegion | None = None

  @property
  def primary_quadrants(self) -> list[tuple[int, int]]:
    """Quadrants originally selected by user."""
    return self._primary_quadrants

  @property
  def padding_quadrants(self) -> list[tuple[int, int]]:
    """Quadrants auto-added to cover missing context."""
    return self._padding_quadrants

  @property
  def all_infill_quadrants(self) -> list[tuple[int, int]]:
    """All quadrants that will be filled with render pixels."""
    return self._primary_quadrants + self._padding_quadrants

  @property
  def is_expanded(self) -> bool:
    """Whether the infill region was expanded to cover missing context."""
    return len(self._padding_quadrants) > 0


class TemplateBuilder:
  """
  Builds template images for infill generation.

  Handles:
  - Optimal placement of infill region to maximize context
  - Validation of edge constraints
  - Assembly of template from quadrant data
  """

  def __init__(
    self,
    infill_region: InfillRegion,
    has_generation: Callable[[int, int], bool],
    get_render: Callable[[int, int], Image.Image | None] | None = None,
    get_generation: Callable[[int, int], Image.Image | None] | None = None,
  ):
    """
    Initialize the template builder.

    Args:
      infill_region: The region to be infilled
      has_generation: Callable(qx, qy) -> bool to check if quadrant has generation
      get_render: Callable(qx, qy) -> Image to get render for quadrant
      get_generation: Callable(qx, qy) -> Image to get generation for quadrant
    """
    self.region = infill_region
    self.has_generation = has_generation
    self.get_render = get_render
    self.get_generation = get_generation
    self._last_validation_error = ""

    # Validate region size
    if not infill_region.is_valid_size():
      raise ValueError(
        f"Infill region too large: {infill_region.area} pixels (max: {MAX_INFILL_AREA})"
      )

  def find_optimal_placement(
    self, allow_expansion: bool = False
  ) -> TemplatePlacement | None:
    """
    Find the optimal placement for the infill region within the template.

    Args:
      allow_expansion: If True, automatically expand infill region to cover
                       missing context quadrants (they'll be filled with render
                       pixels and discarded after generation)

    Returns None if no valid placement exists (would create seams).

    The strategy:
    1. Try to maximize context by checking generated neighbors
    2. Position infill to include as much context as possible
    3. Validate that edges touching template boundary have no generated neighbors
    4. If placement has missing context, try alternative placements
    5. If allow_expansion and context quadrants are still missing, expand the infill
    """
    # Try multiple placement strategies
    # Strategy 1: Maximize context (original approach)
    # Strategy 2+: Exclude problematic sides that would pull in non-generated quadrants

    placement = self._try_placement_with_context_preferences(
      include_left=True,
      include_right=True,
      include_top=True,
      include_bottom=True,
    )

    if placement is not None:
      missing = self._find_missing_context_quadrants(placement)
      if not missing:
        return placement

      # There are missing context quadrants - try alternative placements
      # that exclude the sides causing the problem
      alternative = self._try_alternative_placements(missing, allow_expansion)
      if alternative is not None:
        return alternative

      # All alternatives failed, try expansion on the original placement
      if allow_expansion:
        expanded_placement = self._expand_to_cover_missing(placement, missing)
        if expanded_placement is not None:
          return expanded_placement

      # Everything failed
      missing_str = ", ".join(f"({qx}, {qy})" for qx, qy in missing)
      self._last_validation_error = (
        f"Context quadrants missing generations: {missing_str}"
      )
      return None

    return placement

  def _try_placement_with_context_preferences(
    self,
    include_left: bool,
    include_right: bool,
    include_top: bool,
    include_bottom: bool,
  ) -> TemplatePlacement | None:
    """
    Try to find a valid placement with given context preferences.

    Args:
      include_left: Whether to try to include left context
      include_right: Whether to try to include right context
      include_top: Whether to try to include top context
      include_bottom: Whether to try to include bottom context

    Returns:
      TemplatePlacement if valid (passes seam check), None otherwise
    """
    # Calculate available margin on each side
    margin_x = TEMPLATE_SIZE - self.region.width
    margin_y = TEMPLATE_SIZE - self.region.height

    # Check for generated context on each side of the infill region
    has_left_gen = self._has_generated_context("left") if include_left else False
    has_right_gen = self._has_generated_context("right") if include_right else False
    has_top_gen = self._has_generated_context("top") if include_top else False
    has_bottom_gen = self._has_generated_context("bottom") if include_bottom else False

    # Determine infill position based on context preferences
    # Horizontal positioning
    if has_left_gen and has_right_gen:
      infill_x = margin_x // 2
    elif has_left_gen:
      infill_x = margin_x
    elif has_right_gen:
      infill_x = 0
    else:
      # No horizontal context to include - position to avoid seams
      # If we're NOT including left but there IS generated content on left,
      # push infill to include right side (avoid left seam)
      actual_left_gen = self._has_generated_context("left")
      actual_right_gen = self._has_generated_context("right")
      if actual_right_gen and not actual_left_gen:
        infill_x = 0
      elif actual_left_gen and not actual_right_gen:
        infill_x = margin_x
      else:
        infill_x = 0

    # Vertical positioning
    if has_top_gen and has_bottom_gen:
      infill_y = margin_y // 2
    elif has_top_gen:
      infill_y = margin_y
    elif has_bottom_gen:
      infill_y = 0
    else:
      # No vertical context to include - position to avoid seams
      actual_top_gen = self._has_generated_context("top")
      actual_bottom_gen = self._has_generated_context("bottom")
      if actual_bottom_gen and not actual_top_gen:
        infill_y = 0
      elif actual_top_gen and not actual_bottom_gen:
        infill_y = margin_y
      else:
        infill_y = 0

    # Calculate world offset
    world_offset_x = self.region.x - infill_x
    world_offset_y = self.region.y - infill_y

    placement = TemplatePlacement(
      infill_x=infill_x,
      infill_y=infill_y,
      world_offset_x=world_offset_x,
      world_offset_y=world_offset_y,
    )
    placement._infill_width = self.region.width
    placement._infill_height = self.region.height

    # Validate the placement (seams check)
    is_valid, error = self._validate_placement_seams(placement)
    if not is_valid:
      self._last_validation_error = error
      return None

    return placement

  def _try_alternative_placements(
    self,
    missing: list[tuple[int, int]],
    allow_expansion: bool,
  ) -> TemplatePlacement | None:
    """
    Try alternative placements that avoid missing context quadrants.

    When the optimal placement would include non-generated context quadrants,
    we try placements that exclude certain sides to avoid those quadrants.
    """
    # Determine which sides are causing problems
    # Missing quadrants are in certain positions relative to the infill
    infill_quadrants = set(self.region.overlapping_quadrants())
    infill_min_qx = min(q[0] for q in infill_quadrants)
    infill_max_qx = max(q[0] for q in infill_quadrants)
    infill_min_qy = min(q[1] for q in infill_quadrants)
    infill_max_qy = max(q[1] for q in infill_quadrants)

    problem_sides = set()
    for qx, qy in missing:
      if qx < infill_min_qx:
        problem_sides.add("left")
      if qx > infill_max_qx:
        problem_sides.add("right")
      if qy < infill_min_qy:
        problem_sides.add("top")
      if qy > infill_max_qy:
        problem_sides.add("bottom")

    # Try placements that exclude problem sides
    # Generate combinations of sides to exclude
    side_combinations = []

    # First, try excluding just the problem sides
    if problem_sides:
      side_combinations.append(problem_sides)

    # Then try excluding individual problem sides
    for side in problem_sides:
      side_combinations.append({side})

    # Try each combination
    for exclude_sides in side_combinations:
      placement = self._try_placement_with_context_preferences(
        include_left="left" not in exclude_sides,
        include_right="right" not in exclude_sides,
        include_top="top" not in exclude_sides,
        include_bottom="bottom" not in exclude_sides,
      )

      if placement is None:
        continue

      # Check if this placement has any missing context quadrants
      new_missing = self._find_missing_context_quadrants(placement)

      if not new_missing:
        # Found a valid placement!
        return placement

      # If allow_expansion and fewer missing quadrants, try expansion
      if allow_expansion and len(new_missing) < len(missing):
        expanded = self._expand_to_cover_missing(placement, new_missing)
        if expanded is not None:
          return expanded

    # Last resort: try placements that sacrifice context to avoid missing quadrants
    # This may create seams but is better than not being able to generate at all
    best_placement = self._try_seam_tolerant_placement(problem_sides)
    if best_placement is not None:
      return best_placement

    return None

  def _try_seam_tolerant_placement(
    self, problem_sides: set[str]
  ) -> TemplatePlacement | None:
    """
    Try to find a placement that avoids missing context quadrants,
    even if it might create seams with generated neighbors.

    This is a last resort when no seam-free placement exists.
    """
    margin_x = TEMPLATE_SIZE - self.region.width
    margin_y = TEMPLATE_SIZE - self.region.height

    # Determine which sides have generated content
    has_left_gen = self._has_generated_context("left")
    has_right_gen = self._has_generated_context("right")
    has_top_gen = self._has_generated_context("top")
    has_bottom_gen = self._has_generated_context("bottom")

    # For each problem side, we want to position to EXCLUDE that side's context
    # even if it means creating a seam

    # Try different positions that avoid problem sides
    positions_to_try = []

    # If left is problematic, push infill to left (exclude left context)
    if "left" in problem_sides:
      # Position infill at left, include right context if available
      infill_x = 0
      if has_top_gen and "top" not in problem_sides:
        infill_y = margin_y  # Include top
      elif has_bottom_gen and "bottom" not in problem_sides:
        infill_y = 0  # Include bottom
      else:
        infill_y = 0
      positions_to_try.append((infill_x, infill_y))

    # If right is problematic, push infill to right (exclude right context)
    if "right" in problem_sides:
      infill_x = margin_x
      if has_top_gen and "top" not in problem_sides:
        infill_y = margin_y
      elif has_bottom_gen and "bottom" not in problem_sides:
        infill_y = 0
      else:
        infill_y = 0
      positions_to_try.append((infill_x, infill_y))

    # If top is problematic, push infill to top (exclude top context)
    if "top" in problem_sides:
      infill_y = 0
      if has_right_gen and "right" not in problem_sides:
        infill_x = 0  # Include right
      elif has_left_gen and "left" not in problem_sides:
        infill_x = margin_x  # Include left
      else:
        infill_x = 0
      positions_to_try.append((infill_x, infill_y))

    # If bottom is problematic, push infill to bottom
    if "bottom" in problem_sides:
      infill_y = margin_y
      if has_right_gen and "right" not in problem_sides:
        infill_x = 0
      elif has_left_gen and "left" not in problem_sides:
        infill_x = margin_x
      else:
        infill_x = 0
      positions_to_try.append((infill_x, infill_y))

    # Also try all four corners to maximize options
    corners = [
      (0, 0),  # Top-left
      (margin_x, 0),  # Top-right
      (0, margin_y),  # Bottom-left
      (margin_x, margin_y),  # Bottom-right
    ]
    positions_to_try.extend(corners)

    # Try each position
    for infill_x, infill_y in positions_to_try:
      world_offset_x = self.region.x - infill_x
      world_offset_y = self.region.y - infill_y

      placement = TemplatePlacement(
        infill_x=infill_x,
        infill_y=infill_y,
        world_offset_x=world_offset_x,
        world_offset_y=world_offset_y,
      )
      placement._infill_width = self.region.width
      placement._infill_height = self.region.height

      # Check for missing context quadrants (skip seam check)
      missing = self._find_missing_context_quadrants(placement)

      if not missing:
        # Found a valid placement (may have seams but no missing context)
        return placement

    return None

  def _has_generated_context(self, side: str) -> bool:
    """Check if there are generated pixels adjacent to the infill region on the given side."""
    # Note: Python's // does floor division, so negative coords work correctly
    # e.g., -1 // 512 = -1, -512 // 512 = -1, -513 // 512 = -2

    if side == "left":
      # Check quadrants to the left of the region
      check_x = self.region.x - 1
      qx = check_x // QUADRANT_SIZE
      # Check all quadrants along the left edge
      start_qy = self.region.y // QUADRANT_SIZE
      end_qy = (self.region.bottom - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qy in range(start_qy, end_qy + 1))

    elif side == "right":
      check_x = self.region.right
      qx = check_x // QUADRANT_SIZE
      start_qy = self.region.y // QUADRANT_SIZE
      end_qy = (self.region.bottom - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qy in range(start_qy, end_qy + 1))

    elif side == "top":
      check_y = self.region.y - 1
      qy = check_y // QUADRANT_SIZE
      start_qx = self.region.x // QUADRANT_SIZE
      end_qx = (self.region.right - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qx in range(start_qx, end_qx + 1))

    elif side == "bottom":
      check_y = self.region.bottom
      qy = check_y // QUADRANT_SIZE
      start_qx = self.region.x // QUADRANT_SIZE
      end_qx = (self.region.right - 1) // QUADRANT_SIZE
      return any(self.has_generation(qx, qy) for qx in range(start_qx, end_qx + 1))

    return False

  def _validate_placement_seams(self, placement: TemplatePlacement) -> tuple[bool, str]:
    """
    Validate that a placement doesn't create seams.

    A seam would occur if the infill region touches the template edge
    AND there are generated pixels beyond that edge.

    Returns:
      Tuple of (is_valid, error_message)
    """
    # Check left edge
    if placement.infill_x == 0:
      if self._has_generated_context("left"):
        return False, "Would create seam with generated pixels on left"

    # Check right edge
    if placement.infill_x + self.region.width == TEMPLATE_SIZE:
      if self._has_generated_context("right"):
        return False, "Would create seam with generated pixels on right"

    # Check top edge
    if placement.infill_y == 0:
      if self._has_generated_context("top"):
        return False, "Would create seam with generated pixels on top"

    # Check bottom edge
    if placement.infill_y + self.region.height == TEMPLATE_SIZE:
      if self._has_generated_context("bottom"):
        return False, "Would create seam with generated pixels on bottom"

    return True, ""

  def _find_missing_context_quadrants(
    self, placement: TemplatePlacement
  ) -> list[tuple[int, int]]:
    """
    Find context quadrants that don't have generated pixels.

    Returns list of (qx, qy) positions that are in the template but not
    in the infill region and don't have generations.
    """
    missing = []

    # Calculate which quadrants the template covers
    template_world_left = placement.world_offset_x
    template_world_right = placement.world_offset_x + TEMPLATE_SIZE
    template_world_top = placement.world_offset_y
    template_world_bottom = placement.world_offset_y + TEMPLATE_SIZE

    start_qx = template_world_left // QUADRANT_SIZE
    end_qx = (template_world_right - 1) // QUADRANT_SIZE
    start_qy = template_world_top // QUADRANT_SIZE
    end_qy = (template_world_bottom - 1) // QUADRANT_SIZE

    # Infill quadrants
    infill_quadrants = set(self.region.overlapping_quadrants())

    for qx in range(start_qx, end_qx + 1):
      for qy in range(start_qy, end_qy + 1):
        if (qx, qy) not in infill_quadrants:
          # This is a context quadrant - must have generation
          if not self.has_generation(qx, qy):
            missing.append((qx, qy))

    return missing

  def _expand_to_cover_missing(
    self,
    placement: TemplatePlacement,
    missing: list[tuple[int, int]],
  ) -> TemplatePlacement | None:
    """
    Try to expand the infill region to cover missing context quadrants.

    The expanded region must still fit within the template and not exceed
    the maximum allowed size.

    Returns:
      New TemplatePlacement with expanded infill, or None if expansion not possible
    """
    # Get current infill quadrants
    primary_quadrants = self.region.overlapping_quadrants()

    # Combine primary and missing to get all quadrants we need to cover
    all_quadrants = set(primary_quadrants + missing)

    # Find bounds of expanded region
    min_qx = min(q[0] for q in all_quadrants)
    max_qx = max(q[0] for q in all_quadrants)
    min_qy = min(q[1] for q in all_quadrants)
    max_qy = max(q[1] for q in all_quadrants)

    # Create expanded region
    expanded_region = InfillRegion(
      x=min_qx * QUADRANT_SIZE,
      y=min_qy * QUADRANT_SIZE,
      width=(max_qx - min_qx + 1) * QUADRANT_SIZE,
      height=(max_qy - min_qy + 1) * QUADRANT_SIZE,
    )

    # Check if expanded region is valid size
    if not expanded_region.is_valid_size():
      self._last_validation_error = (
        f"Cannot expand infill to cover missing quadrants: "
        f"expanded region would be {expanded_region.area} pixels "
        f"(max: {MAX_INFILL_AREA})"
      )
      return None

    # Create a new builder for the expanded region to find its placement
    expanded_builder = TemplateBuilder(expanded_region, self.has_generation)
    expanded_placement = expanded_builder.find_optimal_placement(allow_expansion=False)

    if expanded_placement is None:
      self._last_validation_error = expanded_builder._last_validation_error
      return None

    # Track primary vs padding quadrants
    expanded_placement._primary_quadrants = list(primary_quadrants)
    expanded_placement._padding_quadrants = list(missing)
    expanded_placement._expanded_region = expanded_region

    return expanded_placement

  def build(
    self,
    border_width: int = 2,
    allow_expansion: bool = False,
  ) -> tuple[Image.Image, TemplatePlacement] | None:
    """
    Build the template image.

    Args:
      border_width: Width of the red border around the infill region
      allow_expansion: If True, automatically expand infill region to cover
                       missing context quadrants

    Returns:
      Tuple of (template_image, placement) or None if no valid placement exists
    """
    if self.get_render is None or self.get_generation is None:
      raise ValueError("get_render and get_generation must be provided to build")

    placement = self.find_optimal_placement(allow_expansion=allow_expansion)
    if placement is None:
      return None

    # Determine the effective infill region (may be expanded)
    if placement._expanded_region is not None:
      effective_region = placement._expanded_region
    else:
      effective_region = self.region

    # Create template image
    template = Image.new("RGBA", (TEMPLATE_SIZE, TEMPLATE_SIZE), (0, 0, 0, 0))

    # Determine which quadrants we need to fetch
    # The template covers world coordinates:
    #   x: [world_offset_x, world_offset_x + 1024)
    #   y: [world_offset_y, world_offset_y + 1024)

    template_world_left = placement.world_offset_x
    template_world_right = placement.world_offset_x + TEMPLATE_SIZE
    template_world_top = placement.world_offset_y
    template_world_bottom = placement.world_offset_y + TEMPLATE_SIZE

    # Find all quadrants that overlap with the template
    start_qx = template_world_left // QUADRANT_SIZE
    end_qx = (template_world_right - 1) // QUADRANT_SIZE
    start_qy = template_world_top // QUADRANT_SIZE
    end_qy = (template_world_bottom - 1) // QUADRANT_SIZE

    # Infill quadrants (will use render) - use effective region for expanded infills
    infill_quadrants = set(effective_region.overlapping_quadrants())

    # Fill in the template
    for qx in range(start_qx, end_qx + 1):
      for qy in range(start_qy, end_qy + 1):
        # Calculate where this quadrant appears in the template
        quad_world_x = qx * QUADRANT_SIZE
        quad_world_y = qy * QUADRANT_SIZE

        # Position in template coordinates
        template_x = quad_world_x - template_world_left
        template_y = quad_world_y - template_world_top

        # Determine source image
        if (qx, qy) in infill_quadrants:
          # Use render for infill quadrants
          quad_img = self.get_render(qx, qy)
          source_type = "render"
          if quad_img is None:
            continue
        else:
          # Use generation for context quadrants
          quad_img = self.get_generation(qx, qy)
          source_type = "generation"
          if quad_img is None:
            continue

        # Check quadrant image size and fix if needed
        img_w, img_h = quad_img.size
        expected_size = (QUADRANT_SIZE, QUADRANT_SIZE)

        if (img_w, img_h) != expected_size:
          # Resize to expected size
          print(
            f"   ‚ö†Ô∏è Quadrant ({qx}, {qy}) [{source_type}]: "
            f"RESIZING {quad_img.size} -> {expected_size}"
          )
          quad_img = quad_img.resize(expected_size, Image.Resampling.LANCZOS)
        else:
          print(
            f"   üì¶ Quadrant ({qx}, {qy}) [{source_type}]: "
            f"size={quad_img.size}, template_pos=({template_x}, {template_y})"
          )

        if quad_img.mode != "RGBA":
          quad_img = quad_img.convert("RGBA")

        # Calculate crop region if quadrant extends outside template
        crop_left = max(0, -template_x)
        crop_top = max(0, -template_y)
        crop_right = min(QUADRANT_SIZE, TEMPLATE_SIZE - template_x)
        crop_bottom = min(QUADRANT_SIZE, TEMPLATE_SIZE - template_y)

        if crop_left < crop_right and crop_top < crop_bottom:
          cropped = quad_img.crop((crop_left, crop_top, crop_right, crop_bottom))
          paste_x = max(0, template_x)
          paste_y = max(0, template_y)
          template.paste(cropped, (paste_x, paste_y))

    # Now we need to handle partial quadrant overlaps with the infill region
    # If the infill region doesn't align with quadrant boundaries,
    # we need to carefully composite render pixels only in the infill area
    self._apply_infill_mask(template, placement)

    # Draw red border around infill region
    template = self._draw_border(template, placement, border_width)

    return template, placement

  def _apply_infill_mask(
    self, template: Image.Image, placement: TemplatePlacement
  ) -> None:
    """
    Apply a mask to ensure only the infill region has render pixels.

    For quadrants that partially overlap the infill region, we need to
    composite render pixels (infill area) with generation pixels (context area).
    """
    # This is already handled by the quadrant-based approach when infill aligns
    # with quadrant boundaries. For non-aligned infills, we'd need more complex
    # masking. For now, we assume quadrant-aligned infills.
    pass

  def _draw_border(
    self,
    template: Image.Image,
    placement: TemplatePlacement,
    border_width: int,
  ) -> Image.Image:
    """Draw a red border around the infill region."""
    result = template.copy()
    draw = ImageDraw.Draw(result)

    red = (255, 0, 0, 255)

    left = placement.infill_x
    top = placement.infill_y
    right = placement.infill_x + self.region.width
    bottom = placement.infill_y + self.region.height

    for i in range(border_width):
      draw.rectangle(
        [left + i, top + i, right - 1 - i, bottom - 1 - i],
        outline=red,
        fill=None,
      )

    return result

  def get_validation_info(self) -> dict:
    """Get detailed validation information for debugging."""
    return {
      "region": str(self.region),
      "area": self.region.area,
      "max_area": MAX_INFILL_AREA,
      "valid_size": self.region.is_valid_size(),
      "has_left_gen": self._has_generated_context("left"),
      "has_right_gen": self._has_generated_context("right"),
      "has_top_gen": self._has_generated_context("top"),
      "has_bottom_gen": self._has_generated_context("bottom"),
      "overlapping_quadrants": self.region.overlapping_quadrants(),
      "last_validation_error": self._last_validation_error,
    }


def validate_quadrant_selection(
  quadrants: list[tuple[int, int]],
  has_generation: Callable[[int, int], bool],
  allow_expansion: bool = False,
) -> tuple[bool, str, TemplatePlacement | None]:
  """
  Validate a quadrant selection and find optimal placement.

  This is a convenience function for the common case of selecting
  whole quadrants for infill.

  Special handling for full tiles (2x2):
  - If some quadrants already have generations, reduce to just the missing ones
  - The generated quadrants become context for the missing ones

  Args:
    quadrants: List of (qx, qy) quadrant positions to infill
    has_generation: Callable to check if a quadrant has generation
    allow_expansion: If True, automatically expand infill region to cover
                     missing context quadrants (they'll be filled with render
                     pixels and discarded after generation)

  Returns:
    Tuple of (is_valid, message, placement)
  """
  if not quadrants:
    return False, "No quadrants selected", None

  # Check that quadrants form a rectangle
  min_qx = min(q[0] for q in quadrants)
  max_qx = max(q[0] for q in quadrants)
  min_qy = min(q[1] for q in quadrants)
  max_qy = max(q[1] for q in quadrants)

  expected_count = (max_qx - min_qx + 1) * (max_qy - min_qy + 1)
  if len(quadrants) != expected_count:
    return False, "Quadrants must form a contiguous rectangle", None

  # Check all expected positions are present
  expected = set()
  for qx in range(min_qx, max_qx + 1):
    for qy in range(min_qy, max_qy + 1):
      expected.add((qx, qy))

  if set(quadrants) != expected:
    return False, "Quadrants must form a contiguous rectangle", None

  # Create infill region and builder
  region = InfillRegion.from_quadrants(quadrants)

  if not region.is_valid_size():
    return (
      False,
      f"Selection too large: {region.area} pixels (max: {MAX_INFILL_AREA} or full tile)",
      None,
    )

  # For full tiles (2x2), check if some quadrants are already generated
  # If so, reduce the selection to just the non-generated quadrants
  if region.is_full_tile():
    # Check which quadrants already have generations
    generated_quadrants = [q for q in quadrants if has_generation(q[0], q[1])]
    non_generated_quadrants = [q for q in quadrants if not has_generation(q[0], q[1])]

    if len(generated_quadrants) == 4:
      # All quadrants already generated - nothing to do
      return False, "All quadrants already have generations", None

    if len(generated_quadrants) > 0:
      # Some quadrants are generated - reduce selection to just the missing ones
      # The generated quadrants will serve as context
      print(
        f"   üìã {len(generated_quadrants)} of 4 quadrants already generated, "
        f"will generate remaining {len(non_generated_quadrants)}"
      )

      # Recursively validate the reduced selection
      return validate_quadrant_selection(
        non_generated_quadrants, has_generation, allow_expansion
      )

    # No quadrants generated yet - check for external neighbors
    has_any_gen_neighbor = False
    for qx, qy in quadrants:
      # Check all 4 sides of each edge quadrant
      if qx == min(q[0] for q in quadrants):  # Left edge
        if has_generation(qx - 1, qy):
          has_any_gen_neighbor = True
          break
      if qx == max(q[0] for q in quadrants):  # Right edge
        if has_generation(qx + 1, qy):
          has_any_gen_neighbor = True
          break
      if qy == min(q[1] for q in quadrants):  # Top edge
        if has_generation(qx, qy - 1):
          has_any_gen_neighbor = True
          break
      if qy == max(q[1] for q in quadrants):  # Bottom edge
        if has_generation(qx, qy + 1):
          has_any_gen_neighbor = True
          break

    if has_any_gen_neighbor:
      return (
        False,
        "Full tile (2x2) selection cannot have generated neighbors (would create seams)",
        None,
      )

    # Full tile with no neighbors - valid, place at origin
    placement = TemplatePlacement(
      infill_x=0,
      infill_y=0,
      world_offset_x=region.x,
      world_offset_y=region.y,
    )
    placement._infill_width = region.width
    placement._infill_height = region.height
    placement._primary_quadrants = list(quadrants)
    return True, "Valid selection (full tile)", placement

  builder = TemplateBuilder(region, has_generation)
  placement = builder.find_optimal_placement(allow_expansion=allow_expansion)

  if placement is None:
    # Use the specific error from the builder if available
    info = builder.get_validation_info()
    if info["last_validation_error"]:
      return False, info["last_validation_error"], None
    # Fallback to generic messages
    if info["has_left_gen"]:
      return False, "Would create seam with generated pixels on left", None
    if info["has_right_gen"]:
      return False, "Would create seam with generated pixels on right", None
    if info["has_top_gen"]:
      return False, "Would create seam with generated pixels on top", None
    if info["has_bottom_gen"]:
      return False, "Would create seam with generated pixels on bottom", None
    return False, "No valid placement found", None

  # Set primary quadrants if not already set (by expansion)
  if not placement._primary_quadrants:
    placement._primary_quadrants = list(quadrants)

  # Build appropriate message
  if placement.is_expanded:
    padding_str = ", ".join(f"({qx}, {qy})" for qx, qy in placement._padding_quadrants)
    return True, f"Valid selection (expanded to cover: {padding_str})", placement

  return True, "Valid selection", placement


# =============================================================================
# Testing
# =============================================================================


def _test_basic():
  """Run basic tests."""
  print("=" * 60)
  print("Testing InfillRegion")
  print("=" * 60)

  # Test single quadrant
  r1 = InfillRegion.from_quadrant(0, 0)
  print(f"\nSingle quadrant (0,0): {r1}")
  print(f"  Area: {r1.area} (valid: {r1.is_valid_size()})")
  print(f"  Overlapping quadrants: {r1.overlapping_quadrants()}")

  # Test 2x1 quadrants
  r2 = InfillRegion.from_quadrants([(0, 0), (1, 0)])
  print(f"\n2x1 quadrants: {r2}")
  print(f"  Area: {r2.area} (valid: {r2.is_valid_size()})")
  print(f"  Overlapping quadrants: {r2.overlapping_quadrants()}")

  # Test 2x2 quadrants (should be invalid - 100% of tile)
  r3 = InfillRegion.from_quadrants([(0, 0), (1, 0), (0, 1), (1, 1)])
  print(f"\n2x2 quadrants: {r3}")
  print(f"  Area: {r3.area} (valid: {r3.is_valid_size()})")

  print("\n" + "=" * 60)
  print("Testing TemplateBuilder")
  print("=" * 60)

  # Create a mock has_generation function
  # Simulate: quadrants (0,0) and (1,0) are NOT generated, (0,1) and (1,1) ARE generated
  generated = {(0, 1), (1, 1), (2, 0), (2, 1)}

  def has_gen(qx, qy):
    return (qx, qy) in generated

  # Test 1: Select quadrant (1, 0) with generated neighbor below
  region = InfillRegion.from_quadrant(1, 0)
  builder = TemplateBuilder(region, has_gen)
  info = builder.get_validation_info()
  placement = builder.find_optimal_placement()

  print("\nTest 1: Select quadrant (1, 0)")
  print(f"  Info: {info}")
  print(f"  Placement: {placement}")
  if placement:
    print(f"    Infill at: ({placement.infill_x}, {placement.infill_y})")
    print(f"    World offset: ({placement.world_offset_x}, {placement.world_offset_y})")

  # Test 2: Select quadrant (0, 1) surrounded by generated
  region2 = InfillRegion.from_quadrant(0, 1)
  builder2 = TemplateBuilder(region2, has_gen)
  info2 = builder2.get_validation_info()
  placement2 = builder2.find_optimal_placement()

  print("\nTest 2: Select quadrant (0, 1) - has generated neighbor to right")
  print(f"  Info: {info2}")
  print(f"  Placement: {placement2}")
  if placement2:
    print(f"    Infill at: ({placement2.infill_x}, {placement2.infill_y})")

  # Test 3: Validation convenience function
  print("\n" + "=" * 60)
  print("Testing validate_quadrant_selection")
  print("=" * 60)

  # Valid selection
  valid, msg, p = validate_quadrant_selection([(1, 0)], has_gen)
  print(f"\nSelect (1,0): valid={valid}, msg='{msg}'")

  # Invalid - non-contiguous
  valid, msg, p = validate_quadrant_selection([(0, 0), (1, 1)], has_gen)
  print(f"Select (0,0), (1,1) [diagonal]: valid={valid}, msg='{msg}'")

  # Valid 2x1
  valid, msg, p = validate_quadrant_selection([(0, 0), (1, 0)], has_gen)
  print(f"Select (0,0), (1,0) [2x1]: valid={valid}, msg='{msg}'")

  print("\n" + "=" * 60)
  print("All tests complete!")
  print("=" * 60)


if __name__ == "__main__":
  _test_basic()

```

Fixed. Now oversized images will be resized to 512x512 instead of cropped. Try the generation again - you should see:
```
‚ö†Ô∏è Quadrant (-32, 43) [generation]: RESIZING (1024, 1024) -> (512, 512)
```

```plaintext
‚ö†Ô∏è Quadrant (-32, 43) [generation]: RESIZING (1024, 1024) -> (512, 512)
```

---

**User**

OK - the next thing to figure out is the queue system - technically we need n queues - one for each model. please update the backend queue system to handle multiple queues per model id *and* update the frontend to display the correct queueing message and status for multiple model ids 

---

**Cursor**

I'll update the queue system to handle multiple model queues. Let me create a plan and implement it:

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle both old (10 columns) and new (11 columns) schema
    context = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add context_quadrants column if it doesn't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants)
    VALUES (?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def get_queue_status_by_model(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get queue status grouped by model.

  Returns a dictionary with:
    - by_model: dict mapping model_id -> {
        is_processing: bool,
        current_item: dict | None,
        pending_count: int,
        pending_items: list of dicts,
        position: int (1-based, 0 if processing)
      }
    - total_pending: int
    - processing_model: str | None (model_id of currently processing item)
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  # Group pending items by model_id
  by_model: dict[str, dict[str, Any]] = {}

  for item in pending:
    model_id = item.model_id or "default"
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": False,
        "current_item": None,
        "pending_count": 0,
        "pending_items": [],
      }
    by_model[model_id]["pending_count"] += 1
    by_model[model_id]["pending_items"].append(item.to_dict())

  # Add processing item to its model's status
  processing_model = None
  if processing:
    model_id = processing.model_id or "default"
    processing_model = model_id
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": True,
        "current_item": processing.to_dict(),
        "pending_count": 0,
        "pending_items": [],
      }
    else:
      by_model[model_id]["is_processing"] = True
      by_model[model_id]["current_item"] = processing.to_dict()

  return {
    "by_model": by_model,
    "total_pending": len(pending),
    "processing_model": processing_model,
  }


def get_queue_position_for_model(
  conn: sqlite3.Connection, item_id: int, model_id: str | None
) -> int:
  """
  Get the position of an item within its model's queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue for this model, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # For model-specific position, count items with same model_id that are ahead
  # Use empty string for NULL model_id comparison
  if model_id is None:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id IS NULL
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, item_id),
    )
  else:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id = ?
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, model_id, item_id),
    )

  row = cursor.fetchone()
  if row:
    return row[0]

  return -1


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def cancel_processing_items(conn: sqlite3.Connection) -> int:
  """
  Mark all processing items as cancelled (error status).

  This is used when the user wants to cancel everything, including
  items that are currently being processed.

  Returns the number of items cancelled.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE status = ?
    """,
    (
      QueueItemStatus.ERROR.value,
      time.time(),
      "Cancelled by user",
      QueueItemStatus.PROCESSING.value,
    ),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel the current generation
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flag...")
        generation_cancelled = False
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Reset cancellation flag before starting new item
      generation_cancelled = False

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          # Check cancellation one more time before processing
          if generation_cancelled:
            print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
            continue

          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel the current generation
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flag...")
        generation_cancelled = False
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Reset cancellation flag before starting new item
      generation_cancelled = False

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          # Check cancellation one more time before processing
          if generation_cancelled:
            print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
            continue

          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get queue position
    pending = get_pending_queue(conn)
    queue_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": queue_position,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {queue_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_model": model_status["processing_model"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel the current generation
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flag...")
        generation_cancelled = False
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Reset cancellation flag before starting new item
      generation_cancelled = False

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          # Check cancellation one more time before processing
          if generation_cancelled:
            print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
            continue

          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_model": model_status["processing_model"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show queue count
    if (serverStatus.queue_length > 0) {
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

async function generateSelected() {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position, "model:", result.model_id);
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        showToast(
          "info",
          "Processing queue",
          `${status.queue_length} more item(s) in queue...`
        );
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show queue count
    if (serverStatus.queue_length > 0) {
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

async function generateSelected() {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position, "model:", result.model_id);
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        showToast(
          "info",
          "Processing queue",
          `${status.queue_length} more item(s) in queue...`
        );
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show per-model queue counts
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      if (modelQueues.length > 0) {
        const queueParts = modelQueues.map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return `${name}: ${count}`;
        });
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    } else if (serverStatus.queue_length > 0) {
      // Fallback for backwards compatibility
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

async function generateSelected() {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position, "model:", result.model_id);
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        showToast(
          "info",
          "Processing queue",
          `${status.queue_length} more item(s) in queue...`
        );
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show per-model queue counts
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      if (modelQueues.length > 0) {
        const queueParts = modelQueues.map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return `${name}: ${count}`;
        });
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    } else if (serverStatus.queue_length > 0) {
      // Fallback for backwards compatibility
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

async function generateSelected() {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position, "model:", result.model_id);
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = `${status.queue_length} more item(s) in queue...`;
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .filter(([, info]) => info.pending_count > 0)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              return `${name}: ${info.pending_count}`;
            });
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        showToast("info", "Processing queue", queueMsg);
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

Done! Here's a summary of the changes:

**Backend (`queue_db.py`):**
- Added `get_queue_status_by_model()` - returns queue status grouped by model ID
- Added `get_queue_position_for_model()` - returns position within a specific model's queue

**Backend (`app.py`):**
- Updated `/api/status` to include `queue_by_model` (per-model queue info) and `processing_model`
- Updated `add_to_queue_db()` to return model-specific position and model_id in response

**Frontend (`viewer.js`):**
- Added `getModelDisplayName()` helper to convert model IDs to display names
- Updated status bar to show per-model queue counts (e.g., "üìã Omni Water v2: 3, Omni Original: 1")
- Updated queue toast messages to show model name (e.g., "Queued at position 2 (Omni Water v2)")
- Updated "processing queue" toast to show per-model breakdown

Now when you queue items with different models, you'll see:
- Status bar: `üìã Omni Water v2: 3, Omni Original: 1`
- Queue toast: `Queued at position 2 (Omni Water v2)`
- The position shown is within that model's queue, not the global queue

---

**User**

Please log the url of the image that's being downloaded from oxen as well

---

**Cursor**

```python
"""
Reusable library for generating pixel art using the Oxen.ai model.

This module provides the core generation logic that can be used by:
- view_generations.py (Flask web server)
- generate_tiles_omni.py (command-line script)
- automatic_generation.py (automated generation)

The main entry point is `run_generation_for_quadrants()` which handles:
1. Validating the quadrant selection
2. Rendering any missing quadrants
3. Building the template image
4. Uploading to GCS and calling the Oxen API
5. Saving the generated quadrants to the database
"""

import os
import re
import sqlite3
import tempfile
from io import BytesIO
from pathlib import Path
from typing import Callable
from urllib.parse import urlencode

import requests
from dotenv import load_dotenv
from PIL import Image
from playwright.sync_api import sync_playwright

from isometric_nyc.e2e_generation.infill_template import (
  QUADRANT_SIZE,
  InfillRegion,
  TemplateBuilder,
  validate_quadrant_selection,
)
from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  ensure_quadrant_exists,
  image_to_png_bytes,
  png_bytes_to_image,
  save_quadrant_generation,
  save_quadrant_render,
  split_tile_into_quadrants,
  upload_to_gcs,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_generation as shared_get_quadrant_generation,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_render as shared_get_quadrant_render,
)

# Load environment variables
load_dotenv()

# Oxen API configuration
OMNI_MODEL_ID = "cannoneyed-gentle-gold-antlion"
OMNI_WATER_MODEL_ID = "cannoneyed-quiet-green-lamprey"
OMNI_WATER_V2_MODEL_ID = "cannoneyed-rural-rose-dingo"

GCS_BUCKET_NAME = "isometric-nyc-infills"


# =============================================================================
# Quadrant Parsing Utilities
# =============================================================================


def parse_quadrant_tuple(s: str) -> tuple[int, int]:
  """
  Parse a quadrant tuple string like "(0,1)" or "0,1" into a tuple.

  Args:
      s: String in format "(x,y)" or "x,y"

  Returns:
      Tuple of (x, y) coordinates

  Raises:
      ValueError: If the format is invalid
  """
  s = s.strip()
  # Remove optional parentheses
  if s.startswith("(") and s.endswith(")"):
    s = s[1:-1]
  parts = s.split(",")
  if len(parts) != 2:
    raise ValueError(f"Invalid quadrant tuple format: {s}")
  return (int(parts[0].strip()), int(parts[1].strip()))


def parse_quadrant_list(s: str) -> list[tuple[int, int]]:
  """
  Parse a comma-separated list of quadrant tuples.

  Args:
      s: String like "(0,1),(0,2)" or "(0,1), (0,2)"

  Returns:
      List of (x, y) coordinate tuples

  Raises:
      ValueError: If the format is invalid
  """
  # Use regex to find all (x,y) patterns
  pattern = r"\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)"
  matches = re.findall(pattern, s)
  if not matches:
    raise ValueError(f"No valid quadrant tuples found in: {s}")
  return [(int(x), int(y)) for x, y in matches]


# =============================================================================
# Oxen API Functions
# =============================================================================


def call_oxen_api(
  image_url: str,
  model_config: "ModelConfig | None" = None,  # noqa: F821
) -> str:
  """
  Call the Oxen API to generate pixel art.

  Args:
      image_url: Public URL of the input template image
      model_config: Optional model configuration (ModelConfig from model_config.py).
        If not provided, uses defaults.

  Returns:
      URL of the generated image

  Raises:
      requests.HTTPError: If the API call fails
      ValueError: If the response format is unexpected
  """
  # Use provided config or defaults
  if model_config is not None:
    endpoint = model_config.endpoint
    model_id = model_config.model_id
    api_key = model_config.api_key
    num_inference_steps = model_config.num_inference_steps
  else:
    endpoint = "https://hub.oxen.ai/api/images/edit"
    model_id = OMNI_WATER_MODEL_ID
    api_key = os.getenv("OXEN_OMNI_v04_WATER_API_KEY")
    num_inference_steps = 28

  if not api_key:
    raise ValueError(f"API key not found for model {model_id}")

  headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json",
  }

  prompt = (
    "Fill in the outlined section with the missing pixels corresponding to "
    "the <isometric nyc pixel art> style, removing the border and exactly "
    "following the shape/style/structure of the surrounding image (if present)."
  )

  payload = {
    "model": model_id,
    "input_image": image_url,
    "prompt": prompt,
    "num_inference_steps": num_inference_steps,
  }

  print(f"   ü§ñ Calling Oxen API with model {model_id}...")
  response = requests.post(endpoint, headers=headers, json=payload, timeout=300)
  response.raise_for_status()

  result = response.json()

  if "images" in result and len(result["images"]) > 0:
    return result["images"][0]["url"]
  elif "url" in result:
    return result["url"]
  elif "image_url" in result:
    return result["image_url"]
  elif "output" in result:
    return result["output"]
  else:
    raise ValueError(f"Unexpected API response format: {result}")


def download_image_to_pil(url: str) -> Image.Image:
  """
  Download an image from a URL and return as PIL Image.

  Args:
      url: URL of the image to download

  Returns:
      PIL Image object
  """
  response = requests.get(url, timeout=120)
  response.raise_for_status()
  return Image.open(BytesIO(response.content))


# =============================================================================
# Rendering Functions
# =============================================================================


def render_quadrant(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
  port: int,
) -> bytes | None:
  """
  Render a quadrant and save to database.

  This renders the tile containing the quadrant and saves all 4 quadrants.

  Args:
      conn: Database connection
      config: Generation config dict
      x: Quadrant x coordinate
      y: Quadrant y coordinate
      port: Web server port for rendering

  Returns:
      PNG bytes of the rendered quadrant, or None if failed
  """
  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  # Build URL for rendering
  params = {
    "export": "true",
    "lat": quadrant["lat"],
    "lon": quadrant["lng"],
    "width": config["width_px"],
    "height": config["height_px"],
    "azimuth": config["camera_azimuth_degrees"],
    "elevation": config["camera_elevation_degrees"],
    "view_height": config.get("view_height_meters", 200),
  }
  query_string = urlencode(params)
  url = f"http://localhost:{port}/?{query_string}"

  # Render using Playwright
  with sync_playwright() as p:
    browser = p.chromium.launch(
      headless=True,
      args=[
        "--enable-webgl",
        "--use-gl=angle",
        "--ignore-gpu-blocklist",
      ],
    )

    context = browser.new_context(
      viewport={"width": config["width_px"], "height": config["height_px"]},
      device_scale_factor=1,
    )
    page = context.new_page()

    page.goto(url, wait_until="networkidle")

    try:
      page.wait_for_function("window.TILES_LOADED === true", timeout=60000)
    except Exception:
      print("      ‚ö†Ô∏è  Timeout waiting for tiles, continuing anyway...")

    # Get screenshot as bytes
    screenshot_bytes = page.screenshot(type="png")

    page.close()
    context.close()
    browser.close()

  # Open as PIL image and split into quadrants
  full_tile = Image.open(BytesIO(screenshot_bytes))
  quadrant_images = split_tile_into_quadrants(full_tile)

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), quad_img in quadrant_images.items():
    qx, qy = x + dx, y + dy
    png_bytes = image_to_png_bytes(quad_img)
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


# =============================================================================
# Core Generation Logic
# =============================================================================


def run_generation_for_quadrants(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  port: int = DEFAULT_WEB_PORT,
  bucket_name: str = GCS_BUCKET_NAME,
  status_callback: Callable[[str, str], None] | None = None,
  model_config: "ModelConfig | None" = None,  # noqa: F821
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is the main entry point for generation. It:
  1. Validates the quadrant selection
  2. Renders any missing quadrants
  3. Builds the template image with appropriate borders
  4. Uploads to GCS and calls the Oxen API
  5. Saves the generated quadrants to the database

  Args:
      conn: Database connection
      config: Generation config dict
      selected_quadrants: List of (x, y) quadrant coordinates to generate
      port: Web server port for rendering (default: 5173)
      bucket_name: GCS bucket name for uploads
      status_callback: Optional callback(status, message) for progress updates
      model_config: Optional model configuration for the Oxen API (ModelConfig from model_config.py)
      context_quadrants: Optional list of (x, y) quadrant coordinates to use as
        context. These quadrants provide surrounding pixel art context for the
        generation. If a context quadrant has a generation, that will be used;
        otherwise the render will be used.

  Returns:
      Dict with:
          - success: bool
          - message: str (on success)
          - error: str (on failure)
          - quadrants: list of generated quadrant coords (on success)
  """
  # Convert context quadrants to a set for fast lookup
  context_set: set[tuple[int, int]] = (
    set(context_quadrants) if context_quadrants else set()
  )
  if context_set:
    print(f"   üìã Using {len(context_set)} context quadrant(s): {list(context_set)}")

  def update_status(status: str, message: str = "") -> None:
    if status_callback:
      status_callback(status, message)

  update_status("validating", "Checking API key...")

  # Create helper functions for validation
  # These are modified to treat context quadrants as "generated" if they have
  # either a generation or a render
  def has_generation_in_db(qx: int, qy: int) -> bool:
    # Check if this quadrant has an actual generation
    gen = shared_get_quadrant_generation(conn, qx, qy)
    if gen is not None:
      return True

    # For context quadrants, treat them as "generated" if they have a render
    # This allows context quadrants to provide surrounding content even if
    # they don't have generations yet
    if (qx, qy) in context_set:
      render = shared_get_quadrant_render(conn, qx, qy)
      return render is not None

    return False

  def get_render_from_db_with_render(qx: int, qy: int) -> Image.Image | None:
    """Get render, rendering if it doesn't exist yet."""
    render_bytes = shared_get_quadrant_render(conn, qx, qy)
    if render_bytes:
      return png_bytes_to_image(render_bytes)

    # Need to render
    update_status("rendering", f"Rendering quadrant ({qx}, {qy})...")
    print(f"   üì¶ Rendering quadrant ({qx}, {qy})...")
    render_bytes = render_quadrant(conn, config, qx, qy, port)
    if render_bytes:
      return png_bytes_to_image(render_bytes)
    return None

  def get_generation_from_db(qx: int, qy: int) -> Image.Image | None:
    """Get generation, falling back to render for context quadrants."""
    gen_bytes = shared_get_quadrant_generation(conn, qx, qy)
    if gen_bytes:
      return png_bytes_to_image(gen_bytes)

    # For context quadrants, fall back to render if no generation exists
    # This allows context quadrants to provide surrounding pixel art context
    # even if they only have renders
    if (qx, qy) in context_set:
      render_bytes = shared_get_quadrant_render(conn, qx, qy)
      if render_bytes:
        print(f"   üìã Using render as context for ({qx}, {qy})")
        return png_bytes_to_image(render_bytes)

    return None

  update_status("validating", "Validating quadrant selection...")

  # Validate selection with auto-expansion
  is_valid, msg, placement = validate_quadrant_selection(
    selected_quadrants, has_generation_in_db, allow_expansion=True
  )

  if not is_valid:
    update_status("error", msg)
    return {"success": False, "error": msg}

  print(f"‚úÖ Validation: {msg}")

  # Get primary quadrants (the ones user selected, not padding)
  primary_quadrants = (
    placement.primary_quadrants if placement.primary_quadrants else selected_quadrants
  )
  padding_quadrants = placement.padding_quadrants if placement else []

  if padding_quadrants:
    print(f"   üì¶ Padding quadrants: {padding_quadrants}")

  # Create the infill region (may be expanded)
  if placement._expanded_region is not None:
    region = placement._expanded_region
  else:
    region = InfillRegion.from_quadrants(selected_quadrants)

  # Build the template
  update_status("rendering", "Building template image...")
  builder = TemplateBuilder(
    region, has_generation_in_db, get_render_from_db_with_render, get_generation_from_db
  )

  print("üìã Building template...")
  result = builder.build(border_width=2, allow_expansion=True)

  if result is None:
    error_msg = builder._last_validation_error or "Failed to build template"
    update_status("error", error_msg)
    return {
      "success": False,
      "error": error_msg,
    }

  template_image, placement = result

  # Save template to temp file and upload to GCS
  with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
    template_path = Path(tmp.name)
    template_image.save(template_path)

  try:
    update_status("uploading", "Uploading template to cloud...")
    print("üì§ Uploading template to GCS...")
    print(f"   Template path: {template_path}")
    print(f"   Template size: {template_image.size[0]}x{template_image.size[1]}")
    image_url = upload_to_gcs(template_path, bucket_name)
    print(f"   Uploaded URL: {image_url}")

    update_status("generating", "Calling AI model (this may take a minute)...")
    print("ü§ñ Calling Oxen API...")
    generated_url = call_oxen_api(image_url, model_config)

    update_status("saving", "Downloading and saving results...")
    print("üì• Downloading generated image...")
    print(f"   Generated URL: {generated_url}")
    generated_image = download_image_to_pil(generated_url)

    # Extract quadrants from generated image and save to database
    print("üíæ Saving generated quadrants to database...")

    # Figure out what quadrants are in the infill region
    all_infill_quadrants = (
      placement.all_infill_quadrants
      if placement.all_infill_quadrants
      else region.overlapping_quadrants()
    )

    # For each infill quadrant, extract pixels from the generated image
    saved_count = 0
    for qx, qy in all_infill_quadrants:
      # Calculate position in the generated image
      quad_world_x = qx * QUADRANT_SIZE
      quad_world_y = qy * QUADRANT_SIZE

      template_x = quad_world_x - placement.world_offset_x
      template_y = quad_world_y - placement.world_offset_y

      # Crop this quadrant from the generated image
      crop_box = (
        template_x,
        template_y,
        template_x + QUADRANT_SIZE,
        template_y + QUADRANT_SIZE,
      )
      quad_img = generated_image.crop(crop_box)
      png_bytes = image_to_png_bytes(quad_img)

      # Only save primary quadrants (not padding)
      if (qx, qy) in primary_quadrants or (qx, qy) in [
        (q[0], q[1]) for q in primary_quadrants
      ]:
        if save_quadrant_generation(conn, config, qx, qy, png_bytes):
          print(f"   ‚úì Saved generation for ({qx}, {qy})")
          saved_count += 1
        else:
          print(f"   ‚ö†Ô∏è Failed to save generation for ({qx}, {qy})")
      else:
        print(f"   ‚è≠Ô∏è Skipped padding quadrant ({qx}, {qy})")

    update_status("complete", f"Generated {saved_count} quadrant(s)")
    return {
      "success": True,
      "message": f"Generated {saved_count} quadrant{'s' if saved_count != 1 else ''}",
      "quadrants": list(primary_quadrants),
    }

  finally:
    # Clean up temp file
    template_path.unlink(missing_ok=True)

```

Done. Now the logs will show:
```
üì• Downloading generated image...
   Generated URL: https://...
```

```plaintext
üì• Downloading generated image...
   Generated URL: https://...
```

---

**User**

OK - for the multi-model queue, it should also be possible to generate make multiple generation calls, one for each model_id - so if there's already a model generation being called for model_a, if I generate with model_b it needs to start making the generation instead of remaining in the queue

---

**Cursor**

I'll update the queue system to allow parallel processing of different models. This requires:

1. Tracking which models are currently processing
2. Spawning separate threads per model
3. Allowing concurrent model processing

```python
def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue (oldest first).

  Returns None if the queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_next_pending_item_for_available_model(
  conn: sqlite3.Connection, busy_models: set[str | None]
) -> QueueItem | None:
  """
  Get the next pending item for a model that isn't currently busy.

  This enables parallel processing of different models' queues.

  Args:
    conn: Database connection
    busy_models: Set of model_ids that are currently processing
                 (None represents the default/no model)

  Returns None if no available items.
  """
  cursor = conn.cursor()

  # Get all pending items ordered by creation time
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )

  for row in cursor.fetchall():
    item = QueueItem.from_row(row)
    # Check if this model is available (not busy)
    if item.model_id not in busy_models:
      return item

  return None
```

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle both old (10 columns) and new (11 columns) schema
    context = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add context_quadrants column if it doesn't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants)
    VALUES (?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_next_pending_item_for_available_model(
  conn: sqlite3.Connection, busy_models: set[str | None]
) -> QueueItem | None:
  """
  Get the next pending item for a model that isn't currently busy.

  This enables parallel processing of different models' queues.

  Args:
    conn: Database connection
    busy_models: Set of model_ids that are currently processing
                 (None represents the default/no model)

  Returns None if no available items.
  """
  cursor = conn.cursor()

  # Get all pending items ordered by creation time
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )

  for row in cursor.fetchall():
    item = QueueItem.from_row(row)
    # Check if this model is available (not busy)
    if item.model_id not in busy_models:
      return item

  return None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def get_queue_status_by_model(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get queue status grouped by model.

  Returns a dictionary with:
    - by_model: dict mapping model_id -> {
        is_processing: bool,
        current_item: dict | None,
        pending_count: int,
        pending_items: list of dicts,
        position: int (1-based, 0 if processing)
      }
    - total_pending: int
    - processing_model: str | None (model_id of currently processing item)
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  # Group pending items by model_id
  by_model: dict[str, dict[str, Any]] = {}

  for item in pending:
    model_id = item.model_id or "default"
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": False,
        "current_item": None,
        "pending_count": 0,
        "pending_items": [],
      }
    by_model[model_id]["pending_count"] += 1
    by_model[model_id]["pending_items"].append(item.to_dict())

  # Add processing item to its model's status
  processing_model = None
  if processing:
    model_id = processing.model_id or "default"
    processing_model = model_id
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": True,
        "current_item": processing.to_dict(),
        "pending_count": 0,
        "pending_items": [],
      }
    else:
      by_model[model_id]["is_processing"] = True
      by_model[model_id]["current_item"] = processing.to_dict()

  return {
    "by_model": by_model,
    "total_pending": len(pending),
    "processing_model": processing_model,
  }


def get_queue_position_for_model(
  conn: sqlite3.Connection, item_id: int, model_id: str | None
) -> int:
  """
  Get the position of an item within its model's queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue for this model, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # For model-specific position, count items with same model_id that are ahead
  # Use empty string for NULL model_id comparison
  if model_id is None:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id IS NULL
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, item_id),
    )
  else:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id = ?
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, model_id, item_id),
    )

  row = cursor.fetchone()
  if row:
    return row[0]

  return -1


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def cancel_processing_items(conn: sqlite3.Connection) -> int:
  """
  Mark all processing items as cancelled (error status).

  This is used when the user wants to cancel everything, including
  items that are currently being processed.

  Returns the number of items cancelled.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE status = ?
    """,
    (
      QueueItemStatus.ERROR.value,
      time.time(),
      "Cancelled by user",
      QueueItemStatus.PROCESSING.value,
    ),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - only one generation at a time
generation_lock = threading.Lock()
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel the current generation
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flag...")
        generation_cancelled = False
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Reset cancellation flag before starting new item
      generation_cancelled = False

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          # Check cancellation one more time before processing
          if generation_cancelled:
            print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
            continue

          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_model": model_status["processing_model"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def queue_worker():
  """Background worker that processes the generation queue from the database."""
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flag...")
        generation_cancelled = False
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get next pending item
      item = get_next_pending_item(conn)

      if item is None:
        # No items in queue, wait a bit and check again
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      conn.close()
      conn = None

      # Reset cancellation flag before starting new item
      generation_cancelled = False

      # Acquire the generation lock and process the item
      with generation_lock:
        try:
          # Check cancellation one more time before processing
          if generation_cancelled:
            print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
            continue

          process_queue_item_from_db(item_id)
        finally:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None

      # Small delay between items
      time.sleep(0.5)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_model": model_status["processing_model"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_model": model_status["processing_model"],
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_model": model_status["processing_model"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_model": model_status["processing_model"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

---

**User**

OK - one more new feature to add - a "generate with prompt" button that opens a dialog for an extra prompt - this must be then added to the generation request. It needs to be sent via the API to the app server and stored in the queue for the generation. Also, log any additional prompt if present

---

**Cursor**

I'll add a "Generate with Prompt" feature. This requires updates to the queue, API, generation logic, and frontend.

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None
  prompt: str | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle schema evolution: 10 base columns + optional context_quadrants + optional prompt
    context = None
    prompt = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])
    if len(row) > 11 and row[11]:
      prompt = row[11]

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
      prompt=prompt,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    if self.prompt:
      result["prompt"] = self.prompt
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add context_quadrants column if it doesn't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants)
    VALUES (?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_next_pending_item_for_available_model(
  conn: sqlite3.Connection, busy_models: set[str | None]
) -> QueueItem | None:
  """
  Get the next pending item for a model that isn't currently busy.

  This enables parallel processing of different models' queues.

  Args:
    conn: Database connection
    busy_models: Set of model_ids that are currently processing
                 (None represents the default/no model)

  Returns None if no available items.
  """
  cursor = conn.cursor()

  # Get all pending items ordered by creation time
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )

  for row in cursor.fetchall():
    item = QueueItem.from_row(row)
    # Check if this model is available (not busy)
    if item.model_id not in busy_models:
      return item

  return None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def get_queue_status_by_model(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get queue status grouped by model.

  Returns a dictionary with:
    - by_model: dict mapping model_id -> {
        is_processing: bool,
        current_item: dict | None,
        pending_count: int,
        pending_items: list of dicts,
        position: int (1-based, 0 if processing)
      }
    - total_pending: int
    - processing_model: str | None (model_id of currently processing item)
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  # Group pending items by model_id
  by_model: dict[str, dict[str, Any]] = {}

  for item in pending:
    model_id = item.model_id or "default"
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": False,
        "current_item": None,
        "pending_count": 0,
        "pending_items": [],
      }
    by_model[model_id]["pending_count"] += 1
    by_model[model_id]["pending_items"].append(item.to_dict())

  # Add processing item to its model's status
  processing_model = None
  if processing:
    model_id = processing.model_id or "default"
    processing_model = model_id
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": True,
        "current_item": processing.to_dict(),
        "pending_count": 0,
        "pending_items": [],
      }
    else:
      by_model[model_id]["is_processing"] = True
      by_model[model_id]["current_item"] = processing.to_dict()

  return {
    "by_model": by_model,
    "total_pending": len(pending),
    "processing_model": processing_model,
  }


def get_queue_position_for_model(
  conn: sqlite3.Connection, item_id: int, model_id: str | None
) -> int:
  """
  Get the position of an item within its model's queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue for this model, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # For model-specific position, count items with same model_id that are ahead
  # Use empty string for NULL model_id comparison
  if model_id is None:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id IS NULL
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, item_id),
    )
  else:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id = ?
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, model_id, item_id),
    )

  row = cursor.fetchone()
  if row:
    return row[0]

  return -1


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def cancel_processing_items(conn: sqlite3.Connection) -> int:
  """
  Mark all processing items as cancelled (error status).

  This is used when the user wants to cancel everything, including
  items that are currently being processed.

  Returns the number of items cancelled.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE status = ?
    """,
    (
      QueueItemStatus.ERROR.value,
      time.time(),
      "Cancelled by user",
      QueueItemStatus.PROCESSING.value,
    ),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None
  prompt: str | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle schema evolution: 10 base columns + optional context_quadrants + optional prompt
    context = None
    prompt = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])
    if len(row) > 11 and row[11]:
      prompt = row[11]

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
      prompt=prompt,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    if self.prompt:
      result["prompt"] = self.prompt
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT,
      prompt TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add columns if they don't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")
  if "prompt" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN prompt TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants)
    VALUES (?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_next_pending_item_for_available_model(
  conn: sqlite3.Connection, busy_models: set[str | None]
) -> QueueItem | None:
  """
  Get the next pending item for a model that isn't currently busy.

  This enables parallel processing of different models' queues.

  Args:
    conn: Database connection
    busy_models: Set of model_ids that are currently processing
                 (None represents the default/no model)

  Returns None if no available items.
  """
  cursor = conn.cursor()

  # Get all pending items ordered by creation time
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )

  for row in cursor.fetchall():
    item = QueueItem.from_row(row)
    # Check if this model is available (not busy)
    if item.model_id not in busy_models:
      return item

  return None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def get_queue_status_by_model(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get queue status grouped by model.

  Returns a dictionary with:
    - by_model: dict mapping model_id -> {
        is_processing: bool,
        current_item: dict | None,
        pending_count: int,
        pending_items: list of dicts,
        position: int (1-based, 0 if processing)
      }
    - total_pending: int
    - processing_model: str | None (model_id of currently processing item)
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  # Group pending items by model_id
  by_model: dict[str, dict[str, Any]] = {}

  for item in pending:
    model_id = item.model_id or "default"
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": False,
        "current_item": None,
        "pending_count": 0,
        "pending_items": [],
      }
    by_model[model_id]["pending_count"] += 1
    by_model[model_id]["pending_items"].append(item.to_dict())

  # Add processing item to its model's status
  processing_model = None
  if processing:
    model_id = processing.model_id or "default"
    processing_model = model_id
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": True,
        "current_item": processing.to_dict(),
        "pending_count": 0,
        "pending_items": [],
      }
    else:
      by_model[model_id]["is_processing"] = True
      by_model[model_id]["current_item"] = processing.to_dict()

  return {
    "by_model": by_model,
    "total_pending": len(pending),
    "processing_model": processing_model,
  }


def get_queue_position_for_model(
  conn: sqlite3.Connection, item_id: int, model_id: str | None
) -> int:
  """
  Get the position of an item within its model's queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue for this model, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # For model-specific position, count items with same model_id that are ahead
  # Use empty string for NULL model_id comparison
  if model_id is None:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id IS NULL
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, item_id),
    )
  else:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id = ?
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, model_id, item_id),
    )

  row = cursor.fetchone()
  if row:
    return row[0]

  return -1


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def cancel_processing_items(conn: sqlite3.Connection) -> int:
  """
  Mark all processing items as cancelled (error status).

  This is used when the user wants to cancel everything, including
  items that are currently being processed.

  Returns the number of items cancelled.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE status = ?
    """,
    (
      QueueItemStatus.ERROR.value,
      time.time(),
      "Cancelled by user",
      QueueItemStatus.PROCESSING.value,
    ),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None
  prompt: str | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle schema evolution: 10 base columns + optional context_quadrants + optional prompt
    context = None
    prompt = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])
    if len(row) > 11 and row[11]:
      prompt = row[11]

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
      prompt=prompt,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    if self.prompt:
      result["prompt"] = self.prompt
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT,
      prompt TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add columns if they don't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")
  if "prompt" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN prompt TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.
    prompt: Optional additional prompt text for generation

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants, prompt)
    VALUES (?, ?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
      prompt,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_next_pending_item_for_available_model(
  conn: sqlite3.Connection, busy_models: set[str | None]
) -> QueueItem | None:
  """
  Get the next pending item for a model that isn't currently busy.

  This enables parallel processing of different models' queues.

  Args:
    conn: Database connection
    busy_models: Set of model_ids that are currently processing
                 (None represents the default/no model)

  Returns None if no available items.
  """
  cursor = conn.cursor()

  # Get all pending items ordered by creation time
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )

  for row in cursor.fetchall():
    item = QueueItem.from_row(row)
    # Check if this model is available (not busy)
    if item.model_id not in busy_models:
      return item

  return None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def get_queue_status_by_model(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get queue status grouped by model.

  Returns a dictionary with:
    - by_model: dict mapping model_id -> {
        is_processing: bool,
        current_item: dict | None,
        pending_count: int,
        pending_items: list of dicts,
        position: int (1-based, 0 if processing)
      }
    - total_pending: int
    - processing_model: str | None (model_id of currently processing item)
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  # Group pending items by model_id
  by_model: dict[str, dict[str, Any]] = {}

  for item in pending:
    model_id = item.model_id or "default"
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": False,
        "current_item": None,
        "pending_count": 0,
        "pending_items": [],
      }
    by_model[model_id]["pending_count"] += 1
    by_model[model_id]["pending_items"].append(item.to_dict())

  # Add processing item to its model's status
  processing_model = None
  if processing:
    model_id = processing.model_id or "default"
    processing_model = model_id
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": True,
        "current_item": processing.to_dict(),
        "pending_count": 0,
        "pending_items": [],
      }
    else:
      by_model[model_id]["is_processing"] = True
      by_model[model_id]["current_item"] = processing.to_dict()

  return {
    "by_model": by_model,
    "total_pending": len(pending),
    "processing_model": processing_model,
  }


def get_queue_position_for_model(
  conn: sqlite3.Connection, item_id: int, model_id: str | None
) -> int:
  """
  Get the position of an item within its model's queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue for this model, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # For model-specific position, count items with same model_id that are ahead
  # Use empty string for NULL model_id comparison
  if model_id is None:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id IS NULL
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, item_id),
    )
  else:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id = ?
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, model_id, item_id),
    )

  row = cursor.fetchone()
  if row:
    return row[0]

  return -1


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def cancel_processing_items(conn: sqlite3.Connection) -> int:
  """
  Mark all processing items as cancelled (error status).

  This is used when the user wants to cancel everything, including
  items that are currently being processed.

  Returns the number of items cancelled.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE status = ?
    """,
    (
      QueueItemStatus.ERROR.value,
      time.time(),
      "Cancelled by user",
      QueueItemStatus.PROCESSING.value,
    ),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None
  prompt: str | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle schema evolution: 10 base columns + optional context_quadrants + optional prompt
    context = None
    prompt = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])
    if len(row) > 11 and row[11]:
      prompt = row[11]

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
      prompt=prompt,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    if self.prompt:
      result["prompt"] = self.prompt
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT,
      prompt TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add columns if they don't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")
  if "prompt" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN prompt TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.
    prompt: Optional additional prompt text for generation

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants, prompt)
    VALUES (?, ?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
      prompt,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_next_pending_item_for_available_model(
  conn: sqlite3.Connection, busy_models: set[str | None]
) -> QueueItem | None:
  """
  Get the next pending item for a model that isn't currently busy.

  This enables parallel processing of different models' queues.

  Args:
    conn: Database connection
    busy_models: Set of model_ids that are currently processing
                 (None represents the default/no model)

  Returns None if no available items.
  """
  cursor = conn.cursor()

  # Get all pending items ordered by creation time
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )

  for row in cursor.fetchall():
    item = QueueItem.from_row(row)
    # Check if this model is available (not busy)
    if item.model_id not in busy_models:
      return item

  return None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def get_queue_status_by_model(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get queue status grouped by model.

  Returns a dictionary with:
    - by_model: dict mapping model_id -> {
        is_processing: bool,
        current_item: dict | None,
        pending_count: int,
        pending_items: list of dicts,
        position: int (1-based, 0 if processing)
      }
    - total_pending: int
    - processing_model: str | None (model_id of currently processing item)
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  # Group pending items by model_id
  by_model: dict[str, dict[str, Any]] = {}

  for item in pending:
    model_id = item.model_id or "default"
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": False,
        "current_item": None,
        "pending_count": 0,
        "pending_items": [],
      }
    by_model[model_id]["pending_count"] += 1
    by_model[model_id]["pending_items"].append(item.to_dict())

  # Add processing item to its model's status
  processing_model = None
  if processing:
    model_id = processing.model_id or "default"
    processing_model = model_id
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": True,
        "current_item": processing.to_dict(),
        "pending_count": 0,
        "pending_items": [],
      }
    else:
      by_model[model_id]["is_processing"] = True
      by_model[model_id]["current_item"] = processing.to_dict()

  return {
    "by_model": by_model,
    "total_pending": len(pending),
    "processing_model": processing_model,
  }


def get_queue_position_for_model(
  conn: sqlite3.Connection, item_id: int, model_id: str | None
) -> int:
  """
  Get the position of an item within its model's queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue for this model, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # For model-specific position, count items with same model_id that are ahead
  # Use empty string for NULL model_id comparison
  if model_id is None:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id IS NULL
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, item_id),
    )
  else:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id = ?
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, model_id, item_id),
    )

  row = cursor.fetchone()
  if row:
    return row[0]

  return -1


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def cancel_processing_items(conn: sqlite3.Connection) -> int:
  """
  Mark all processing items as cancelled (error status).

  This is used when the user wants to cancel everything, including
  items that are currently being processed.

  Returns the number of items cancelled.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE status = ?
    """,
    (
      QueueItemStatus.ERROR.value,
      time.time(),
      "Cancelled by user",
      QueueItemStatus.PROCESSING.value,
    ),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None
  prompt: str | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle schema evolution: 10 base columns + optional context_quadrants + optional prompt
    context = None
    prompt = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])
    if len(row) > 11 and row[11]:
      prompt = row[11]

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
      prompt=prompt,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    if self.prompt:
      result["prompt"] = self.prompt
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT,
      prompt TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add columns if they don't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")
  if "prompt" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN prompt TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.
    prompt: Optional additional prompt text for generation

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants, prompt)
    VALUES (?, ?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
      prompt,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_next_pending_item_for_available_model(
  conn: sqlite3.Connection, busy_models: set[str | None]
) -> QueueItem | None:
  """
  Get the next pending item for a model that isn't currently busy.

  This enables parallel processing of different models' queues.

  Args:
    conn: Database connection
    busy_models: Set of model_ids that are currently processing
                 (None represents the default/no model)

  Returns None if no available items.
  """
  cursor = conn.cursor()

  # Get all pending items ordered by creation time
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )

  for row in cursor.fetchall():
    item = QueueItem.from_row(row)
    # Check if this model is available (not busy)
    if item.model_id not in busy_models:
      return item

  return None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def get_queue_status_by_model(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get queue status grouped by model.

  Returns a dictionary with:
    - by_model: dict mapping model_id -> {
        is_processing: bool,
        current_item: dict | None,
        pending_count: int,
        pending_items: list of dicts,
        position: int (1-based, 0 if processing)
      }
    - total_pending: int
    - processing_model: str | None (model_id of currently processing item)
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  # Group pending items by model_id
  by_model: dict[str, dict[str, Any]] = {}

  for item in pending:
    model_id = item.model_id or "default"
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": False,
        "current_item": None,
        "pending_count": 0,
        "pending_items": [],
      }
    by_model[model_id]["pending_count"] += 1
    by_model[model_id]["pending_items"].append(item.to_dict())

  # Add processing item to its model's status
  processing_model = None
  if processing:
    model_id = processing.model_id or "default"
    processing_model = model_id
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": True,
        "current_item": processing.to_dict(),
        "pending_count": 0,
        "pending_items": [],
      }
    else:
      by_model[model_id]["is_processing"] = True
      by_model[model_id]["current_item"] = processing.to_dict()

  return {
    "by_model": by_model,
    "total_pending": len(pending),
    "processing_model": processing_model,
  }


def get_queue_position_for_model(
  conn: sqlite3.Connection, item_id: int, model_id: str | None
) -> int:
  """
  Get the position of an item within its model's queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue for this model, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # For model-specific position, count items with same model_id that are ahead
  # Use empty string for NULL model_id comparison
  if model_id is None:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id IS NULL
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, item_id),
    )
  else:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id = ?
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, model_id, item_id),
    )

  row = cursor.fetchone()
  if row:
    return row[0]

  return -1


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def cancel_processing_items(conn: sqlite3.Connection) -> int:
  """
  Mark all processing items as cancelled (error status).

  This is used when the user wants to cancel everything, including
  items that are currently being processed.

  Returns the number of items cancelled.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE status = ?
    """,
    (
      QueueItemStatus.ERROR.value,
      time.time(),
      "Cancelled by user",
      QueueItemStatus.PROCESSING.value,
    ),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None
  prompt: str | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle schema evolution: 10 base columns + optional context_quadrants + optional prompt
    context = None
    prompt = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])
    if len(row) > 11 and row[11]:
      prompt = row[11]

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
      prompt=prompt,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    if self.prompt:
      result["prompt"] = self.prompt
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT,
      prompt TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add columns if they don't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")
  if "prompt" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN prompt TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.
    prompt: Optional additional prompt text for generation

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants, prompt)
    VALUES (?, ?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
      prompt,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_next_pending_item_for_available_model(
  conn: sqlite3.Connection, busy_models: set[str | None]
) -> QueueItem | None:
  """
  Get the next pending item for a model that isn't currently busy.

  This enables parallel processing of different models' queues.

  Args:
    conn: Database connection
    busy_models: Set of model_ids that are currently processing
                 (None represents the default/no model)

  Returns None if no available items.
  """
  cursor = conn.cursor()

  # Get all pending items ordered by creation time
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )

  for row in cursor.fetchall():
    item = QueueItem.from_row(row)
    # Check if this model is available (not busy)
    if item.model_id not in busy_models:
      return item

  return None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def get_queue_status_by_model(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get queue status grouped by model.

  Returns a dictionary with:
    - by_model: dict mapping model_id -> {
        is_processing: bool,
        current_item: dict | None,
        pending_count: int,
        pending_items: list of dicts,
        position: int (1-based, 0 if processing)
      }
    - total_pending: int
    - processing_model: str | None (model_id of currently processing item)
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  # Group pending items by model_id
  by_model: dict[str, dict[str, Any]] = {}

  for item in pending:
    model_id = item.model_id or "default"
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": False,
        "current_item": None,
        "pending_count": 0,
        "pending_items": [],
      }
    by_model[model_id]["pending_count"] += 1
    by_model[model_id]["pending_items"].append(item.to_dict())

  # Add processing item to its model's status
  processing_model = None
  if processing:
    model_id = processing.model_id or "default"
    processing_model = model_id
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": True,
        "current_item": processing.to_dict(),
        "pending_count": 0,
        "pending_items": [],
      }
    else:
      by_model[model_id]["is_processing"] = True
      by_model[model_id]["current_item"] = processing.to_dict()

  return {
    "by_model": by_model,
    "total_pending": len(pending),
    "processing_model": processing_model,
  }


def get_queue_position_for_model(
  conn: sqlite3.Connection, item_id: int, model_id: str | None
) -> int:
  """
  Get the position of an item within its model's queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue for this model, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # For model-specific position, count items with same model_id that are ahead
  # Use empty string for NULL model_id comparison
  if model_id is None:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id IS NULL
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, item_id),
    )
  else:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id = ?
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, model_id, item_id),
    )

  row = cursor.fetchone()
  if row:
    return row[0]

  return -1


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def cancel_processing_items(conn: sqlite3.Connection) -> int:
  """
  Mark all processing items as cancelled (error status).

  This is used when the user wants to cancel everything, including
  items that are currently being processed.

  Returns the number of items cancelled.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE status = ?
    """,
    (
      QueueItemStatus.ERROR.value,
      time.time(),
      "Cancelled by user",
      QueueItemStatus.PROCESSING.value,
    ),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_model": model_status["processing_model"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "generate", model_id, context_quadrants)
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_model": model_status["processing_model"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  # Parse optional prompt
  prompt = data.get("prompt")
  if prompt and not isinstance(prompt, str):
    return jsonify(
      {
        "success": False,
        "error": "prompt must be a string",
      }
    ), 400

  # Clean up prompt (strip whitespace, None if empty)
  if prompt:
    prompt = prompt.strip()
    if not prompt:
      prompt = None

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  if prompt:
    print(f"   Prompt: {prompt}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(
    selected_quadrants, "generate", model_id, context_quadrants, prompt
  )
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants, prompt
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None
    prompt = row[4]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    if prompt:
      print(f"   Prompt: {prompt}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants, prompt
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_model": model_status["processing_model"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  # Parse optional prompt
  prompt = data.get("prompt")
  if prompt and not isinstance(prompt, str):
    return jsonify(
      {
        "success": False,
        "error": "prompt must be a string",
      }
    ), 400

  # Clean up prompt (strip whitespace, None if empty)
  if prompt:
    prompt = prompt.strip()
    if not prompt:
      prompt = None

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  if prompt:
    print(f"   Prompt: {prompt}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(
    selected_quadrants, "generate", model_id, context_quadrants, prompt
  )
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.
    prompt: Optional additional prompt text for generation

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants, prompt
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None
    prompt = row[4]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    if prompt:
      print(f"   Prompt: {prompt}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants, prompt
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_model": model_status["processing_model"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
    }

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  # Parse optional prompt
  prompt = data.get("prompt")
  if prompt and not isinstance(prompt, str):
    return jsonify(
      {
        "success": False,
        "error": "prompt must be a string",
      }
    ), 400

  # Clean up prompt (strip whitespace, None if empty)
  if prompt:
    prompt = prompt.strip()
    if not prompt:
      prompt = None

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  if prompt:
    print(f"   Prompt: {prompt}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(
    selected_quadrants, "generate", model_id, context_quadrants, prompt
  )
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Reusable library for generating pixel art using the Oxen.ai model.

This module provides the core generation logic that can be used by:
- view_generations.py (Flask web server)
- generate_tiles_omni.py (command-line script)
- automatic_generation.py (automated generation)

The main entry point is `run_generation_for_quadrants()` which handles:
1. Validating the quadrant selection
2. Rendering any missing quadrants
3. Building the template image
4. Uploading to GCS and calling the Oxen API
5. Saving the generated quadrants to the database
"""

import os
import re
import sqlite3
import tempfile
from io import BytesIO
from pathlib import Path
from typing import Callable
from urllib.parse import urlencode

import requests
from dotenv import load_dotenv
from PIL import Image
from playwright.sync_api import sync_playwright

from isometric_nyc.e2e_generation.infill_template import (
  QUADRANT_SIZE,
  InfillRegion,
  TemplateBuilder,
  validate_quadrant_selection,
)
from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  ensure_quadrant_exists,
  image_to_png_bytes,
  png_bytes_to_image,
  save_quadrant_generation,
  save_quadrant_render,
  split_tile_into_quadrants,
  upload_to_gcs,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_generation as shared_get_quadrant_generation,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_render as shared_get_quadrant_render,
)

# Load environment variables
load_dotenv()

# Oxen API configuration
OMNI_MODEL_ID = "cannoneyed-gentle-gold-antlion"
OMNI_WATER_MODEL_ID = "cannoneyed-quiet-green-lamprey"
OMNI_WATER_V2_MODEL_ID = "cannoneyed-rural-rose-dingo"

GCS_BUCKET_NAME = "isometric-nyc-infills"


# =============================================================================
# Quadrant Parsing Utilities
# =============================================================================


def parse_quadrant_tuple(s: str) -> tuple[int, int]:
  """
  Parse a quadrant tuple string like "(0,1)" or "0,1" into a tuple.

  Args:
      s: String in format "(x,y)" or "x,y"

  Returns:
      Tuple of (x, y) coordinates

  Raises:
      ValueError: If the format is invalid
  """
  s = s.strip()
  # Remove optional parentheses
  if s.startswith("(") and s.endswith(")"):
    s = s[1:-1]
  parts = s.split(",")
  if len(parts) != 2:
    raise ValueError(f"Invalid quadrant tuple format: {s}")
  return (int(parts[0].strip()), int(parts[1].strip()))


def parse_quadrant_list(s: str) -> list[tuple[int, int]]:
  """
  Parse a comma-separated list of quadrant tuples.

  Args:
      s: String like "(0,1),(0,2)" or "(0,1), (0,2)"

  Returns:
      List of (x, y) coordinate tuples

  Raises:
      ValueError: If the format is invalid
  """
  # Use regex to find all (x,y) patterns
  pattern = r"\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)"
  matches = re.findall(pattern, s)
  if not matches:
    raise ValueError(f"No valid quadrant tuples found in: {s}")
  return [(int(x), int(y)) for x, y in matches]


# =============================================================================
# Oxen API Functions
# =============================================================================


def call_oxen_api(
  image_url: str,
  model_config: "ModelConfig | None" = None,  # noqa: F821
) -> str:
  """
  Call the Oxen API to generate pixel art.

  Args:
      image_url: Public URL of the input template image
      model_config: Optional model configuration (ModelConfig from model_config.py).
        If not provided, uses defaults.

  Returns:
      URL of the generated image

  Raises:
      requests.HTTPError: If the API call fails
      ValueError: If the response format is unexpected
  """
  # Use provided config or defaults
  if model_config is not None:
    endpoint = model_config.endpoint
    model_id = model_config.model_id
    api_key = model_config.api_key
    num_inference_steps = model_config.num_inference_steps
  else:
    endpoint = "https://hub.oxen.ai/api/images/edit"
    model_id = OMNI_WATER_MODEL_ID
    api_key = os.getenv("OXEN_OMNI_v04_WATER_API_KEY")
    num_inference_steps = 28

  if not api_key:
    raise ValueError(f"API key not found for model {model_id}")

  headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json",
  }

  prompt = (
    "Fill in the outlined section with the missing pixels corresponding to "
    "the <isometric nyc pixel art> style, removing the border and exactly "
    "following the shape/style/structure of the surrounding image (if present)."
  )

  payload = {
    "model": model_id,
    "input_image": image_url,
    "prompt": prompt,
    "num_inference_steps": num_inference_steps,
  }

  print(f"   ü§ñ Calling Oxen API with model {model_id}...")
  response = requests.post(endpoint, headers=headers, json=payload, timeout=300)
  response.raise_for_status()

  result = response.json()

  if "images" in result and len(result["images"]) > 0:
    return result["images"][0]["url"]
  elif "url" in result:
    return result["url"]
  elif "image_url" in result:
    return result["image_url"]
  elif "output" in result:
    return result["output"]
  else:
    raise ValueError(f"Unexpected API response format: {result}")


def download_image_to_pil(url: str) -> Image.Image:
  """
  Download an image from a URL and return as PIL Image.

  Args:
      url: URL of the image to download

  Returns:
      PIL Image object
  """
  response = requests.get(url, timeout=120)
  response.raise_for_status()
  return Image.open(BytesIO(response.content))


# =============================================================================
# Rendering Functions
# =============================================================================


def render_quadrant(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
  port: int,
) -> bytes | None:
  """
  Render a quadrant and save to database.

  This renders the tile containing the quadrant and saves all 4 quadrants.

  Args:
      conn: Database connection
      config: Generation config dict
      x: Quadrant x coordinate
      y: Quadrant y coordinate
      port: Web server port for rendering

  Returns:
      PNG bytes of the rendered quadrant, or None if failed
  """
  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  # Build URL for rendering
  params = {
    "export": "true",
    "lat": quadrant["lat"],
    "lon": quadrant["lng"],
    "width": config["width_px"],
    "height": config["height_px"],
    "azimuth": config["camera_azimuth_degrees"],
    "elevation": config["camera_elevation_degrees"],
    "view_height": config.get("view_height_meters", 200),
  }
  query_string = urlencode(params)
  url = f"http://localhost:{port}/?{query_string}"

  # Render using Playwright
  with sync_playwright() as p:
    browser = p.chromium.launch(
      headless=True,
      args=[
        "--enable-webgl",
        "--use-gl=angle",
        "--ignore-gpu-blocklist",
      ],
    )

    context = browser.new_context(
      viewport={"width": config["width_px"], "height": config["height_px"]},
      device_scale_factor=1,
    )
    page = context.new_page()

    page.goto(url, wait_until="networkidle")

    try:
      page.wait_for_function("window.TILES_LOADED === true", timeout=60000)
    except Exception:
      print("      ‚ö†Ô∏è  Timeout waiting for tiles, continuing anyway...")

    # Get screenshot as bytes
    screenshot_bytes = page.screenshot(type="png")

    page.close()
    context.close()
    browser.close()

  # Open as PIL image and split into quadrants
  full_tile = Image.open(BytesIO(screenshot_bytes))
  quadrant_images = split_tile_into_quadrants(full_tile)

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), quad_img in quadrant_images.items():
    qx, qy = x + dx, y + dy
    png_bytes = image_to_png_bytes(quad_img)
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


# =============================================================================
# Core Generation Logic
# =============================================================================


def run_generation_for_quadrants(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  port: int = DEFAULT_WEB_PORT,
  bucket_name: str = GCS_BUCKET_NAME,
  status_callback: Callable[[str, str], None] | None = None,
  model_config: "ModelConfig | None" = None,  # noqa: F821
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is the main entry point for generation. It:
  1. Validates the quadrant selection
  2. Renders any missing quadrants
  3. Builds the template image with appropriate borders
  4. Uploads to GCS and calls the Oxen API
  5. Saves the generated quadrants to the database

  Args:
      conn: Database connection
      config: Generation config dict
      selected_quadrants: List of (x, y) quadrant coordinates to generate
      port: Web server port for rendering (default: 5173)
      bucket_name: GCS bucket name for uploads
      status_callback: Optional callback(status, message) for progress updates
      model_config: Optional model configuration for the Oxen API (ModelConfig from model_config.py)
      context_quadrants: Optional list of (x, y) quadrant coordinates to use as
        context. These quadrants provide surrounding pixel art context for the
        generation. If a context quadrant has a generation, that will be used;
        otherwise the render will be used.
      prompt: Optional additional prompt text for generation

  Returns:
      Dict with:
          - success: bool
          - message: str (on success)
          - error: str (on failure)
          - quadrants: list of generated quadrant coords (on success)
  """
  # Convert context quadrants to a set for fast lookup
  context_set: set[tuple[int, int]] = (
    set(context_quadrants) if context_quadrants else set()
  )
  if context_set:
    print(f"   üìã Using {len(context_set)} context quadrant(s): {list(context_set)}")
  if prompt:
    print(f"   üìù Additional prompt: {prompt}")

  def update_status(status: str, message: str = "") -> None:
    if status_callback:
      status_callback(status, message)

  update_status("validating", "Checking API key...")

  # Create helper functions for validation
  # These are modified to treat context quadrants as "generated" if they have
  # either a generation or a render
  def has_generation_in_db(qx: int, qy: int) -> bool:
    # Check if this quadrant has an actual generation
    gen = shared_get_quadrant_generation(conn, qx, qy)
    if gen is not None:
      return True

    # For context quadrants, treat them as "generated" if they have a render
    # This allows context quadrants to provide surrounding content even if
    # they don't have generations yet
    if (qx, qy) in context_set:
      render = shared_get_quadrant_render(conn, qx, qy)
      return render is not None

    return False

  def get_render_from_db_with_render(qx: int, qy: int) -> Image.Image | None:
    """Get render, rendering if it doesn't exist yet."""
    render_bytes = shared_get_quadrant_render(conn, qx, qy)
    if render_bytes:
      return png_bytes_to_image(render_bytes)

    # Need to render
    update_status("rendering", f"Rendering quadrant ({qx}, {qy})...")
    print(f"   üì¶ Rendering quadrant ({qx}, {qy})...")
    render_bytes = render_quadrant(conn, config, qx, qy, port)
    if render_bytes:
      return png_bytes_to_image(render_bytes)
    return None

  def get_generation_from_db(qx: int, qy: int) -> Image.Image | None:
    """Get generation, falling back to render for context quadrants."""
    gen_bytes = shared_get_quadrant_generation(conn, qx, qy)
    if gen_bytes:
      return png_bytes_to_image(gen_bytes)

    # For context quadrants, fall back to render if no generation exists
    # This allows context quadrants to provide surrounding pixel art context
    # even if they only have renders
    if (qx, qy) in context_set:
      render_bytes = shared_get_quadrant_render(conn, qx, qy)
      if render_bytes:
        print(f"   üìã Using render as context for ({qx}, {qy})")
        return png_bytes_to_image(render_bytes)

    return None

  update_status("validating", "Validating quadrant selection...")

  # Validate selection with auto-expansion
  is_valid, msg, placement = validate_quadrant_selection(
    selected_quadrants, has_generation_in_db, allow_expansion=True
  )

  if not is_valid:
    update_status("error", msg)
    return {"success": False, "error": msg}

  print(f"‚úÖ Validation: {msg}")

  # Get primary quadrants (the ones user selected, not padding)
  primary_quadrants = (
    placement.primary_quadrants if placement.primary_quadrants else selected_quadrants
  )
  padding_quadrants = placement.padding_quadrants if placement else []

  if padding_quadrants:
    print(f"   üì¶ Padding quadrants: {padding_quadrants}")

  # Create the infill region (may be expanded)
  if placement._expanded_region is not None:
    region = placement._expanded_region
  else:
    region = InfillRegion.from_quadrants(selected_quadrants)

  # Build the template
  update_status("rendering", "Building template image...")
  builder = TemplateBuilder(
    region, has_generation_in_db, get_render_from_db_with_render, get_generation_from_db
  )

  print("üìã Building template...")
  result = builder.build(border_width=2, allow_expansion=True)

  if result is None:
    error_msg = builder._last_validation_error or "Failed to build template"
    update_status("error", error_msg)
    return {
      "success": False,
      "error": error_msg,
    }

  template_image, placement = result

  # Save template to temp file and upload to GCS
  with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
    template_path = Path(tmp.name)
    template_image.save(template_path)

  try:
    update_status("uploading", "Uploading template to cloud...")
    print("üì§ Uploading template to GCS...")
    print(f"   Template path: {template_path}")
    print(f"   Template size: {template_image.size[0]}x{template_image.size[1]}")
    image_url = upload_to_gcs(template_path, bucket_name)
    print(f"   Uploaded URL: {image_url}")

    update_status("generating", "Calling AI model (this may take a minute)...")
    print("ü§ñ Calling Oxen API...")
    generated_url = call_oxen_api(image_url, model_config)

    update_status("saving", "Downloading and saving results...")
    print("üì• Downloading generated image...")
    print(f"   Generated URL: {generated_url}")
    generated_image = download_image_to_pil(generated_url)

    # Extract quadrants from generated image and save to database
    print("üíæ Saving generated quadrants to database...")

    # Figure out what quadrants are in the infill region
    all_infill_quadrants = (
      placement.all_infill_quadrants
      if placement.all_infill_quadrants
      else region.overlapping_quadrants()
    )

    # For each infill quadrant, extract pixels from the generated image
    saved_count = 0
    for qx, qy in all_infill_quadrants:
      # Calculate position in the generated image
      quad_world_x = qx * QUADRANT_SIZE
      quad_world_y = qy * QUADRANT_SIZE

      template_x = quad_world_x - placement.world_offset_x
      template_y = quad_world_y - placement.world_offset_y

      # Crop this quadrant from the generated image
      crop_box = (
        template_x,
        template_y,
        template_x + QUADRANT_SIZE,
        template_y + QUADRANT_SIZE,
      )
      quad_img = generated_image.crop(crop_box)
      png_bytes = image_to_png_bytes(quad_img)

      # Only save primary quadrants (not padding)
      if (qx, qy) in primary_quadrants or (qx, qy) in [
        (q[0], q[1]) for q in primary_quadrants
      ]:
        if save_quadrant_generation(conn, config, qx, qy, png_bytes):
          print(f"   ‚úì Saved generation for ({qx}, {qy})")
          saved_count += 1
        else:
          print(f"   ‚ö†Ô∏è Failed to save generation for ({qx}, {qy})")
      else:
        print(f"   ‚è≠Ô∏è Skipped padding quadrant ({qx}, {qy})")

    update_status("complete", f"Generated {saved_count} quadrant(s)")
    return {
      "success": True,
      "message": f"Generated {saved_count} quadrant{'s' if saved_count != 1 else ''}",
      "quadrants": list(primary_quadrants),
    }

  finally:
    # Clean up temp file
    template_path.unlink(missing_ok=True)

```

```python
"""
Reusable library for generating pixel art using the Oxen.ai model.

This module provides the core generation logic that can be used by:
- view_generations.py (Flask web server)
- generate_tiles_omni.py (command-line script)
- automatic_generation.py (automated generation)

The main entry point is `run_generation_for_quadrants()` which handles:
1. Validating the quadrant selection
2. Rendering any missing quadrants
3. Building the template image
4. Uploading to GCS and calling the Oxen API
5. Saving the generated quadrants to the database
"""

import os
import re
import sqlite3
import tempfile
from io import BytesIO
from pathlib import Path
from typing import Callable
from urllib.parse import urlencode

import requests
from dotenv import load_dotenv
from PIL import Image
from playwright.sync_api import sync_playwright

from isometric_nyc.e2e_generation.infill_template import (
  QUADRANT_SIZE,
  InfillRegion,
  TemplateBuilder,
  validate_quadrant_selection,
)
from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  ensure_quadrant_exists,
  image_to_png_bytes,
  png_bytes_to_image,
  save_quadrant_generation,
  save_quadrant_render,
  split_tile_into_quadrants,
  upload_to_gcs,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_generation as shared_get_quadrant_generation,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_render as shared_get_quadrant_render,
)

# Load environment variables
load_dotenv()

# Oxen API configuration
OMNI_MODEL_ID = "cannoneyed-gentle-gold-antlion"
OMNI_WATER_MODEL_ID = "cannoneyed-quiet-green-lamprey"
OMNI_WATER_V2_MODEL_ID = "cannoneyed-rural-rose-dingo"

GCS_BUCKET_NAME = "isometric-nyc-infills"


# =============================================================================
# Quadrant Parsing Utilities
# =============================================================================


def parse_quadrant_tuple(s: str) -> tuple[int, int]:
  """
  Parse a quadrant tuple string like "(0,1)" or "0,1" into a tuple.

  Args:
      s: String in format "(x,y)" or "x,y"

  Returns:
      Tuple of (x, y) coordinates

  Raises:
      ValueError: If the format is invalid
  """
  s = s.strip()
  # Remove optional parentheses
  if s.startswith("(") and s.endswith(")"):
    s = s[1:-1]
  parts = s.split(",")
  if len(parts) != 2:
    raise ValueError(f"Invalid quadrant tuple format: {s}")
  return (int(parts[0].strip()), int(parts[1].strip()))


def parse_quadrant_list(s: str) -> list[tuple[int, int]]:
  """
  Parse a comma-separated list of quadrant tuples.

  Args:
      s: String like "(0,1),(0,2)" or "(0,1), (0,2)"

  Returns:
      List of (x, y) coordinate tuples

  Raises:
      ValueError: If the format is invalid
  """
  # Use regex to find all (x,y) patterns
  pattern = r"\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)"
  matches = re.findall(pattern, s)
  if not matches:
    raise ValueError(f"No valid quadrant tuples found in: {s}")
  return [(int(x), int(y)) for x, y in matches]


# =============================================================================
# Oxen API Functions
# =============================================================================


def call_oxen_api(
  image_url: str,
  model_config: "ModelConfig | None" = None,  # noqa: F821
  additional_prompt: str | None = None,
) -> str:
  """
  Call the Oxen API to generate pixel art.

  Args:
      image_url: Public URL of the input template image
      model_config: Optional model configuration (ModelConfig from model_config.py).
        If not provided, uses defaults.
      additional_prompt: Optional additional text to append to the base prompt

  Returns:
      URL of the generated image

  Raises:
      requests.HTTPError: If the API call fails
      ValueError: If the response format is unexpected
  """
  # Use provided config or defaults
  if model_config is not None:
    endpoint = model_config.endpoint
    model_id = model_config.model_id
    api_key = model_config.api_key
    num_inference_steps = model_config.num_inference_steps
  else:
    endpoint = "https://hub.oxen.ai/api/images/edit"
    model_id = OMNI_WATER_MODEL_ID
    api_key = os.getenv("OXEN_OMNI_v04_WATER_API_KEY")
    num_inference_steps = 28

  if not api_key:
    raise ValueError(f"API key not found for model {model_id}")

  headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json",
  }

  # Build prompt - base prompt plus any additional text
  base_prompt = (
    "Fill in the outlined section with the missing pixels corresponding to "
    "the <isometric nyc pixel art> style, removing the border and exactly "
    "following the shape/style/structure of the surrounding image (if present)."
  )

  if additional_prompt:
    prompt = f"{base_prompt} {additional_prompt}"
    print(f"   üìù Using additional prompt: {additional_prompt}")
  else:
    prompt = base_prompt

  payload = {
    "model": model_id,
    "input_image": image_url,
    "prompt": prompt,
    "num_inference_steps": num_inference_steps,
  }

  print(f"   ü§ñ Calling Oxen API with model {model_id}...")
  response = requests.post(endpoint, headers=headers, json=payload, timeout=300)
  response.raise_for_status()

  result = response.json()

  if "images" in result and len(result["images"]) > 0:
    return result["images"][0]["url"]
  elif "url" in result:
    return result["url"]
  elif "image_url" in result:
    return result["image_url"]
  elif "output" in result:
    return result["output"]
  else:
    raise ValueError(f"Unexpected API response format: {result}")


def download_image_to_pil(url: str) -> Image.Image:
  """
  Download an image from a URL and return as PIL Image.

  Args:
      url: URL of the image to download

  Returns:
      PIL Image object
  """
  response = requests.get(url, timeout=120)
  response.raise_for_status()
  return Image.open(BytesIO(response.content))


# =============================================================================
# Rendering Functions
# =============================================================================


def render_quadrant(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
  port: int,
) -> bytes | None:
  """
  Render a quadrant and save to database.

  This renders the tile containing the quadrant and saves all 4 quadrants.

  Args:
      conn: Database connection
      config: Generation config dict
      x: Quadrant x coordinate
      y: Quadrant y coordinate
      port: Web server port for rendering

  Returns:
      PNG bytes of the rendered quadrant, or None if failed
  """
  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  # Build URL for rendering
  params = {
    "export": "true",
    "lat": quadrant["lat"],
    "lon": quadrant["lng"],
    "width": config["width_px"],
    "height": config["height_px"],
    "azimuth": config["camera_azimuth_degrees"],
    "elevation": config["camera_elevation_degrees"],
    "view_height": config.get("view_height_meters", 200),
  }
  query_string = urlencode(params)
  url = f"http://localhost:{port}/?{query_string}"

  # Render using Playwright
  with sync_playwright() as p:
    browser = p.chromium.launch(
      headless=True,
      args=[
        "--enable-webgl",
        "--use-gl=angle",
        "--ignore-gpu-blocklist",
      ],
    )

    context = browser.new_context(
      viewport={"width": config["width_px"], "height": config["height_px"]},
      device_scale_factor=1,
    )
    page = context.new_page()

    page.goto(url, wait_until="networkidle")

    try:
      page.wait_for_function("window.TILES_LOADED === true", timeout=60000)
    except Exception:
      print("      ‚ö†Ô∏è  Timeout waiting for tiles, continuing anyway...")

    # Get screenshot as bytes
    screenshot_bytes = page.screenshot(type="png")

    page.close()
    context.close()
    browser.close()

  # Open as PIL image and split into quadrants
  full_tile = Image.open(BytesIO(screenshot_bytes))
  quadrant_images = split_tile_into_quadrants(full_tile)

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), quad_img in quadrant_images.items():
    qx, qy = x + dx, y + dy
    png_bytes = image_to_png_bytes(quad_img)
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


# =============================================================================
# Core Generation Logic
# =============================================================================


def run_generation_for_quadrants(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  port: int = DEFAULT_WEB_PORT,
  bucket_name: str = GCS_BUCKET_NAME,
  status_callback: Callable[[str, str], None] | None = None,
  model_config: "ModelConfig | None" = None,  # noqa: F821
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is the main entry point for generation. It:
  1. Validates the quadrant selection
  2. Renders any missing quadrants
  3. Builds the template image with appropriate borders
  4. Uploads to GCS and calls the Oxen API
  5. Saves the generated quadrants to the database

  Args:
      conn: Database connection
      config: Generation config dict
      selected_quadrants: List of (x, y) quadrant coordinates to generate
      port: Web server port for rendering (default: 5173)
      bucket_name: GCS bucket name for uploads
      status_callback: Optional callback(status, message) for progress updates
      model_config: Optional model configuration for the Oxen API (ModelConfig from model_config.py)
      context_quadrants: Optional list of (x, y) quadrant coordinates to use as
        context. These quadrants provide surrounding pixel art context for the
        generation. If a context quadrant has a generation, that will be used;
        otherwise the render will be used.
      prompt: Optional additional prompt text for generation

  Returns:
      Dict with:
          - success: bool
          - message: str (on success)
          - error: str (on failure)
          - quadrants: list of generated quadrant coords (on success)
  """
  # Convert context quadrants to a set for fast lookup
  context_set: set[tuple[int, int]] = (
    set(context_quadrants) if context_quadrants else set()
  )
  if context_set:
    print(f"   üìã Using {len(context_set)} context quadrant(s): {list(context_set)}")
  if prompt:
    print(f"   üìù Additional prompt: {prompt}")

  def update_status(status: str, message: str = "") -> None:
    if status_callback:
      status_callback(status, message)

  update_status("validating", "Checking API key...")

  # Create helper functions for validation
  # These are modified to treat context quadrants as "generated" if they have
  # either a generation or a render
  def has_generation_in_db(qx: int, qy: int) -> bool:
    # Check if this quadrant has an actual generation
    gen = shared_get_quadrant_generation(conn, qx, qy)
    if gen is not None:
      return True

    # For context quadrants, treat them as "generated" if they have a render
    # This allows context quadrants to provide surrounding content even if
    # they don't have generations yet
    if (qx, qy) in context_set:
      render = shared_get_quadrant_render(conn, qx, qy)
      return render is not None

    return False

  def get_render_from_db_with_render(qx: int, qy: int) -> Image.Image | None:
    """Get render, rendering if it doesn't exist yet."""
    render_bytes = shared_get_quadrant_render(conn, qx, qy)
    if render_bytes:
      return png_bytes_to_image(render_bytes)

    # Need to render
    update_status("rendering", f"Rendering quadrant ({qx}, {qy})...")
    print(f"   üì¶ Rendering quadrant ({qx}, {qy})...")
    render_bytes = render_quadrant(conn, config, qx, qy, port)
    if render_bytes:
      return png_bytes_to_image(render_bytes)
    return None

  def get_generation_from_db(qx: int, qy: int) -> Image.Image | None:
    """Get generation, falling back to render for context quadrants."""
    gen_bytes = shared_get_quadrant_generation(conn, qx, qy)
    if gen_bytes:
      return png_bytes_to_image(gen_bytes)

    # For context quadrants, fall back to render if no generation exists
    # This allows context quadrants to provide surrounding pixel art context
    # even if they only have renders
    if (qx, qy) in context_set:
      render_bytes = shared_get_quadrant_render(conn, qx, qy)
      if render_bytes:
        print(f"   üìã Using render as context for ({qx}, {qy})")
        return png_bytes_to_image(render_bytes)

    return None

  update_status("validating", "Validating quadrant selection...")

  # Validate selection with auto-expansion
  is_valid, msg, placement = validate_quadrant_selection(
    selected_quadrants, has_generation_in_db, allow_expansion=True
  )

  if not is_valid:
    update_status("error", msg)
    return {"success": False, "error": msg}

  print(f"‚úÖ Validation: {msg}")

  # Get primary quadrants (the ones user selected, not padding)
  primary_quadrants = (
    placement.primary_quadrants if placement.primary_quadrants else selected_quadrants
  )
  padding_quadrants = placement.padding_quadrants if placement else []

  if padding_quadrants:
    print(f"   üì¶ Padding quadrants: {padding_quadrants}")

  # Create the infill region (may be expanded)
  if placement._expanded_region is not None:
    region = placement._expanded_region
  else:
    region = InfillRegion.from_quadrants(selected_quadrants)

  # Build the template
  update_status("rendering", "Building template image...")
  builder = TemplateBuilder(
    region, has_generation_in_db, get_render_from_db_with_render, get_generation_from_db
  )

  print("üìã Building template...")
  result = builder.build(border_width=2, allow_expansion=True)

  if result is None:
    error_msg = builder._last_validation_error or "Failed to build template"
    update_status("error", error_msg)
    return {
      "success": False,
      "error": error_msg,
    }

  template_image, placement = result

  # Save template to temp file and upload to GCS
  with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
    template_path = Path(tmp.name)
    template_image.save(template_path)

  try:
    update_status("uploading", "Uploading template to cloud...")
    print("üì§ Uploading template to GCS...")
    print(f"   Template path: {template_path}")
    print(f"   Template size: {template_image.size[0]}x{template_image.size[1]}")
    image_url = upload_to_gcs(template_path, bucket_name)
    print(f"   Uploaded URL: {image_url}")

    update_status("generating", "Calling AI model (this may take a minute)...")
    print("ü§ñ Calling Oxen API...")
    generated_url = call_oxen_api(image_url, model_config)

    update_status("saving", "Downloading and saving results...")
    print("üì• Downloading generated image...")
    print(f"   Generated URL: {generated_url}")
    generated_image = download_image_to_pil(generated_url)

    # Extract quadrants from generated image and save to database
    print("üíæ Saving generated quadrants to database...")

    # Figure out what quadrants are in the infill region
    all_infill_quadrants = (
      placement.all_infill_quadrants
      if placement.all_infill_quadrants
      else region.overlapping_quadrants()
    )

    # For each infill quadrant, extract pixels from the generated image
    saved_count = 0
    for qx, qy in all_infill_quadrants:
      # Calculate position in the generated image
      quad_world_x = qx * QUADRANT_SIZE
      quad_world_y = qy * QUADRANT_SIZE

      template_x = quad_world_x - placement.world_offset_x
      template_y = quad_world_y - placement.world_offset_y

      # Crop this quadrant from the generated image
      crop_box = (
        template_x,
        template_y,
        template_x + QUADRANT_SIZE,
        template_y + QUADRANT_SIZE,
      )
      quad_img = generated_image.crop(crop_box)
      png_bytes = image_to_png_bytes(quad_img)

      # Only save primary quadrants (not padding)
      if (qx, qy) in primary_quadrants or (qx, qy) in [
        (q[0], q[1]) for q in primary_quadrants
      ]:
        if save_quadrant_generation(conn, config, qx, qy, png_bytes):
          print(f"   ‚úì Saved generation for ({qx}, {qy})")
          saved_count += 1
        else:
          print(f"   ‚ö†Ô∏è Failed to save generation for ({qx}, {qy})")
      else:
        print(f"   ‚è≠Ô∏è Skipped padding quadrant ({qx}, {qy})")

    update_status("complete", f"Generated {saved_count} quadrant(s)")
    return {
      "success": True,
      "message": f"Generated {saved_count} quadrant{'s' if saved_count != 1 else ''}",
      "quadrants": list(primary_quadrants),
    }

  finally:
    # Clean up temp file
    template_path.unlink(missing_ok=True)

```

```python
"""
Reusable library for generating pixel art using the Oxen.ai model.

This module provides the core generation logic that can be used by:
- view_generations.py (Flask web server)
- generate_tiles_omni.py (command-line script)
- automatic_generation.py (automated generation)

The main entry point is `run_generation_for_quadrants()` which handles:
1. Validating the quadrant selection
2. Rendering any missing quadrants
3. Building the template image
4. Uploading to GCS and calling the Oxen API
5. Saving the generated quadrants to the database
"""

import os
import re
import sqlite3
import tempfile
from io import BytesIO
from pathlib import Path
from typing import Callable
from urllib.parse import urlencode

import requests
from dotenv import load_dotenv
from PIL import Image
from playwright.sync_api import sync_playwright

from isometric_nyc.e2e_generation.infill_template import (
  QUADRANT_SIZE,
  InfillRegion,
  TemplateBuilder,
  validate_quadrant_selection,
)
from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  ensure_quadrant_exists,
  image_to_png_bytes,
  png_bytes_to_image,
  save_quadrant_generation,
  save_quadrant_render,
  split_tile_into_quadrants,
  upload_to_gcs,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_generation as shared_get_quadrant_generation,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_render as shared_get_quadrant_render,
)

# Load environment variables
load_dotenv()

# Oxen API configuration
OMNI_MODEL_ID = "cannoneyed-gentle-gold-antlion"
OMNI_WATER_MODEL_ID = "cannoneyed-quiet-green-lamprey"
OMNI_WATER_V2_MODEL_ID = "cannoneyed-rural-rose-dingo"

GCS_BUCKET_NAME = "isometric-nyc-infills"


# =============================================================================
# Quadrant Parsing Utilities
# =============================================================================


def parse_quadrant_tuple(s: str) -> tuple[int, int]:
  """
  Parse a quadrant tuple string like "(0,1)" or "0,1" into a tuple.

  Args:
      s: String in format "(x,y)" or "x,y"

  Returns:
      Tuple of (x, y) coordinates

  Raises:
      ValueError: If the format is invalid
  """
  s = s.strip()
  # Remove optional parentheses
  if s.startswith("(") and s.endswith(")"):
    s = s[1:-1]
  parts = s.split(",")
  if len(parts) != 2:
    raise ValueError(f"Invalid quadrant tuple format: {s}")
  return (int(parts[0].strip()), int(parts[1].strip()))


def parse_quadrant_list(s: str) -> list[tuple[int, int]]:
  """
  Parse a comma-separated list of quadrant tuples.

  Args:
      s: String like "(0,1),(0,2)" or "(0,1), (0,2)"

  Returns:
      List of (x, y) coordinate tuples

  Raises:
      ValueError: If the format is invalid
  """
  # Use regex to find all (x,y) patterns
  pattern = r"\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)"
  matches = re.findall(pattern, s)
  if not matches:
    raise ValueError(f"No valid quadrant tuples found in: {s}")
  return [(int(x), int(y)) for x, y in matches]


# =============================================================================
# Oxen API Functions
# =============================================================================


def call_oxen_api(
  image_url: str,
  model_config: "ModelConfig | None" = None,  # noqa: F821
  additional_prompt: str | None = None,
) -> str:
  """
  Call the Oxen API to generate pixel art.

  Args:
      image_url: Public URL of the input template image
      model_config: Optional model configuration (ModelConfig from model_config.py).
        If not provided, uses defaults.
      additional_prompt: Optional additional text to append to the base prompt

  Returns:
      URL of the generated image

  Raises:
      requests.HTTPError: If the API call fails
      ValueError: If the response format is unexpected
  """
  # Use provided config or defaults
  if model_config is not None:
    endpoint = model_config.endpoint
    model_id = model_config.model_id
    api_key = model_config.api_key
    num_inference_steps = model_config.num_inference_steps
  else:
    endpoint = "https://hub.oxen.ai/api/images/edit"
    model_id = OMNI_WATER_MODEL_ID
    api_key = os.getenv("OXEN_OMNI_v04_WATER_API_KEY")
    num_inference_steps = 28

  if not api_key:
    raise ValueError(f"API key not found for model {model_id}")

  headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json",
  }

  # Build prompt - base prompt plus any additional text
  base_prompt = (
    "Fill in the outlined section with the missing pixels corresponding to "
    "the <isometric nyc pixel art> style, removing the border and exactly "
    "following the shape/style/structure of the surrounding image (if present)."
  )

  if additional_prompt:
    prompt = f"{base_prompt} {additional_prompt}"
    print(f"   üìù Using additional prompt: {additional_prompt}")
  else:
    prompt = base_prompt

  payload = {
    "model": model_id,
    "input_image": image_url,
    "prompt": prompt,
    "num_inference_steps": num_inference_steps,
  }

  print(f"   ü§ñ Calling Oxen API with model {model_id}...")
  response = requests.post(endpoint, headers=headers, json=payload, timeout=300)
  response.raise_for_status()

  result = response.json()

  if "images" in result and len(result["images"]) > 0:
    return result["images"][0]["url"]
  elif "url" in result:
    return result["url"]
  elif "image_url" in result:
    return result["image_url"]
  elif "output" in result:
    return result["output"]
  else:
    raise ValueError(f"Unexpected API response format: {result}")


def download_image_to_pil(url: str) -> Image.Image:
  """
  Download an image from a URL and return as PIL Image.

  Args:
      url: URL of the image to download

  Returns:
      PIL Image object
  """
  response = requests.get(url, timeout=120)
  response.raise_for_status()
  return Image.open(BytesIO(response.content))


# =============================================================================
# Rendering Functions
# =============================================================================


def render_quadrant(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
  port: int,
) -> bytes | None:
  """
  Render a quadrant and save to database.

  This renders the tile containing the quadrant and saves all 4 quadrants.

  Args:
      conn: Database connection
      config: Generation config dict
      x: Quadrant x coordinate
      y: Quadrant y coordinate
      port: Web server port for rendering

  Returns:
      PNG bytes of the rendered quadrant, or None if failed
  """
  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  # Build URL for rendering
  params = {
    "export": "true",
    "lat": quadrant["lat"],
    "lon": quadrant["lng"],
    "width": config["width_px"],
    "height": config["height_px"],
    "azimuth": config["camera_azimuth_degrees"],
    "elevation": config["camera_elevation_degrees"],
    "view_height": config.get("view_height_meters", 200),
  }
  query_string = urlencode(params)
  url = f"http://localhost:{port}/?{query_string}"

  # Render using Playwright
  with sync_playwright() as p:
    browser = p.chromium.launch(
      headless=True,
      args=[
        "--enable-webgl",
        "--use-gl=angle",
        "--ignore-gpu-blocklist",
      ],
    )

    context = browser.new_context(
      viewport={"width": config["width_px"], "height": config["height_px"]},
      device_scale_factor=1,
    )
    page = context.new_page()

    page.goto(url, wait_until="networkidle")

    try:
      page.wait_for_function("window.TILES_LOADED === true", timeout=60000)
    except Exception:
      print("      ‚ö†Ô∏è  Timeout waiting for tiles, continuing anyway...")

    # Get screenshot as bytes
    screenshot_bytes = page.screenshot(type="png")

    page.close()
    context.close()
    browser.close()

  # Open as PIL image and split into quadrants
  full_tile = Image.open(BytesIO(screenshot_bytes))
  quadrant_images = split_tile_into_quadrants(full_tile)

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), quad_img in quadrant_images.items():
    qx, qy = x + dx, y + dy
    png_bytes = image_to_png_bytes(quad_img)
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


# =============================================================================
# Core Generation Logic
# =============================================================================


def run_generation_for_quadrants(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  port: int = DEFAULT_WEB_PORT,
  bucket_name: str = GCS_BUCKET_NAME,
  status_callback: Callable[[str, str], None] | None = None,
  model_config: "ModelConfig | None" = None,  # noqa: F821
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is the main entry point for generation. It:
  1. Validates the quadrant selection
  2. Renders any missing quadrants
  3. Builds the template image with appropriate borders
  4. Uploads to GCS and calls the Oxen API
  5. Saves the generated quadrants to the database

  Args:
      conn: Database connection
      config: Generation config dict
      selected_quadrants: List of (x, y) quadrant coordinates to generate
      port: Web server port for rendering (default: 5173)
      bucket_name: GCS bucket name for uploads
      status_callback: Optional callback(status, message) for progress updates
      model_config: Optional model configuration for the Oxen API (ModelConfig from model_config.py)
      context_quadrants: Optional list of (x, y) quadrant coordinates to use as
        context. These quadrants provide surrounding pixel art context for the
        generation. If a context quadrant has a generation, that will be used;
        otherwise the render will be used.
      prompt: Optional additional prompt text for generation

  Returns:
      Dict with:
          - success: bool
          - message: str (on success)
          - error: str (on failure)
          - quadrants: list of generated quadrant coords (on success)
  """
  # Convert context quadrants to a set for fast lookup
  context_set: set[tuple[int, int]] = (
    set(context_quadrants) if context_quadrants else set()
  )
  if context_set:
    print(f"   üìã Using {len(context_set)} context quadrant(s): {list(context_set)}")
  if prompt:
    print(f"   üìù Additional prompt: {prompt}")

  def update_status(status: str, message: str = "") -> None:
    if status_callback:
      status_callback(status, message)

  update_status("validating", "Checking API key...")

  # Create helper functions for validation
  # These are modified to treat context quadrants as "generated" if they have
  # either a generation or a render
  def has_generation_in_db(qx: int, qy: int) -> bool:
    # Check if this quadrant has an actual generation
    gen = shared_get_quadrant_generation(conn, qx, qy)
    if gen is not None:
      return True

    # For context quadrants, treat them as "generated" if they have a render
    # This allows context quadrants to provide surrounding content even if
    # they don't have generations yet
    if (qx, qy) in context_set:
      render = shared_get_quadrant_render(conn, qx, qy)
      return render is not None

    return False

  def get_render_from_db_with_render(qx: int, qy: int) -> Image.Image | None:
    """Get render, rendering if it doesn't exist yet."""
    render_bytes = shared_get_quadrant_render(conn, qx, qy)
    if render_bytes:
      return png_bytes_to_image(render_bytes)

    # Need to render
    update_status("rendering", f"Rendering quadrant ({qx}, {qy})...")
    print(f"   üì¶ Rendering quadrant ({qx}, {qy})...")
    render_bytes = render_quadrant(conn, config, qx, qy, port)
    if render_bytes:
      return png_bytes_to_image(render_bytes)
    return None

  def get_generation_from_db(qx: int, qy: int) -> Image.Image | None:
    """Get generation, falling back to render for context quadrants."""
    gen_bytes = shared_get_quadrant_generation(conn, qx, qy)
    if gen_bytes:
      return png_bytes_to_image(gen_bytes)

    # For context quadrants, fall back to render if no generation exists
    # This allows context quadrants to provide surrounding pixel art context
    # even if they only have renders
    if (qx, qy) in context_set:
      render_bytes = shared_get_quadrant_render(conn, qx, qy)
      if render_bytes:
        print(f"   üìã Using render as context for ({qx}, {qy})")
        return png_bytes_to_image(render_bytes)

    return None

  update_status("validating", "Validating quadrant selection...")

  # Validate selection with auto-expansion
  is_valid, msg, placement = validate_quadrant_selection(
    selected_quadrants, has_generation_in_db, allow_expansion=True
  )

  if not is_valid:
    update_status("error", msg)
    return {"success": False, "error": msg}

  print(f"‚úÖ Validation: {msg}")

  # Get primary quadrants (the ones user selected, not padding)
  primary_quadrants = (
    placement.primary_quadrants if placement.primary_quadrants else selected_quadrants
  )
  padding_quadrants = placement.padding_quadrants if placement else []

  if padding_quadrants:
    print(f"   üì¶ Padding quadrants: {padding_quadrants}")

  # Create the infill region (may be expanded)
  if placement._expanded_region is not None:
    region = placement._expanded_region
  else:
    region = InfillRegion.from_quadrants(selected_quadrants)

  # Build the template
  update_status("rendering", "Building template image...")
  builder = TemplateBuilder(
    region, has_generation_in_db, get_render_from_db_with_render, get_generation_from_db
  )

  print("üìã Building template...")
  result = builder.build(border_width=2, allow_expansion=True)

  if result is None:
    error_msg = builder._last_validation_error or "Failed to build template"
    update_status("error", error_msg)
    return {
      "success": False,
      "error": error_msg,
    }

  template_image, placement = result

  # Save template to temp file and upload to GCS
  with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
    template_path = Path(tmp.name)
    template_image.save(template_path)

  try:
    update_status("uploading", "Uploading template to cloud...")
    print("üì§ Uploading template to GCS...")
    print(f"   Template path: {template_path}")
    print(f"   Template size: {template_image.size[0]}x{template_image.size[1]}")
    image_url = upload_to_gcs(template_path, bucket_name)
    print(f"   Uploaded URL: {image_url}")

    update_status("generating", "Calling AI model (this may take a minute)...")
    print("ü§ñ Calling Oxen API...")
    generated_url = call_oxen_api(image_url, model_config, prompt)

    update_status("saving", "Downloading and saving results...")
    print("üì• Downloading generated image...")
    print(f"   Generated URL: {generated_url}")
    generated_image = download_image_to_pil(generated_url)

    # Extract quadrants from generated image and save to database
    print("üíæ Saving generated quadrants to database...")

    # Figure out what quadrants are in the infill region
    all_infill_quadrants = (
      placement.all_infill_quadrants
      if placement.all_infill_quadrants
      else region.overlapping_quadrants()
    )

    # For each infill quadrant, extract pixels from the generated image
    saved_count = 0
    for qx, qy in all_infill_quadrants:
      # Calculate position in the generated image
      quad_world_x = qx * QUADRANT_SIZE
      quad_world_y = qy * QUADRANT_SIZE

      template_x = quad_world_x - placement.world_offset_x
      template_y = quad_world_y - placement.world_offset_y

      # Crop this quadrant from the generated image
      crop_box = (
        template_x,
        template_y,
        template_x + QUADRANT_SIZE,
        template_y + QUADRANT_SIZE,
      )
      quad_img = generated_image.crop(crop_box)
      png_bytes = image_to_png_bytes(quad_img)

      # Only save primary quadrants (not padding)
      if (qx, qy) in primary_quadrants or (qx, qy) in [
        (q[0], q[1]) for q in primary_quadrants
      ]:
        if save_quadrant_generation(conn, config, qx, qy, png_bytes):
          print(f"   ‚úì Saved generation for ({qx}, {qy})")
          saved_count += 1
        else:
          print(f"   ‚ö†Ô∏è Failed to save generation for ({qx}, {qy})")
      else:
        print(f"   ‚è≠Ô∏è Skipped padding quadrant ({qx}, {qy})")

    update_status("complete", f"Generated {saved_count} quadrant(s)")
    return {
      "success": True,
      "message": f"Generated {saved_count} quadrant{'s' if saved_count != 1 else ''}",
      "quadrants": list(primary_quadrants),
    }

  finally:
    # Clean up temp file
    template_path.unlink(missing_ok=True)

```

Now let me add the frontend button and dialog. First, the HTML:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Generated Tiles Viewer</title>
    <link rel="stylesheet" href="/static/viewer.css" />
    <style>
      /* Dynamic grid sizing based on template variables */
      .grid {
        grid-template-columns: repeat({{ nx }}, {{ size_px }}px);
        grid-auto-rows: {{ size_px }}px;
      }
      .tile.placeholder {
        min-width: {{ size_px }}px;
        min-height: {{ size_px }}px;
      }
    </style>
  </head>
  <body>
    <!-- Config data for JS -->
    <script
      id="app-config"
      type="application/json"
      data-config='{"x": {{ x }}, "y": {{ y }}, "nx": {{ nx }}, "ny": {{ ny }}, "size_px": {{ size_px }}, "models": {{ models_config | safe }}, "default_model_id": "{{ default_model_id }}"}'
    ></script>

    <!-- Toast notification container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Fixed toolbar -->
    <div class="toolbar">
      <div class="toolbar-row">
        <div class="controls">
          <label>X: <input type="number" id="x" value="{{ x }}" /></label>
          <label>Y: <input type="number" id="y" value="{{ y }}" /></label>
          <label
            >NX: <input type="number" id="nx" value="{{ nx }}" min="1" max="20"
          /></label>
          <label
            >NY: <input type="number" id="ny" value="{{ ny }}" min="1" max="20"
          /></label>
          <label
            >Size:
            <input type="number" id="sizePx" value="{{ size_px }}" step="32"
          /></label>
          <button onclick="goTo()">Go</button>
          <div class="toggle-group">
            <label
              ><input
                type="checkbox"
                id="showLines"
                {%
                if
                show_lines
                %}checked{%
                endif
                %}
                onchange="toggleLines()"
              />
              Lines</label
            >
            <label
              ><input
                type="checkbox"
                id="showCoords"
                {%
                if
                show_coords
                %}checked{%
                endif
                %}
                onchange="toggleCoords()"
              />
              Coords</label
            >
            <label
              ><input
                type="checkbox"
                id="showRender"
                {%
                if
                show_render
                %}checked{%
                endif
                %}
                onchange="toggleRender()"
              />
              Renders</label
            >
          </div>
          <div class="toggle-group model-group">
            <label class="model-label"
              >Model:
              <select id="modelSelect" class="model-select">
                <!-- Populated by JavaScript -->
              </select>
            </label>
          </div>
          <div class="toggle-group tools-group">
            <span class="tools-label">Tools:</span>
            <button
              id="selectTool"
              class="tool-btn"
              onclick="toggleSelectTool()"
              title="Select quadrants (S)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path>
                <path d="M13 13l6 6"></path>
              </svg>
              Select
            </button>
            <button
              id="fixWaterTool"
              class="tool-btn"
              onclick="toggleFixWaterTool()"
              title="Fix water color (W)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
              </svg>
              Fix Water
            </button>
            <button
              id="waterFillTool"
              class="tool-btn"
              onclick="toggleWaterFillTool()"
              title="Fill quadrant with water (F)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <rect x="3" y="3" width="18" height="18" rx="2"></rect>
                <path d="M12 8v8"></path>
                <path d="M8 12h8"></path>
              </svg>
              Water Fill
            </button>
          </div>
        </div>
        <div class="toolbar-info">
          <span>({{ x }}, {{ y }}) ‚Üí ({{ x + nx - 1 }}, {{ y + ny - 1 }})</span>
          <span>{{ generation_dir }}</span>
        </div>
      </div>
      <div class="selection-status" id="selectionStatus">
        <span id="selectionCount">0 quadrants selected</span>
        <span class="selection-limit">(max 4)</span>
        <button
          id="deselectAllBtn"
          class="deselect-btn"
          onclick="deselectAll()"
          disabled
        >
          Deselect All
        </button>
        <button
          id="deleteBtn"
          class="delete-btn"
          onclick="deleteSelected()"
          disabled
        >
          Delete
        </button>
        <button
          id="renderBtn"
          class="render-btn"
          onclick="renderSelected()"
          disabled
        >
          Render
        </button>
        <button
          id="generateBtn"
          class="generate-btn"
          onclick="generateSelected()"
          disabled
        >
          Generate
        </button>
        <button
          id="generateWithPromptBtn"
          class="generate-prompt-btn"
          onclick="showPromptDialog()"
          disabled
          title="Generate with additional prompt text"
        >
          + Prompt
        </button>
        <button
          id="generateRectBtn"
          class="generate-rect-btn"
          onclick="generateRectangle()"
          disabled
          title="Select exactly 2 quadrants to define rectangle corners"
        >
          Generate Rectangle
        </button>
        <button
          id="clearQueueBtn"
          class="clear-queue-btn"
          onclick="clearQueue()"
          title="Clear all pending items from the generation queue"
        >
          Clear Queue
        </button>
      </div>
      <div class="water-fix-status" id="waterFixStatus" style="display: none">
        <span class="water-fix-label">Target Color:</span>
        <span class="color-swatch" id="targetColorSwatch"></span>
        <span class="color-hex" id="targetColorHex"
          >Click a quadrant to pick color</span
        >
        <span class="water-fix-quadrant" id="waterFixQuadrant"></span>
        <button
          id="applyWaterFixBtn"
          class="apply-water-fix-btn"
          onclick="applyWaterFix()"
          disabled
        >
          Apply Fix
        </button>
        <button
          id="cancelWaterFixBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFix()"
        >
          Cancel
        </button>
      </div>
      <div class="water-fill-status" id="waterFillStatus" style="display: none">
        <span class="water-fill-label">Water Fill:</span>
        <span class="color-swatch water-color-preview"></span>
        <span class="water-fill-instruction" id="waterFillInstruction"
          >Click a quadrant to fill with water</span
        >
        <button
          id="cancelWaterFillBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFill()"
        >
          Cancel
        </button>
      </div>
    </div>

    <div
      class="grid-container {% if show_lines %}show-lines{% endif %} {% if show_coords %}show-coords{% endif %}"
      id="gridContainer"
    >
      <div class="grid">
        {% for dy in range(ny) %} {% for dx in range(nx) %} {% set qx = x + dx
        %} {% set qy = y + dy %} {% set has_gen = tiles.get((dx, dy), False) %}
        <div
          class="tile {% if not has_gen %}placeholder{% endif %}"
          data-coords="{{ qx }},{{ qy }}"
        >
          <span class="coords">({{ qx }}, {{ qy }})</span>
          {% if has_gen %}
          <img
            src="/tile/{{ qx }}/{{ qy }}?render={{ '1' if show_render else '0' }}"
            alt="Tile {{ qx }},{{ qy }}"
          />
          {% endif %}
        </div>
        {% endfor %} {% endfor %}
      </div>
    </div>

    <script src="/static/viewer.js"></script>
  </body>
</html>

```

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Generated Tiles Viewer</title>
    <link rel="stylesheet" href="/static/viewer.css" />
    <style>
      /* Dynamic grid sizing based on template variables */
      .grid {
        grid-template-columns: repeat({{ nx }}, {{ size_px }}px);
        grid-auto-rows: {{ size_px }}px;
      }
      .tile.placeholder {
        min-width: {{ size_px }}px;
        min-height: {{ size_px }}px;
      }
    </style>
  </head>
  <body>
    <!-- Config data for JS -->
    <script
      id="app-config"
      type="application/json"
      data-config='{"x": {{ x }}, "y": {{ y }}, "nx": {{ nx }}, "ny": {{ ny }}, "size_px": {{ size_px }}, "models": {{ models_config | safe }}, "default_model_id": "{{ default_model_id }}"}'
    ></script>

    <!-- Toast notification container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Fixed toolbar -->
    <div class="toolbar">
      <div class="toolbar-row">
        <div class="controls">
          <label>X: <input type="number" id="x" value="{{ x }}" /></label>
          <label>Y: <input type="number" id="y" value="{{ y }}" /></label>
          <label
            >NX: <input type="number" id="nx" value="{{ nx }}" min="1" max="20"
          /></label>
          <label
            >NY: <input type="number" id="ny" value="{{ ny }}" min="1" max="20"
          /></label>
          <label
            >Size:
            <input type="number" id="sizePx" value="{{ size_px }}" step="32"
          /></label>
          <button onclick="goTo()">Go</button>
          <div class="toggle-group">
            <label
              ><input
                type="checkbox"
                id="showLines"
                {%
                if
                show_lines
                %}checked{%
                endif
                %}
                onchange="toggleLines()"
              />
              Lines</label
            >
            <label
              ><input
                type="checkbox"
                id="showCoords"
                {%
                if
                show_coords
                %}checked{%
                endif
                %}
                onchange="toggleCoords()"
              />
              Coords</label
            >
            <label
              ><input
                type="checkbox"
                id="showRender"
                {%
                if
                show_render
                %}checked{%
                endif
                %}
                onchange="toggleRender()"
              />
              Renders</label
            >
          </div>
          <div class="toggle-group model-group">
            <label class="model-label"
              >Model:
              <select id="modelSelect" class="model-select">
                <!-- Populated by JavaScript -->
              </select>
            </label>
          </div>
          <div class="toggle-group tools-group">
            <span class="tools-label">Tools:</span>
            <button
              id="selectTool"
              class="tool-btn"
              onclick="toggleSelectTool()"
              title="Select quadrants (S)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path>
                <path d="M13 13l6 6"></path>
              </svg>
              Select
            </button>
            <button
              id="fixWaterTool"
              class="tool-btn"
              onclick="toggleFixWaterTool()"
              title="Fix water color (W)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
              </svg>
              Fix Water
            </button>
            <button
              id="waterFillTool"
              class="tool-btn"
              onclick="toggleWaterFillTool()"
              title="Fill quadrant with water (F)"
            >
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <rect x="3" y="3" width="18" height="18" rx="2"></rect>
                <path d="M12 8v8"></path>
                <path d="M8 12h8"></path>
              </svg>
              Water Fill
            </button>
          </div>
        </div>
        <div class="toolbar-info">
          <span>({{ x }}, {{ y }}) ‚Üí ({{ x + nx - 1 }}, {{ y + ny - 1 }})</span>
          <span>{{ generation_dir }}</span>
        </div>
      </div>
      <div class="selection-status" id="selectionStatus">
        <span id="selectionCount">0 quadrants selected</span>
        <span class="selection-limit">(max 4)</span>
        <button
          id="deselectAllBtn"
          class="deselect-btn"
          onclick="deselectAll()"
          disabled
        >
          Deselect All
        </button>
        <button
          id="deleteBtn"
          class="delete-btn"
          onclick="deleteSelected()"
          disabled
        >
          Delete
        </button>
        <button
          id="renderBtn"
          class="render-btn"
          onclick="renderSelected()"
          disabled
        >
          Render
        </button>
        <button
          id="generateBtn"
          class="generate-btn"
          onclick="generateSelected()"
          disabled
        >
          Generate
        </button>
        <button
          id="generateWithPromptBtn"
          class="generate-prompt-btn"
          onclick="showPromptDialog()"
          disabled
          title="Generate with additional prompt text"
        >
          + Prompt
        </button>
        <button
          id="generateRectBtn"
          class="generate-rect-btn"
          onclick="generateRectangle()"
          disabled
          title="Select exactly 2 quadrants to define rectangle corners"
        >
          Generate Rectangle
        </button>
        <button
          id="clearQueueBtn"
          class="clear-queue-btn"
          onclick="clearQueue()"
          title="Clear all pending items from the generation queue"
        >
          Clear Queue
        </button>
      </div>
      <div class="water-fix-status" id="waterFixStatus" style="display: none">
        <span class="water-fix-label">Target Color:</span>
        <span class="color-swatch" id="targetColorSwatch"></span>
        <span class="color-hex" id="targetColorHex"
          >Click a quadrant to pick color</span
        >
        <span class="water-fix-quadrant" id="waterFixQuadrant"></span>
        <button
          id="applyWaterFixBtn"
          class="apply-water-fix-btn"
          onclick="applyWaterFix()"
          disabled
        >
          Apply Fix
        </button>
        <button
          id="cancelWaterFixBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFix()"
        >
          Cancel
        </button>
      </div>
      <div class="water-fill-status" id="waterFillStatus" style="display: none">
        <span class="water-fill-label">Water Fill:</span>
        <span class="color-swatch water-color-preview"></span>
        <span class="water-fill-instruction" id="waterFillInstruction"
          >Click a quadrant to fill with water</span
        >
        <button
          id="cancelWaterFillBtn"
          class="cancel-water-fix-btn"
          onclick="cancelWaterFill()"
        >
          Cancel
        </button>
      </div>
    </div>

    <div
      class="grid-container {% if show_lines %}show-lines{% endif %} {% if show_coords %}show-coords{% endif %}"
      id="gridContainer"
    >
      <div class="grid">
        {% for dy in range(ny) %} {% for dx in range(nx) %} {% set qx = x + dx
        %} {% set qy = y + dy %} {% set has_gen = tiles.get((dx, dy), False) %}
        <div
          class="tile {% if not has_gen %}placeholder{% endif %}"
          data-coords="{{ qx }},{{ qy }}"
        >
          <span class="coords">({{ qx }}, {{ qy }})</span>
          {% if has_gen %}
          <img
            src="/tile/{{ qx }}/{{ qy }}?render={{ '1' if show_render else '0' }}"
            alt="Tile {{ qx }},{{ qy }}"
          />
          {% endif %}
        </div>
        {% endfor %} {% endfor %}
      </div>
    </div>

    <!-- Prompt Dialog -->
    <div id="promptDialog" class="dialog-overlay" style="display: none">
      <div class="dialog-content">
        <h3>Generate with Prompt</h3>
        <p class="dialog-description">
          Add additional instructions for the generation:
        </p>
        <textarea
          id="promptInput"
          class="prompt-input"
          placeholder="e.g., 'Add more trees' or 'Make the water darker'"
          rows="3"
        ></textarea>
        <div class="dialog-buttons">
          <button class="dialog-cancel-btn" onclick="hidePromptDialog()">
            Cancel
          </button>
          <button class="dialog-submit-btn" onclick="submitPromptGeneration()">
            Generate
          </button>
        </div>
      </div>
    </div>

    <script src="/static/viewer.js"></script>
  </body>
</html>

```

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
  font-size: 12px;
  background: #1a1a2e;
  color: #eee;
  min-height: 100vh;
  padding: 15px;
  padding-top: 95px; /* Space for fixed toolbar */
}

.toolbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: #1a1a2e;
  padding: 10px 15px;
  z-index: 100;
  border-bottom: 1px solid #333;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.toolbar-row {
  display: flex;
  align-items: center;
  gap: 15px;
  flex-wrap: wrap;
}

.toolbar-info {
  color: #666;
  font-size: 0.75rem;
}

.toolbar-info span + span {
  margin-left: 12px;
}

.controls {
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
}

.controls label {
  color: #888;
  font-size: 0.8rem;
}

.controls input[type="number"] {
  width: 50px;
  padding: 5px 6px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #16213e;
  color: #fff;
  font-family: inherit;
  font-size: 0.8rem;
}

.controls button {
  padding: 5px 12px;
  background: #00d9ff;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.75rem;
  font-weight: bold;
}

.controls button:hover {
  background: #00b8d4;
}

.toggle-group {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-left: 8px;
  padding-left: 12px;
  border-left: 1px solid #333;
}

.toggle-group label {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  user-select: none;
  font-size: 0.75rem;
}

.toggle-group input[type="checkbox"] {
  width: 14px;
  height: 14px;
  accent-color: #00d9ff;
  cursor: pointer;
}

.grid-container {
  display: inline-block;
  border-radius: 8px;
  overflow: hidden;
}

.grid-container.show-lines {
  border: 2px solid #333;
}

.grid {
  display: grid;
  background: #333;
}

.grid-container.show-lines .grid {
  gap: 2px;
}

.grid-container:not(.show-lines) .grid {
  gap: 0;
  background: transparent;
}

.grid-container:not(.show-lines) {
  border: none;
}

.tile {
  position: relative;
  background: #2a2a4a;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tile img {
  display: block;
  max-width: 100%;
  height: auto;
}

.tile.placeholder {
  background: #3a3a5a;
}

.tile .coords {
  position: absolute;
  top: 6px;
  left: 6px;
  background: rgba(0, 0, 0, 0.7);
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 0.65rem;
  color: #00d9ff;
  transition: opacity 0.2s;
}

.tile.placeholder .coords {
  color: #666;
}

.grid-container:not(.show-coords) .tile .coords {
  opacity: 0;
}

/* Tool button styles */
.tools-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.tools-label {
  color: #666;
  font-size: 0.7rem;
}

.tool-btn {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: #2a2a3e;
  color: #666;
  border: 1px solid #444;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  transition: all 0.15s ease;
}

.tool-btn:hover {
  background: #3a3a4e;
  color: #999;
  border-color: #555;
}

.tool-btn.active {
  background: #10b981;
  color: #fff;
  border-color: #10b981;
  box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
}

.tool-btn.active:hover {
  background: #059669;
  border-color: #059669;
}

.tool-btn svg {
  width: 12px;
  height: 12px;
}

/* Selection styles */
.tile.selected {
  outline: 3px solid #ff3333;
  outline-offset: -3px;
  z-index: 10;
}

.grid-container.show-lines .tile.selected {
  outline-color: #ff3333;
}

.tile.selectable {
  cursor: pointer;
}

.tile.placeholder.selected {
  background: rgba(255, 51, 51, 0.15);
}

/* Locked tiles (during generation) */
.tile.locked {
  outline: 3px solid #a855f7;
  outline-offset: -3px;
  z-index: 10;
}

.grid-container.show-lines .tile.locked {
  outline-color: #a855f7;
}

.tile.placeholder.locked {
  background: rgba(168, 85, 247, 0.2);
}

/* Queued tiles (in queue, waiting to be generated) */
.tile.queued {
  outline: 3px dashed #c084fc !important;
  outline-offset: -3px;
  z-index: 9;
  animation: pulse-queue 1.5s ease-in-out infinite;
  /* Fallback: box-shadow for browsers that don't render dashed outlines well */
  box-shadow: inset 0 0 0 3px rgba(192, 132, 252, 0.5);
}

@keyframes pulse-queue {
  0%,
  100% {
    outline-color: #c084fc;
    box-shadow: inset 0 0 0 3px rgba(192, 132, 252, 0.5);
  }
  50% {
    outline-color: #8b5cf6;
    box-shadow: inset 0 0 0 3px rgba(139, 92, 246, 0.7);
  }
}

.grid-container.show-lines .tile.queued {
  outline-color: #c084fc;
}

.tile.placeholder.queued {
  background: rgba(168, 85, 247, 0.3) !important;
}

/* Allow selection while generating - only disable clicking on locked/queued tiles */
body.generating .tile.locked.selectable,
body.generating .tile.queued.selectable {
  cursor: not-allowed;
}

/* Selection status bar */
.selection-status {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 10px;
  background: rgba(255, 51, 51, 0.1);
  border: 1px solid rgba(255, 51, 51, 0.3);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #ff6666;
  margin-top: 8px;
}

.selection-status.empty {
  background: transparent;
  border-color: #333;
  color: #666;
}

.selection-status.generating {
  background: rgba(168, 85, 247, 0.1);
  border-color: rgba(168, 85, 247, 0.4);
  color: #a855f7;
}

.selection-limit {
  color: #888;
  font-size: 0.65rem;
}

.deselect-btn {
  padding: 3px 8px;
  background: #ff3333;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  margin-left: auto;
  transition: all 0.2s;
}

.deselect-btn:hover:not(:disabled) {
  background: #ff5555;
}

.deselect-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
}

.delete-btn {
  padding: 3px 8px;
  background: #dc2626;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  transition: all 0.2s;
}

.delete-btn:hover:not(:disabled) {
  background: #b91c1c;
}

.delete-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
}

.render-btn {
  padding: 4px 12px;
  background: #f59e0b;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
}

.render-btn:hover:not(:disabled) {
  background: #d97706;
}

.render-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.render-btn.loading {
  background: #666;
  cursor: wait;
}

.render-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

.generate-btn {
  padding: 4px 12px;
  background: #00d9ff;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
}

.generate-btn:hover:not(:disabled) {
  background: #00b8d4;
}

.generate-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

/* Generate Rectangle button */
.generate-rect-btn {
  padding: 4px 12px;
  background: #8b5cf6;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
}

.generate-rect-btn:hover:not(:disabled) {
  background: #7c3aed;
}

.generate-rect-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.generate-rect-btn.loading {
  background: #666;
  cursor: wait;
}

.generate-rect-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

/* Clear Queue button */
.clear-queue-btn {
  padding: 4px 10px;
  background: #6b7280;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  font-weight: 500;
  transition: all 0.2s;
  margin-left: 8px;
}

.clear-queue-btn:hover {
  background: #ef4444;
}

.clear-queue-btn:active {
  background: #dc2626;
}

/* Toast notification system */
.toast-container {
  position: fixed;
  bottom: 15px;
  right: 15px;
  z-index: 1000;
  display: flex;
  flex-direction: column-reverse;
  gap: 8px;
  max-width: 320px;
}

.toast {
  padding: 10px 14px;
  border-radius: 6px;
  font-size: 0.75rem;
  animation: slideIn 0.3s ease-out;
  display: flex;
  align-items: flex-start;
  gap: 10px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.toast.success {
  background: linear-gradient(135deg, #065f46 0%, #047857 100%);
  border: 1px solid #10b981;
  color: #d1fae5;
}

.toast.error {
  background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
  border: 1px solid #ef4444;
  color: #fee2e2;
}

.toast.info {
  background: linear-gradient(135deg, #1e3a5f 0%, #1e40af 100%);
  border: 1px solid #3b82f6;
  color: #dbeafe;
}

.toast.loading {
  background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
  border: 1px solid #6b7280;
  color: #e5e7eb;
}

.toast-icon {
  flex-shrink: 0;
  font-size: 1rem;
}

.toast-content {
  flex: 1;
}

.toast-title {
  font-weight: 600;
  margin-bottom: 2px;
}

.toast-message {
  opacity: 0.9;
  font-size: 0.7rem;
}

.toast-close {
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  opacity: 0.7;
  font-size: 1rem;
  padding: 0;
  line-height: 1;
}

.toast-close:hover {
  opacity: 1;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOut {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

.toast.removing {
  animation: slideOut 0.3s ease-in forwards;
}

/* Loading spinner for generate button */
.generate-btn.loading {
  background: #666;
  color: #fff;
  cursor: wait;
}

.generate-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Water fix tool styles */
.water-fix-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid rgba(59, 130, 246, 0.3);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #60a5fa;
  margin-top: 8px;
}

.water-fix-label {
  color: #93c5fd;
  font-weight: 500;
}

.color-swatch {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  border: 2px solid #fff;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3), inset 0 0 0 1px rgba(0, 0, 0, 0.1);
  background: #333;
}

.color-swatch.has-color {
  cursor: pointer;
}

.color-hex {
  font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
  font-size: 0.75rem;
  color: #93c5fd;
  min-width: 180px;
}

.water-fix-quadrant {
  color: #60a5fa;
  font-size: 0.7rem;
}

.apply-water-fix-btn {
  padding: 4px 12px;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
  margin-left: auto;
}

.apply-water-fix-btn:hover:not(:disabled) {
  background: #2563eb;
}

.apply-water-fix-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.apply-water-fix-btn.loading {
  background: #666;
  cursor: wait;
}

.cancel-water-fix-btn {
  padding: 4px 8px;
  background: #4b5563;
  color: #d1d5db;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  transition: all 0.2s;
}

.cancel-water-fix-btn:hover {
  background: #6b7280;
}

/* Fix water tool active state */
.tile.fix-water-selectable {
  cursor: crosshair;
}

.tile.fix-water-selectable:hover {
  outline: 2px solid #3b82f6;
  outline-offset: -2px;
}

.tile.water-fix-selected {
  outline: 3px solid #3b82f6;
  outline-offset: -3px;
  z-index: 10;
}

/* Water fill tool styles */
.water-fill-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(74, 99, 114, 0.15);
  border: 1px solid rgba(74, 99, 114, 0.4);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #7ba3b8;
  margin-top: 8px;
}

.water-fill-label {
  color: #93c5fd;
  font-weight: 500;
}

.water-color-preview {
  background: #4a6372 !important;
}

.water-fill-instruction {
  color: #7ba3b8;
}

.tile.water-fill-selectable {
  cursor: pointer;
}

.tile.water-fill-selectable:hover {
  outline: 2px solid #4a6372;
  outline-offset: -2px;
}

/* Model selector styles */
.model-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.model-label {
  display: flex;
  align-items: center;
  gap: 6px;
  color: #888;
  font-size: 0.75rem;
}

.model-select {
  padding: 4px 8px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #16213e;
  color: #fff;
  font-family: inherit;
  font-size: 0.75rem;
  cursor: pointer;
  min-width: 140px;
}

.model-select:hover {
  border-color: #00d9ff;
}

.model-select:focus {
  outline: none;
  border-color: #00d9ff;
  box-shadow: 0 0 0 2px rgba(0, 217, 255, 0.2);
}

.model-select option {
  background: #16213e;
  color: #fff;
  padding: 4px;
}

/* Generate with Prompt button */
.generate-prompt-btn {
  background: linear-gradient(135deg, #9b59b6, #8e44ad);
  color: #fff;
  border: none;
  padding: 6px 12px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.generate-prompt-btn:hover:not(:disabled) {
  background: linear-gradient(135deg, #a569c0, #9b59b6);
  transform: translateY(-1px);
}

.generate-prompt-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Prompt Dialog */
.dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.dialog-content {
  background: #1a1a2e;
  border: 1px solid #333;
  border-radius: 8px;
  padding: 24px;
  min-width: 400px;
  max-width: 500px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
}

.dialog-content h3 {
  margin: 0 0 12px 0;
  color: #fff;
  font-size: 18px;
}

.dialog-description {
  color: #aaa;
  font-size: 14px;
  margin: 0 0 16px 0;
}

.prompt-input {
  width: 100%;
  background: #0f0f1a;
  border: 1px solid #333;
  border-radius: 4px;
  color: #fff;
  font-size: 14px;
  padding: 12px;
  resize: vertical;
  font-family: inherit;
  box-sizing: border-box;
}

.prompt-input:focus {
  outline: none;
  border-color: #9b59b6;
  box-shadow: 0 0 0 2px rgba(155, 89, 182, 0.2);
}

.prompt-input::placeholder {
  color: #666;
}

.dialog-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 20px;
}

.dialog-cancel-btn {
  background: #333;
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

.dialog-cancel-btn:hover {
  background: #444;
}

.dialog-submit-btn {
  background: linear-gradient(135deg, #9b59b6, #8e44ad);
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.dialog-submit-btn:hover {
  background: linear-gradient(135deg, #a569c0, #9b59b6);
}

```

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show per-model queue counts
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      if (modelQueues.length > 0) {
        const queueParts = modelQueues.map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return `${name}: ${count}`;
        });
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    } else if (serverStatus.queue_length > 0) {
      // Fallback for backwards compatibility
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate with prompt button
  const generateWithPromptBtn = document.getElementById("generateWithPromptBtn");
  if (generateWithPromptBtn) {
    generateWithPromptBtn.disabled = count === 0;
  }
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

async function generateSelected() {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position, "model:", result.model_id);
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = `${status.queue_length} more item(s) in queue...`;
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .filter(([, info]) => info.pending_count > 0)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              return `${name}: ${info.pending_count}`;
            });
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        showToast("info", "Processing queue", queueMsg);
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show per-model queue counts
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      if (modelQueues.length > 0) {
        const queueParts = modelQueues.map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return `${name}: ${count}`;
        });
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    } else if (serverStatus.queue_length > 0) {
      // Fallback for backwards compatibility
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate with prompt button
  const generateWithPromptBtn = document.getElementById("generateWithPromptBtn");
  if (generateWithPromptBtn) {
    generateWithPromptBtn.disabled = count === 0;
  }
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

// Prompt dialog functions
function showPromptDialog() {
  if (selectedQuadrants.size === 0) return;
  const dialog = document.getElementById("promptDialog");
  const input = document.getElementById("promptInput");
  if (dialog && input) {
    input.value = "";
    dialog.style.display = "flex";
    input.focus();
  }
}

function hidePromptDialog() {
  const dialog = document.getElementById("promptDialog");
  if (dialog) {
    dialog.style.display = "none";
  }
}

async function submitPromptGeneration() {
  const input = document.getElementById("promptInput");
  const prompt = input ? input.value.trim() : "";
  hidePromptDialog();
  await generateSelected(prompt);
}

async function generateSelected(prompt = null) {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position, "model:", result.model_id);
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = `${status.queue_length} more item(s) in queue...`;
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .filter(([, info]) => info.pending_count > 0)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              return `${name}: ${info.pending_count}`;
            });
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        showToast("info", "Processing queue", queueMsg);
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show per-model queue counts
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      if (modelQueues.length > 0) {
        const queueParts = modelQueues.map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return `${name}: ${count}`;
        });
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    } else if (serverStatus.queue_length > 0) {
      // Fallback for backwards compatibility
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate with prompt button
  const generateWithPromptBtn = document.getElementById("generateWithPromptBtn");
  if (generateWithPromptBtn) {
    generateWithPromptBtn.disabled = count === 0;
  }
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

// Prompt dialog functions
function showPromptDialog() {
  if (selectedQuadrants.size === 0) return;
  const dialog = document.getElementById("promptDialog");
  const input = document.getElementById("promptInput");
  if (dialog && input) {
    input.value = "";
    dialog.style.display = "flex";
    input.focus();
  }
}

function hidePromptDialog() {
  const dialog = document.getElementById("promptDialog");
  if (dialog) {
    dialog.style.display = "none";
  }
}

async function submitPromptGeneration() {
  const input = document.getElementById("promptInput");
  const prompt = input ? input.value.trim() : "";
  hidePromptDialog();
  await generateSelected(prompt);
}

async function generateSelected(prompt = null) {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    // Include prompt if provided
    if (prompt) {
      requestBody.prompt = prompt;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position, "model:", result.model_id);
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = `${status.queue_length} more item(s) in queue...`;
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .filter(([, info]) => info.pending_count > 0)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              return `${name}: ${info.pending_count}`;
            });
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        showToast("info", "Processing queue", queueMsg);
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to currently processing quadrants
  if (status.is_generating && status.quadrants && status.quadrants.length > 0) {
    document.body.classList.add("generating");
    status.quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show per-model queue counts
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      if (modelQueues.length > 0) {
        const queueParts = modelQueues.map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return `${name}: ${count}`;
        });
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    } else if (serverStatus.queue_length > 0) {
      // Fallback for backwards compatibility
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate with prompt button
  const generateWithPromptBtn = document.getElementById("generateWithPromptBtn");
  if (generateWithPromptBtn) {
    generateWithPromptBtn.disabled = count === 0;
  }
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

// Prompt dialog functions
function showPromptDialog() {
  if (selectedQuadrants.size === 0) return;
  const dialog = document.getElementById("promptDialog");
  const input = document.getElementById("promptInput");
  if (dialog && input) {
    input.value = "";
    dialog.style.display = "flex";
    input.focus();
  }
}

function hidePromptDialog() {
  const dialog = document.getElementById("promptDialog");
  if (dialog) {
    dialog.style.display = "none";
  }
}

async function submitPromptGeneration() {
  const input = document.getElementById("promptInput");
  const prompt = input ? input.value.trim() : "";
  hidePromptDialog();
  await generateSelected(prompt);
}

async function generateSelected(prompt = null) {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  const promptMsg = prompt ? " with prompt" : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${promptMsg}${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    // Include prompt if provided
    if (prompt) {
      requestBody.prompt = prompt;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position, "model:", result.model_id);
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = `${status.queue_length} more item(s) in queue...`;
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .filter(([, info]) => info.pending_count > 0)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              return `${name}: ${info.pending_count}`;
            });
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        showToast("info", "Processing queue", queueMsg);
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

Done! Here's a summary of the "Generate with Prompt" feature:

**Backend (`queue_db.py`):**
- Added `prompt` field to `QueueItem` dataclass
- Updated database schema with `prompt TEXT` column
- Added migration for existing databases
- Updated `add_to_queue()` to accept prompt parameter

**Backend (`app.py`):**
- Updated `/api/generate` to accept `prompt` in request body
- Updated `add_to_queue_db()` to pass prompt
- Updated `process_queue_item_from_db()` to read and log prompt
- Updated `run_generation()` to pass prompt to generation

**Backend (`generate_omni.py`):**
- Updated `run_generation_for_quadrants()` to accept prompt
- Updated `call_oxen_api()` to append additional prompt to base prompt
- Added logging for prompts

**Frontend (`viewer.html`):**
- Added "+ Prompt" button next to Generate button
- Added prompt dialog with textarea for entering additional instructions

**Frontend (`viewer.css`):**
- Added styles for the "+ Prompt" button (purple gradient)
- Added styles for the dialog overlay and content

**Frontend (`viewer.js`):**
- Added `showPromptDialog()`, `hidePromptDialog()`, `submitPromptGeneration()` functions
- Updated `generateSelected()` to accept optional prompt parameter
- Updated request body to include prompt if provided
- Updated toast message to indicate when prompt is used

The prompt is appended to the base generation prompt, so users can add instructions like:
- "Add more trees"
- "Make the water darker"
- "Include more buildings"

---

**User**

OK awesome - now I see another issue with the multi-model queue. It seems like the backend threads are working, but as soon as I generate with a different model, the "generating" quadrant outlines from the first generation model disappear, and the status bar doesn't indicate that the first generation is working

---

**Cursor**

I see the issue - the frontend is only tracking one generation at a time, but now we have multiple models running in parallel. I need to update both the backend state and frontend to handle multiple concurrent generations.

First, let me add a function to get all processing items in queue_db.py:

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None
  prompt: str | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle schema evolution: 10 base columns + optional context_quadrants + optional prompt
    context = None
    prompt = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])
    if len(row) > 11 and row[11]:
      prompt = row[11]

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
      prompt=prompt,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    if self.prompt:
      result["prompt"] = self.prompt
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT,
      prompt TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add columns if they don't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")
  if "prompt" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN prompt TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.
    prompt: Optional additional prompt text for generation

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants, prompt)
    VALUES (?, ?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
      prompt,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_next_pending_item_for_available_model(
  conn: sqlite3.Connection, busy_models: set[str | None]
) -> QueueItem | None:
  """
  Get the next pending item for a model that isn't currently busy.

  This enables parallel processing of different models' queues.

  Args:
    conn: Database connection
    busy_models: Set of model_ids that are currently processing
                 (None represents the default/no model)

  Returns None if no available items.
  """
  cursor = conn.cursor()

  # Get all pending items ordered by creation time
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )

  for row in cursor.fetchall():
    item = QueueItem.from_row(row)
    # Check if this model is available (not busy)
    if item.model_id not in busy_models:
      return item

  return None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def get_all_processing_items(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all items currently being processed (one per model in parallel mode)."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at ASC
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_status_by_model(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get queue status grouped by model.

  Returns a dictionary with:
    - by_model: dict mapping model_id -> {
        is_processing: bool,
        current_item: dict | None,
        pending_count: int,
        pending_items: list of dicts,
        position: int (1-based, 0 if processing)
      }
    - total_pending: int
    - processing_models: list of model_ids currently processing
    - all_processing_quadrants: list of all quadrants currently being processed
  """
  processing_items = get_all_processing_items(conn)
  pending = get_pending_queue(conn)

  # Group pending items by model_id
  by_model: dict[str, dict[str, Any]] = {}

  for item in pending:
    model_id = item.model_id or "default"
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": False,
        "current_item": None,
        "pending_count": 0,
        "pending_items": [],
      }
    by_model[model_id]["pending_count"] += 1
    by_model[model_id]["pending_items"].append(item.to_dict())

  # Add processing item to its model's status
  processing_model = None
  if processing:
    model_id = processing.model_id or "default"
    processing_model = model_id
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": True,
        "current_item": processing.to_dict(),
        "pending_count": 0,
        "pending_items": [],
      }
    else:
      by_model[model_id]["is_processing"] = True
      by_model[model_id]["current_item"] = processing.to_dict()

  return {
    "by_model": by_model,
    "total_pending": len(pending),
    "processing_model": processing_model,
  }


def get_queue_position_for_model(
  conn: sqlite3.Connection, item_id: int, model_id: str | None
) -> int:
  """
  Get the position of an item within its model's queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue for this model, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # For model-specific position, count items with same model_id that are ahead
  # Use empty string for NULL model_id comparison
  if model_id is None:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id IS NULL
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, item_id),
    )
  else:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id = ?
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, model_id, item_id),
    )

  row = cursor.fetchone()
  if row:
    return row[0]

  return -1


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def cancel_processing_items(conn: sqlite3.Connection) -> int:
  """
  Mark all processing items as cancelled (error status).

  This is used when the user wants to cancel everything, including
  items that are currently being processed.

  Returns the number of items cancelled.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE status = ?
    """,
    (
      QueueItemStatus.ERROR.value,
      time.time(),
      "Cancelled by user",
      QueueItemStatus.PROCESSING.value,
    ),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None
  prompt: str | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle schema evolution: 10 base columns + optional context_quadrants + optional prompt
    context = None
    prompt = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])
    if len(row) > 11 and row[11]:
      prompt = row[11]

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
      prompt=prompt,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    if self.prompt:
      result["prompt"] = self.prompt
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT,
      prompt TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add columns if they don't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")
  if "prompt" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN prompt TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.
    prompt: Optional additional prompt text for generation

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants, prompt)
    VALUES (?, ?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
      prompt,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_next_pending_item_for_available_model(
  conn: sqlite3.Connection, busy_models: set[str | None]
) -> QueueItem | None:
  """
  Get the next pending item for a model that isn't currently busy.

  This enables parallel processing of different models' queues.

  Args:
    conn: Database connection
    busy_models: Set of model_ids that are currently processing
                 (None represents the default/no model)

  Returns None if no available items.
  """
  cursor = conn.cursor()

  # Get all pending items ordered by creation time
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )

  for row in cursor.fetchall():
    item = QueueItem.from_row(row)
    # Check if this model is available (not busy)
    if item.model_id not in busy_models:
      return item

  return None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def get_all_processing_items(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all items currently being processed (one per model in parallel mode)."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at ASC
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_status_by_model(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get queue status grouped by model.

  Returns a dictionary with:
    - by_model: dict mapping model_id -> {
        is_processing: bool,
        current_item: dict | None,
        pending_count: int,
        pending_items: list of dicts,
        position: int (1-based, 0 if processing)
      }
    - total_pending: int
    - processing_models: list of model_ids currently processing
    - all_processing_quadrants: list of all quadrants currently being processed
  """
  processing_items = get_all_processing_items(conn)
  pending = get_pending_queue(conn)

  # Group pending items by model_id
  by_model: dict[str, dict[str, Any]] = {}

  for item in pending:
    model_id = item.model_id or "default"
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": False,
        "current_item": None,
        "pending_count": 0,
        "pending_items": [],
      }
    by_model[model_id]["pending_count"] += 1
    by_model[model_id]["pending_items"].append(item.to_dict())

  # Add all processing items to their model's status
  processing_models = []
  all_processing_quadrants = []

  for processing in processing_items:
    model_id = processing.model_id or "default"
    processing_models.append(model_id)

    # Collect all processing quadrants
    if processing.quadrants:
      all_processing_quadrants.extend(processing.quadrants)

    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": True,
        "current_item": processing.to_dict(),
        "pending_count": 0,
        "pending_items": [],
      }
    else:
      by_model[model_id]["is_processing"] = True
      by_model[model_id]["current_item"] = processing.to_dict()

  return {
    "by_model": by_model,
    "total_pending": len(pending),
    "processing_models": processing_models,
    "all_processing_quadrants": all_processing_quadrants,
  }


def get_queue_position_for_model(
  conn: sqlite3.Connection, item_id: int, model_id: str | None
) -> int:
  """
  Get the position of an item within its model's queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue for this model, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # For model-specific position, count items with same model_id that are ahead
  # Use empty string for NULL model_id comparison
  if model_id is None:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id IS NULL
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, item_id),
    )
  else:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id = ?
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, model_id, item_id),
    )

  row = cursor.fetchone()
  if row:
    return row[0]

  return -1


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def cancel_processing_items(conn: sqlite3.Connection) -> int:
  """
  Mark all processing items as cancelled (error status).

  This is used when the user wants to cancel everything, including
  items that are currently being processed.

  Returns the number of items cancelled.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE status = ?
    """,
    (
      QueueItemStatus.ERROR.value,
      time.time(),
      "Cancelled by user",
      QueueItemStatus.PROCESSING.value,
    ),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.
    prompt: Optional additional prompt text for generation

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants, prompt
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None
    prompt = row[4]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    if prompt:
      print(f"   Prompt: {prompt}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants, prompt
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_models": model_status["processing_models"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
      # All quadrants being processed across all models
      "all_processing_quadrants": model_status["all_processing_quadrants"],
    }

    # Set is_generating based on whether any models are active
    response["is_generating"] = len(active_models) > 0

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  # Parse optional prompt
  prompt = data.get("prompt")
  if prompt and not isinstance(prompt, str):
    return jsonify(
      {
        "success": False,
        "error": "prompt must be a string",
      }
    ), 400

  # Clean up prompt (strip whitespace, None if empty)
  if prompt:
    prompt = prompt.strip()
    if not prompt:
      prompt = None

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  if prompt:
    print(f"   Prompt: {prompt}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(
    selected_quadrants, "generate", model_id, context_quadrants, prompt
  )
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

Now let me update the frontend to use the new `all_processing_quadrants`:

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to ALL currently processing quadrants (from all models)
  const processingQuadrants = status.all_processing_quadrants || status.quadrants || [];
  const isProcessing = status.is_generating || (status.active_model_count > 0);

  if (isProcessing && processingQuadrants.length > 0) {
    document.body.classList.add("generating");
    processingQuadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else if (!isProcessing) {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show per-model queue counts
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      if (modelQueues.length > 0) {
        const queueParts = modelQueues.map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return `${name}: ${count}`;
        });
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    } else if (serverStatus.queue_length > 0) {
      // Fallback for backwards compatibility
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate with prompt button
  const generateWithPromptBtn = document.getElementById("generateWithPromptBtn");
  if (generateWithPromptBtn) {
    generateWithPromptBtn.disabled = count === 0;
  }
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

// Prompt dialog functions
function showPromptDialog() {
  if (selectedQuadrants.size === 0) return;
  const dialog = document.getElementById("promptDialog");
  const input = document.getElementById("promptInput");
  if (dialog && input) {
    input.value = "";
    dialog.style.display = "flex";
    input.focus();
  }
}

function hidePromptDialog() {
  const dialog = document.getElementById("promptDialog");
  if (dialog) {
    dialog.style.display = "none";
  }
}

async function submitPromptGeneration() {
  const input = document.getElementById("promptInput");
  const prompt = input ? input.value.trim() : "";
  hidePromptDialog();
  await generateSelected(prompt);
}

async function generateSelected(prompt = null) {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  const promptMsg = prompt ? " with prompt" : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${promptMsg}${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    // Include prompt if provided
    if (prompt) {
      requestBody.prompt = prompt;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position, "model:", result.model_id);
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = `${status.queue_length} more item(s) in queue...`;
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .filter(([, info]) => info.pending_count > 0)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              return `${name}: ${info.pending_count}`;
            });
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        showToast("info", "Processing queue", queueMsg);
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to ALL currently processing quadrants (from all models)
  const processingQuadrants = status.all_processing_quadrants || status.quadrants || [];
  const isProcessing = status.is_generating || (status.active_model_count > 0);

  if (isProcessing && processingQuadrants.length > 0) {
    document.body.classList.add("generating");
    processingQuadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else if (!isProcessing) {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  // Ignore keyboard shortcuts when prompt dialog is open
  const promptDialog = document.getElementById("promptDialog");
  if (promptDialog && promptDialog.style.display !== "none") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    // Show all active models generating
    const activeModels = serverStatus.active_models || [];
    const processingQuadrants = serverStatus.all_processing_quadrants || serverStatus.quadrants || [];

    if (activeModels.length > 0 && processingQuadrants.length > 0) {
      // Show which models are actively generating
      const modelNames = activeModels.map(
        (modelId) => getModelDisplayName(modelId) || modelId || "default"
      );

      if (activeModels.length === 1) {
        const coordsStr = processingQuadrants
          .map(([x, y]) => `(${x},${y})`)
          .join(" ");
        statusParts.push(`üîÑ ${modelNames[0]}: ${coordsStr}`);
      } else {
        // Multiple models generating in parallel
        statusParts.push(`üîÑ Generating: ${modelNames.join(", ")}`);
      }
    } else if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      // Fallback to old behavior
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show per-model queue counts
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      if (modelQueues.length > 0) {
        const queueParts = modelQueues.map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return `${name}: ${count}`;
        });
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    } else if (serverStatus.queue_length > 0) {
      // Fallback for backwards compatibility
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate with prompt button
  const generateWithPromptBtn = document.getElementById("generateWithPromptBtn");
  if (generateWithPromptBtn) {
    generateWithPromptBtn.disabled = count === 0;
  }
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

// Prompt dialog functions
function showPromptDialog() {
  if (selectedQuadrants.size === 0) return;
  const dialog = document.getElementById("promptDialog");
  const input = document.getElementById("promptInput");
  if (dialog && input) {
    input.value = "";
    dialog.style.display = "flex";
    input.focus();
  }
}

function hidePromptDialog() {
  const dialog = document.getElementById("promptDialog");
  if (dialog) {
    dialog.style.display = "none";
  }
}

async function submitPromptGeneration() {
  const input = document.getElementById("promptInput");
  const prompt = input ? input.value.trim() : "";
  hidePromptDialog();
  await generateSelected(prompt);
}

async function generateSelected(prompt = null) {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  const promptMsg = prompt ? " with prompt" : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${promptMsg}${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    // Include prompt if provided
    if (prompt) {
      requestBody.prompt = prompt;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position, "model:", result.model_id);
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes
    const wasGenerating = isGenerating || isRendering;
    isGenerating = status.is_generating && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = `${status.queue_length} more item(s) in queue...`;
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .filter(([, info]) => info.pending_count > 0)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              return `${name}: ${info.pending_count}`;
            });
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        showToast("info", "Processing queue", queueMsg);
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Add options for each model
  config.models.forEach((model) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;
    if (model.model_id === config.default_model_id) {
      option.selected = true;
    }
    select.appendChild(option);
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to ALL currently processing quadrants (from all models)
  const processingQuadrants = status.all_processing_quadrants || status.quadrants || [];
  const isProcessing = status.is_generating || (status.active_model_count > 0);

  if (isProcessing && processingQuadrants.length > 0) {
    document.body.classList.add("generating");
    processingQuadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else if (!isProcessing) {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items
  if (status.queue && status.queue.length > 0) {
    status.queue.forEach((item) => {
      if (item.quadrants) {
        item.quadrants.forEach(([qx, qy]) => {
          const tile = document.querySelector(
            `.tile[data-coords="${qx},${qy}"]`
          );
          if (tile && !tile.classList.contains("locked")) {
            tile.classList.add("queued");
          }
        });
      }
    });
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  // Ignore keyboard shortcuts when prompt dialog is open
  const promptDialog = document.getElementById("promptDialog");
  if (promptDialog && promptDialog.style.display !== "none") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate fix water tool if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate select tool if active
  if (selectToolActive) {
    toggleSelectTool();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    // Show all active models generating
    const activeModels = serverStatus.active_models || [];
    const processingQuadrants = serverStatus.all_processing_quadrants || serverStatus.quadrants || [];

    if (activeModels.length > 0 && processingQuadrants.length > 0) {
      // Show which models are actively generating
      const modelNames = activeModels.map(
        (modelId) => getModelDisplayName(modelId) || modelId || "default"
      );

      if (activeModels.length === 1) {
        const coordsStr = processingQuadrants
          .map(([x, y]) => `(${x},${y})`)
          .join(" ");
        statusParts.push(`üîÑ ${modelNames[0]}: ${coordsStr}`);
      } else {
        // Multiple models generating in parallel
        statusParts.push(`üîÑ Generating: ${modelNames.join(", ")}`);
      }
    } else if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      // Fallback to old behavior
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show per-model queue counts
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      if (modelQueues.length > 0) {
        const queueParts = modelQueues.map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return `${name}: ${count}`;
        });
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    } else if (serverStatus.queue_length > 0) {
      // Fallback for backwards compatibility
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Show selection count
  if (count > 0) {
    statusParts.push(`${count} selected`);
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = "0 quadrants selected";
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate with prompt button
  const generateWithPromptBtn = document.getElementById("generateWithPromptBtn");
  if (generateWithPromptBtn) {
    generateWithPromptBtn.disabled = count === 0;
  }
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

// Prompt dialog functions
function showPromptDialog() {
  if (selectedQuadrants.size === 0) return;
  const dialog = document.getElementById("promptDialog");
  const input = document.getElementById("promptInput");
  if (dialog && input) {
    input.value = "";
    dialog.style.display = "flex";
    input.focus();
  }
}

function hidePromptDialog() {
  const dialog = document.getElementById("promptDialog");
  if (dialog) {
    dialog.style.display = "none";
  }
}

async function submitPromptGeneration() {
  const input = document.getElementById("promptInput");
  const prompt = input ? input.value.trim() : "";
  hidePromptDialog();
  await generateSelected(prompt);
}

async function generateSelected(prompt = null) {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  const promptMsg = prompt ? " with prompt" : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${promptMsg}${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    // Include prompt if provided
    if (prompt) {
      requestBody.prompt = prompt;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Generation queued at position:", result.position, "model:", result.model_id);
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes - consider active_model_count for parallel processing
    const wasGenerating = isGenerating || isRendering;
    const hasActiveModels = (status.active_model_count || 0) > 0;
    isGenerating = (status.is_generating || hasActiveModels) && status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = `${status.queue_length} more item(s) in queue...`;
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .filter(([, info]) => info.pending_count > 0)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              return `${name}: ${info.pending_count}`;
            });
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        showToast("info", "Processing queue", queueMsg);
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

Done! Here's what I fixed:

**Backend (`queue_db.py`):**
- Added `get_all_processing_items()` function to get ALL items being processed (not just one)
- Updated `get_queue_status_by_model()` to return:
  - `processing_models`: list of all model IDs currently processing
  - `all_processing_quadrants`: combined list of all quadrants being processed across all models

**Backend (`app.py`):**
- Updated `/api/status` to include `all_processing_quadrants` in the response
- Updated `is_generating` to be true if ANY model is active

**Frontend (`viewer.js`):**
- Updated `applyStatusStyles()` to use `all_processing_quadrants` - now shows locked styles for ALL quadrants being generated, regardless of model
- Updated status bar to show all active models when generating in parallel:
  - Single model: `üîÑ Omni Water v2: (5,3) (5,4)`
  - Multiple models: `üîÑ Generating: Omni Water v2, Omni Original`
- Updated `checkGenerationStatus()` to consider `active_model_count` for determining if processing is happening

Now when you generate with different models in parallel:
1. All processing quadrants show the "locked" outline
2. Status bar shows all active models
3. The "generating" body class remains active while any model is processing

---

**User**

OK next feature to build - let's show all pending generations by outlining the entire generation (e.g. the 2x2 tile, 2x1 or 1x2 group, or 1x1 quadrant). Each generation should have a small number icon in the upper left corner that shows which position in the queue it is. In addition, when hovering over a pending generation, there should be a small trash icon that appears that allows the user to cancel that generation

---

**Cursor**

I'll implement this feature with:
1. Visual overlays for each pending generation group with queue position badges
2. A cancel API endpoint
3. Hover-triggered trash icon for cancellation

Let me start by examining the current queue structure and tile layout:

Let me create a comprehensive solution for this feature. I'll start by adding the cancel-by-ID function in the queue database:

```python
"""
Database-backed generation queue.

Provides a robust, persistent queue for generation and render requests
that survives server restarts and doesn't rely on client-side state.
"""

import json
import sqlite3
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any


class QueueItemType(str, Enum):
  GENERATE = "generate"
  RENDER = "render"


class QueueItemStatus(str, Enum):
  PENDING = "pending"
  PROCESSING = "processing"
  COMPLETE = "complete"
  ERROR = "error"


@dataclass
class QueueItem:
  """Represents a single item in the generation queue."""

  id: int
  item_type: QueueItemType
  quadrants: list[tuple[int, int]]
  model_id: str | None
  status: QueueItemStatus
  created_at: float
  started_at: float | None
  completed_at: float | None
  error_message: str | None
  result_message: str | None
  context_quadrants: list[tuple[int, int]] | None = None
  prompt: str | None = None

  @classmethod
  def from_row(cls, row: tuple) -> "QueueItem":
    """Create a QueueItem from a database row."""
    # Handle schema evolution: 10 base columns + optional context_quadrants + optional prompt
    context = None
    prompt = None
    if len(row) > 10 and row[10]:
      context = json.loads(row[10])
    if len(row) > 11 and row[11]:
      prompt = row[11]

    return cls(
      id=row[0],
      item_type=QueueItemType(row[1]),
      quadrants=json.loads(row[2]),
      model_id=row[3],
      status=QueueItemStatus(row[4]),
      created_at=row[5],
      started_at=row[6],
      completed_at=row[7],
      error_message=row[8],
      result_message=row[9],
      context_quadrants=context,
      prompt=prompt,
    )

  def to_dict(self) -> dict[str, Any]:
    """Convert to dictionary for JSON serialization."""
    result = {
      "id": self.id,
      "type": self.item_type.value,
      "quadrants": self.quadrants,
      "model_id": self.model_id,
      "status": self.status.value,
      "created_at": self.created_at,
      "started_at": self.started_at,
      "completed_at": self.completed_at,
      "error_message": self.error_message,
      "result_message": self.result_message,
    }
    if self.context_quadrants:
      result["context_quadrants"] = self.context_quadrants
    if self.prompt:
      result["prompt"] = self.prompt
    return result


def init_queue_table(conn: sqlite3.Connection) -> None:
  """Initialize the generation_queue table if it doesn't exist."""
  cursor = conn.cursor()
  cursor.execute("""
    CREATE TABLE IF NOT EXISTS generation_queue (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_type TEXT NOT NULL,
      quadrants TEXT NOT NULL,
      model_id TEXT,
      status TEXT NOT NULL DEFAULT 'pending',
      created_at REAL NOT NULL,
      started_at REAL,
      completed_at REAL,
      error_message TEXT,
      result_message TEXT,
      context_quadrants TEXT,
      prompt TEXT
    )
  """)
  # Create index on status for efficient queue queries
  cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_queue_status ON generation_queue(status)
  """)

  # Migration: Add columns if they don't exist (for existing dbs)
  cursor.execute("PRAGMA table_info(generation_queue)")
  columns = [row[1] for row in cursor.fetchall()]
  if "context_quadrants" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN context_quadrants TEXT")
  if "prompt" not in columns:
    cursor.execute("ALTER TABLE generation_queue ADD COLUMN prompt TEXT")

  conn.commit()


def add_to_queue(
  conn: sqlite3.Connection,
  item_type: QueueItemType,
  quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> QueueItem:
  """
  Add a new item to the generation queue.

  Args:
    conn: Database connection
    item_type: Type of operation (generate or render)
    quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation. If a context quadrant has a generation, that will be used;
      otherwise the render will be used.
    prompt: Optional additional prompt text for generation

  Returns:
    The created QueueItem
  """
  cursor = conn.cursor()
  created_at = time.time()

  context_json = json.dumps(context_quadrants) if context_quadrants else None

  cursor.execute(
    """
    INSERT INTO generation_queue
      (item_type, quadrants, model_id, status, created_at, context_quadrants, prompt)
    VALUES (?, ?, ?, ?, ?, ?, ?)
    """,
    (
      item_type.value,
      json.dumps(quadrants),
      model_id,
      QueueItemStatus.PENDING.value,
      created_at,
      context_json,
      prompt,
    ),
  )
  conn.commit()

  item_id = cursor.lastrowid
  return QueueItem(
    id=item_id,
    item_type=item_type,
    quadrants=quadrants,
    model_id=model_id,
    status=QueueItemStatus.PENDING,
    created_at=created_at,
    started_at=None,
    completed_at=None,
    error_message=None,
    result_message=None,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def get_next_pending_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the next pending item from the queue.

  Returns the oldest pending item, or None if queue is empty.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    LIMIT 1
    """,
    (QueueItemStatus.PENDING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def get_next_pending_item_for_available_model(
  conn: sqlite3.Connection, busy_models: set[str | None]
) -> QueueItem | None:
  """
  Get the next pending item for a model that isn't currently busy.

  This enables parallel processing of different models' queues.

  Args:
    conn: Database connection
    busy_models: Set of model_ids that are currently processing
                 (None represents the default/no model)

  Returns None if no available items.
  """
  cursor = conn.cursor()

  # Get all pending items ordered by creation time
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )

  for row in cursor.fetchall():
    item = QueueItem.from_row(row)
    # Check if this model is available (not busy)
    if item.model_id not in busy_models:
      return item

  return None


def get_processing_item(conn: sqlite3.Connection) -> QueueItem | None:
  """
  Get the currently processing item, if any.

  Returns the item currently being processed, or None.
  """
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at DESC
    LIMIT 1
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  row = cursor.fetchone()
  return QueueItem.from_row(row) if row else None


def mark_item_processing(conn: sqlite3.Connection, item_id: int) -> None:
  """Mark a queue item as processing."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = ?
    WHERE id = ?
    """,
    (QueueItemStatus.PROCESSING.value, time.time(), item_id),
  )
  conn.commit()


def mark_item_complete(
  conn: sqlite3.Connection, item_id: int, result_message: str | None = None
) -> None:
  """Mark a queue item as complete."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, result_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.COMPLETE.value, time.time(), result_message, item_id),
  )
  conn.commit()


def mark_item_error(conn: sqlite3.Connection, item_id: int, error_message: str) -> None:
  """Mark a queue item as errored."""
  cursor = conn.cursor()
  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ?
    """,
    (QueueItemStatus.ERROR.value, time.time(), error_message, item_id),
  )
  conn.commit()


def get_pending_queue(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all pending items in the queue, ordered by creation time."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY created_at ASC
    """,
    (QueueItemStatus.PENDING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_position(conn: sqlite3.Connection, item_id: int) -> int:
  """
  Get the position of an item in the queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # Check if it's pending and get position
  cursor.execute(
    """
    SELECT COUNT(*) + 1
    FROM generation_queue
    WHERE status = ? AND created_at < (
      SELECT created_at FROM generation_queue WHERE id = ?
    )
    """,
    (QueueItemStatus.PENDING.value, item_id),
  )
  row = cursor.fetchone()
  if row and row[0] > 0:
    return row[0]

  return -1


def get_queue_status(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get a summary of the current queue status.

  Returns a dictionary with:
    - is_processing: bool
    - current_item: dict | None
    - pending_count: int
    - pending_items: list of dicts
  """
  processing = get_processing_item(conn)
  pending = get_pending_queue(conn)

  return {
    "is_processing": processing is not None,
    "current_item": processing.to_dict() if processing else None,
    "pending_count": len(pending),
    "pending_items": [item.to_dict() for item in pending],
  }


def get_all_processing_items(conn: sqlite3.Connection) -> list[QueueItem]:
  """Get all items currently being processed (one per model in parallel mode)."""
  cursor = conn.cursor()
  cursor.execute(
    """
    SELECT id, item_type, quadrants, model_id, status,
           created_at, started_at, completed_at, error_message, result_message,
           context_quadrants, prompt
    FROM generation_queue
    WHERE status = ?
    ORDER BY started_at ASC
    """,
    (QueueItemStatus.PROCESSING.value,),
  )
  return [QueueItem.from_row(row) for row in cursor.fetchall()]


def get_queue_status_by_model(conn: sqlite3.Connection) -> dict[str, Any]:
  """
  Get queue status grouped by model.

  Returns a dictionary with:
    - by_model: dict mapping model_id -> {
        is_processing: bool,
        current_item: dict | None,
        pending_count: int,
        pending_items: list of dicts,
        position: int (1-based, 0 if processing)
      }
    - total_pending: int
    - processing_models: list of model_ids currently processing
    - all_processing_quadrants: list of all quadrants currently being processed
  """
  processing_items = get_all_processing_items(conn)
  pending = get_pending_queue(conn)

  # Group pending items by model_id
  by_model: dict[str, dict[str, Any]] = {}

  for item in pending:
    model_id = item.model_id or "default"
    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": False,
        "current_item": None,
        "pending_count": 0,
        "pending_items": [],
      }
    by_model[model_id]["pending_count"] += 1
    by_model[model_id]["pending_items"].append(item.to_dict())

  # Add all processing items to their model's status
  processing_models = []
  all_processing_quadrants = []

  for processing in processing_items:
    model_id = processing.model_id or "default"
    processing_models.append(model_id)

    # Collect all processing quadrants
    if processing.quadrants:
      all_processing_quadrants.extend(processing.quadrants)

    if model_id not in by_model:
      by_model[model_id] = {
        "is_processing": True,
        "current_item": processing.to_dict(),
        "pending_count": 0,
        "pending_items": [],
      }
    else:
      by_model[model_id]["is_processing"] = True
      by_model[model_id]["current_item"] = processing.to_dict()

  return {
    "by_model": by_model,
    "total_pending": len(pending),
    "processing_models": processing_models,
    "all_processing_quadrants": all_processing_quadrants,
  }


def get_queue_position_for_model(
  conn: sqlite3.Connection, item_id: int, model_id: str | None
) -> int:
  """
  Get the position of an item within its model's queue.

  Returns 0 if the item is currently processing,
  1 if it's first in the pending queue for this model, etc.
  Returns -1 if the item is not found or already complete.
  """
  cursor = conn.cursor()

  # Check if it's processing
  cursor.execute(
    "SELECT 1 FROM generation_queue WHERE id = ? AND status = ?",
    (item_id, QueueItemStatus.PROCESSING.value),
  )
  if cursor.fetchone():
    return 0

  # For model-specific position, count items with same model_id that are ahead
  # Use empty string for NULL model_id comparison
  if model_id is None:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id IS NULL
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, item_id),
    )
  else:
    cursor.execute(
      """
      SELECT COUNT(*) + 1
      FROM generation_queue
      WHERE status = ?
        AND model_id = ?
        AND created_at < (
          SELECT created_at FROM generation_queue WHERE id = ?
        )
      """,
      (QueueItemStatus.PENDING.value, model_id, item_id),
    )

  row = cursor.fetchone()
  if row:
    return row[0]

  return -1


def reset_all_processing_items(conn: sqlite3.Connection) -> int:
  """
  Reset ALL items in 'processing' state back to 'pending'.

  This should be called on server startup to ensure any items that were
  interrupted mid-processing (e.g., due to server shutdown) are retried.

  Returns the number of items reset.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value),
  )
  conn.commit()
  return cursor.rowcount


def cleanup_stale_processing(
  conn: sqlite3.Connection, max_age_seconds: float = 3600.0
) -> int:
  """
  Clean up items stuck in 'processing' state for too long.

  This handles cases where the server crashed during processing.
  Items older than max_age_seconds are reset to 'pending'.

  Note: For server startup, use reset_all_processing_items() instead,
  which resets all processing items regardless of age.

  Returns the number of items reset.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, started_at = NULL
    WHERE status = ? AND started_at < ?
    """,
    (QueueItemStatus.PENDING.value, QueueItemStatus.PROCESSING.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_completed_items(
  conn: sqlite3.Connection, max_age_seconds: float = 86400.0
) -> int:
  """
  Delete completed/errored items older than max_age_seconds.

  Returns the number of items deleted.
  """
  cursor = conn.cursor()
  cutoff_time = time.time() - max_age_seconds

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status IN (?, ?) AND completed_at < ?
    """,
    (QueueItemStatus.COMPLETE.value, QueueItemStatus.ERROR.value, cutoff_time),
  )
  conn.commit()
  return cursor.rowcount


def clear_pending_queue(conn: sqlite3.Connection) -> int:
  """
  Delete all pending items from the queue.

  Does NOT affect items that are currently processing.
  Returns the number of items deleted.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    DELETE FROM generation_queue
    WHERE status = ?
    """,
    (QueueItemStatus.PENDING.value,),
  )
  conn.commit()
  return cursor.rowcount


def cancel_queue_item_by_id(conn: sqlite3.Connection, item_id: int) -> bool:
  """
  Cancel a specific queue item by its ID.

  Can cancel items in 'pending' or 'processing' status.

  Returns True if an item was cancelled, False otherwise.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE id = ? AND status IN (?, ?)
    """,
    (
      QueueItemStatus.ERROR.value,
      time.time(),
      "Cancelled by user",
      item_id,
      QueueItemStatus.PENDING.value,
      QueueItemStatus.PROCESSING.value,
    ),
  )
  conn.commit()

  return cursor.rowcount > 0


def cancel_processing_items(conn: sqlite3.Connection) -> int:
  """
  Mark all processing items as cancelled (error status).

  This is used when the user wants to cancel everything, including
  items that are currently being processed.

  Returns the number of items cancelled.
  """
  cursor = conn.cursor()

  cursor.execute(
    """
    UPDATE generation_queue
    SET status = ?, completed_at = ?, error_message = ?
    WHERE status = ?
    """,
    (
      QueueItemStatus.ERROR.value,
      time.time(),
      "Cancelled by user",
      QueueItemStatus.PROCESSING.value,
    ),
  )
  conn.commit()
  return cursor.rowcount


def clear_all_queue_items(conn: sqlite3.Connection) -> dict[str, int]:
  """
  Delete all items from the queue (pending, processing, complete, error).

  Returns a dict with counts by status.
  """
  cursor = conn.cursor()

  # Get counts first
  cursor.execute(
    """
    SELECT status, COUNT(*) FROM generation_queue GROUP BY status
    """
  )
  counts = {row[0]: row[1] for row in cursor.fetchall()}

  # Delete all
  cursor.execute("DELETE FROM generation_queue")
  conn.commit()

  return counts

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  cancel_queue_item_by_id,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.
    prompt: Optional additional prompt text for generation

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants, prompt
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None
    prompt = row[4]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    if prompt:
      print(f"   Prompt: {prompt}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants, prompt
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_models": model_status["processing_models"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
      # All quadrants being processed across all models
      "all_processing_quadrants": model_status["all_processing_quadrants"],
    }

    # Set is_generating based on whether any models are active
    response["is_generating"] = len(active_models) > 0

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  # Parse optional prompt
  prompt = data.get("prompt")
  if prompt and not isinstance(prompt, str):
    return jsonify(
      {
        "success": False,
        "error": "prompt must be a string",
      }
    ), 400

  # Clean up prompt (strip whitespace, None if empty)
  if prompt:
    prompt = prompt.strip()
    if not prompt:
      prompt = None

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  if prompt:
    print(f"   Prompt: {prompt}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(
    selected_quadrants, "generate", model_id, context_quadrants, prompt
  )
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  cancel_queue_item_by_id,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.
    prompt: Optional additional prompt text for generation

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants, prompt
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None
    prompt = row[4]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    if prompt:
      print(f"   Prompt: {prompt}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants, prompt
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_models": model_status["processing_models"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
      # All quadrants being processed across all models
      "all_processing_quadrants": model_status["all_processing_quadrants"],
    }

    # Set is_generating based on whether any models are active
    response["is_generating"] = len(active_models) > 0

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/queue/cancel/<int:item_id>", methods=["POST"])
def api_cancel_queue_item(item_id: int):
  """
  API endpoint to cancel a specific queue item by its ID.

  Returns:
    {
      "success": true,
      "cancelled": true,
      "item_id": N,
      "message": "Cancelled queue item N"
    }
  """
  global generation_cancelled

  print(f"\n{'=' * 60}")
  print(f"üóëÔ∏è  Cancel queue item request received: item_id={item_id}")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    cancelled = cancel_queue_item_by_id(conn, item_id)

    if cancelled:
      # Set the cancellation flag so the worker knows to stop
      # (in case this was a processing item)
      generation_cancelled = True
      print(f"‚úÖ Cancelled queue item {item_id}")

      return jsonify(
        {
          "success": True,
          "cancelled": True,
          "item_id": item_id,
          "message": f"Cancelled queue item {item_id}",
        }
      )
    else:
      print(f"‚ÑπÔ∏è  Queue item {item_id} not found or already completed")
      return jsonify(
        {
          "success": True,
          "cancelled": False,
          "item_id": item_id,
          "message": f"Queue item {item_id} not found or already completed",
        }
      )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  # Parse optional prompt
  prompt = data.get("prompt")
  if prompt and not isinstance(prompt, str):
    return jsonify(
      {
        "success": False,
        "error": "prompt must be a string",
      }
    ), 400

  # Clean up prompt (strip whitespace, None if empty)
  if prompt:
    prompt = prompt.strip()
    if not prompt:
      prompt = None

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  if prompt:
    print(f"   Prompt: {prompt}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(
    selected_quadrants, "generate", model_id, context_quadrants, prompt
  )
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// LocalStorage keys for persistence
const STORAGE_KEY_MODEL = "viewer_selected_model";
const STORAGE_KEY_TOOL = "viewer_selected_tool";
const STORAGE_KEY_SELECTION = "viewer_selected_quadrants";

// Save selected model ID to localStorage
function saveSelectedModel(modelId) {
  try {
    localStorage.setItem(STORAGE_KEY_MODEL, modelId);
  } catch (e) {
    console.warn("Could not save model to localStorage:", e);
  }
}

// Get saved model ID from localStorage
function getSavedModel() {
  try {
    return localStorage.getItem(STORAGE_KEY_MODEL);
  } catch (e) {
    return null;
  }
}

// Save selected tool to localStorage
function saveSelectedTool(toolName) {
  try {
    localStorage.setItem(STORAGE_KEY_TOOL, toolName || "");
  } catch (e) {
    console.warn("Could not save tool to localStorage:", e);
  }
}

// Get saved tool from localStorage
function getSavedTool() {
  try {
    return localStorage.getItem(STORAGE_KEY_TOOL) || "";
  } catch (e) {
    return "";
  }
}

// Save selected quadrants to localStorage
function saveSelectedQuadrants() {
  try {
    const quadrantsArray = Array.from(selectedQuadrants);
    localStorage.setItem(STORAGE_KEY_SELECTION, JSON.stringify(quadrantsArray));
  } catch (e) {
    console.warn("Could not save selection to localStorage:", e);
  }
}

// Get saved quadrants from localStorage
function getSavedQuadrants() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY_SELECTION);
    return saved ? JSON.parse(saved) : [];
  } catch (e) {
    return [];
  }
}

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Check if saved model ID exists in available models
  const savedModelId = getSavedModel();
  const savedModelExists =
    savedModelId && config.models.some((m) => m.model_id === savedModelId);

  // Add options for each model
  config.models.forEach((model, index) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;

    // Select saved model if it exists, otherwise use default or first
    if (savedModelExists && model.model_id === savedModelId) {
      option.selected = true;
    } else if (
      !savedModelExists &&
      model.model_id === config.default_model_id
    ) {
      option.selected = true;
    } else if (!savedModelExists && !config.default_model_id && index === 0) {
      option.selected = true;
    }
    select.appendChild(option);
  });

  // Auto-blur after selection and save to localStorage
  select.addEventListener("change", () => {
    saveSelectedModel(select.value);
    select.blur();
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to ALL currently processing quadrants (from all models)
  const processingQuadrants =
    status.all_processing_quadrants || status.quadrants || [];
  const isProcessing = status.is_generating || status.active_model_count > 0;

  if (isProcessing && processingQuadrants.length > 0) {
    document.body.classList.add("generating");
    processingQuadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else if (!isProcessing) {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items AND create overlays
  updateQueueOverlays(status.queue || []);
}

// Create/update overlays for pending queue items
function updateQueueOverlays(queueItems) {
  // Remove existing overlays
  document.querySelectorAll(".queue-overlay").forEach((el) => el.remove());

  // Also clear queued class from all tiles
  document.querySelectorAll(".tile.queued").forEach((tile) => {
    tile.classList.remove("queued");
  });

  if (!queueItems || queueItems.length === 0) return;

  const grid = document.querySelector(".grid");
  if (!grid) return;

  // Get grid dimensions from config
  const gridX = config.x;
  const gridY = config.y;
  const sizePx = config.size_px;
  const showLines = document.getElementById("showLines")?.checked || false;
  const gap = showLines ? 2 : 0;

  queueItems.forEach((item, index) => {
    if (!item.quadrants || item.quadrants.length === 0) return;

    // Calculate bounding box for this generation
    const quadrants = item.quadrants;
    let minCol = Infinity,
      maxCol = -Infinity;
    let minRow = Infinity,
      maxRow = -Infinity;

    // Track which tiles are visible in the current view
    const visibleQuadrants = [];

    quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        // This quadrant is visible in current view
        visibleQuadrants.push([qx, qy]);

        // Calculate column and row relative to grid origin
        const col = qx - gridX;
        const row = qy - gridY;

        minCol = Math.min(minCol, col);
        maxCol = Math.max(maxCol, col);
        minRow = Math.min(minRow, row);
        maxRow = Math.max(maxRow, row);

        // Also add queued class to tile
        if (!tile.classList.contains("locked")) {
          tile.classList.add("queued");
        }
      }
    });

    // Skip if no visible quadrants
    if (visibleQuadrants.length === 0) return;

    // Create overlay element
    const overlay = document.createElement("div");
    overlay.className = "queue-overlay";
    overlay.dataset.itemId = item.id;

    // Calculate position and size
    const left = minCol * (sizePx + gap);
    const top = minRow * (sizePx + gap);
    const width = (maxCol - minCol + 1) * sizePx + (maxCol - minCol) * gap;
    const height = (maxRow - minRow + 1) * sizePx + (maxRow - minRow) * gap;

    overlay.style.left = `${left}px`;
    overlay.style.top = `${top}px`;
    overlay.style.width = `${width}px`;
    overlay.style.height = `${height}px`;

    // Queue position badge (1-indexed for display)
    const badge = document.createElement("div");
    badge.className = "queue-badge";
    badge.textContent = index + 1;
    overlay.appendChild(badge);

    // Model name label (smaller, below badge)
    if (item.model_id) {
      const modelLabel = document.createElement("div");
      modelLabel.className = "queue-model-label";
      modelLabel.textContent = getModelDisplayName(item.model_id) || item.model_id;
      overlay.appendChild(modelLabel);
    }

    // Cancel button (visible on hover)
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "queue-cancel-btn";
    cancelBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
      <line x1="10" y1="11" x2="10" y2="17"/>
      <line x1="14" y1="11" x2="14" y2="17"/>
    </svg>`;
    cancelBtn.title = "Cancel this generation";
    cancelBtn.onclick = (e) => {
      e.stopPropagation();
      cancelQueueItem(item.id);
    };
    overlay.appendChild(cancelBtn);

    grid.appendChild(overlay);
  });
}

// Cancel a specific queue item
async function cancelQueueItem(itemId) {
  try {
    const response = await fetch(`/api/queue/cancel/${itemId}`, {
      method: "POST",
    });
    const result = await response.json();

    if (result.success && result.cancelled) {
      showToast("success", "Cancelled", result.message);
      // Trigger immediate status update
      checkGenerationStatus();
    } else if (result.success && !result.cancelled) {
      showToast("info", "Not found", result.message);
    } else {
      showToast("error", "Error", result.error || "Failed to cancel");
    }
  } catch (error) {
    console.error("Cancel queue item failed:", error);
    showToast("error", "Error", "Failed to cancel queue item");
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  // Ignore keyboard shortcuts when prompt dialog is open
  const promptDialog = document.getElementById("promptDialog");
  if (promptDialog && promptDialog.style.display !== "none") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate other tools if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
    saveSelectedTool("select");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
    saveSelectedTool("");
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate other tools if active
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
    saveSelectedTool("fixwater");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
    saveSelectedTool("waterfill");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    // Show all active models generating
    const activeModels = serverStatus.active_models || [];
    const processingQuadrants =
      serverStatus.all_processing_quadrants || serverStatus.quadrants || [];

    if (activeModels.length > 0 && processingQuadrants.length > 0) {
      // Show which models are actively generating
      const modelNames = activeModels.map(
        (modelId) => getModelDisplayName(modelId) || modelId || "default"
      );

      if (activeModels.length === 1) {
        const coordsStr = processingQuadrants
          .map(([x, y]) => `(${x},${y})`)
          .join(" ");
        statusParts.push(`üîÑ ${modelNames[0]}: ${coordsStr}`);
      } else {
        // Multiple models generating in parallel
        statusParts.push(`üîÑ Generating: ${modelNames.join(", ")}`);
      }
    } else if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      // Fallback to old behavior
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show per-model queue counts
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      if (modelQueues.length > 0) {
        const queueParts = modelQueues.map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return `${name}: ${count}`;
        });
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    } else if (serverStatus.queue_length > 0) {
      // Fallback for backwards compatibility
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Update selection display in toolbar-info (separate from status)
  const selectedDisplay = document.getElementById("selectedQuadrantsDisplay");
  if (selectedDisplay) {
    if (count > 0) {
      const coordsStr = Array.from(selectedQuadrants)
        .map((key) => {
          const [x, y] = key.split(",");
          return `(${x},${y})`;
        })
        .join(" ");
      selectedDisplay.textContent = `‚úì ${coordsStr}`;
      selectedDisplay.style.display = "";
    } else {
      selectedDisplay.textContent = "";
      selectedDisplay.style.display = "none";
    }
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = `${count} selected`;
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate with prompt button
  const generateWithPromptBtn = document.getElementById(
    "generateWithPromptBtn"
  );
  if (generateWithPromptBtn) {
    generateWithPromptBtn.disabled = count === 0;
  }
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

// Prompt dialog functions
function showPromptDialog() {
  if (selectedQuadrants.size === 0) return;
  const dialog = document.getElementById("promptDialog");
  const input = document.getElementById("promptInput");
  if (dialog && input) {
    input.value = "";
    dialog.style.display = "flex";
    input.focus();
  }
}

function hidePromptDialog() {
  const dialog = document.getElementById("promptDialog");
  if (dialog) {
    dialog.style.display = "none";
  }
}

async function submitPromptGeneration() {
  const input = document.getElementById("promptInput");
  const prompt = input ? input.value.trim() : "";
  hidePromptDialog();
  await generateSelected(prompt);
}

async function generateSelected(prompt = null) {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  const promptMsg = prompt ? " with prompt" : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${promptMsg}${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    // Include prompt if provided
    if (prompt) {
      requestBody.prompt = prompt;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log(
        "Generation queued at position:",
        result.position,
        "model:",
        result.model_id
      );
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  saveSelectedQuadrants();
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  saveSelectedQuadrants();
  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes - consider active_model_count for parallel processing
    const wasGenerating = isGenerating || isRendering;
    const hasActiveModels = (status.active_model_count || 0) > 0;
    isGenerating =
      (status.is_generating || hasActiveModels) &&
      status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = `${status.queue_length} more item(s) in queue...`;
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .filter(([, info]) => info.pending_count > 0)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              return `${name}: ${info.pending_count}`;
            });
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        showToast("info", "Processing queue", queueMsg);
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Restore saved tool on page load
function restoreSavedTool() {
  const savedTool = getSavedTool();
  if (!savedTool) return;

  // Check if the tool button exists before activating
  switch (savedTool) {
    case "select":
      if (document.getElementById("selectTool")) {
        toggleSelectTool();
      }
      break;
    case "fixwater":
      if (document.getElementById("fixWaterTool")) {
        toggleFixWaterTool();
      }
      break;
    case "waterfill":
      if (document.getElementById("waterFillTool")) {
        toggleWaterFillTool();
      }
      break;
    default:
      // Unknown tool, clear saved state
      saveSelectedTool("");
      break;
  }
}

// Restore saved quadrant selections on page load
function restoreSavedQuadrants() {
  const savedQuadrants = getSavedQuadrants();
  if (!savedQuadrants || savedQuadrants.length === 0) return;

  let restoredCount = 0;

  savedQuadrants.forEach((key) => {
    // Check if this quadrant tile exists on the current page
    const tile = document.querySelector(`.tile[data-coords="${key}"]`);
    if (tile) {
      // Don't restore if tile is locked or queued
      if (
        !tile.classList.contains("locked") &&
        !tile.classList.contains("queued")
      ) {
        selectedQuadrants.add(key);
        tile.classList.add("selected");
        restoredCount++;
      }
    }
  });

  if (restoredCount > 0) {
    console.log(`Restored ${restoredCount} selected quadrant(s)`);
    // Update localStorage to only contain valid selections
    saveSelectedQuadrants();
    updateSelectionStatus();
  } else if (savedQuadrants.length > 0) {
    // Had saved selections but none are on current page - clear storage
    saveSelectedQuadrants();
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  // Restore saved tool
  restoreSavedTool();

  // Restore saved quadrant selections
  restoreSavedQuadrants();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
  font-size: 12px;
  background: #1a1a2e;
  color: #eee;
  min-height: 100vh;
  padding: 15px;
  padding-top: 95px; /* Space for fixed toolbar */
}

.toolbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: #1a1a2e;
  padding: 10px 15px;
  z-index: 100;
  border-bottom: 1px solid #333;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.toolbar-row {
  display: flex;
  align-items: center;
  gap: 15px;
  flex-wrap: wrap;
}

.toolbar-info {
  color: #666;
  font-size: 0.75rem;
}

.toolbar-info span + span {
  margin-left: 12px;
}

.toolbar-info .selected-quadrants {
  color: #00d9ff;
  font-weight: bold;
}

.controls {
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
}

.controls label {
  color: #888;
  font-size: 0.8rem;
}

.controls input[type="number"] {
  width: 50px;
  padding: 5px 6px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #16213e;
  color: #fff;
  font-family: inherit;
  font-size: 0.8rem;
}

.controls button {
  padding: 5px 12px;
  background: #00d9ff;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.75rem;
  font-weight: bold;
}

.controls button:hover {
  background: #00b8d4;
}

.toggle-group {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-left: 8px;
  padding-left: 12px;
  border-left: 1px solid #333;
}

.toggle-group label {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  user-select: none;
  font-size: 0.75rem;
}

.toggle-group input[type="checkbox"] {
  width: 14px;
  height: 14px;
  accent-color: #00d9ff;
  cursor: pointer;
}

.grid-container {
  display: inline-block;
  border-radius: 8px;
  overflow: hidden;
}

.grid-container.show-lines {
  border: 2px solid #333;
}

.grid {
  display: grid;
  background: #333;
}

.grid-container.show-lines .grid {
  gap: 2px;
}

.grid-container:not(.show-lines) .grid {
  gap: 0;
  background: transparent;
}

.grid-container:not(.show-lines) {
  border: none;
}

.tile {
  position: relative;
  background: #2a2a4a;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tile img {
  display: block;
  max-width: 100%;
  height: auto;
}

.tile.placeholder {
  background: #3a3a5a;
}

.tile .coords {
  position: absolute;
  top: 6px;
  left: 6px;
  background: rgba(0, 0, 0, 0.7);
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 0.65rem;
  color: #00d9ff;
  transition: opacity 0.2s;
}

.tile.placeholder .coords {
  color: #666;
}

.grid-container:not(.show-coords) .tile .coords {
  opacity: 0;
}

/* Tool button styles */
.tools-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.tools-label {
  color: #666;
  font-size: 0.7rem;
}

.tool-btn {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: #2a2a3e;
  color: #666;
  border: 1px solid #444;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  transition: all 0.15s ease;
}

.tool-btn:hover {
  background: #3a3a4e;
  color: #999;
  border-color: #555;
}

.tool-btn.active {
  background: #10b981;
  color: #fff;
  border-color: #10b981;
  box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
}

.tool-btn.active:hover {
  background: #059669;
  border-color: #059669;
}

.tool-btn svg {
  width: 12px;
  height: 12px;
}

/* Selection styles */
.tile.selected {
  outline: 3px solid #ff3333;
  outline-offset: -3px;
  z-index: 10;
}

.grid-container.show-lines .tile.selected {
  outline-color: #ff3333;
}

.tile.selectable {
  cursor: pointer;
}

.tile.placeholder.selected {
  background: rgba(255, 51, 51, 0.15);
}

/* Locked tiles (during generation) */
.tile.locked {
  outline: 3px solid #a855f7;
  outline-offset: -3px;
  z-index: 10;
}

.grid-container.show-lines .tile.locked {
  outline-color: #a855f7;
}

.tile.placeholder.locked {
  background: rgba(168, 85, 247, 0.2);
}

/* Queued tiles (in queue, waiting to be generated) */
.tile.queued {
  outline: 3px dashed #c084fc !important;
  outline-offset: -3px;
  z-index: 9;
  animation: pulse-queue 1.5s ease-in-out infinite;
  /* Fallback: box-shadow for browsers that don't render dashed outlines well */
  box-shadow: inset 0 0 0 3px rgba(192, 132, 252, 0.5);
}

@keyframes pulse-queue {
  0%,
  100% {
    outline-color: #c084fc;
    box-shadow: inset 0 0 0 3px rgba(192, 132, 252, 0.5);
  }
  50% {
    outline-color: #8b5cf6;
    box-shadow: inset 0 0 0 3px rgba(139, 92, 246, 0.7);
  }
}

.grid-container.show-lines .tile.queued {
  outline-color: #c084fc;
}

.tile.placeholder.queued {
  background: rgba(168, 85, 247, 0.3) !important;
}

/* Allow selection while generating - only disable clicking on locked/queued tiles */
body.generating .tile.locked.selectable,
body.generating .tile.queued.selectable {
  cursor: not-allowed;
}

/* Selection status bar */
.selection-status {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 10px;
  background: rgba(255, 51, 51, 0.1);
  border: 1px solid rgba(255, 51, 51, 0.3);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #ff6666;
  margin-top: 8px;
}

.selection-status.empty {
  background: transparent;
  border-color: #333;
  color: #666;
}

.selection-status.generating {
  background: rgba(168, 85, 247, 0.1);
  border-color: rgba(168, 85, 247, 0.4);
  color: #a855f7;
}

.selection-limit {
  color: #888;
  font-size: 0.65rem;
}

.deselect-btn {
  padding: 3px 8px;
  background: #ff3333;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  margin-left: auto;
  transition: all 0.2s;
}

.deselect-btn:hover:not(:disabled) {
  background: #ff5555;
}

.deselect-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
}

.delete-btn {
  padding: 3px 8px;
  background: #dc2626;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  transition: all 0.2s;
}

.delete-btn:hover:not(:disabled) {
  background: #b91c1c;
}

.delete-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
}

.render-btn {
  padding: 4px 12px;
  background: #f59e0b;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
}

.render-btn:hover:not(:disabled) {
  background: #d97706;
}

.render-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.render-btn.loading {
  background: #666;
  cursor: wait;
}

.render-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

.generate-btn {
  padding: 4px 12px;
  background: #00d9ff;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
}

.generate-btn:hover:not(:disabled) {
  background: #00b8d4;
}

.generate-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

/* Generate Rectangle button */
.generate-rect-btn {
  padding: 4px 12px;
  background: #8b5cf6;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
}

.generate-rect-btn:hover:not(:disabled) {
  background: #7c3aed;
}

.generate-rect-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.generate-rect-btn.loading {
  background: #666;
  cursor: wait;
}

.generate-rect-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

/* Clear Queue button */
.clear-queue-btn {
  padding: 4px 10px;
  background: #6b7280;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  font-weight: 500;
  transition: all 0.2s;
  margin-left: 8px;
}

.clear-queue-btn:hover {
  background: #ef4444;
}

.clear-queue-btn:active {
  background: #dc2626;
}

/* Toast notification system */
.toast-container {
  position: fixed;
  bottom: 15px;
  right: 15px;
  z-index: 1000;
  display: flex;
  flex-direction: column-reverse;
  gap: 8px;
  max-width: 320px;
}

.toast {
  padding: 10px 14px;
  border-radius: 6px;
  font-size: 0.75rem;
  animation: slideIn 0.3s ease-out;
  display: flex;
  align-items: flex-start;
  gap: 10px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.toast.success {
  background: linear-gradient(135deg, #065f46 0%, #047857 100%);
  border: 1px solid #10b981;
  color: #d1fae5;
}

.toast.error {
  background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
  border: 1px solid #ef4444;
  color: #fee2e2;
}

.toast.info {
  background: linear-gradient(135deg, #1e3a5f 0%, #1e40af 100%);
  border: 1px solid #3b82f6;
  color: #dbeafe;
}

.toast.loading {
  background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
  border: 1px solid #6b7280;
  color: #e5e7eb;
}

.toast-icon {
  flex-shrink: 0;
  font-size: 1rem;
}

.toast-content {
  flex: 1;
}

.toast-title {
  font-weight: 600;
  margin-bottom: 2px;
}

.toast-message {
  opacity: 0.9;
  font-size: 0.7rem;
}

.toast-close {
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  opacity: 0.7;
  font-size: 1rem;
  padding: 0;
  line-height: 1;
}

.toast-close:hover {
  opacity: 1;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOut {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

.toast.removing {
  animation: slideOut 0.3s ease-in forwards;
}

/* Loading spinner for generate button */
.generate-btn.loading {
  background: #666;
  color: #fff;
  cursor: wait;
}

.generate-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Water fix tool styles */
.water-fix-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid rgba(59, 130, 246, 0.3);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #60a5fa;
  margin-top: 8px;
}

.water-fix-label {
  color: #93c5fd;
  font-weight: 500;
}

.color-swatch {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  border: 2px solid #fff;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3), inset 0 0 0 1px rgba(0, 0, 0, 0.1);
  background: #333;
}

.color-swatch.has-color {
  cursor: pointer;
}

.color-hex {
  font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
  font-size: 0.75rem;
  color: #93c5fd;
  min-width: 180px;
}

.water-fix-quadrant {
  color: #60a5fa;
  font-size: 0.7rem;
}

.apply-water-fix-btn {
  padding: 4px 12px;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
  margin-left: auto;
}

.apply-water-fix-btn:hover:not(:disabled) {
  background: #2563eb;
}

.apply-water-fix-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.apply-water-fix-btn.loading {
  background: #666;
  cursor: wait;
}

.cancel-water-fix-btn {
  padding: 4px 8px;
  background: #4b5563;
  color: #d1d5db;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  transition: all 0.2s;
}

.cancel-water-fix-btn:hover {
  background: #6b7280;
}

/* Fix water tool active state */
.tile.fix-water-selectable {
  cursor: crosshair;
}

.tile.fix-water-selectable:hover {
  outline: 2px solid #3b82f6;
  outline-offset: -2px;
}

.tile.water-fix-selected {
  outline: 3px solid #3b82f6;
  outline-offset: -3px;
  z-index: 10;
}

/* Water fill tool styles */
.water-fill-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(74, 99, 114, 0.15);
  border: 1px solid rgba(74, 99, 114, 0.4);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #7ba3b8;
  margin-top: 8px;
}

.water-fill-label {
  color: #93c5fd;
  font-weight: 500;
}

.water-color-preview {
  background: #4a6372 !important;
}

.water-fill-instruction {
  color: #7ba3b8;
}

.tile.water-fill-selectable {
  cursor: pointer;
}

.tile.water-fill-selectable:hover {
  outline: 2px solid #4a6372;
  outline-offset: -2px;
}

/* Model selector styles */
.model-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.model-label {
  display: flex;
  align-items: center;
  gap: 6px;
  color: #888;
  font-size: 0.75rem;
}

.model-select {
  padding: 4px 8px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #16213e;
  color: #fff;
  font-family: inherit;
  font-size: 0.75rem;
  cursor: pointer;
  min-width: 140px;
}

.model-select:hover {
  border-color: #00d9ff;
}

.model-select:focus {
  outline: none;
  border-color: #00d9ff;
  box-shadow: 0 0 0 2px rgba(0, 217, 255, 0.2);
}

.model-select option {
  background: #16213e;
  color: #fff;
  padding: 4px;
}

/* Generate with Prompt button */
.generate-prompt-btn {
  background: linear-gradient(135deg, #9b59b6, #8e44ad);
  color: #fff;
  border: none;
  padding: 6px 12px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.generate-prompt-btn:hover:not(:disabled) {
  background: linear-gradient(135deg, #a569c0, #9b59b6);
  transform: translateY(-1px);
}

.generate-prompt-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Prompt Dialog */
.dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.dialog-content {
  background: #1a1a2e;
  border: 1px solid #333;
  border-radius: 8px;
  padding: 24px;
  min-width: 400px;
  max-width: 500px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
}

.dialog-content h3 {
  margin: 0 0 12px 0;
  color: #fff;
  font-size: 18px;
}

.dialog-description {
  color: #aaa;
  font-size: 14px;
  margin: 0 0 16px 0;
}

.prompt-input {
  width: 100%;
  background: #0f0f1a;
  border: 1px solid #333;
  border-radius: 4px;
  color: #fff;
  font-size: 14px;
  padding: 12px;
  resize: vertical;
  font-family: inherit;
  box-sizing: border-box;
}

.prompt-input:focus {
  outline: none;
  border-color: #9b59b6;
  box-shadow: 0 0 0 2px rgba(155, 89, 182, 0.2);
}

.prompt-input::placeholder {
  color: #666;
}

.dialog-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 20px;
}

.dialog-cancel-btn {
  background: #333;
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

.dialog-cancel-btn:hover {
  background: #444;
}

.dialog-submit-btn {
  background: linear-gradient(135deg, #9b59b6, #8e44ad);
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.dialog-submit-btn:hover {
  background: linear-gradient(135deg, #a569c0, #9b59b6);
}

/* Queue Overlays - show pending generations as grouped rectangles */
.queue-overlay {
  position: absolute;
  border: 3px dashed #c084fc;
  border-radius: 4px;
  pointer-events: auto;
  z-index: 20;
  animation: pulse-queue-overlay 1.5s ease-in-out infinite;
  box-sizing: border-box;
}

@keyframes pulse-queue-overlay {
  0%,
  100% {
    border-color: #c084fc;
    box-shadow: 0 0 12px rgba(192, 132, 252, 0.3);
  }
  50% {
    border-color: #8b5cf6;
    box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
  }
}

.queue-overlay:hover {
  border-color: #a855f7;
  box-shadow: 0 0 16px rgba(168, 85, 247, 0.6);
}

/* Queue position badge */
.queue-badge {
  position: absolute;
  top: 6px;
  left: 6px;
  min-width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #8b5cf6, #a855f7);
  color: white;
  font-size: 12px;
  font-weight: bold;
  font-family: "SF Mono", "Monaco", monospace;
  border-radius: 6px;
  padding: 0 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  z-index: 1;
}

/* Model label below badge */
.queue-model-label {
  position: absolute;
  top: 34px;
  left: 6px;
  font-size: 9px;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.9);
  background: rgba(139, 92, 246, 0.8);
  padding: 2px 6px;
  border-radius: 3px;
  max-width: calc(100% - 40px);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
}

/* Cancel button - visible on hover */
.queue-cancel-btn {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(220, 38, 38, 0.9);
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  opacity: 0;
  transform: scale(0.8);
  transition: all 0.15s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.queue-overlay:hover .queue-cancel-btn {
  opacity: 1;
  transform: scale(1);
}

.queue-cancel-btn:hover {
  background: #dc2626;
  transform: scale(1.1);
}

.queue-cancel-btn svg {
  width: 14px;
  height: 14px;
}

/* Make grid position relative for overlay positioning */
.grid {
  position: relative;
}

```

Done! I've implemented the queue overlay feature. Here's what was added:

**Backend (`queue_db.py`):**
- Added `cancel_queue_item_by_id(conn, item_id)` function to cancel a specific queue item

**Backend (`app.py`):**
- Added `/api/queue/cancel/<item_id>` POST endpoint that cancels a specific item and returns success/failure

**Frontend (`viewer.js`):**
- Added `updateQueueOverlays()` function that creates overlay elements for each pending generation:
  - Calculates the bounding box of all quadrants in the generation
  - Creates a positioned overlay element that spans the entire group
  - Shows a **position badge** (1, 2, 3...) in the upper left corner
  - Shows the **model name** below the badge
  - Shows a **cancel (trash) button** that appears on hover
- Added `cancelQueueItem(itemId)` function to call the cancel API

**Styles (`viewer.css`):**
- **Overlay**: Dashed purple border with pulse animation matching the existing queue style
- **Badge**: Gradient purple pill showing the queue position number
- **Model label**: Small label below the badge showing which model will be used
- **Cancel button**: Red trash icon that fades in and scales up on hover, positioned in the upper right

The overlays properly handle different generation sizes (1x1, 1x2, 2x1, 2x2) by calculating the bounding box of all quadrants in each queue item.

---

**User**

Esnure that the generation in progress has a little icon in the top left that indicates it's working

---

**Cursor**

I'll add a "working" indicator overlay for generations currently in progress. Let me update the code:

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// LocalStorage keys for persistence
const STORAGE_KEY_MODEL = "viewer_selected_model";
const STORAGE_KEY_TOOL = "viewer_selected_tool";
const STORAGE_KEY_SELECTION = "viewer_selected_quadrants";

// Save selected model ID to localStorage
function saveSelectedModel(modelId) {
  try {
    localStorage.setItem(STORAGE_KEY_MODEL, modelId);
  } catch (e) {
    console.warn("Could not save model to localStorage:", e);
  }
}

// Get saved model ID from localStorage
function getSavedModel() {
  try {
    return localStorage.getItem(STORAGE_KEY_MODEL);
  } catch (e) {
    return null;
  }
}

// Save selected tool to localStorage
function saveSelectedTool(toolName) {
  try {
    localStorage.setItem(STORAGE_KEY_TOOL, toolName || "");
  } catch (e) {
    console.warn("Could not save tool to localStorage:", e);
  }
}

// Get saved tool from localStorage
function getSavedTool() {
  try {
    return localStorage.getItem(STORAGE_KEY_TOOL) || "";
  } catch (e) {
    return "";
  }
}

// Save selected quadrants to localStorage
function saveSelectedQuadrants() {
  try {
    const quadrantsArray = Array.from(selectedQuadrants);
    localStorage.setItem(STORAGE_KEY_SELECTION, JSON.stringify(quadrantsArray));
  } catch (e) {
    console.warn("Could not save selection to localStorage:", e);
  }
}

// Get saved quadrants from localStorage
function getSavedQuadrants() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY_SELECTION);
    return saved ? JSON.parse(saved) : [];
  } catch (e) {
    return [];
  }
}

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Check if saved model ID exists in available models
  const savedModelId = getSavedModel();
  const savedModelExists =
    savedModelId && config.models.some((m) => m.model_id === savedModelId);

  // Add options for each model
  config.models.forEach((model, index) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;

    // Select saved model if it exists, otherwise use default or first
    if (savedModelExists && model.model_id === savedModelId) {
      option.selected = true;
    } else if (
      !savedModelExists &&
      model.model_id === config.default_model_id
    ) {
      option.selected = true;
    } else if (!savedModelExists && !config.default_model_id && index === 0) {
      option.selected = true;
    }
    select.appendChild(option);
  });

  // Auto-blur after selection and save to localStorage
  select.addEventListener("change", () => {
    saveSelectedModel(select.value);
    select.blur();
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to ALL currently processing quadrants (from all models)
  const processingQuadrants =
    status.all_processing_quadrants || status.quadrants || [];
  const isProcessing = status.is_generating || status.active_model_count > 0;

  if (isProcessing && processingQuadrants.length > 0) {
    document.body.classList.add("generating");
    processingQuadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else if (!isProcessing) {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items AND create overlays
  // Also create overlays for processing items
  const processingItems = getProcessingItems(status);
  updateQueueOverlays(status.queue || [], processingItems);
}

// Extract currently processing items from status
function getProcessingItems(status) {
  const processingItems = [];
  if (status.queue_by_model) {
    Object.entries(status.queue_by_model).forEach(([modelId, info]) => {
      if (info.is_processing && info.current_item) {
        processingItems.push({
          ...info.current_item,
          model_id: modelId,
          _isProcessing: true,
        });
      }
    });
  }
  return processingItems;
}

// Create/update overlays for pending queue items and processing items
function updateQueueOverlays(queueItems, processingItems = []) {
  // Remove existing overlays
  document.querySelectorAll(".queue-overlay").forEach((el) => el.remove());

  // Also clear queued class from all tiles
  document.querySelectorAll(".tile.queued").forEach((tile) => {
    tile.classList.remove("queued");
  });

  const hasItems =
    (queueItems && queueItems.length > 0) ||
    (processingItems && processingItems.length > 0);
  if (!hasItems) return;

  const grid = document.querySelector(".grid");
  if (!grid) return;

  // Get grid dimensions from config
  const gridX = config.x;
  const gridY = config.y;
  const sizePx = config.size_px;
  const showLines = document.getElementById("showLines")?.checked || false;
  const gap = showLines ? 2 : 0;

  queueItems.forEach((item, index) => {
    if (!item.quadrants || item.quadrants.length === 0) return;

    // Calculate bounding box for this generation
    const quadrants = item.quadrants;
    let minCol = Infinity,
      maxCol = -Infinity;
    let minRow = Infinity,
      maxRow = -Infinity;

    // Track which tiles are visible in the current view
    const visibleQuadrants = [];

    quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        // This quadrant is visible in current view
        visibleQuadrants.push([qx, qy]);

        // Calculate column and row relative to grid origin
        const col = qx - gridX;
        const row = qy - gridY;

        minCol = Math.min(minCol, col);
        maxCol = Math.max(maxCol, col);
        minRow = Math.min(minRow, row);
        maxRow = Math.max(maxRow, row);

        // Also add queued class to tile
        if (!tile.classList.contains("locked")) {
          tile.classList.add("queued");
        }
      }
    });

    // Skip if no visible quadrants
    if (visibleQuadrants.length === 0) return;

    // Create overlay element
    const overlay = document.createElement("div");
    overlay.className = "queue-overlay";
    overlay.dataset.itemId = item.id;

    // Calculate position and size
    const left = minCol * (sizePx + gap);
    const top = minRow * (sizePx + gap);
    const width = (maxCol - minCol + 1) * sizePx + (maxCol - minCol) * gap;
    const height = (maxRow - minRow + 1) * sizePx + (maxRow - minRow) * gap;

    overlay.style.left = `${left}px`;
    overlay.style.top = `${top}px`;
    overlay.style.width = `${width}px`;
    overlay.style.height = `${height}px`;

    // Queue position badge (1-indexed for display)
    const badge = document.createElement("div");
    badge.className = "queue-badge";
    badge.textContent = index + 1;
    overlay.appendChild(badge);

    // Model name label (smaller, below badge)
    if (item.model_id) {
      const modelLabel = document.createElement("div");
      modelLabel.className = "queue-model-label";
      modelLabel.textContent =
        getModelDisplayName(item.model_id) || item.model_id;
      overlay.appendChild(modelLabel);
    }

    // Cancel button (visible on hover)
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "queue-cancel-btn";
    cancelBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
      <line x1="10" y1="11" x2="10" y2="17"/>
      <line x1="14" y1="11" x2="14" y2="17"/>
    </svg>`;
    cancelBtn.title = "Cancel this generation";
    cancelBtn.onclick = (e) => {
      e.stopPropagation();
      cancelQueueItem(item.id);
    };
    overlay.appendChild(cancelBtn);

    grid.appendChild(overlay);
  });
}

// Cancel a specific queue item
async function cancelQueueItem(itemId) {
  try {
    const response = await fetch(`/api/queue/cancel/${itemId}`, {
      method: "POST",
    });
    const result = await response.json();

    if (result.success && result.cancelled) {
      showToast("success", "Cancelled", result.message);
      // Trigger immediate status update
      checkGenerationStatus();
    } else if (result.success && !result.cancelled) {
      showToast("info", "Not found", result.message);
    } else {
      showToast("error", "Error", result.error || "Failed to cancel");
    }
  } catch (error) {
    console.error("Cancel queue item failed:", error);
    showToast("error", "Error", "Failed to cancel queue item");
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  // Ignore keyboard shortcuts when prompt dialog is open
  const promptDialog = document.getElementById("promptDialog");
  if (promptDialog && promptDialog.style.display !== "none") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate other tools if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
    saveSelectedTool("select");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
    saveSelectedTool("");
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate other tools if active
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
    saveSelectedTool("fixwater");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
    saveSelectedTool("waterfill");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    // Show all active models generating
    const activeModels = serverStatus.active_models || [];
    const processingQuadrants =
      serverStatus.all_processing_quadrants || serverStatus.quadrants || [];

    if (activeModels.length > 0 && processingQuadrants.length > 0) {
      // Show which models are actively generating
      const modelNames = activeModels.map(
        (modelId) => getModelDisplayName(modelId) || modelId || "default"
      );

      if (activeModels.length === 1) {
        const coordsStr = processingQuadrants
          .map(([x, y]) => `(${x},${y})`)
          .join(" ");
        statusParts.push(`üîÑ ${modelNames[0]}: ${coordsStr}`);
      } else {
        // Multiple models generating in parallel
        statusParts.push(`üîÑ Generating: ${modelNames.join(", ")}`);
      }
    } else if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      // Fallback to old behavior
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
      statusParts.push(`${action} ${coordsStr}`);
    }

    // Show per-model queue counts
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      if (modelQueues.length > 0) {
        const queueParts = modelQueues.map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return `${name}: ${count}`;
        });
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    } else if (serverStatus.queue_length > 0) {
      // Fallback for backwards compatibility
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Update selection display in toolbar-info (separate from status)
  const selectedDisplay = document.getElementById("selectedQuadrantsDisplay");
  if (selectedDisplay) {
    if (count > 0) {
      const coordsStr = Array.from(selectedQuadrants)
        .map((key) => {
          const [x, y] = key.split(",");
          return `(${x},${y})`;
        })
        .join(" ");
      selectedDisplay.textContent = `‚úì ${coordsStr}`;
      selectedDisplay.style.display = "";
    } else {
      selectedDisplay.textContent = "";
      selectedDisplay.style.display = "none";
    }
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = `${count} selected`;
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate with prompt button
  const generateWithPromptBtn = document.getElementById(
    "generateWithPromptBtn"
  );
  if (generateWithPromptBtn) {
    generateWithPromptBtn.disabled = count === 0;
  }
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

// Prompt dialog functions
function showPromptDialog() {
  if (selectedQuadrants.size === 0) return;
  const dialog = document.getElementById("promptDialog");
  const input = document.getElementById("promptInput");
  if (dialog && input) {
    input.value = "";
    dialog.style.display = "flex";
    input.focus();
  }
}

function hidePromptDialog() {
  const dialog = document.getElementById("promptDialog");
  if (dialog) {
    dialog.style.display = "none";
  }
}

async function submitPromptGeneration() {
  const input = document.getElementById("promptInput");
  const prompt = input ? input.value.trim() : "";
  hidePromptDialog();
  await generateSelected(prompt);
}

async function generateSelected(prompt = null) {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  const promptMsg = prompt ? " with prompt" : "";
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${promptMsg}${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    // Include prompt if provided
    if (prompt) {
      requestBody.prompt = prompt;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log(
        "Generation queued at position:",
        result.position,
        "model:",
        result.model_id
      );
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();

  // Show immediate feedback
  showToast(
    "info",
    "Adding to queue...",
    `Queueing ${coords.length} quadrant(s) for render`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();
  updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

  showToast(
    "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
        showToast(
          "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

        showToast(
          "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
      }
    } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  saveSelectedQuadrants();
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  saveSelectedQuadrants();
  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes - consider active_model_count for parallel processing
    const wasGenerating = isGenerating || isRendering;
    const hasActiveModels = (status.active_model_count || 0) > 0;
    isGenerating =
      (status.is_generating || hasActiveModels) &&
      status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
      clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
      if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = `${status.queue_length} more item(s) in queue...`;
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .filter(([, info]) => info.pending_count > 0)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              return `${name}: ${info.pending_count}`;
            });
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        showToast("info", "Processing queue", queueMsg);
      } else {
        // No more items, reload after delay
        stopStatusPolling();
        setTimeout(() => window.location.reload(), 1500);
      }
    } else if (status.status === "error" && status.error) {
      clearLoadingToasts();
      showToast("error", "Error", status.error);

      // Continue polling if there are more items in queue
      if (status.queue_length === 0) {
        stopStatusPolling();
      }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
      stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Restore saved tool on page load
function restoreSavedTool() {
  const savedTool = getSavedTool();
  if (!savedTool) return;

  // Check if the tool button exists before activating
  switch (savedTool) {
    case "select":
      if (document.getElementById("selectTool")) {
        toggleSelectTool();
      }
      break;
    case "fixwater":
      if (document.getElementById("fixWaterTool")) {
        toggleFixWaterTool();
      }
      break;
    case "waterfill":
      if (document.getElementById("waterFillTool")) {
        toggleWaterFillTool();
      }
      break;
    default:
      // Unknown tool, clear saved state
      saveSelectedTool("");
      break;
  }
}

// Restore saved quadrant selections on page load
function restoreSavedQuadrants() {
  const savedQuadrants = getSavedQuadrants();
  if (!savedQuadrants || savedQuadrants.length === 0) return;

  let restoredCount = 0;

  savedQuadrants.forEach((key) => {
    // Check if this quadrant tile exists on the current page
    const tile = document.querySelector(`.tile[data-coords="${key}"]`);
    if (tile) {
      // Don't restore if tile is locked or queued
      if (
        !tile.classList.contains("locked") &&
        !tile.classList.contains("queued")
      ) {
        selectedQuadrants.add(key);
        tile.classList.add("selected");
        restoredCount++;
      }
    }
  });

  if (restoredCount > 0) {
    console.log(`Restored ${restoredCount} selected quadrant(s)`);
    // Update localStorage to only contain valid selections
    saveSelectedQuadrants();
    updateSelectionStatus();
  } else if (savedQuadrants.length > 0) {
    // Had saved selections but none are on current page - clear storage
    saveSelectedQuadrants();
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  // Restore saved tool
  restoreSavedTool();

  // Restore saved quadrant selections
  restoreSavedQuadrants();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// LocalStorage keys for persistence
const STORAGE_KEY_MODEL = "viewer_selected_model";
const STORAGE_KEY_TOOL = "viewer_selected_tool";
const STORAGE_KEY_SELECTION = "viewer_selected_quadrants";

// Save selected model ID to localStorage
function saveSelectedModel(modelId) {
  try {
    localStorage.setItem(STORAGE_KEY_MODEL, modelId);
  } catch (e) {
    console.warn("Could not save model to localStorage:", e);
  }
}

// Get saved model ID from localStorage
function getSavedModel() {
  try {
    return localStorage.getItem(STORAGE_KEY_MODEL);
  } catch (e) {
    return null;
  }
}

// Save selected tool to localStorage
function saveSelectedTool(toolName) {
  try {
    localStorage.setItem(STORAGE_KEY_TOOL, toolName || "");
  } catch (e) {
    console.warn("Could not save tool to localStorage:", e);
  }
}

// Get saved tool from localStorage
function getSavedTool() {
  try {
    return localStorage.getItem(STORAGE_KEY_TOOL) || "";
  } catch (e) {
    return "";
  }
}

// Save selected quadrants to localStorage
function saveSelectedQuadrants() {
  try {
    const quadrantsArray = Array.from(selectedQuadrants);
    localStorage.setItem(STORAGE_KEY_SELECTION, JSON.stringify(quadrantsArray));
  } catch (e) {
    console.warn("Could not save selection to localStorage:", e);
  }
}

// Get saved quadrants from localStorage
function getSavedQuadrants() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY_SELECTION);
    return saved ? JSON.parse(saved) : [];
  } catch (e) {
    return [];
  }
}

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Check if saved model ID exists in available models
  const savedModelId = getSavedModel();
  const savedModelExists =
    savedModelId && config.models.some((m) => m.model_id === savedModelId);

  // Add options for each model
  config.models.forEach((model, index) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;

    // Select saved model if it exists, otherwise use default or first
    if (savedModelExists && model.model_id === savedModelId) {
      option.selected = true;
    } else if (
      !savedModelExists &&
      model.model_id === config.default_model_id
    ) {
      option.selected = true;
    } else if (!savedModelExists && !config.default_model_id && index === 0) {
      option.selected = true;
    }
    select.appendChild(option);
  });

  // Auto-blur after selection and save to localStorage
  select.addEventListener("change", () => {
    saveSelectedModel(select.value);
    select.blur();
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to ALL currently processing quadrants (from all models)
  const processingQuadrants =
    status.all_processing_quadrants || status.quadrants || [];
  const isProcessing = status.is_generating || status.active_model_count > 0;

  if (isProcessing && processingQuadrants.length > 0) {
    document.body.classList.add("generating");
    processingQuadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else if (!isProcessing) {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items AND create overlays
  // Also create overlays for processing items
  const processingItems = getProcessingItems(status);
  updateQueueOverlays(status.queue || [], processingItems);
}

// Extract currently processing items from status
function getProcessingItems(status) {
  const processingItems = [];
  if (status.queue_by_model) {
    Object.entries(status.queue_by_model).forEach(([modelId, info]) => {
      if (info.is_processing && info.current_item) {
        processingItems.push({
          ...info.current_item,
          model_id: modelId,
          _isProcessing: true,
        });
      }
    });
  }
  return processingItems;
}

// Create/update overlays for pending queue items and processing items
function updateQueueOverlays(queueItems, processingItems = []) {
  // Remove existing overlays
  document.querySelectorAll(".queue-overlay").forEach((el) => el.remove());

  // Also clear queued class from all tiles
  document.querySelectorAll(".tile.queued").forEach((tile) => {
      tile.classList.remove("queued");
  });

  const hasItems =
    (queueItems && queueItems.length > 0) ||
    (processingItems && processingItems.length > 0);
  if (!hasItems) return;

  const grid = document.querySelector(".grid");
  if (!grid) return;

  // Get grid dimensions from config
  const gridX = config.x;
  const gridY = config.y;
  const sizePx = config.size_px;
  const showLines = document.getElementById("showLines")?.checked || false;
  const gap = showLines ? 2 : 0;

  // Helper function to create an overlay for an item
  function createOverlay(item, options = {}) {
    const { isProcessing = false, queuePosition = null } = options;

    if (!item.quadrants || item.quadrants.length === 0) return null;

    // Calculate bounding box for this generation
    const quadrants = item.quadrants;
    let minCol = Infinity,
      maxCol = -Infinity;
    let minRow = Infinity,
      maxRow = -Infinity;

    // Track which tiles are visible in the current view
    const visibleQuadrants = [];

    quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        visibleQuadrants.push([qx, qy]);
        const col = qx - gridX;
        const row = qy - gridY;
        minCol = Math.min(minCol, col);
        maxCol = Math.max(maxCol, col);
        minRow = Math.min(minRow, row);
        maxRow = Math.max(maxRow, row);

        // Add appropriate class to tile
        if (isProcessing) {
          tile.classList.add("locked");
        } else if (!tile.classList.contains("locked")) {
          tile.classList.add("queued");
        }
      }
    });

    if (visibleQuadrants.length === 0) return null;

    // Create overlay element
    const overlay = document.createElement("div");
    overlay.className = isProcessing
      ? "queue-overlay processing"
      : "queue-overlay";
    overlay.dataset.itemId = item.id;

    // Calculate position and size
    const left = minCol * (sizePx + gap);
    const top = minRow * (sizePx + gap);
    const width = (maxCol - minCol + 1) * sizePx + (maxCol - minCol) * gap;
    const height = (maxRow - minRow + 1) * sizePx + (maxRow - minRow) * gap;

    overlay.style.left = `${left}px`;
    overlay.style.top = `${top}px`;
    overlay.style.width = `${width}px`;
    overlay.style.height = `${height}px`;

    // Badge: spinner for processing, number for queued
    const badge = document.createElement("div");
    badge.className = isProcessing ? "queue-badge processing" : "queue-badge";
    if (isProcessing) {
      badge.innerHTML = `<svg class="processing-spinner" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
        <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
      </svg>`;
    } else {
      badge.textContent = queuePosition;
    }
    overlay.appendChild(badge);

    // Model name label
    if (item.model_id) {
      const modelLabel = document.createElement("div");
      modelLabel.className = "queue-model-label";
      modelLabel.textContent =
        getModelDisplayName(item.model_id) || item.model_id;
      overlay.appendChild(modelLabel);
    }

    // Cancel button (visible on hover) - for both processing and queued
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "queue-cancel-btn";
    cancelBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
      <line x1="10" y1="11" x2="10" y2="17"/>
      <line x1="14" y1="11" x2="14" y2="17"/>
    </svg>`;
    cancelBtn.title = "Cancel this generation";
    cancelBtn.onclick = (e) => {
      e.stopPropagation();
      cancelQueueItem(item.id);
    };
    overlay.appendChild(cancelBtn);

    grid.appendChild(overlay);
  });
}

// Cancel a specific queue item
async function cancelQueueItem(itemId) {
  try {
    const response = await fetch(`/api/queue/cancel/${itemId}`, {
      method: "POST",
    });
    const result = await response.json();

    if (result.success && result.cancelled) {
      showToast("success", "Cancelled", result.message);
      // Trigger immediate status update
      checkGenerationStatus();
    } else if (result.success && !result.cancelled) {
      showToast("info", "Not found", result.message);
    } else {
      showToast("error", "Error", result.error || "Failed to cancel");
    }
  } catch (error) {
    console.error("Cancel queue item failed:", error);
    showToast("error", "Error", "Failed to cancel queue item");
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  // Ignore keyboard shortcuts when prompt dialog is open
  const promptDialog = document.getElementById("promptDialog");
  if (promptDialog && promptDialog.style.display !== "none") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate other tools if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
    saveSelectedTool("select");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
    saveSelectedTool("");
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate other tools if active
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
    saveSelectedTool("fixwater");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
    saveSelectedTool("waterfill");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    // Show all active models generating
    const activeModels = serverStatus.active_models || [];
    const processingQuadrants =
      serverStatus.all_processing_quadrants || serverStatus.quadrants || [];

    if (activeModels.length > 0 && processingQuadrants.length > 0) {
      // Show which models are actively generating
      const modelNames = activeModels.map(
        (modelId) => getModelDisplayName(modelId) || modelId || "default"
      );

      if (activeModels.length === 1) {
        const coordsStr = processingQuadrants
          .map(([x, y]) => `(${x},${y})`)
          .join(" ");
        statusParts.push(`üîÑ ${modelNames[0]}: ${coordsStr}`);
      } else {
        // Multiple models generating in parallel
        statusParts.push(`üîÑ Generating: ${modelNames.join(", ")}`);
      }
    } else if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      // Fallback to old behavior
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
    statusParts.push(`${action} ${coordsStr}`);
  }

    // Show per-model queue counts
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      if (modelQueues.length > 0) {
        const queueParts = modelQueues.map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return `${name}: ${count}`;
        });
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    } else if (serverStatus.queue_length > 0) {
      // Fallback for backwards compatibility
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Update selection display in toolbar-info (separate from status)
  const selectedDisplay = document.getElementById("selectedQuadrantsDisplay");
  if (selectedDisplay) {
  if (count > 0) {
      const coordsStr = Array.from(selectedQuadrants)
        .map((key) => {
          const [x, y] = key.split(",");
          return `(${x},${y})`;
        })
        .join(" ");
      selectedDisplay.textContent = `‚úì ${coordsStr}`;
      selectedDisplay.style.display = "";
    } else {
      selectedDisplay.textContent = "";
      selectedDisplay.style.display = "none";
    }
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = `${count} selected`;
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate with prompt button
  const generateWithPromptBtn = document.getElementById(
    "generateWithPromptBtn"
  );
  if (generateWithPromptBtn) {
    generateWithPromptBtn.disabled = count === 0;
  }
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

// Prompt dialog functions
function showPromptDialog() {
  if (selectedQuadrants.size === 0) return;
  const dialog = document.getElementById("promptDialog");
  const input = document.getElementById("promptInput");
  if (dialog && input) {
    input.value = "";
    dialog.style.display = "flex";
    input.focus();
  }
}

function hidePromptDialog() {
  const dialog = document.getElementById("promptDialog");
  if (dialog) {
    dialog.style.display = "none";
  }
}

async function submitPromptGeneration() {
  const input = document.getElementById("promptInput");
  const prompt = input ? input.value.trim() : "";
  hidePromptDialog();
  await generateSelected(prompt);
}

async function generateSelected(prompt = null) {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  const promptMsg = prompt ? " with prompt" : "";
    showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${promptMsg}${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    // Include prompt if provided
    if (prompt) {
      requestBody.prompt = prompt;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log(
        "Generation queued at position:",
        result.position,
        "model:",
        result.model_id
      );
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();

    // Show immediate feedback
    showToast(
      "info",
      "Adding to queue...",
      `Queueing ${coords.length} quadrant(s) for render`
    );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();
    updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

    showToast(
      "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
      showToast(
        "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

      showToast(
        "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
        }
      } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  saveSelectedQuadrants();
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  saveSelectedQuadrants();
  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes - consider active_model_count for parallel processing
    const wasGenerating = isGenerating || isRendering;
    const hasActiveModels = (status.active_model_count || 0) > 0;
    isGenerating =
      (status.is_generating || hasActiveModels) &&
      status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
        clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
        if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = `${status.queue_length} more item(s) in queue...`;
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .filter(([, info]) => info.pending_count > 0)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              return `${name}: ${info.pending_count}`;
            });
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        showToast("info", "Processing queue", queueMsg);
        } else {
        // No more items, reload after delay
          stopStatusPolling();
          setTimeout(() => window.location.reload(), 1500);
        }
      } else if (status.status === "error" && status.error) {
        clearLoadingToasts();
      showToast("error", "Error", status.error);

        // Continue polling if there are more items in queue
        if (status.queue_length === 0) {
          stopStatusPolling();
        }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
        stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Restore saved tool on page load
function restoreSavedTool() {
  const savedTool = getSavedTool();
  if (!savedTool) return;

  // Check if the tool button exists before activating
  switch (savedTool) {
    case "select":
      if (document.getElementById("selectTool")) {
        toggleSelectTool();
      }
      break;
    case "fixwater":
      if (document.getElementById("fixWaterTool")) {
        toggleFixWaterTool();
      }
      break;
    case "waterfill":
      if (document.getElementById("waterFillTool")) {
        toggleWaterFillTool();
      }
      break;
    default:
      // Unknown tool, clear saved state
      saveSelectedTool("");
      break;
  }
}

// Restore saved quadrant selections on page load
function restoreSavedQuadrants() {
  const savedQuadrants = getSavedQuadrants();
  if (!savedQuadrants || savedQuadrants.length === 0) return;

  let restoredCount = 0;

  savedQuadrants.forEach((key) => {
    // Check if this quadrant tile exists on the current page
    const tile = document.querySelector(`.tile[data-coords="${key}"]`);
    if (tile) {
      // Don't restore if tile is locked or queued
      if (
        !tile.classList.contains("locked") &&
        !tile.classList.contains("queued")
      ) {
        selectedQuadrants.add(key);
        tile.classList.add("selected");
        restoredCount++;
      }
    }
  });

  if (restoredCount > 0) {
    console.log(`Restored ${restoredCount} selected quadrant(s)`);
    // Update localStorage to only contain valid selections
    saveSelectedQuadrants();
  updateSelectionStatus();
  } else if (savedQuadrants.length > 0) {
    // Had saved selections but none are on current page - clear storage
    saveSelectedQuadrants();
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  // Restore saved tool
  restoreSavedTool();

  // Restore saved quadrant selections
  restoreSavedQuadrants();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```javascript
// Get config from data attributes
const config = JSON.parse(document.getElementById("app-config").dataset.config);

// LocalStorage keys for persistence
const STORAGE_KEY_MODEL = "viewer_selected_model";
const STORAGE_KEY_TOOL = "viewer_selected_tool";
const STORAGE_KEY_SELECTION = "viewer_selected_quadrants";

// Save selected model ID to localStorage
function saveSelectedModel(modelId) {
  try {
    localStorage.setItem(STORAGE_KEY_MODEL, modelId);
  } catch (e) {
    console.warn("Could not save model to localStorage:", e);
  }
}

// Get saved model ID from localStorage
function getSavedModel() {
  try {
    return localStorage.getItem(STORAGE_KEY_MODEL);
  } catch (e) {
    return null;
  }
}

// Save selected tool to localStorage
function saveSelectedTool(toolName) {
  try {
    localStorage.setItem(STORAGE_KEY_TOOL, toolName || "");
  } catch (e) {
    console.warn("Could not save tool to localStorage:", e);
  }
}

// Get saved tool from localStorage
function getSavedTool() {
  try {
    return localStorage.getItem(STORAGE_KEY_TOOL) || "";
  } catch (e) {
    return "";
  }
}

// Save selected quadrants to localStorage
function saveSelectedQuadrants() {
  try {
    const quadrantsArray = Array.from(selectedQuadrants);
    localStorage.setItem(STORAGE_KEY_SELECTION, JSON.stringify(quadrantsArray));
  } catch (e) {
    console.warn("Could not save selection to localStorage:", e);
  }
}

// Get saved quadrants from localStorage
function getSavedQuadrants() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY_SELECTION);
    return saved ? JSON.parse(saved) : [];
  } catch (e) {
    return [];
  }
}

// Initialize model selector
function initModelSelector() {
  const select = document.getElementById("modelSelect");
  if (!select || !config.models || config.models.length === 0) {
    return;
  }

  // Clear existing options
  select.innerHTML = "";

  // Check if saved model ID exists in available models
  const savedModelId = getSavedModel();
  const savedModelExists =
    savedModelId && config.models.some((m) => m.model_id === savedModelId);

  // Add options for each model
  config.models.forEach((model, index) => {
    const option = document.createElement("option");
    option.value = model.model_id;
    option.textContent = model.name;

    // Select saved model if it exists, otherwise use default or first
    if (savedModelExists && model.model_id === savedModelId) {
      option.selected = true;
    } else if (
      !savedModelExists &&
      model.model_id === config.default_model_id
    ) {
      option.selected = true;
    } else if (!savedModelExists && !config.default_model_id && index === 0) {
      option.selected = true;
    }
    select.appendChild(option);
  });

  // Auto-blur after selection and save to localStorage
  select.addEventListener("change", () => {
    saveSelectedModel(select.value);
    select.blur();
  });
}

// Get the currently selected model ID
function getSelectedModelId() {
  const select = document.getElementById("modelSelect");
  return select ? select.value : null;
}

// Get display name for a model ID
function getModelDisplayName(modelId) {
  if (!modelId) return null;
  const configEl = document.getElementById("app-config");
  if (!configEl) return modelId;
  try {
    const config = JSON.parse(configEl.dataset.config);
    const models = config.models || [];
    const model = models.find((m) => m.model_id === modelId);
    return model ? model.name : modelId;
  } catch {
    return modelId;
  }
}

// Apply locked/queued styles based on server status
function applyStatusStyles(status) {
  // Clear all existing locked/queued styles first
  document.querySelectorAll(".tile.locked, .tile.queued").forEach((tile) => {
    tile.classList.remove("locked", "queued");
  });

  // Apply locked style to ALL currently processing quadrants (from all models)
  const processingQuadrants =
    status.all_processing_quadrants || status.quadrants || [];
  const isProcessing = status.is_generating || status.active_model_count > 0;

  if (isProcessing && processingQuadrants.length > 0) {
    document.body.classList.add("generating");
    processingQuadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        tile.classList.add("locked");
      }
    });
  } else if (!isProcessing) {
    document.body.classList.remove("generating");
  }

  // Apply queued style to pending queue items AND create overlays
  // Also create overlays for processing items
  const processingItems = getProcessingItems(status);
  updateQueueOverlays(status.queue || [], processingItems);
}

// Extract currently processing items from status
function getProcessingItems(status) {
  const processingItems = [];
  if (status.queue_by_model) {
    Object.entries(status.queue_by_model).forEach(([modelId, info]) => {
      if (info.is_processing && info.current_item) {
        processingItems.push({
          ...info.current_item,
          model_id: modelId,
          _isProcessing: true,
        });
      }
    });
  }
  return processingItems;
}

// Create/update overlays for pending queue items and processing items
function updateQueueOverlays(queueItems, processingItems = []) {
  // Remove existing overlays
  document.querySelectorAll(".queue-overlay").forEach((el) => el.remove());

  // Also clear queued class from all tiles
  document.querySelectorAll(".tile.queued").forEach((tile) => {
      tile.classList.remove("queued");
  });

  const hasItems =
    (queueItems && queueItems.length > 0) ||
    (processingItems && processingItems.length > 0);
  if (!hasItems) return;

  const grid = document.querySelector(".grid");
  if (!grid) return;

  // Get grid dimensions from config
  const gridX = config.x;
  const gridY = config.y;
  const sizePx = config.size_px;
  const showLines = document.getElementById("showLines")?.checked || false;
  const gap = showLines ? 2 : 0;

  // Helper function to create an overlay for an item
  function createOverlay(item, options = {}) {
    const { isProcessing = false, queuePosition = null } = options;

    if (!item.quadrants || item.quadrants.length === 0) return null;

    // Calculate bounding box for this generation
    const quadrants = item.quadrants;
    let minCol = Infinity,
      maxCol = -Infinity;
    let minRow = Infinity,
      maxRow = -Infinity;

    // Track which tiles are visible in the current view
    const visibleQuadrants = [];

    quadrants.forEach(([qx, qy]) => {
      const tile = document.querySelector(`.tile[data-coords="${qx},${qy}"]`);
      if (tile) {
        visibleQuadrants.push([qx, qy]);
        const col = qx - gridX;
        const row = qy - gridY;
        minCol = Math.min(minCol, col);
        maxCol = Math.max(maxCol, col);
        minRow = Math.min(minRow, row);
        maxRow = Math.max(maxRow, row);

        // Add appropriate class to tile
        if (isProcessing) {
          tile.classList.add("locked");
        } else if (!tile.classList.contains("locked")) {
          tile.classList.add("queued");
        }
      }
    });

    if (visibleQuadrants.length === 0) return null;

    // Create overlay element
    const overlay = document.createElement("div");
    overlay.className = isProcessing
      ? "queue-overlay processing"
      : "queue-overlay";
    overlay.dataset.itemId = item.id;

    // Calculate position and size
    const left = minCol * (sizePx + gap);
    const top = minRow * (sizePx + gap);
    const width = (maxCol - minCol + 1) * sizePx + (maxCol - minCol) * gap;
    const height = (maxRow - minRow + 1) * sizePx + (maxRow - minRow) * gap;

    overlay.style.left = `${left}px`;
    overlay.style.top = `${top}px`;
    overlay.style.width = `${width}px`;
    overlay.style.height = `${height}px`;

    // Badge: spinner for processing, number for queued
    const badge = document.createElement("div");
    badge.className = isProcessing ? "queue-badge processing" : "queue-badge";
    if (isProcessing) {
      badge.innerHTML = `<svg class="processing-spinner" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
        <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/>
      </svg>`;
    } else {
      badge.textContent = queuePosition;
    }
    overlay.appendChild(badge);

    // Model name label
    if (item.model_id) {
      const modelLabel = document.createElement("div");
      modelLabel.className = "queue-model-label";
      modelLabel.textContent =
        getModelDisplayName(item.model_id) || item.model_id;
      overlay.appendChild(modelLabel);
    }

    // Cancel button (visible on hover) - for both processing and queued
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "queue-cancel-btn";
    cancelBtn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
      <line x1="10" y1="11" x2="10" y2="17"/>
      <line x1="14" y1="11" x2="14" y2="17"/>
    </svg>`;
    cancelBtn.title = isProcessing
      ? "Cancel this generation (in progress)"
      : "Cancel this generation";
    cancelBtn.onclick = (e) => {
      e.stopPropagation();
      cancelQueueItem(item.id);
    };
    overlay.appendChild(cancelBtn);

    return overlay;
  }

  // First, create overlays for processing items (with spinner)
  processingItems.forEach((item) => {
    const overlay = createOverlay(item, { isProcessing: true });
    if (overlay) {
      grid.appendChild(overlay);
    }
  });

  // Then, create overlays for queued items (with position numbers)
  queueItems.forEach((item, index) => {
    const overlay = createOverlay(item, { queuePosition: index + 1 });
    if (overlay) {
      grid.appendChild(overlay);
    }
  });
}

// Cancel a specific queue item
async function cancelQueueItem(itemId) {
  try {
    const response = await fetch(`/api/queue/cancel/${itemId}`, {
      method: "POST",
    });
    const result = await response.json();

    if (result.success && result.cancelled) {
      showToast("success", "Cancelled", result.message);
      // Trigger immediate status update
      checkGenerationStatus();
    } else if (result.success && !result.cancelled) {
      showToast("info", "Not found", result.message);
    } else {
      showToast("error", "Error", result.error || "Failed to cancel");
    }
  } catch (error) {
    console.error("Cancel queue item failed:", error);
    showToast("error", "Error", "Failed to cancel queue item");
  }
}

function getParams() {
  const x = document.getElementById("x").value;
  const y = document.getElementById("y").value;
  const nx = document.getElementById("nx").value;
  const ny = document.getElementById("ny").value;
  const sizePx = document.getElementById("sizePx").value;
  const showLines = document.getElementById("showLines").checked ? "1" : "0";
  const showCoords = document.getElementById("showCoords").checked ? "1" : "0";
  const showRender = document.getElementById("showRender").checked ? "1" : "0";
  return { x, y, nx, ny, sizePx, showLines, showCoords, showRender };
}

function goTo() {
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

function navigate(dx, dy) {
  const params = getParams();
  const x = parseInt(params.x) + dx;
  const y = parseInt(params.y) + dy;
  window.location.href = `?x=${x}&y=${y}&nx=${params.nx}&ny=${params.ny}&size=${params.sizePx}&lines=${params.showLines}&coords=${params.showCoords}&render=${params.showRender}`;
}

function toggleLines() {
  const container = document.getElementById("gridContainer");
  const showLines = document.getElementById("showLines").checked;
  container.classList.toggle("show-lines", showLines);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("lines", showLines ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleCoords() {
  const container = document.getElementById("gridContainer");
  const showCoords = document.getElementById("showCoords").checked;
  container.classList.toggle("show-coords", showCoords);

  // Update URL without reload
  const url = new URL(window.location);
  url.searchParams.set("coords", showCoords ? "1" : "0");
  history.replaceState({}, "", url);
}

function toggleRender() {
  // This requires a page reload to fetch different data
  const { x, y, nx, ny, sizePx, showLines, showCoords, showRender } =
    getParams();
  window.location.href = `?x=${x}&y=${y}&nx=${nx}&ny=${ny}&size=${sizePx}&lines=${showLines}&coords=${showCoords}&render=${showRender}`;
}

// Keyboard navigation
document.addEventListener("keydown", (e) => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT") return;

  // Ignore keyboard shortcuts when prompt dialog is open
  const promptDialog = document.getElementById("promptDialog");
  if (promptDialog && promptDialog.style.display !== "none") return;

  switch (e.key) {
    case "ArrowLeft":
      navigate(-1, 0);
      break;
    case "ArrowRight":
      navigate(1, 0);
      break;
    case "ArrowUp":
      navigate(0, -1);
      break;
    case "ArrowDown":
      navigate(0, 1);
      break;
    case "l":
    case "L":
      document.getElementById("showLines").click();
      break;
    case "c":
    case "C":
      document.getElementById("showCoords").click();
      break;
    case "d":
    case "D":
      document.getElementById("showRender").click();
      break;
    case "g":
    case "G":
      generateSelected();
      break;
    case "s":
    case "S":
      toggleSelectTool();
      break;
    case "w":
    case "W":
      toggleFixWaterTool();
      break;
    case "f":
    case "F":
      toggleWaterFillTool();
      break;
    case "Escape":
      if (selectToolActive) toggleSelectTool();
      if (fixWaterToolActive) cancelWaterFix();
      if (waterFillToolActive) cancelWaterFill();
      break;
  }
});

// Select tool state
let selectToolActive = false;
const selectedQuadrants = new Set();
const MAX_SELECTION = 4;

function toggleSelectTool() {
  // Deactivate other tools if active
  if (fixWaterToolActive) {
    cancelWaterFix();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }

  selectToolActive = !selectToolActive;
  const btn = document.getElementById("selectTool");
  const tiles = document.querySelectorAll(".tile");

  if (selectToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => tile.classList.add("selectable"));
    saveSelectedTool("select");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => tile.classList.remove("selectable"));
    saveSelectedTool("");
  }
}

// Fix water tool state
let fixWaterToolActive = false;
let fixWaterTargetColor = null;
let fixWaterQuadrant = null;

function toggleFixWaterTool() {
  // Deactivate other tools if active
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (waterFillToolActive) {
    cancelWaterFill();
  }

  fixWaterToolActive = !fixWaterToolActive;
  const btn = document.getElementById("fixWaterTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFixStatus = document.getElementById("waterFixStatus");

  if (fixWaterToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      // Only make tiles with images selectable
      if (tile.querySelector("img")) {
        tile.classList.add("fix-water-selectable");
      }
    });
    // Show water fix status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFixStatus.style.display = "flex";
    // Reset state
    resetWaterFixState();
    saveSelectedTool("fixwater");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("fix-water-selectable");
      tile.classList.remove("water-fix-selected");
    });
    // Hide water fix status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFixStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function resetWaterFixState() {
  fixWaterTargetColor = null;
  fixWaterQuadrant = null;
  document.getElementById("targetColorSwatch").style.background = "#333";
  document.getElementById("targetColorSwatch").classList.remove("has-color");
  document.getElementById("targetColorHex").textContent =
    "Click a quadrant to pick color";
  document.getElementById("waterFixQuadrant").textContent = "";
  // Reset button state
  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.remove("loading");
  btn.textContent = "Apply Fix";
  document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
    tile.classList.remove("water-fix-selected");
  });
}

function cancelWaterFix() {
  if (fixWaterToolActive) {
    toggleFixWaterTool();
  }
}

function rgbToHex(r, g, b) {
  return (
    "#" +
    [r, g, b]
      .map((x) => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      })
      .join("")
      .toUpperCase()
  );
}

function getPixelColorFromImage(img, x, y) {
  // Create an off-screen canvas
  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth;
  canvas.height = img.naturalHeight;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  // Get the pixel data at the clicked position
  const pixelData = ctx.getImageData(x, y, 1, 1).data;

  return {
    r: pixelData[0],
    g: pixelData[1],
    b: pixelData[2],
    a: pixelData[3],
  };
}

function handleFixWaterClick(tileEl, e) {
  if (!fixWaterToolActive) return;

  const img = tileEl.querySelector("img");
  if (!img) {
    showToast("error", "No image", "This quadrant has no generation to fix");
    return;
  }

  // Get coordinates
  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Calculate click position relative to the image
  const rect = img.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  // Scale to natural image dimensions
  const scaleX = img.naturalWidth / rect.width;
  const scaleY = img.naturalHeight / rect.height;
  const imgX = Math.floor(clickX * scaleX);
  const imgY = Math.floor(clickY * scaleY);

  // Ensure we're within bounds
  if (
    imgX < 0 ||
    imgX >= img.naturalWidth ||
    imgY < 0 ||
    imgY >= img.naturalHeight
  ) {
    console.log("Click outside image bounds");
    return;
  }

  try {
    // Get the pixel color
    const color = getPixelColorFromImage(img, imgX, imgY);
    const hex = rgbToHex(color.r, color.g, color.b);

    console.log(
      `Picked color at (${imgX}, ${imgY}) in quadrant (${qx}, ${qy}): RGB(${color.r}, ${color.g}, ${color.b}) = ${hex}`
    );

    // Update state
    fixWaterTargetColor = hex;
    fixWaterQuadrant = { x: qx, y: qy };

    // Update UI
    document.getElementById("targetColorSwatch").style.background = hex;
    document.getElementById("targetColorSwatch").classList.add("has-color");
    document.getElementById(
      "targetColorHex"
    ).textContent = `${hex} ‚Äî RGB(${color.r}, ${color.g}, ${color.b})`;
    document.getElementById(
      "waterFixQuadrant"
    ).textContent = `Quadrant (${qx}, ${qy})`;
    document.getElementById("applyWaterFixBtn").disabled = false;

    // Update selected tile visual
    document.querySelectorAll(".tile.water-fix-selected").forEach((tile) => {
      tile.classList.remove("water-fix-selected");
    });
    tileEl.classList.add("water-fix-selected");

    showToast("info", "Color picked", `Target color: ${hex} at (${qx}, ${qy})`);
  } catch (error) {
    console.error("Error picking color:", error);
    showToast(
      "error",
      "Error picking color",
      "Could not read pixel color. Try again."
    );
  }
}

async function applyWaterFix() {
  if (!fixWaterTargetColor || !fixWaterQuadrant) {
    showToast("error", "No color selected", "Pick a color first");
    return;
  }

  // Default replacement color - a nice blue water color
  const replacementColor = "#2A4A5F";

  const btn = document.getElementById("applyWaterFixBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.textContent = "Applying...";

  showToast(
    "loading",
    "Applying water fix...",
    `Replacing ${fixWaterTargetColor} in (${fixWaterQuadrant.x}, ${fixWaterQuadrant.y})`
  );

  try {
    const response = await fetch("/api/fix-water", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        x: fixWaterQuadrant.x,
        y: fixWaterQuadrant.y,
        target_color: fixWaterTargetColor,
        replacement_color: replacementColor,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast(
        "success",
        "Water fix applied!",
        result.message || "Color replaced successfully"
      );

      // Refresh the specific tile image immediately with cache-busting
      const { x, y } = fixWaterQuadrant;
      const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);
      if (tile) {
        const img = tile.querySelector("img");
        if (img) {
          // Add timestamp to bust browser cache
          const currentSrc = new URL(img.src);
          currentSrc.searchParams.set("_t", Date.now());
          img.src = currentSrc.toString();
        }
      }

      // Reset the tool after a short delay
      setTimeout(() => {
        cancelWaterFix();
      }, 1000);
    } else {
      showToast("error", "Water fix failed", result.error || "Unknown error");
      btn.disabled = false;
      btn.classList.remove("loading");
      btn.textContent = "Apply Fix";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fix error:", error);
    showToast("error", "Request failed", error.message);
    btn.disabled = false;
    btn.classList.remove("loading");
    btn.textContent = "Apply Fix";
  }
}

// Water Fill tool - fills entire quadrant with water color
let waterFillToolActive = false;

function toggleWaterFillTool() {
  // Deactivate other tools
  if (selectToolActive) {
    toggleSelectTool();
  }
  if (fixWaterToolActive) {
    cancelWaterFix();
  }

  waterFillToolActive = !waterFillToolActive;
  const btn = document.getElementById("waterFillTool");
  const tiles = document.querySelectorAll(".tile");
  const selectionStatus = document.getElementById("selectionStatus");
  const waterFillStatus = document.getElementById("waterFillStatus");

  if (waterFillToolActive) {
    btn.classList.add("active");
    tiles.forEach((tile) => {
      tile.classList.add("water-fill-selectable");
    });
    // Show water fill status bar, hide selection status
    selectionStatus.style.display = "none";
    waterFillStatus.style.display = "flex";
    saveSelectedTool("waterfill");
  } else {
    btn.classList.remove("active");
    tiles.forEach((tile) => {
      tile.classList.remove("water-fill-selectable");
    });
    // Hide water fill status bar, show selection status
    selectionStatus.style.display = "flex";
    waterFillStatus.style.display = "none";
    saveSelectedTool("");
  }
}

function cancelWaterFill() {
  if (waterFillToolActive) {
    toggleWaterFillTool();
  }
}

async function handleWaterFillClick(tileEl) {
  if (!waterFillToolActive) return;

  const coords = tileEl.dataset.coords.split(",").map(Number);
  const [qx, qy] = coords;

  // Confirm action
  if (!confirm(`Fill quadrant (${qx}, ${qy}) entirely with water color?`)) {
    return;
  }

  const instruction = document.getElementById("waterFillInstruction");
  instruction.textContent = `Filling (${qx}, ${qy})...`;

  showToast(
    "loading",
    "Filling with water...",
    `Processing quadrant (${qx}, ${qy})`
  );

  try {
    const response = await fetch("/api/water-fill", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ x: qx, y: qy }),
    });

    const result = await response.json();
    clearLoadingToasts();

    if (result.success) {
      showToast("success", "Water fill complete!", result.message);

      // Refresh the tile image
      const img = tileEl.querySelector("img");
      if (img) {
        const currentSrc = new URL(img.src);
        currentSrc.searchParams.set("_t", Date.now());
        img.src = currentSrc.toString();
      }

      instruction.textContent = "Click a quadrant to fill with water";
    } else {
      showToast("error", "Water fill failed", result.error || "Unknown error");
      instruction.textContent = "Click a quadrant to fill with water";
    }
  } catch (error) {
    clearLoadingToasts();
    console.error("Water fill error:", error);
    showToast("error", "Request failed", error.message);
    instruction.textContent = "Click a quadrant to fill with water";
  }
}

function updateSelectionStatus(serverStatus = null) {
  const count = selectedQuadrants.size;
  const countEl = document.getElementById("selectionCount");
  const limitEl = document.querySelector(".selection-limit");
  const statusEl = document.getElementById("selectionStatus");
  const deselectBtn = document.getElementById("deselectAllBtn");
  const deleteBtn = document.getElementById("deleteBtn");
  const renderBtn = document.getElementById("renderBtn");
  const generateBtn = document.getElementById("generateBtn");
  const generateRectBtn = document.getElementById("generateRectBtn");

  let statusParts = [];

  // Show current processing status from server
  if (serverStatus) {
    // Show all active models generating
    const activeModels = serverStatus.active_models || [];
    const processingQuadrants =
      serverStatus.all_processing_quadrants || serverStatus.quadrants || [];

    if (activeModels.length > 0 && processingQuadrants.length > 0) {
      // Show which models are actively generating
      const modelNames = activeModels.map(
        (modelId) => getModelDisplayName(modelId) || modelId || "default"
      );

      if (activeModels.length === 1) {
        const coordsStr = processingQuadrants
          .map(([x, y]) => `(${x},${y})`)
          .join(" ");
        statusParts.push(`üîÑ ${modelNames[0]}: ${coordsStr}`);
      } else {
        // Multiple models generating in parallel
        statusParts.push(`üîÑ Generating: ${modelNames.join(", ")}`);
      }
    } else if (
      serverStatus.is_generating &&
      serverStatus.quadrants &&
      serverStatus.quadrants.length > 0
    ) {
      // Fallback to old behavior
      const action =
        serverStatus.status === "rendering" ? "Rendering" : "Generating";
      const coordsStr = serverStatus.quadrants
        .map(([x, y]) => `(${x},${y})`)
        .join(" ");
    statusParts.push(`${action} ${coordsStr}`);
  }

    // Show per-model queue counts
    if (serverStatus.queue_by_model) {
      const modelQueues = Object.entries(serverStatus.queue_by_model);
      if (modelQueues.length > 0) {
        const queueParts = modelQueues.map(([modelId, info]) => {
          const name = getModelDisplayName(modelId) || modelId;
          const count = info.pending_count + (info.is_processing ? 1 : 0);
          return `${name}: ${count}`;
        });
        statusParts.push(`üìã ${queueParts.join(", ")}`);
      }
    } else if (serverStatus.queue_length > 0) {
      // Fallback for backwards compatibility
      statusParts.push(`üìã Queued: ${serverStatus.queue_length}`);
    }
  }

  // Update selection display in toolbar-info (separate from status)
  const selectedDisplay = document.getElementById("selectedQuadrantsDisplay");
  if (selectedDisplay) {
  if (count > 0) {
      const coordsStr = Array.from(selectedQuadrants)
        .map((key) => {
          const [x, y] = key.split(",");
          return `(${x},${y})`;
        })
        .join(" ");
      selectedDisplay.textContent = `‚úì ${coordsStr}`;
      selectedDisplay.style.display = "";
    } else {
      selectedDisplay.textContent = "";
      selectedDisplay.style.display = "none";
    }
  }

  let statusText;
  if (statusParts.length > 0) {
    statusText = statusParts.join(" ‚Ä¢ ");
  } else {
    statusText = `${count} selected`;
  }

  countEl.textContent = statusText;

  // Update status bar styling
  const isProcessing =
    serverStatus &&
    (serverStatus.is_generating || serverStatus.queue_length > 0);
  if (isProcessing) {
    if (limitEl) limitEl.style.display = "none";
    statusEl.classList.remove("empty");
    statusEl.classList.add("generating");
  } else {
    if (limitEl) limitEl.style.display = "";
    statusEl.classList.toggle("empty", count === 0);
    statusEl.classList.remove("generating");
  }

  // Enable buttons for selection (can add to queue even during processing)
  deselectBtn.disabled = count === 0;
  deleteBtn.disabled = count === 0;
  renderBtn.disabled = count === 0;
  generateBtn.disabled = count === 0;
  // Generate with prompt button
  const generateWithPromptBtn = document.getElementById(
    "generateWithPromptBtn"
  );
  if (generateWithPromptBtn) {
    generateWithPromptBtn.disabled = count === 0;
  }
  // Generate Rectangle requires exactly 2 selected
  generateRectBtn.disabled = count !== 2;
}

// Toast notification system
function showToast(type, title, message, duration = 5000) {
  const container = document.getElementById("toastContainer");
  const toast = document.createElement("div");
  toast.className = `toast ${type}`;

  const icons = {
    success: "‚úÖ",
    error: "‚ùå",
    info: "‚ÑπÔ∏è",
    loading: "‚è≥",
  };

  toast.innerHTML = `
    <span class="toast-icon">${icons[type] || "‚ÑπÔ∏è"}</span>
    <div class="toast-content">
      <div class="toast-title">${title}</div>
      ${message ? `<div class="toast-message">${message}</div>` : ""}
    </div>
    <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
  `;

  container.appendChild(toast);

  // Auto-remove after duration (except for loading toasts)
  if (type !== "loading" && duration > 0) {
    setTimeout(() => {
      toast.classList.add("removing");
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }

  return toast;
}

function clearLoadingToasts() {
  document.querySelectorAll(".toast.loading").forEach((t) => t.remove());
}

// Generation/Render state (tracked from server)
let isGenerating = false;
let isRendering = false;

async function deleteSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  // Confirm deletion
  const coordsStr = coords.map(([x, y]) => `(${x},${y})`).join(", ");
  if (!confirm(`Delete generation data for ${coordsStr}?`)) {
    return;
  }

  try {
    const response = await fetch("/api/delete", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.success) {
      showToast("success", "Deleted", result.message);
      // Deselect and refresh
      deselectAll();
      location.reload();
    } else {
      showToast("error", "Delete failed", result.error);
    }
  } catch (error) {
    console.error("Delete error:", error);
    showToast("error", "Delete failed", error.message);
  }
}

async function clearQueue() {
  // Get current queue info first
  try {
    const statusResponse = await fetch("/api/status");
    const status = await statusResponse.json();

    const queueLength = status.queue_length || 0;
    const isGenerating = status.is_generating || false;

    if (queueLength === 0 && !isGenerating) {
      showToast(
        "info",
        "Nothing to clear",
        "There are no pending items or active generations."
      );
      return;
    }

    // Build confirm message based on what will be cancelled
    let confirmMessage = "Are you sure you want to clear the queue?";
    const parts = [];
    if (queueLength > 0) {
      parts.push(`${queueLength} pending item(s)`);
    }
    if (isGenerating) {
      parts.push("the current generation in progress");
    }
    if (parts.length > 0) {
      confirmMessage = `Are you sure you want to cancel ${parts.join(
        " and "
      )}?`;
    }

    if (!confirm(confirmMessage)) {
      return;
    }

    // Clear the queue
    const response = await fetch("/api/queue/clear", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });

    const result = await response.json();

    if (result.success) {
      showToast(
        "success",
        "Queue cleared",
        result.message || `Cleared ${result.cleared_count} item(s)`
      );
      // Refresh status
      await checkGenerationStatus();
    } else {
      showToast(
        "error",
        "Failed to clear queue",
        result.error || "Unknown error"
      );
    }
  } catch (error) {
    console.error("Clear queue error:", error);
    showToast("error", "Request failed", error.message);
  }
}

// Prompt dialog functions
function showPromptDialog() {
  if (selectedQuadrants.size === 0) return;
  const dialog = document.getElementById("promptDialog");
  const input = document.getElementById("promptInput");
  if (dialog && input) {
    input.value = "";
    dialog.style.display = "flex";
    input.focus();
  }
}

function hidePromptDialog() {
  const dialog = document.getElementById("promptDialog");
  if (dialog) {
    dialog.style.display = "none";
  }
}

async function submitPromptGeneration() {
  const input = document.getElementById("promptInput");
  const prompt = input ? input.value.trim() : "";
  hidePromptDialog();
  await generateSelected(prompt);
}

async function generateSelected(prompt = null) {
  if (selectedQuadrants.size === 0) return;

  // Separate selected quadrants into those that need generation vs those that already have it
  const toGenerate = [];
  const contextQuadrants = [];

  Array.from(selectedQuadrants).forEach((s) => {
    const [x, y] = s.split(",").map(Number);
    const tile = document.querySelector(`.tile[data-coords="${x},${y}"]`);

    if (tile && !tile.classList.contains("placeholder")) {
      // This quadrant already has a generation - use as context
      contextQuadrants.push([x, y]);
    } else {
      // This quadrant needs generation
      toGenerate.push([x, y]);
    }
  });

  // If nothing needs generation, inform the user
  if (toGenerate.length === 0) {
    showToast(
      "info",
      "Already generated",
      "All selected quadrants already have generations. Select at least one empty quadrant."
    );
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate requested for:",
    toGenerate,
    "with context:",
    contextQuadrants,
    "model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();

  // Show immediate feedback with context info
  const contextMsg =
    contextQuadrants.length > 0
      ? ` (using ${contextQuadrants.length} as context)`
      : "";
  const promptMsg = prompt ? " with prompt" : "";
    showToast(
    "info",
    "Adding to queue...",
    `Queueing ${toGenerate.length} quadrant(s) for generation${promptMsg}${contextMsg}`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const requestBody = {
      quadrants: toGenerate,
      model_id: modelId,
    };

    // Include context quadrants if any
    if (contextQuadrants.length > 0) {
      requestBody.context = contextQuadrants;
    }

    // Include prompt if provided
    if (prompt) {
      requestBody.prompt = prompt;
    }

    const response = await fetch("/api/generate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    });

    const result = await response.json();

    if (result.queued) {
      console.log(
        "Generation queued at position:",
        result.position,
        "model:",
        result.model_id
      );
      // Get model name for display
      const modelName = getModelDisplayName(result.model_id);
      const modelInfo = modelName ? ` (${modelName})` : "";
      showToast(
        "success",
        "Added to queue",
        `Queued at position ${result.position}${modelInfo}`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Generation error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function renderSelected() {
  if (selectedQuadrants.size === 0) return;

  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return [x, y];
  });

  console.log("Render requested for:", coords);

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();

    // Show immediate feedback
    showToast(
      "info",
      "Adding to queue...",
      `Queueing ${coords.length} quadrant(s) for render`
    );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/render", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ quadrants: coords }),
    });

    const result = await response.json();

    if (result.queued) {
      console.log("Render queued at position:", result.position);
      showToast(
        "success",
        "Added to queue",
        `Render queued at position ${result.position}.`
      );
    } else if (!result.success) {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    console.error("Render error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );
  }
}

async function generateRectangle() {
  if (selectedQuadrants.size !== 2) {
    showToast(
      "error",
      "Invalid selection",
      "Please select exactly 2 quadrants to define the rectangle corners."
    );
    return;
  }

  // Get the two selected coordinates
  const coords = Array.from(selectedQuadrants).map((s) => {
    const [x, y] = s.split(",").map(Number);
    return { x, y };
  });

  // Calculate rectangle bounds (top-left and bottom-right)
  const minX = Math.min(coords[0].x, coords[1].x);
  const maxX = Math.max(coords[0].x, coords[1].x);
  const minY = Math.min(coords[0].y, coords[1].y);
  const maxY = Math.max(coords[0].y, coords[1].y);

  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const totalQuadrants = width * height;

  // Build confirmation message
  const confirmMessage =
    `Generate rectangle from (${minX}, ${minY}) to (${maxX}, ${maxY})?\n\n` +
    `Size: ${width} √ó ${height} = ${totalQuadrants} quadrant(s)\n\n` +
    `This will create a generation plan and queue all steps.\n` +
    `Pre-existing generations will be skipped.`;

  if (!confirm(confirmMessage)) {
    return;
  }

  const modelId = getSelectedModelId();

  console.log(
    "Generate rectangle requested:",
    { tl: [minX, minY], br: [maxX, maxY] },
    "with model:",
    modelId
  );

  // Clear selection
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  selectedQuadrants.clear();
  saveSelectedQuadrants();
    updateSelectionStatus();

  // Show immediate feedback
  const btn = document.getElementById("generateRectBtn");
  btn.disabled = true;
  btn.classList.add("loading");
  btn.innerHTML = 'Queueing...<span class="spinner"></span>';

    showToast(
      "loading",
    "Creating generation plan...",
    `Rectangle (${minX}, ${minY}) to (${maxX}, ${maxY})`
  );

  // Start polling for status updates
  startStatusPolling();

  try {
    const response = await fetch("/api/generate-rectangle", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        tl: [minX, minY],
        br: [maxX, maxY],
        model_id: modelId,
      }),
    });

    const result = await response.json();
    clearLoadingToasts();

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";

    if (result.success) {
      if (result.queued_count === 0) {
      showToast(
        "info",
          "Nothing to generate",
          result.message || "All quadrants already generated."
        );
      } else {
        console.log("Rectangle generation queued:", result);
        const summary = result.plan_summary || {};
        const stepTypes = summary.steps_by_type || {};
        const typeInfo = Object.entries(stepTypes)
          .map(([type, count]) => `${count}√ó ${type}`)
          .join(", ");

      showToast(
        "success",
          "Rectangle queued!",
          `${result.queued_count} step(s) for ${
            summary.total_quadrants || "?"
          } quadrant(s)` + (typeInfo ? ` (${typeInfo})` : "")
        );
        }
      } else {
      showToast("error", "Failed to queue", result.error || "Unknown error");
    }

    // Fetch latest status to update UI
    await checkGenerationStatus();
  } catch (error) {
    clearLoadingToasts();
    console.error("Generate rectangle error:", error);
    showToast(
      "error",
      "Request failed",
      error.message || "Could not connect to server."
    );

    // Reset button
    btn.classList.remove("loading");
    btn.innerHTML = "Generate Rectangle";
  }
}

function deselectAll() {
  selectedQuadrants.clear();
  document.querySelectorAll(".tile.selected").forEach((tile) => {
    tile.classList.remove("selected");
  });
  saveSelectedQuadrants();
  updateSelectionStatus();
  console.log("Deselected all quadrants");
}

function toggleTileSelection(tileEl, qx, qy) {
  if (!selectToolActive) return;

  // Check if this tile is currently being generated or in the queue
  const key = `${qx},${qy}`;
  if (
    tileEl.classList.contains("locked") ||
    tileEl.classList.contains("queued")
  ) {
    console.log(
      `Cannot select quadrant (${qx}, ${qy}) - currently generating or in queue`
    );
    return;
  }

  if (selectedQuadrants.has(key)) {
    selectedQuadrants.delete(key);
    tileEl.classList.remove("selected");
    console.log(`Deselected quadrant (${qx}, ${qy})`);
  } else {
    // Check if we've hit the max selection limit
    if (selectedQuadrants.size >= MAX_SELECTION) {
      console.log(`Cannot select more than ${MAX_SELECTION} quadrants`);
      return;
    }
    selectedQuadrants.add(key);
    tileEl.classList.add("selected");
    console.log(`Selected quadrant (${qx}, ${qy})`);
  }

  saveSelectedQuadrants();
  updateSelectionStatus();

  // Log current selection
  if (selectedQuadrants.size > 0) {
    console.log("Selected:", Array.from(selectedQuadrants).join("; "));
  }
}

// Setup tile click handlers
document.querySelectorAll(".tile").forEach((tile) => {
  tile.addEventListener("click", (e) => {
    // Handle fix water tool clicks
    if (fixWaterToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleFixWaterClick(tile, e);
      return;
    }

    // Handle water fill tool clicks
    if (waterFillToolActive) {
      e.preventDefault();
      e.stopPropagation();
      handleWaterFillClick(tile);
      return;
    }

    // Handle select tool clicks
    if (!selectToolActive) return;
    e.preventDefault();
    e.stopPropagation();

    const coords = tile.dataset.coords.split(",").map(Number);
    toggleTileSelection(tile, coords[0], coords[1]);
  });
});

// Initialize selection status
updateSelectionStatus();

// Status polling for generation progress
let statusPollInterval = null;
let lastStatus = null;

function startStatusPolling() {
  if (statusPollInterval) return;
  statusPollInterval = setInterval(checkGenerationStatus, 1000);
}

function stopStatusPolling() {
  if (statusPollInterval) {
    clearInterval(statusPollInterval);
    statusPollInterval = null;
  }
}

async function checkGenerationStatus() {
  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    console.log("Status poll:", status);

    // Track state changes - consider active_model_count for parallel processing
    const wasGenerating = isGenerating || isRendering;
    const hasActiveModels = (status.active_model_count || 0) > 0;
    isGenerating =
      (status.is_generating || hasActiveModels) &&
      status.status !== "rendering";
    isRendering = status.is_generating && status.status === "rendering";
    const nowProcessing = isGenerating || isRendering;

    // Apply visual styles based on server status
    applyStatusStyles(status);

    // Update render button based on state
    const renderBtn = document.getElementById("renderBtn");

    if (nowProcessing) {
      // Show loading state on render button only (generate state is shown in toolbar)
      if (isRendering) {
        renderBtn.classList.add("loading");
        renderBtn.innerHTML = 'Rendering<span class="spinner"></span>';
      } else {
        renderBtn.classList.remove("loading");
        renderBtn.innerHTML = "Render";
      }

      // Show toast if not already showing
      if (document.querySelectorAll(".toast.loading").length === 0) {
        const opName = isRendering ? "Render" : "Generation";
        showToast(
          "loading",
          `${opName} in progress...`,
          status.message || "Please wait..."
        );
      }

      // Update the loading toast message
      const loadingToast = document.querySelector(
        ".toast.loading .toast-message"
      );
      if (loadingToast && status.message) {
        loadingToast.textContent = status.message;
      }
    } else {
      // Reset render button
      renderBtn.classList.remove("loading");
      renderBtn.innerHTML = "Render";
    }

    // Handle status transitions
    if (status.status === "complete" && wasGenerating && !nowProcessing) {
        clearLoadingToasts();
      showToast("success", "Complete!", status.message);

      // Check if there are more items in queue
        if (status.queue_length > 0) {
        // Build per-model queue message
        let queueMsg = `${status.queue_length} more item(s) in queue...`;
        if (status.queue_by_model) {
          const parts = Object.entries(status.queue_by_model)
            .filter(([, info]) => info.pending_count > 0)
            .map(([modelId, info]) => {
              const name = getModelDisplayName(modelId) || modelId;
              return `${name}: ${info.pending_count}`;
            });
          if (parts.length > 0) {
            queueMsg = parts.join(", ");
          }
        }
        showToast("info", "Processing queue", queueMsg);
        } else {
        // No more items, reload after delay
          stopStatusPolling();
          setTimeout(() => window.location.reload(), 1500);
        }
      } else if (status.status === "error" && status.error) {
        clearLoadingToasts();
      showToast("error", "Error", status.error);

        // Continue polling if there are more items in queue
        if (status.queue_length === 0) {
          stopStatusPolling();
        }
    } else if (
      status.status === "idle" &&
      status.queue_length === 0 &&
      !nowProcessing
    ) {
      // Idle with no queue - stop polling
        stopStatusPolling();
    }

    // Update selection status with server info
    updateSelectionStatus(status);
    lastStatus = status;
  } catch (error) {
    console.error("Status check failed:", error);
  }
}

// Restore saved tool on page load
function restoreSavedTool() {
  const savedTool = getSavedTool();
  if (!savedTool) return;

  // Check if the tool button exists before activating
  switch (savedTool) {
    case "select":
      if (document.getElementById("selectTool")) {
        toggleSelectTool();
      }
      break;
    case "fixwater":
      if (document.getElementById("fixWaterTool")) {
        toggleFixWaterTool();
      }
      break;
    case "waterfill":
      if (document.getElementById("waterFillTool")) {
        toggleWaterFillTool();
      }
      break;
    default:
      // Unknown tool, clear saved state
      saveSelectedTool("");
      break;
  }
}

// Restore saved quadrant selections on page load
function restoreSavedQuadrants() {
  const savedQuadrants = getSavedQuadrants();
  if (!savedQuadrants || savedQuadrants.length === 0) return;

  let restoredCount = 0;

  savedQuadrants.forEach((key) => {
    // Check if this quadrant tile exists on the current page
    const tile = document.querySelector(`.tile[data-coords="${key}"]`);
    if (tile) {
      // Don't restore if tile is locked or queued
      if (
        !tile.classList.contains("locked") &&
        !tile.classList.contains("queued")
      ) {
        selectedQuadrants.add(key);
        tile.classList.add("selected");
        restoredCount++;
      }
    }
  });

  if (restoredCount > 0) {
    console.log(`Restored ${restoredCount} selected quadrant(s)`);
    // Update localStorage to only contain valid selections
    saveSelectedQuadrants();
  updateSelectionStatus();
  } else if (savedQuadrants.length > 0) {
    // Had saved selections but none are on current page - clear storage
    saveSelectedQuadrants();
  }
}

// Initialize on page load
(async function initialize() {
  // Initialize model selector
  initModelSelector();

  // Restore saved tool
  restoreSavedTool();

  // Restore saved quadrant selections
  restoreSavedQuadrants();

  try {
    const response = await fetch("/api/status");
    const status = await response.json();

    // Apply initial status styles
    applyStatusStyles(status);

    if (status.is_generating || status.queue_length > 0) {
      console.log(
        "Processing in progress or queue non-empty, starting polling..."
      );
      isGenerating = status.is_generating && status.status !== "rendering";
      isRendering = status.is_generating && status.status === "rendering";
      startStatusPolling();
    }

    updateSelectionStatus(status);
  } catch (error) {
    console.error("Initial status check failed:", error);
  }
})();

```

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
  font-size: 12px;
  background: #1a1a2e;
  color: #eee;
  min-height: 100vh;
  padding: 15px;
  padding-top: 95px; /* Space for fixed toolbar */
}

.toolbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: #1a1a2e;
  padding: 10px 15px;
  z-index: 100;
  border-bottom: 1px solid #333;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.toolbar-row {
  display: flex;
  align-items: center;
  gap: 15px;
  flex-wrap: wrap;
}

.toolbar-info {
  color: #666;
  font-size: 0.75rem;
}

.toolbar-info span + span {
  margin-left: 12px;
}

.toolbar-info .selected-quadrants {
  color: #00d9ff;
  font-weight: bold;
}

.controls {
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
}

.controls label {
  color: #888;
  font-size: 0.8rem;
}

.controls input[type="number"] {
  width: 50px;
  padding: 5px 6px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #16213e;
  color: #fff;
  font-family: inherit;
  font-size: 0.8rem;
}

.controls button {
  padding: 5px 12px;
  background: #00d9ff;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.75rem;
  font-weight: bold;
}

.controls button:hover {
  background: #00b8d4;
}

.toggle-group {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-left: 8px;
  padding-left: 12px;
  border-left: 1px solid #333;
}

.toggle-group label {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  user-select: none;
  font-size: 0.75rem;
}

.toggle-group input[type="checkbox"] {
  width: 14px;
  height: 14px;
  accent-color: #00d9ff;
  cursor: pointer;
}

.grid-container {
  display: inline-block;
  border-radius: 8px;
  overflow: hidden;
}

.grid-container.show-lines {
  border: 2px solid #333;
}

.grid {
  display: grid;
  background: #333;
}

.grid-container.show-lines .grid {
  gap: 2px;
}

.grid-container:not(.show-lines) .grid {
  gap: 0;
  background: transparent;
}

.grid-container:not(.show-lines) {
  border: none;
}

.tile {
  position: relative;
  background: #2a2a4a;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tile img {
  display: block;
  max-width: 100%;
  height: auto;
}

.tile.placeholder {
  background: #3a3a5a;
}

.tile .coords {
  position: absolute;
  top: 6px;
  left: 6px;
  background: rgba(0, 0, 0, 0.7);
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 0.65rem;
  color: #00d9ff;
  transition: opacity 0.2s;
}

.tile.placeholder .coords {
  color: #666;
}

.grid-container:not(.show-coords) .tile .coords {
  opacity: 0;
}

/* Tool button styles */
.tools-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.tools-label {
  color: #666;
  font-size: 0.7rem;
}

.tool-btn {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: #2a2a3e;
  color: #666;
  border: 1px solid #444;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  transition: all 0.15s ease;
}

.tool-btn:hover {
  background: #3a3a4e;
  color: #999;
  border-color: #555;
}

.tool-btn.active {
  background: #10b981;
  color: #fff;
  border-color: #10b981;
  box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
}

.tool-btn.active:hover {
  background: #059669;
  border-color: #059669;
}

.tool-btn svg {
  width: 12px;
  height: 12px;
}

/* Selection styles */
.tile.selected {
  outline: 3px solid #ff3333;
  outline-offset: -3px;
  z-index: 10;
}

.grid-container.show-lines .tile.selected {
  outline-color: #ff3333;
}

.tile.selectable {
  cursor: pointer;
}

.tile.placeholder.selected {
  background: rgba(255, 51, 51, 0.15);
}

/* Locked tiles (during generation) */
.tile.locked {
  outline: 3px solid #a855f7;
  outline-offset: -3px;
  z-index: 10;
}

.grid-container.show-lines .tile.locked {
  outline-color: #a855f7;
}

.tile.placeholder.locked {
  background: rgba(168, 85, 247, 0.2);
}

/* Queued tiles (in queue, waiting to be generated) */
.tile.queued {
  outline: 3px dashed #c084fc !important;
  outline-offset: -3px;
  z-index: 9;
  animation: pulse-queue 1.5s ease-in-out infinite;
  /* Fallback: box-shadow for browsers that don't render dashed outlines well */
  box-shadow: inset 0 0 0 3px rgba(192, 132, 252, 0.5);
}

@keyframes pulse-queue {
  0%,
  100% {
    outline-color: #c084fc;
    box-shadow: inset 0 0 0 3px rgba(192, 132, 252, 0.5);
  }
  50% {
    outline-color: #8b5cf6;
    box-shadow: inset 0 0 0 3px rgba(139, 92, 246, 0.7);
  }
}

.grid-container.show-lines .tile.queued {
  outline-color: #c084fc;
}

.tile.placeholder.queued {
  background: rgba(168, 85, 247, 0.3) !important;
}

/* Allow selection while generating - only disable clicking on locked/queued tiles */
body.generating .tile.locked.selectable,
body.generating .tile.queued.selectable {
  cursor: not-allowed;
}

/* Selection status bar */
.selection-status {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 10px;
  background: rgba(255, 51, 51, 0.1);
  border: 1px solid rgba(255, 51, 51, 0.3);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #ff6666;
  margin-top: 8px;
}

.selection-status.empty {
  background: transparent;
  border-color: #333;
  color: #666;
}

.selection-status.generating {
  background: rgba(168, 85, 247, 0.1);
  border-color: rgba(168, 85, 247, 0.4);
  color: #a855f7;
}

.selection-limit {
  color: #888;
  font-size: 0.65rem;
}

.deselect-btn {
  padding: 3px 8px;
  background: #ff3333;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  margin-left: auto;
  transition: all 0.2s;
}

.deselect-btn:hover:not(:disabled) {
  background: #ff5555;
}

.deselect-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
}

.delete-btn {
  padding: 3px 8px;
  background: #dc2626;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  transition: all 0.2s;
}

.delete-btn:hover:not(:disabled) {
  background: #b91c1c;
}

.delete-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
}

.render-btn {
  padding: 4px 12px;
  background: #f59e0b;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
}

.render-btn:hover:not(:disabled) {
  background: #d97706;
}

.render-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.render-btn.loading {
  background: #666;
  cursor: wait;
}

.render-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

.generate-btn {
  padding: 4px 12px;
  background: #00d9ff;
  color: #1a1a2e;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
}

.generate-btn:hover:not(:disabled) {
  background: #00b8d4;
}

.generate-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

/* Generate Rectangle button */
.generate-rect-btn {
  padding: 4px 12px;
  background: #8b5cf6;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
}

.generate-rect-btn:hover:not(:disabled) {
  background: #7c3aed;
}

.generate-rect-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.generate-rect-btn.loading {
  background: #666;
  cursor: wait;
}

.generate-rect-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

/* Clear Queue button */
.clear-queue-btn {
  padding: 4px 10px;
  background: #6b7280;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  font-weight: 500;
  transition: all 0.2s;
  margin-left: 8px;
}

.clear-queue-btn:hover {
  background: #ef4444;
}

.clear-queue-btn:active {
  background: #dc2626;
}

/* Toast notification system */
.toast-container {
  position: fixed;
  bottom: 15px;
  right: 15px;
  z-index: 1000;
  display: flex;
  flex-direction: column-reverse;
  gap: 8px;
  max-width: 320px;
}

.toast {
  padding: 10px 14px;
  border-radius: 6px;
  font-size: 0.75rem;
  animation: slideIn 0.3s ease-out;
  display: flex;
  align-items: flex-start;
  gap: 10px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.toast.success {
  background: linear-gradient(135deg, #065f46 0%, #047857 100%);
  border: 1px solid #10b981;
  color: #d1fae5;
}

.toast.error {
  background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
  border: 1px solid #ef4444;
  color: #fee2e2;
}

.toast.info {
  background: linear-gradient(135deg, #1e3a5f 0%, #1e40af 100%);
  border: 1px solid #3b82f6;
  color: #dbeafe;
}

.toast.loading {
  background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
  border: 1px solid #6b7280;
  color: #e5e7eb;
}

.toast-icon {
  flex-shrink: 0;
  font-size: 1rem;
}

.toast-content {
  flex: 1;
}

.toast-title {
  font-weight: 600;
  margin-bottom: 2px;
}

.toast-message {
  opacity: 0.9;
  font-size: 0.7rem;
}

.toast-close {
  background: none;
  border: none;
  color: inherit;
  cursor: pointer;
  opacity: 0.7;
  font-size: 1rem;
  padding: 0;
  line-height: 1;
}

.toast-close:hover {
  opacity: 1;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOut {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

.toast.removing {
  animation: slideOut 0.3s ease-in forwards;
}

/* Loading spinner for generate button */
.generate-btn.loading {
  background: #666;
  color: #fff;
  cursor: wait;
}

.generate-btn .spinner {
  display: inline-block;
  width: 10px;
  height: 10px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-left: 4px;
  vertical-align: middle;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Water fix tool styles */
.water-fix-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid rgba(59, 130, 246, 0.3);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #60a5fa;
  margin-top: 8px;
}

.water-fix-label {
  color: #93c5fd;
  font-weight: 500;
}

.color-swatch {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  border: 2px solid #fff;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3), inset 0 0 0 1px rgba(0, 0, 0, 0.1);
  background: #333;
}

.color-swatch.has-color {
  cursor: pointer;
}

.color-hex {
  font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
  font-size: 0.75rem;
  color: #93c5fd;
  min-width: 180px;
}

.water-fix-quadrant {
  color: #60a5fa;
  font-size: 0.7rem;
}

.apply-water-fix-btn {
  padding: 4px 12px;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.7rem;
  font-weight: bold;
  transition: all 0.2s;
  margin-left: auto;
}

.apply-water-fix-btn:hover:not(:disabled) {
  background: #2563eb;
}

.apply-water-fix-btn:disabled {
  background: #444;
  color: #666;
  cursor: not-allowed;
  font-weight: normal;
}

.apply-water-fix-btn.loading {
  background: #666;
  cursor: wait;
}

.cancel-water-fix-btn {
  padding: 4px 8px;
  background: #4b5563;
  color: #d1d5db;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-size: 0.65rem;
  transition: all 0.2s;
}

.cancel-water-fix-btn:hover {
  background: #6b7280;
}

/* Fix water tool active state */
.tile.fix-water-selectable {
  cursor: crosshair;
}

.tile.fix-water-selectable:hover {
  outline: 2px solid #3b82f6;
  outline-offset: -2px;
}

.tile.water-fix-selected {
  outline: 3px solid #3b82f6;
  outline-offset: -3px;
  z-index: 10;
}

/* Water fill tool styles */
.water-fill-status {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 12px;
  background: rgba(74, 99, 114, 0.15);
  border: 1px solid rgba(74, 99, 114, 0.4);
  border-radius: 4px;
  font-size: 0.7rem;
  color: #7ba3b8;
  margin-top: 8px;
}

.water-fill-label {
  color: #93c5fd;
  font-weight: 500;
}

.water-color-preview {
  background: #4a6372 !important;
}

.water-fill-instruction {
  color: #7ba3b8;
}

.tile.water-fill-selectable {
  cursor: pointer;
}

.tile.water-fill-selectable:hover {
  outline: 2px solid #4a6372;
  outline-offset: -2px;
}

/* Model selector styles */
.model-group {
  display: flex;
  align-items: center;
  gap: 6px;
}

.model-label {
  display: flex;
  align-items: center;
  gap: 6px;
  color: #888;
  font-size: 0.75rem;
}

.model-select {
  padding: 4px 8px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #16213e;
  color: #fff;
  font-family: inherit;
  font-size: 0.75rem;
  cursor: pointer;
  min-width: 140px;
}

.model-select:hover {
  border-color: #00d9ff;
}

.model-select:focus {
  outline: none;
  border-color: #00d9ff;
  box-shadow: 0 0 0 2px rgba(0, 217, 255, 0.2);
}

.model-select option {
  background: #16213e;
  color: #fff;
  padding: 4px;
}

/* Generate with Prompt button */
.generate-prompt-btn {
  background: linear-gradient(135deg, #9b59b6, #8e44ad);
  color: #fff;
  border: none;
  padding: 6px 12px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.generate-prompt-btn:hover:not(:disabled) {
  background: linear-gradient(135deg, #a569c0, #9b59b6);
  transform: translateY(-1px);
}

.generate-prompt-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Prompt Dialog */
.dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.dialog-content {
  background: #1a1a2e;
  border: 1px solid #333;
  border-radius: 8px;
  padding: 24px;
  min-width: 400px;
  max-width: 500px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
}

.dialog-content h3 {
  margin: 0 0 12px 0;
  color: #fff;
  font-size: 18px;
}

.dialog-description {
  color: #aaa;
  font-size: 14px;
  margin: 0 0 16px 0;
}

.prompt-input {
  width: 100%;
  background: #0f0f1a;
  border: 1px solid #333;
  border-radius: 4px;
  color: #fff;
  font-size: 14px;
  padding: 12px;
  resize: vertical;
  font-family: inherit;
  box-sizing: border-box;
}

.prompt-input:focus {
  outline: none;
  border-color: #9b59b6;
  box-shadow: 0 0 0 2px rgba(155, 89, 182, 0.2);
}

.prompt-input::placeholder {
  color: #666;
}

.dialog-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 20px;
}

.dialog-cancel-btn {
  background: #333;
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

.dialog-cancel-btn:hover {
  background: #444;
}

.dialog-submit-btn {
  background: linear-gradient(135deg, #9b59b6, #8e44ad);
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.dialog-submit-btn:hover {
  background: linear-gradient(135deg, #a569c0, #9b59b6);
}

/* Queue Overlays - show pending generations as grouped rectangles */
.queue-overlay {
  position: absolute;
  border: 3px dashed #c084fc;
  border-radius: 4px;
  pointer-events: auto;
  z-index: 20;
  animation: pulse-queue-overlay 1.5s ease-in-out infinite;
  box-sizing: border-box;
}

/* Processing overlay - solid border, different color */
.queue-overlay.processing {
  border-style: solid;
  border-color: #a855f7;
  animation: pulse-processing-overlay 1s ease-in-out infinite;
}

@keyframes pulse-queue-overlay {
  0%,
  100% {
    border-color: #c084fc;
    box-shadow: 0 0 12px rgba(192, 132, 252, 0.3);
  }
  50% {
    border-color: #8b5cf6;
    box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
  }
}

@keyframes pulse-processing-overlay {
  0%,
  100% {
    border-color: #a855f7;
    box-shadow: 0 0 16px rgba(168, 85, 247, 0.4);
  }
  50% {
    border-color: #c084fc;
    box-shadow: 0 0 24px rgba(192, 132, 252, 0.7);
  }
}

.queue-overlay:hover {
  border-color: #a855f7;
  box-shadow: 0 0 16px rgba(168, 85, 247, 0.6);
}

/* Queue position badge */
.queue-badge {
  position: absolute;
  top: 6px;
  left: 6px;
  min-width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #8b5cf6, #a855f7);
  color: white;
  font-size: 12px;
  font-weight: bold;
  font-family: "SF Mono", "Monaco", monospace;
  border-radius: 6px;
  padding: 0 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  z-index: 1;
}

/* Processing badge - with spinner */
.queue-badge.processing {
  background: linear-gradient(135deg, #10b981, #059669);
  min-width: 28px;
  height: 28px;
}

/* Spinner animation for processing badge */
.processing-spinner {
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

/* Model label below badge */
.queue-model-label {
  position: absolute;
  top: 34px;
  left: 6px;
  font-size: 9px;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.9);
  background: rgba(139, 92, 246, 0.8);
  padding: 2px 6px;
  border-radius: 3px;
  max-width: calc(100% - 40px);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
}

/* Cancel button - visible on hover */
.queue-cancel-btn {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(220, 38, 38, 0.9);
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  opacity: 0;
  transform: scale(0.8);
  transition: all 0.15s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.queue-overlay:hover .queue-cancel-btn {
  opacity: 1;
  transform: scale(1);
}

.queue-cancel-btn:hover {
  background: #dc2626;
  transform: scale(1.1);
}

.queue-cancel-btn svg {
  width: 14px;
  height: 14px;
}

/* Make grid position relative for overlay positioning */
.grid {
  position: relative;
}

```

Done! I've added a visual indicator for in-progress generations. Here's what was updated:

**Frontend (`viewer.js`):**
- Added `getProcessingItems()` function to extract currently processing items from the status response
- Refactored `updateQueueOverlays()` to handle both processing and queued items
- Processing items get a **spinning icon** (loading indicator) instead of a queue position number
- Both processing and queued overlays have cancel buttons

**Styles (`viewer.css`):**
- **Processing overlay**: Solid purple border (vs dashed for queued) with a faster pulse animation
- **Processing badge**: Green gradient background with a spinning SVG icon
- Added `@keyframes spin` for the spinner animation

**Visual differences:**
| State | Border | Badge | Color |
|-------|--------|-------|-------|
| **Queued** | Dashed purple | Position number (1, 2, 3...) | Purple gradient |
| **Processing** | Solid purple | Spinning loader icon | Green gradient |

The spinner rotates continuously to indicate active work, making it immediately clear which generation is currently being processed vs. waiting in the queue.

---

**User**

OK next improvement - for the rectangle plan genertion, we also need to consider in-progress / queued generations when determining if a seam will be formed with the generation. Please update the logic/tests accordingly

---

**Cursor**

I'll update the rectangle plan logic to consider in-progress and queued generations when determining seam formation. Let me modify the code:

```python
"""
Rectangle generation plan algorithm.

Creates a sequence of generation steps for filling a rectangular region
of quadrants, respecting pre-existing generated quadrants and following
tile placement rules.

Tile Placement Rules:
- 2x2: No side of the tile may touch any previously generated quadrants.
- 2x1/1x2: Both quadrants of the 2-long side must touch previously generated
  quadrants along that axis on ONE side. Neither quadrant may touch previously
  generated quadrants along the transverse (short) side.
- 1x1: Ideally generated when 3 other quadrants in a 2x2 block are generated.

Algorithm:
1. Place as many 2x2 tiles as possible
2. Place 2x1/1x2 tiles for remaining gaps
3. Fill remaining single quadrants with 1x1 tiles
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any


@dataclass(frozen=True)
class Point:
  """A 2D point representing a quadrant coordinate."""

  x: int
  y: int

  def __str__(self) -> str:
    return f"({self.x},{self.y})"

  def __add__(self, other: Point) -> Point:
    return Point(self.x + other.x, self.y + other.y)

  @classmethod
  def from_string(cls, s: str) -> Point:
    """Parse a string like '(x,y)' or 'x,y' into a Point."""
    s = s.strip().replace("(", "").replace(")", "").replace(" ", "")
    parts = s.split(",")
    if len(parts) != 2:
      raise ValueError(f"Invalid coordinate format: {s}")
    return cls(int(parts[0]), int(parts[1]))

  def to_tuple(self) -> tuple[int, int]:
    """Convert to a tuple."""
    return (self.x, self.y)


@dataclass
class RectBounds:
  """Bounds of the rectangle to generate."""

  top_left: Point
  bottom_right: Point

  @property
  def width(self) -> int:
    """Width of the rectangle (x extent)."""
    return self.bottom_right.x - self.top_left.x + 1

  @property
  def height(self) -> int:
    """Height of the rectangle (y extent)."""
    return self.bottom_right.y - self.top_left.y + 1

  @property
  def area(self) -> int:
    """Total number of quadrants in the rectangle."""
    return self.width * self.height

  def contains(self, p: Point) -> bool:
    """Check if a point is within the rectangle bounds."""
    return (
      self.top_left.x <= p.x <= self.bottom_right.x
      and self.top_left.y <= p.y <= self.bottom_right.y
    )

  def all_points(self) -> list[Point]:
    """Return all points within the rectangle bounds."""
    return [
      Point(x, y)
      for y in range(self.top_left.y, self.bottom_right.y + 1)
      for x in range(self.top_left.x, self.bottom_right.x + 1)
    ]


@dataclass
class GenerationStep:
  """A single generation step containing quadrants to generate together."""

  quadrants: list[Point]
  step_type: str = ""  # "2x2", "2x1", "1x2", "1x1" for debugging

  def to_dict(self) -> dict[str, Any]:
    """Convert to JSON-serializable dict."""
    return {
      "quadrants": [(q.x, q.y) for q in self.quadrants],
      "type": self.step_type,
    }


@dataclass
class RectanglePlan:
  """A complete generation plan for a rectangle."""

  bounds: RectBounds
  steps: list[GenerationStep] = field(default_factory=list)
  pre_generated: set[Point] = field(default_factory=set)

  def to_dict(self) -> dict[str, Any]:
    """Convert to JSON-serializable dict."""
    return {
      "bounds": {
        "top_left": self.bounds.top_left.to_tuple(),
        "bottom_right": self.bounds.bottom_right.to_tuple(),
      },
      "steps": [step.to_dict() for step in self.steps],
      "pre_generated": [p.to_tuple() for p in self.pre_generated],
    }


# =============================================================================
# 2x2 Tile Placement
# =============================================================================


def get_2x2_quadrants(top_left: Point) -> list[Point]:
  """Get the 4 quadrants of a 2x2 tile given its top-left corner."""
  x, y = top_left.x, top_left.y
  return [
    Point(x, y),
    Point(x + 1, y),
    Point(x, y + 1),
    Point(x + 1, y + 1),
  ]


def get_2x2_neighbors(top_left: Point) -> list[Point]:
  """
  Get all 8 exterior neighbors of a 2x2 tile.

  For a 2x2 at (x,y), (x+1,y), (x,y+1), (x+1,y+1):
  - Top: (x, y-1), (x+1, y-1)
  - Bottom: (x, y+2), (x+1, y+2)
  - Left: (x-1, y), (x-1, y+1)
  - Right: (x+2, y), (x+2, y+1)
  """
  x, y = top_left.x, top_left.y
  return [
    # Top
    Point(x, y - 1),
    Point(x + 1, y - 1),
    # Bottom
    Point(x, y + 2),
    Point(x + 1, y + 2),
    # Left
    Point(x - 1, y),
    Point(x - 1, y + 1),
    # Right
    Point(x + 2, y),
    Point(x + 2, y + 1),
  ]


def can_place_2x2(
  top_left: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a 2x2 tile can be placed at the given top-left position.

  Rules:
  - All 4 quadrants must be within bounds
  - All 4 quadrants must not be already generated or scheduled
  - No neighbor of the 2x2 may be generated (outside bounds is OK if not generated)
  """
  quadrants = get_2x2_quadrants(top_left)

  # All quadrants must be within bounds and unscheduled
  for q in quadrants:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # No neighbor may be generated
  neighbors = get_2x2_neighbors(top_left)
  for n in neighbors:
    if n in generated:
      return False
    # If neighbor is scheduled but not yet generated, that's also a problem
    # because we're building the plan incrementally
    if n in scheduled:
      return False

  return True


def find_all_valid_2x2_positions(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[Point]:
  """Find all valid top-left positions for 2x2 tiles."""
  valid = []
  # Check all possible 2x2 positions (need room for 2x2)
  for y in range(bounds.top_left.y, bounds.bottom_right.y):  # -1 for 2x2
    for x in range(bounds.top_left.x, bounds.bottom_right.x):
      tl = Point(x, y)
      if can_place_2x2(tl, bounds, generated, scheduled):
        valid.append(tl)
  return valid


def place_2x2_tiles(
  bounds: RectBounds,
  generated: set[Point],
) -> tuple[list[GenerationStep], set[Point]]:
  """
  Place as many 2x2 tiles as possible.

  Returns the generation steps and the set of scheduled quadrants.

  Strategy: Use a greedy approach with gap-leaving pattern.
  We alternate rows of 2x2s with single-column gaps to maximize coverage.
  """
  steps: list[GenerationStep] = []
  scheduled: set[Point] = set()

  # Keep placing 2x2 tiles until no more can be placed
  # Use a simple greedy approach: iterate through all valid positions
  while True:
    valid_positions = find_all_valid_2x2_positions(bounds, generated, scheduled)
    if not valid_positions:
      break

    # Pick the first valid position (top-left to bottom-right order)
    # This creates a natural tiling pattern
    tl = valid_positions[0]
    quadrants = get_2x2_quadrants(tl)

    steps.append(GenerationStep(quadrants=quadrants, step_type="2x2"))
    for q in quadrants:
      scheduled.add(q)

  return steps, scheduled


# =============================================================================
# 2x1 / 1x2 Tile Placement
# =============================================================================


def can_place_2x1_horizontal(
  left: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a horizontal 2x1 tile can be placed at (left.x, left.y) and (left.x+1, left.y).

  Rules (following task 019 strip plan):
  - Both quadrants must be within bounds and unscheduled
  - At least one of top/bottom side must have BOTH neighbors generated
    (can be both sides, like when bridging between two 2x2 tiles)
  - Neither left nor right neighbor may be generated (transverse sides)
  """
  right = Point(left.x + 1, left.y)

  # Both must be in bounds and not already covered
  for q in [left, right]:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # Check transverse (short) sides - must NOT be generated
  left_neighbor = Point(left.x - 1, left.y)
  right_neighbor = Point(right.x + 1, right.y)
  if left_neighbor in generated or left_neighbor in scheduled:
    return False
  if right_neighbor in generated or right_neighbor in scheduled:
    return False

  # Check long sides - AT LEAST ONE side must have BOTH neighbors generated
  # Note: Both sides CAN be generated (e.g., bridging between two 2x2 tiles)
  top_left = Point(left.x, left.y - 1)
  top_right = Point(right.x, right.y - 1)
  bottom_left = Point(left.x, left.y + 1)
  bottom_right = Point(right.x, right.y + 1)

  # "Generated" for the purpose of long-side check includes both
  # pre-existing generated AND scheduled quadrants
  combined = generated | scheduled

  top_both_generated = top_left in combined and top_right in combined
  bottom_both_generated = bottom_left in combined and bottom_right in combined

  # At least one side must be fully generated
  return top_both_generated or bottom_both_generated


def can_place_1x2_vertical(
  top: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a vertical 1x2 tile can be placed at (top.x, top.y) and (top.x, top.y+1).

  Rules (following task 019 strip plan):
  - Both quadrants must be within bounds and unscheduled
  - At least one of left/right side must have BOTH neighbors generated
    (can be both sides, like when bridging between two 2x2 tiles)
  - Neither top nor bottom neighbor may be generated (transverse sides)
  """
  bottom = Point(top.x, top.y + 1)

  # Both must be in bounds and not already covered
  for q in [top, bottom]:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # Check transverse (short) sides - must NOT be generated
  top_neighbor = Point(top.x, top.y - 1)
  bottom_neighbor = Point(bottom.x, bottom.y + 1)
  if top_neighbor in generated or top_neighbor in scheduled:
    return False
  if bottom_neighbor in generated or bottom_neighbor in scheduled:
    return False

  # Check long sides - AT LEAST ONE side must have BOTH neighbors generated
  # Note: Both sides CAN be generated (e.g., bridging between two 2x2 tiles)
  left_top = Point(top.x - 1, top.y)
  left_bottom = Point(top.x - 1, bottom.y)
  right_top = Point(top.x + 1, top.y)
  right_bottom = Point(top.x + 1, bottom.y)

  combined = generated | scheduled

  left_both_generated = left_top in combined and left_bottom in combined
  right_both_generated = right_top in combined and right_bottom in combined

  # At least one side must be fully generated
  return left_both_generated or right_both_generated


def find_all_valid_2x1_positions(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[tuple[Point, str]]:
  """
  Find all valid positions for 2x1 (horizontal) and 1x2 (vertical) tiles.

  Returns list of (position, type) where type is "2x1" or "1x2".

  Following task 019 strip plan pattern:
  - Vertical bridges (1x2) are processed first to connect 2x2 tiles
  - Horizontal bridges (2x1) are processed second to connect to the edge
  """
  valid: list[tuple[Point, str]] = []

  # Check vertical 1x2 tiles FIRST (bridges between 2x2 tiles)
  for y in range(bounds.top_left.y, bounds.bottom_right.y):  # -1 for 2 tall
    for x in range(bounds.top_left.x, bounds.bottom_right.x + 1):
      top = Point(x, y)
      if can_place_1x2_vertical(top, bounds, generated, scheduled):
        valid.append((top, "1x2"))

  # Check horizontal 2x1 tiles SECOND (connect to generation edge)
  for y in range(bounds.top_left.y, bounds.bottom_right.y + 1):
    for x in range(bounds.top_left.x, bounds.bottom_right.x):  # -1 for 2 wide
      left = Point(x, y)
      if can_place_2x1_horizontal(left, bounds, generated, scheduled):
        valid.append((left, "2x1"))

  return valid


def place_2x1_tiles(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> tuple[list[GenerationStep], set[Point]]:
  """
  Place 2x1 and 1x2 tiles where possible.

  These tiles bridge gaps between 2x2 tiles and the generation edge.
  """
  steps: list[GenerationStep] = []
  new_scheduled = set(scheduled)

  # Keep placing tiles until no more can be placed
  while True:
    valid_positions = find_all_valid_2x1_positions(bounds, generated, new_scheduled)
    if not valid_positions:
      break

    # Pick the first valid position
    pos, tile_type = valid_positions[0]

    if tile_type == "2x1":
      quadrants = [pos, Point(pos.x + 1, pos.y)]
    else:  # 1x2
      quadrants = [pos, Point(pos.x, pos.y + 1)]

    steps.append(GenerationStep(quadrants=quadrants, step_type=tile_type))
    for q in quadrants:
      new_scheduled.add(q)

  return steps, new_scheduled


# =============================================================================
# 1x1 Tile Placement
# =============================================================================


def get_2x2_block_positions(p: Point) -> list[list[Point]]:
  """
  Get all 2x2 blocks that contain the point p.

  A point can be in up to 4 different 2x2 blocks:
  - As top-left
  - As top-right
  - As bottom-left
  - As bottom-right
  """
  blocks = []
  # p as top-left
  blocks.append([p, Point(p.x + 1, p.y), Point(p.x, p.y + 1), Point(p.x + 1, p.y + 1)])
  # p as top-right
  blocks.append([Point(p.x - 1, p.y), p, Point(p.x - 1, p.y + 1), Point(p.x, p.y + 1)])
  # p as bottom-left
  blocks.append([Point(p.x, p.y - 1), Point(p.x + 1, p.y - 1), p, Point(p.x + 1, p.y)])
  # p as bottom-right
  blocks.append([Point(p.x - 1, p.y - 1), Point(p.x, p.y - 1), Point(p.x - 1, p.y), p])
  return blocks


def count_generated_in_block(block: list[Point], combined: set[Point]) -> int:
  """Count how many quadrants in a 2x2 block are generated/scheduled."""
  return sum(1 for p in block if p in combined)


def place_1x1_tiles(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[GenerationStep]:
  """
  Fill remaining gaps with 1x1 tiles.

  Prioritize quadrants where 3 of 4 positions in a 2x2 block are generated.
  """
  steps: list[GenerationStep] = []
  combined = generated | scheduled
  new_scheduled = set(scheduled)

  # Find all remaining unscheduled quadrants within bounds
  remaining = [p for p in bounds.all_points() if p not in combined]

  # Sort by priority: quadrants with more generated neighbors in 2x2 blocks first
  def priority(p: Point) -> int:
    blocks = get_2x2_block_positions(p)
    # Find the block with the most generated quadrants
    max_generated = max(
      count_generated_in_block(block, combined | new_scheduled) for block in blocks
    )
    return -max_generated  # Negative for descending sort

  remaining.sort(key=priority)

  for p in remaining:
    if p not in new_scheduled:
      steps.append(GenerationStep(quadrants=[p], step_type="1x1"))
      new_scheduled.add(p)

  return steps


# =============================================================================
# Main Algorithm
# =============================================================================


def create_rectangle_plan(
  bounds: RectBounds,
  generated: set[Point] | None = None,
  queued: set[Point] | None = None,
) -> RectanglePlan:
  """
  Create a generation plan for filling a rectangle.

  Args:
      bounds: The rectangle bounds (top-left to bottom-right inclusive)
      generated: Set of already-generated quadrant positions
      queued: Set of quadrant positions that are in-progress or queued for generation.
              These are treated as "will be generated" for seam detection purposes,
              meaning tiles cannot be placed adjacent to them (to avoid seams).

  Returns:
      RectanglePlan with the sequence of generation steps
  """
  generated = generated or set()
  queued = queued or set()

  # Combine generated and queued for seam detection
  # Queued quadrants are treated as if they will be generated,
  # so we cannot place tiles adjacent to them
  effective_generated = generated | queued

  # Filter out quadrants that are already generated OR queued from the rectangle
  points_to_generate = set(bounds.all_points()) - effective_generated

  if not points_to_generate:
    return RectanglePlan(bounds=bounds, steps=[], pre_generated=generated)

  # Phase 1: Place 2x2 tiles
  steps_2x2, scheduled = place_2x2_tiles(bounds, effective_generated)

  # Phase 2: Place 2x1/1x2 tiles
  steps_2x1, scheduled = place_2x1_tiles(bounds, effective_generated, scheduled)

  # Phase 3: Fill with 1x1 tiles
  steps_1x1 = place_1x1_tiles(bounds, effective_generated, scheduled)

  all_steps = steps_2x2 + steps_2x1 + steps_1x1

  return RectanglePlan(
    bounds=bounds,
    steps=all_steps,
    pre_generated=generated,
  )


def create_rectangle_plan_from_coords(
  tl: tuple[int, int],
  br: tuple[int, int],
  generated: set[tuple[int, int]] | None = None,
) -> RectanglePlan:
  """
  Convenience function to create a plan from coordinate tuples.

  Args:
      tl: Top-left corner (x, y)
      br: Bottom-right corner (x, y)
      generated: Set of already-generated quadrant positions as (x, y) tuples

  Returns:
      RectanglePlan with the sequence of generation steps
  """
  bounds = RectBounds(Point(tl[0], tl[1]), Point(br[0], br[1]))
  gen_points = {Point(x, y) for x, y in (generated or set())}
  return create_rectangle_plan(bounds, gen_points)


# =============================================================================
# Validation
# =============================================================================


def validate_plan(plan: RectanglePlan) -> tuple[bool, list[str]]:
  """
  Validate that a plan covers all required quadrants exactly once.

  Returns (is_valid, error_messages).
  """
  errors: list[str] = []

  # Check that all required quadrants are covered
  required = set(plan.bounds.all_points()) - plan.pre_generated
  covered: set[Point] = set()

  for step in plan.steps:
    for q in step.quadrants:
      if q in covered:
        errors.append(f"Quadrant {q} is covered multiple times")
      covered.add(q)

  missing = required - covered
  if missing:
    errors.append(f"Missing quadrants: {sorted(missing, key=lambda p: (p.y, p.x))}")

  extra = covered - required
  if extra:
    errors.append(f"Extra quadrants: {sorted(extra, key=lambda p: (p.y, p.x))}")

  return len(errors) == 0, errors


def get_plan_summary(plan: RectanglePlan) -> dict[str, Any]:
  """Get a summary of the plan for display."""
  by_type: dict[str, int] = {}
  for step in plan.steps:
    t = step.step_type or f"{len(step.quadrants)}-quad"
    by_type[t] = by_type.get(t, 0) + 1

  total_quadrants = sum(len(step.quadrants) for step in plan.steps)

  return {
    "bounds": {
      "tl": plan.bounds.top_left.to_tuple(),
      "br": plan.bounds.bottom_right.to_tuple(),
      "width": plan.bounds.width,
      "height": plan.bounds.height,
    },
    "pre_generated_count": len(plan.pre_generated),
    "total_steps": len(plan.steps),
    "total_quadrants": total_quadrants,
    "steps_by_type": by_type,
  }

```

```python
"""
Rectangle generation plan algorithm.

Creates a sequence of generation steps for filling a rectangular region
of quadrants, respecting pre-existing generated quadrants and following
tile placement rules.

Tile Placement Rules:
- 2x2: No side of the tile may touch any previously generated quadrants.
- 2x1/1x2: Both quadrants of the 2-long side must touch previously generated
  quadrants along that axis on ONE side. Neither quadrant may touch previously
  generated quadrants along the transverse (short) side.
- 1x1: Ideally generated when 3 other quadrants in a 2x2 block are generated.

Algorithm:
1. Place as many 2x2 tiles as possible
2. Place 2x1/1x2 tiles for remaining gaps
3. Fill remaining single quadrants with 1x1 tiles
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any


@dataclass(frozen=True)
class Point:
  """A 2D point representing a quadrant coordinate."""

  x: int
  y: int

  def __str__(self) -> str:
    return f"({self.x},{self.y})"

  def __add__(self, other: Point) -> Point:
    return Point(self.x + other.x, self.y + other.y)

  @classmethod
  def from_string(cls, s: str) -> Point:
    """Parse a string like '(x,y)' or 'x,y' into a Point."""
    s = s.strip().replace("(", "").replace(")", "").replace(" ", "")
    parts = s.split(",")
    if len(parts) != 2:
      raise ValueError(f"Invalid coordinate format: {s}")
    return cls(int(parts[0]), int(parts[1]))

  def to_tuple(self) -> tuple[int, int]:
    """Convert to a tuple."""
    return (self.x, self.y)


@dataclass
class RectBounds:
  """Bounds of the rectangle to generate."""

  top_left: Point
  bottom_right: Point

  @property
  def width(self) -> int:
    """Width of the rectangle (x extent)."""
    return self.bottom_right.x - self.top_left.x + 1

  @property
  def height(self) -> int:
    """Height of the rectangle (y extent)."""
    return self.bottom_right.y - self.top_left.y + 1

  @property
  def area(self) -> int:
    """Total number of quadrants in the rectangle."""
    return self.width * self.height

  def contains(self, p: Point) -> bool:
    """Check if a point is within the rectangle bounds."""
    return (
      self.top_left.x <= p.x <= self.bottom_right.x
      and self.top_left.y <= p.y <= self.bottom_right.y
    )

  def all_points(self) -> list[Point]:
    """Return all points within the rectangle bounds."""
    return [
      Point(x, y)
      for y in range(self.top_left.y, self.bottom_right.y + 1)
      for x in range(self.top_left.x, self.bottom_right.x + 1)
    ]


@dataclass
class GenerationStep:
  """A single generation step containing quadrants to generate together."""

  quadrants: list[Point]
  step_type: str = ""  # "2x2", "2x1", "1x2", "1x1" for debugging

  def to_dict(self) -> dict[str, Any]:
    """Convert to JSON-serializable dict."""
    return {
      "quadrants": [(q.x, q.y) for q in self.quadrants],
      "type": self.step_type,
    }


@dataclass
class RectanglePlan:
  """A complete generation plan for a rectangle."""

  bounds: RectBounds
  steps: list[GenerationStep] = field(default_factory=list)
  pre_generated: set[Point] = field(default_factory=set)

  def to_dict(self) -> dict[str, Any]:
    """Convert to JSON-serializable dict."""
    return {
      "bounds": {
        "top_left": self.bounds.top_left.to_tuple(),
        "bottom_right": self.bounds.bottom_right.to_tuple(),
      },
      "steps": [step.to_dict() for step in self.steps],
      "pre_generated": [p.to_tuple() for p in self.pre_generated],
    }


# =============================================================================
# 2x2 Tile Placement
# =============================================================================


def get_2x2_quadrants(top_left: Point) -> list[Point]:
  """Get the 4 quadrants of a 2x2 tile given its top-left corner."""
  x, y = top_left.x, top_left.y
  return [
    Point(x, y),
    Point(x + 1, y),
    Point(x, y + 1),
    Point(x + 1, y + 1),
  ]


def get_2x2_neighbors(top_left: Point) -> list[Point]:
  """
  Get all 8 exterior neighbors of a 2x2 tile.

  For a 2x2 at (x,y), (x+1,y), (x,y+1), (x+1,y+1):
  - Top: (x, y-1), (x+1, y-1)
  - Bottom: (x, y+2), (x+1, y+2)
  - Left: (x-1, y), (x-1, y+1)
  - Right: (x+2, y), (x+2, y+1)
  """
  x, y = top_left.x, top_left.y
  return [
    # Top
    Point(x, y - 1),
    Point(x + 1, y - 1),
    # Bottom
    Point(x, y + 2),
    Point(x + 1, y + 2),
    # Left
    Point(x - 1, y),
    Point(x - 1, y + 1),
    # Right
    Point(x + 2, y),
    Point(x + 2, y + 1),
  ]


def can_place_2x2(
  top_left: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a 2x2 tile can be placed at the given top-left position.

  Rules:
  - All 4 quadrants must be within bounds
  - All 4 quadrants must not be already generated or scheduled
  - No neighbor of the 2x2 may be generated (outside bounds is OK if not generated)
  """
  quadrants = get_2x2_quadrants(top_left)

  # All quadrants must be within bounds and unscheduled
  for q in quadrants:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # No neighbor may be generated
  neighbors = get_2x2_neighbors(top_left)
  for n in neighbors:
    if n in generated:
      return False
    # If neighbor is scheduled but not yet generated, that's also a problem
    # because we're building the plan incrementally
    if n in scheduled:
      return False

  return True


def find_all_valid_2x2_positions(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[Point]:
  """Find all valid top-left positions for 2x2 tiles."""
  valid = []
  # Check all possible 2x2 positions (need room for 2x2)
  for y in range(bounds.top_left.y, bounds.bottom_right.y):  # -1 for 2x2
    for x in range(bounds.top_left.x, bounds.bottom_right.x):
      tl = Point(x, y)
      if can_place_2x2(tl, bounds, generated, scheduled):
        valid.append(tl)
  return valid


def place_2x2_tiles(
  bounds: RectBounds,
  generated: set[Point],
) -> tuple[list[GenerationStep], set[Point]]:
  """
  Place as many 2x2 tiles as possible.

  Returns the generation steps and the set of scheduled quadrants.

  Strategy: Use a greedy approach with gap-leaving pattern.
  We alternate rows of 2x2s with single-column gaps to maximize coverage.
  """
  steps: list[GenerationStep] = []
  scheduled: set[Point] = set()

  # Keep placing 2x2 tiles until no more can be placed
  # Use a simple greedy approach: iterate through all valid positions
  while True:
    valid_positions = find_all_valid_2x2_positions(bounds, generated, scheduled)
    if not valid_positions:
      break

    # Pick the first valid position (top-left to bottom-right order)
    # This creates a natural tiling pattern
    tl = valid_positions[0]
    quadrants = get_2x2_quadrants(tl)

    steps.append(GenerationStep(quadrants=quadrants, step_type="2x2"))
    for q in quadrants:
      scheduled.add(q)

  return steps, scheduled


# =============================================================================
# 2x1 / 1x2 Tile Placement
# =============================================================================


def can_place_2x1_horizontal(
  left: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a horizontal 2x1 tile can be placed at (left.x, left.y) and (left.x+1, left.y).

  Rules (following task 019 strip plan):
  - Both quadrants must be within bounds and unscheduled
  - At least one of top/bottom side must have BOTH neighbors generated
    (can be both sides, like when bridging between two 2x2 tiles)
  - Neither left nor right neighbor may be generated (transverse sides)
  """
  right = Point(left.x + 1, left.y)

  # Both must be in bounds and not already covered
  for q in [left, right]:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # Check transverse (short) sides - must NOT be generated
  left_neighbor = Point(left.x - 1, left.y)
  right_neighbor = Point(right.x + 1, right.y)
  if left_neighbor in generated or left_neighbor in scheduled:
    return False
  if right_neighbor in generated or right_neighbor in scheduled:
    return False

  # Check long sides - AT LEAST ONE side must have BOTH neighbors generated
  # Note: Both sides CAN be generated (e.g., bridging between two 2x2 tiles)
  top_left = Point(left.x, left.y - 1)
  top_right = Point(right.x, right.y - 1)
  bottom_left = Point(left.x, left.y + 1)
  bottom_right = Point(right.x, right.y + 1)

  # "Generated" for the purpose of long-side check includes both
  # pre-existing generated AND scheduled quadrants
  combined = generated | scheduled

  top_both_generated = top_left in combined and top_right in combined
  bottom_both_generated = bottom_left in combined and bottom_right in combined

  # At least one side must be fully generated
  return top_both_generated or bottom_both_generated


def can_place_1x2_vertical(
  top: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a vertical 1x2 tile can be placed at (top.x, top.y) and (top.x, top.y+1).

  Rules (following task 019 strip plan):
  - Both quadrants must be within bounds and unscheduled
  - At least one of left/right side must have BOTH neighbors generated
    (can be both sides, like when bridging between two 2x2 tiles)
  - Neither top nor bottom neighbor may be generated (transverse sides)
  """
  bottom = Point(top.x, top.y + 1)

  # Both must be in bounds and not already covered
  for q in [top, bottom]:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # Check transverse (short) sides - must NOT be generated
  top_neighbor = Point(top.x, top.y - 1)
  bottom_neighbor = Point(bottom.x, bottom.y + 1)
  if top_neighbor in generated or top_neighbor in scheduled:
    return False
  if bottom_neighbor in generated or bottom_neighbor in scheduled:
    return False

  # Check long sides - AT LEAST ONE side must have BOTH neighbors generated
  # Note: Both sides CAN be generated (e.g., bridging between two 2x2 tiles)
  left_top = Point(top.x - 1, top.y)
  left_bottom = Point(top.x - 1, bottom.y)
  right_top = Point(top.x + 1, top.y)
  right_bottom = Point(top.x + 1, bottom.y)

  combined = generated | scheduled

  left_both_generated = left_top in combined and left_bottom in combined
  right_both_generated = right_top in combined and right_bottom in combined

  # At least one side must be fully generated
  return left_both_generated or right_both_generated


def find_all_valid_2x1_positions(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[tuple[Point, str]]:
  """
  Find all valid positions for 2x1 (horizontal) and 1x2 (vertical) tiles.

  Returns list of (position, type) where type is "2x1" or "1x2".

  Following task 019 strip plan pattern:
  - Vertical bridges (1x2) are processed first to connect 2x2 tiles
  - Horizontal bridges (2x1) are processed second to connect to the edge
  """
  valid: list[tuple[Point, str]] = []

  # Check vertical 1x2 tiles FIRST (bridges between 2x2 tiles)
  for y in range(bounds.top_left.y, bounds.bottom_right.y):  # -1 for 2 tall
    for x in range(bounds.top_left.x, bounds.bottom_right.x + 1):
      top = Point(x, y)
      if can_place_1x2_vertical(top, bounds, generated, scheduled):
        valid.append((top, "1x2"))

  # Check horizontal 2x1 tiles SECOND (connect to generation edge)
  for y in range(bounds.top_left.y, bounds.bottom_right.y + 1):
    for x in range(bounds.top_left.x, bounds.bottom_right.x):  # -1 for 2 wide
      left = Point(x, y)
      if can_place_2x1_horizontal(left, bounds, generated, scheduled):
        valid.append((left, "2x1"))

  return valid


def place_2x1_tiles(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> tuple[list[GenerationStep], set[Point]]:
  """
  Place 2x1 and 1x2 tiles where possible.

  These tiles bridge gaps between 2x2 tiles and the generation edge.
  """
  steps: list[GenerationStep] = []
  new_scheduled = set(scheduled)

  # Keep placing tiles until no more can be placed
  while True:
    valid_positions = find_all_valid_2x1_positions(bounds, generated, new_scheduled)
    if not valid_positions:
      break

    # Pick the first valid position
    pos, tile_type = valid_positions[0]

    if tile_type == "2x1":
      quadrants = [pos, Point(pos.x + 1, pos.y)]
    else:  # 1x2
      quadrants = [pos, Point(pos.x, pos.y + 1)]

    steps.append(GenerationStep(quadrants=quadrants, step_type=tile_type))
    for q in quadrants:
      new_scheduled.add(q)

  return steps, new_scheduled


# =============================================================================
# 1x1 Tile Placement
# =============================================================================


def get_2x2_block_positions(p: Point) -> list[list[Point]]:
  """
  Get all 2x2 blocks that contain the point p.

  A point can be in up to 4 different 2x2 blocks:
  - As top-left
  - As top-right
  - As bottom-left
  - As bottom-right
  """
  blocks = []
  # p as top-left
  blocks.append([p, Point(p.x + 1, p.y), Point(p.x, p.y + 1), Point(p.x + 1, p.y + 1)])
  # p as top-right
  blocks.append([Point(p.x - 1, p.y), p, Point(p.x - 1, p.y + 1), Point(p.x, p.y + 1)])
  # p as bottom-left
  blocks.append([Point(p.x, p.y - 1), Point(p.x + 1, p.y - 1), p, Point(p.x + 1, p.y)])
  # p as bottom-right
  blocks.append([Point(p.x - 1, p.y - 1), Point(p.x, p.y - 1), Point(p.x - 1, p.y), p])
  return blocks


def count_generated_in_block(block: list[Point], combined: set[Point]) -> int:
  """Count how many quadrants in a 2x2 block are generated/scheduled."""
  return sum(1 for p in block if p in combined)


def place_1x1_tiles(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[GenerationStep]:
  """
  Fill remaining gaps with 1x1 tiles.

  Prioritize quadrants where 3 of 4 positions in a 2x2 block are generated.
  """
  steps: list[GenerationStep] = []
  combined = generated | scheduled
  new_scheduled = set(scheduled)

  # Find all remaining unscheduled quadrants within bounds
  remaining = [p for p in bounds.all_points() if p not in combined]

  # Sort by priority: quadrants with more generated neighbors in 2x2 blocks first
  def priority(p: Point) -> int:
    blocks = get_2x2_block_positions(p)
    # Find the block with the most generated quadrants
    max_generated = max(
      count_generated_in_block(block, combined | new_scheduled) for block in blocks
    )
    return -max_generated  # Negative for descending sort

  remaining.sort(key=priority)

  for p in remaining:
    if p not in new_scheduled:
      steps.append(GenerationStep(quadrants=[p], step_type="1x1"))
      new_scheduled.add(p)

  return steps


# =============================================================================
# Main Algorithm
# =============================================================================


def create_rectangle_plan(
  bounds: RectBounds,
  generated: set[Point] | None = None,
  queued: set[Point] | None = None,
) -> RectanglePlan:
  """
  Create a generation plan for filling a rectangle.

  Args:
      bounds: The rectangle bounds (top-left to bottom-right inclusive)
      generated: Set of already-generated quadrant positions
      queued: Set of quadrant positions that are in-progress or queued for generation.
              These are treated as "will be generated" for seam detection purposes,
              meaning tiles cannot be placed adjacent to them (to avoid seams).

  Returns:
      RectanglePlan with the sequence of generation steps
  """
  generated = generated or set()
  queued = queued or set()

  # Combine generated and queued for seam detection
  # Queued quadrants are treated as if they will be generated,
  # so we cannot place tiles adjacent to them
  effective_generated = generated | queued

  # Filter out quadrants that are already generated OR queued from the rectangle
  points_to_generate = set(bounds.all_points()) - effective_generated

  if not points_to_generate:
    return RectanglePlan(bounds=bounds, steps=[], pre_generated=generated)

  # Phase 1: Place 2x2 tiles
  steps_2x2, scheduled = place_2x2_tiles(bounds, effective_generated)

  # Phase 2: Place 2x1/1x2 tiles
  steps_2x1, scheduled = place_2x1_tiles(bounds, effective_generated, scheduled)

  # Phase 3: Fill with 1x1 tiles
  steps_1x1 = place_1x1_tiles(bounds, effective_generated, scheduled)

  all_steps = steps_2x2 + steps_2x1 + steps_1x1

  return RectanglePlan(
    bounds=bounds,
    steps=all_steps,
    pre_generated=generated,
  )


def create_rectangle_plan_from_coords(
  tl: tuple[int, int],
  br: tuple[int, int],
  generated: set[tuple[int, int]] | None = None,
  queued: set[tuple[int, int]] | None = None,
) -> RectanglePlan:
  """
  Convenience function to create a plan from coordinate tuples.

  Args:
      tl: Top-left corner (x, y)
      br: Bottom-right corner (x, y)
      generated: Set of already-generated quadrant positions as (x, y) tuples
      queued: Set of quadrant positions that are in-progress or queued for generation
              as (x, y) tuples. These are treated as "will be generated" for seam
              detection purposes.

  Returns:
      RectanglePlan with the sequence of generation steps
  """
  bounds = RectBounds(Point(tl[0], tl[1]), Point(br[0], br[1]))
  gen_points = {Point(x, y) for x, y in (generated or set())}
  queued_points = {Point(x, y) for x, y in (queued or set())}
  return create_rectangle_plan(bounds, gen_points, queued_points)


# =============================================================================
# Validation
# =============================================================================


def validate_plan(plan: RectanglePlan) -> tuple[bool, list[str]]:
  """
  Validate that a plan covers all required quadrants exactly once.

  Returns (is_valid, error_messages).
  """
  errors: list[str] = []

  # Check that all required quadrants are covered
  required = set(plan.bounds.all_points()) - plan.pre_generated
  covered: set[Point] = set()

  for step in plan.steps:
    for q in step.quadrants:
      if q in covered:
        errors.append(f"Quadrant {q} is covered multiple times")
      covered.add(q)

  missing = required - covered
  if missing:
    errors.append(f"Missing quadrants: {sorted(missing, key=lambda p: (p.y, p.x))}")

  extra = covered - required
  if extra:
    errors.append(f"Extra quadrants: {sorted(extra, key=lambda p: (p.y, p.x))}")

  return len(errors) == 0, errors


def get_plan_summary(plan: RectanglePlan) -> dict[str, Any]:
  """Get a summary of the plan for display."""
  by_type: dict[str, int] = {}
  for step in plan.steps:
    t = step.step_type or f"{len(step.quadrants)}-quad"
    by_type[t] = by_type.get(t, 0) + 1

  total_quadrants = sum(len(step.quadrants) for step in plan.steps)

  return {
    "bounds": {
      "tl": plan.bounds.top_left.to_tuple(),
      "br": plan.bounds.bottom_right.to_tuple(),
      "width": plan.bounds.width,
      "height": plan.bounds.height,
    },
    "pre_generated_count": len(plan.pre_generated),
    "total_steps": len(plan.steps),
    "total_quadrants": total_quadrants,
    "steps_by_type": by_type,
  }

```

```python
"""
Tests for make_rectangle_plan.py

These tests verify the rectangle generation planning algorithm handles
all cases correctly, including:
- Basic coverage of all quadrants
- 2x2 tile placement rules (no touching generated neighbors)
- 2x1/1x2 tile placement rules (extend from generated edges)
- 1x1 filling of remaining gaps
- Pre-existing generated quadrants
- Various rectangle sizes and configurations
"""

from isometric_nyc.e2e_generation.make_rectangle_plan import (
  GenerationStep,
  Point,
  RectanglePlan,
  RectBounds,
  can_place_1x2_vertical,
  can_place_2x1_horizontal,
  can_place_2x2,
  create_rectangle_plan,
  create_rectangle_plan_from_coords,
  get_2x2_neighbors,
  get_2x2_quadrants,
  get_plan_summary,
  validate_plan,
)

# =============================================================================
# Point Tests
# =============================================================================


class TestPoint:
  def test_str(self) -> None:
    p = Point(3, 5)
    assert str(p) == "(3,5)"

  def test_add(self) -> None:
    p1 = Point(1, 2)
    p2 = Point(3, 4)
    result = p1 + p2
    assert result == Point(4, 6)

  def test_from_string_simple(self) -> None:
    p = Point.from_string("3,5")
    assert p == Point(3, 5)

  def test_from_string_with_parens(self) -> None:
    p = Point.from_string("(3,5)")
    assert p == Point(3, 5)

  def test_from_string_negative(self) -> None:
    p = Point.from_string("-3,-5")
    assert p == Point(-3, -5)

  def test_to_tuple(self) -> None:
    p = Point(3, 5)
    assert p.to_tuple() == (3, 5)


# =============================================================================
# RectBounds Tests
# =============================================================================


class TestRectBounds:
  def test_width_height(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(10, 5))
    assert bounds.width == 11
    assert bounds.height == 6

  def test_area(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(3, 2))
    assert bounds.area == 12  # 4 x 3

  def test_contains(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert bounds.contains(Point(0, 0))
    assert bounds.contains(Point(5, 5))
    assert bounds.contains(Point(3, 3))
    assert not bounds.contains(Point(-1, 0))
    assert not bounds.contains(Point(6, 0))
    assert not bounds.contains(Point(0, -1))
    assert not bounds.contains(Point(0, 6))

  def test_all_points(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(2, 1))
    points = bounds.all_points()
    expected = [
      Point(0, 0),
      Point(1, 0),
      Point(2, 0),
      Point(0, 1),
      Point(1, 1),
      Point(2, 1),
    ]
    assert points == expected


# =============================================================================
# 2x2 Tile Helper Tests
# =============================================================================


class TestGet2x2Quadrants:
  def test_basic(self) -> None:
    quadrants = get_2x2_quadrants(Point(0, 0))
    assert quadrants == [
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
    ]

  def test_offset(self) -> None:
    quadrants = get_2x2_quadrants(Point(5, 3))
    assert quadrants == [
      Point(5, 3),
      Point(6, 3),
      Point(5, 4),
      Point(6, 4),
    ]


class TestGet2x2Neighbors:
  def test_basic(self) -> None:
    neighbors = get_2x2_neighbors(Point(0, 0))
    # Top, Bottom, Left, Right
    expected = [
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 2),
      Point(1, 2),  # Bottom
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(2, 0),
      Point(2, 1),  # Right
    ]
    assert set(neighbors) == set(expected)
    assert len(neighbors) == 8


# =============================================================================
# 2x2 Placement Tests
# =============================================================================


class TestCanPlace2x2:
  def test_empty_grid(self) -> None:
    """2x2 can be placed in empty rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert can_place_2x2(Point(0, 0), bounds, set(), set())

  def test_out_of_bounds(self) -> None:
    """2x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Top-left at (5, 5) would extend to (6, 6)
    assert not can_place_2x2(Point(5, 5), bounds, set(), set())
    # Top-left at (5, 0) would extend to (6, 1)
    assert not can_place_2x2(Point(5, 0), bounds, set(), set())

  def test_neighbor_generated_top(self) -> None:
    """2x2 cannot be placed if top neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Top neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_bottom(self) -> None:
    """2x2 cannot be placed if bottom neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2)}  # Bottom neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_left(self) -> None:
    """2x2 cannot be placed if left neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0)}  # Left neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_right(self) -> None:
    """2x2 cannot be placed if right neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0)}  # Right neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_generated(self) -> None:
    """2x2 cannot be placed if any quadrant is already generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 0)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_scheduled(self) -> None:
    """2x2 cannot be placed if any quadrant is already scheduled."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    scheduled = {Point(1, 1)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, set(), scheduled)

  def test_valid_with_distant_generated(self) -> None:
    """2x2 can be placed if generated quadrants are not neighbors."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(3, 3)}  # Far from (0,0) 2x2
    assert can_place_2x2(Point(0, 0), bounds, generated, set())


# =============================================================================
# 2x1 Horizontal Placement Tests
# =============================================================================


class TestCanPlace2x1Horizontal:
  def test_valid_with_top_generated(self) -> None:
    """2x1 can be placed when top row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(1, -1)}  # Top neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_with_bottom_generated(self) -> None:
    """2x1 can be placed when bottom row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 1), Point(1, 1)}  # Bottom neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_left_generated(self) -> None:
    """2x1 cannot be placed when left neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_right_generated(self) -> None:
    """2x1 cannot be placed when right neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """2x1 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """2x1 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 1),
      Point(1, 1),  # Bottom
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_only_partial_long_side(self) -> None:
    """2x1 cannot be placed when only one of two top neighbors is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Only one top neighbor
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """2x1 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(5, -1), Point(6, -1)}
    # Left at x=5 would extend to x=6
    assert not can_place_2x1_horizontal(Point(5, 0), bounds, generated, set())


# =============================================================================
# 1x2 Vertical Placement Tests
# =============================================================================


class TestCanPlace1x2Vertical:
  def test_valid_with_left_generated(self) -> None:
    """1x2 can be placed when left column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(-1, 1)}  # Left neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_with_right_generated(self) -> None:
    """1x2 can be placed when right column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(1, 0), Point(1, 1)}  # Right neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_top_generated(self) -> None:
    """1x2 cannot be placed when top neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_bottom_generated(self) -> None:
    """1x2 cannot be placed when bottom neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """1x2 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """1x2 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(1, 0),
      Point(1, 1),  # Right
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """1x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 5), Point(-1, 6)}
    # Top at y=5 would extend to y=6
    assert not can_place_1x2_vertical(Point(0, 5), bounds, generated, set())


# =============================================================================
# Full Rectangle Plan Tests
# =============================================================================


class TestCreateRectanglePlan:
  def test_empty_rectangle_no_generated(self) -> None:
    """Empty rectangle with no pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant(self) -> None:
    """Single quadrant rectangle."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_2x2_rectangle(self) -> None:
    """2x2 rectangle should be a single 2x2 tile."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    plan = create_rectangle_plan(bounds)

    # Should have exactly one 2x2 step
    assert len(plan.steps) == 1
    assert len(plan.steps[0].quadrants) == 4
    assert plan.steps[0].step_type == "2x2"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_3x3_rectangle(self) -> None:
    """3x3 rectangle - mix of tiles."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_4x4_rectangle(self) -> None:
    """4x4 rectangle - should fit multiple 2x2 tiles."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have multiple 2x2 tiles
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 1

  def test_wide_rectangle(self) -> None:
    """Wide rectangle (10x2)."""
    bounds = RectBounds(Point(0, 0), Point(9, 1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_tall_rectangle(self) -> None:
    """Tall rectangle (2x10)."""
    bounds = RectBounds(Point(0, 0), Point(1, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_corner(self) -> None:
    """Rectangle with one corner already generated."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should not include (0,0) in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants

  def test_with_pre_generated_edge(self) -> None:
    """Rectangle with one edge already generated (outside the bounds)."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generated row above the rectangle
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_interior(self) -> None:
    """Rectangle with some interior quadrants already generated."""
    bounds = RectBounds(Point(0, 0), Point(4, 4))
    # Some interior points generated
    generated = {Point(2, 2), Point(2, 3)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should not include generated points
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(2, 2) not in all_quadrants
    assert Point(2, 3) not in all_quadrants

  def test_fully_generated(self) -> None:
    """Rectangle where all quadrants are already generated."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 0
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_negative_coordinates(self) -> None:
    """Rectangle in negative coordinate space."""
    bounds = RectBounds(Point(-5, -3), Point(-2, -1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_convenience(self) -> None:
    """Test the convenience function with tuples."""
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3))

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_with_generated(self) -> None:
    """Test convenience function with pre-generated set."""
    generated = {(0, 0), (1, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3), generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants


# =============================================================================
# 2x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x2RuleEnforcement:
  def test_2x2_not_touching_pre_generated(self) -> None:
    """2x2 tiles should not touch pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Pre-generated quadrant at (2, -1) - above the rectangle
    generated = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    # Find all 2x2 steps
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        # Subtract the tile itself
        neighbors -= set(step.quadrants)
        # No neighbor should be pre-generated
        for n in neighbors:
          assert n not in generated, (
            f"2x2 at {step.quadrants} has pre-generated neighbor {n}"
          )

  def test_2x2_not_touching_other_scheduled(self) -> None:
    """2x2 tiles should not touch other scheduled tiles (at placement time)."""
    # This is verified by the algorithm itself - 2x2 tiles can only be placed
    # where no neighbor is scheduled. We verify by checking no 2x2 tiles share edges.
    bounds = RectBounds(Point(0, 0), Point(7, 7))
    plan = create_rectangle_plan(bounds)

    # Collect all 2x2 tile quadrants
    all_2x2_quadrants: set[Point] = set()
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          all_2x2_quadrants.add(q)

    # Check that no 2x2 tiles share edges (they should have gaps)
    # Actually, 2x2 tiles CAN share edges with OTHER 2x2 tiles if they were
    # placed later. The rule is only about pre-existing generated content.
    # Let's just verify the plan is valid.
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# 2x1/1x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x1RuleEnforcement:
  def test_2x1_extends_from_generated_edge(self) -> None:
    """2x1 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Pre-generated row above
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x2_extends_from_generated_edge(self) -> None:
    """1x2 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Pre-generated column to the left
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Plan Summary Tests
# =============================================================================


class TestPlanSummary:
  def test_summary_basic(self) -> None:
    """Test plan summary generation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    summary = get_plan_summary(plan)

    assert summary["bounds"]["width"] == 4
    assert summary["bounds"]["height"] == 4
    assert summary["total_quadrants"] == 16
    assert summary["total_steps"] > 0

  def test_summary_with_pre_generated(self) -> None:
    """Test summary with pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0), Point(0, 1)}
    plan = create_rectangle_plan(bounds, generated)
    summary = get_plan_summary(plan)

    assert summary["pre_generated_count"] == 2
    assert summary["total_quadrants"] == 14  # 16 - 2


# =============================================================================
# Edge Case Tests
# =============================================================================


class TestEdgeCases:
  def test_1x1_rectangle(self) -> None:
    """Smallest possible rectangle."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid

  def test_1x10_strip(self) -> None:
    """Very thin horizontal strip."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_10x1_strip(self) -> None:
    """Very thin vertical strip."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_large_rectangle(self) -> None:
    """Large rectangle (20x20)."""
    bounds = RectBounds(Point(0, 0), Point(19, 19))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have many 2x2 tiles (greedy algorithm may not be optimal)
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 40  # Should have a reasonable number of 2x2 tiles

  def test_checkerboard_pre_generated(self) -> None:
    """Checkerboard pattern of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Checkerboard: every other quadrant
    generated = {Point(x, y) for y in range(6) for x in range(6) if (x + y) % 2 == 0}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # All steps should be 1x1 due to checkerboard pattern
    for step in plan.steps:
      assert step.step_type == "1x1"

  def test_surrounded_by_generated(self) -> None:
    """Rectangle completely surrounded by generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    # Generate a border around the rectangle
    generated: set[Point] = set()
    for x in range(-1, 5):
      generated.add(Point(x, -1))  # Top
      generated.add(Point(x, 4))  # Bottom
    for y in range(0, 4):
      generated.add(Point(-1, y))  # Left
      generated.add(Point(4, y))  # Right

    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles CAN be placed in the interior (shielded by outer ring)
    # But edges should use smaller tiles
    # Check that all 2x2 tiles don't touch the generated border
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # 2x2 at edge positions would have generated neighbors
          # Interior 2x2 (at 1,1 or 1,2 etc.) is OK
          neighbors = [
            Point(q.x - 1, q.y),
            Point(q.x + 1, q.y),
            Point(q.x, q.y - 1),
            Point(q.x, q.y + 1),
          ]
          for n in neighbors:
            if n not in step.quadrants:  # Not part of the tile itself
              assert n not in generated, (
                f"2x2 at {step.quadrants} has neighbor {n} in generated"
              )


# =============================================================================
# Integration Tests - Complex Scenarios
# =============================================================================


class TestComplexScenarios:
  def test_partial_strip_extension(self) -> None:
    """Extending from a partially generated strip."""
    bounds = RectBounds(Point(0, 0), Point(7, 3))
    # Some quadrants above are generated
    generated = {Point(0, -1), Point(1, -1), Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_l_shaped_pre_generated(self) -> None:
    """L-shaped region of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # L-shape in top-left
    generated = {
      Point(-1, 0),
      Point(-1, 1),
      Point(-1, 2),
      Point(0, -1),
      Point(1, -1),
      Point(2, -1),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_island_of_generated(self) -> None:
    """Island of pre-generated quadrants in the middle."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # 2x2 island in the center
    generated = {Point(4, 4), Point(5, 4), Point(4, 5), Point(5, 5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Generated island should not be in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for g in generated:
      assert g not in all_quadrants

  def test_multiple_disjoint_pre_generated(self) -> None:
    """Multiple disjoint pre-generated regions."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # Two separate 2x2 regions
    generated = {
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
      Point(7, 7),
      Point(8, 7),
      Point(7, 8),
      Point(8, 8),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Serialization Tests
# =============================================================================


# =============================================================================
# Task 019 Strip Plan Pattern Tests
# =============================================================================


class TestStripPlanPattern:
  """
  Tests that verify the algorithm follows the 019 strip plan pattern:
  1. 2x2 tiles placed with gaps (every 3rd column)
  2. 1x2 bridges between 2x2 tiles
  3. 2x1 bridges connecting to generation edge
  4. 1x1 fills for remaining gaps
  """

  def test_depth_3_horizontal_pattern(self) -> None:
    """
    Test 6x3 rectangle with bottom edge generated.

    Expected pattern (following 019):
    Row 0-1: 2x2 at (0,0), (3,0) with 1x2 bridges at (2,0), (5,0)
    Row 2:   2x1 at (0,2), (3,2) with 1x1 at (2,2), (5,2)

    Visual:
    A A C B B D   <- row 0 (A=2x2, B=2x2, C=1x2, D=1x2)
    A A C B B D   <- row 1
    E E G F F H   <- row 2 (E=2x1, F=2x1, G=1x1, H=1x1)
    G G G G G G   <- generation edge (y=3, outside rectangle)
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generation edge at y=3 (below rectangle)
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 1x2, 2 2x1, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

    # Verify 2x2 positions
    two_by_two = [s for s in plan.steps if s.step_type == "2x2"]
    two_by_two_positions = [
      (min(q.x for q in s.quadrants), min(q.y for q in s.quadrants)) for s in two_by_two
    ]
    assert (0, 0) in two_by_two_positions
    assert (3, 0) in two_by_two_positions

    # Verify 1x2 positions (between 2x2 tiles)
    one_by_two = [s for s in plan.steps if s.step_type == "1x2"]
    one_by_two_positions = [s.quadrants[0] for s in one_by_two]
    assert Point(2, 0) in one_by_two_positions
    assert Point(5, 0) in one_by_two_positions

    # Verify 2x1 positions (connecting to edge)
    two_by_one = [s for s in plan.steps if s.step_type == "2x1"]
    two_by_one_positions = [
      (min(q.x for q in s.quadrants), s.quadrants[0].y) for s in two_by_one
    ]
    assert (0, 2) in two_by_one_positions
    assert (3, 2) in two_by_one_positions

  def test_depth_3_vertical_pattern(self) -> None:
    """
    Test 3x6 rectangle with left edge generated.

    Similar pattern but rotated 90 degrees.
    """
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Generation edge at x=-1 (left of rectangle)
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type - pattern should be similar
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 2x1, 2 1x2, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

  def test_1x2_bridges_between_2x2(self) -> None:
    """Test that 1x2 bridges correctly connect two 2x2 tiles."""
    # 5x3 rectangle (need 3 rows for 2x2 + bridge pattern)
    # With generation edge at y=3 (one row gap from 2x2 tiles)
    bounds = RectBounds(Point(0, 0), Point(4, 2))
    generated = {Point(x, 3) for x in range(5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Visual:
    # A A C B B   <- row 0 (A=2x2 at 0,0; B=2x2 at 3,0; C=1x2 at 2,0)
    # A A C B B   <- row 1
    # D D E F F   <- row 2 (D=2x1 at 0,2; E=1x1 at 2,2; F=2x1 at 3,2)
    # G G G G G   <- generation edge

    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # 2 2x2 tiles, 1 1x2 bridge, 2 2x1, 1 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 1, f"Expected 1 1x2 bridge, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 1, f"Expected 1 1x1 fill, got {types}"

  def test_order_matches_019_pattern(self) -> None:
    """
    Verify that generation order follows 019:
    1. 2x2 tiles first
    2. 1x2 bridges second
    3. 2x1 bridges third
    4. 1x1 fills last
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Check order
    current_phase = 0
    phase_order = {"2x2": 0, "1x2": 1, "2x1": 2, "1x1": 3}

    for step in plan.steps:
      phase = phase_order.get(step.step_type, 4)
      assert phase >= current_phase, (
        f"Step {step.step_type} appears after later phase. "
        f"Expected order: 2x2, 1x2, 2x1, 1x1"
      )
      current_phase = phase


class TestSerialization:
  def test_step_to_dict(self) -> None:
    """Test GenerationStep serialization."""
    step = GenerationStep(quadrants=[Point(0, 0), Point(1, 0)], step_type="2x1")
    d = step.to_dict()
    assert d["quadrants"] == [(0, 0), (1, 0)]
    assert d["type"] == "2x1"

  def test_plan_to_dict(self) -> None:
    """Test RectanglePlan serialization."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    d = plan.to_dict()

    assert d["bounds"]["top_left"] == (0, 0)
    assert d["bounds"]["bottom_right"] == (3, 3)
    assert len(d["steps"]) > 0


# =============================================================================
# Validation Tests
# =============================================================================


class TestValidation:
  def test_valid_plan(self) -> None:
    """Valid plan should pass validation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid
    assert len(errors) == 0

  def test_detect_duplicate_coverage(self) -> None:
    """Validation should detect duplicate coverage."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with duplicates
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0)]),
        GenerationStep(quadrants=[Point(0, 0), Point(0, 1)]),  # Duplicate!
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("multiple times" in e for e in errors)

  def test_detect_missing_quadrants(self) -> None:
    """Validation should detect missing quadrants."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with missing quadrant
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0), Point(0, 1)]),
        # Missing (1, 1)
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("Missing" in e for e in errors)


# =============================================================================
# Queued Quadrant Tests - Seam Detection with In-Progress/Queued Generations
# =============================================================================


class TestQueuedQuadrants:
  """
  Tests that verify the algorithm correctly considers in-progress and queued
  generations when determining if a seam will be formed.

  Queued quadrants are treated the same as generated quadrants for seam
  detection purposes - tiles cannot be placed adjacent to them.
  """

  def test_queued_quadrants_prevent_2x2_placement(self) -> None:
    """2x2 tiles cannot be placed adjacent to queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # No generated quadrants
    generated: set[Point] = set()
    # But there's a queued generation at (2, -1) - above the rectangle
    queued = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Find all 2x2 steps and verify none touch the queued quadrant
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        neighbors -= set(step.quadrants)
        for n in neighbors:
          assert n not in queued, (
            f"2x2 at {step.quadrants} has queued neighbor {n}"
          )

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_queued_quadrants_excluded_from_plan(self) -> None:
    """Queued quadrants within bounds should not be included in the plan."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Some interior points are queued
    queued = {Point(1, 1), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Should not include queued points in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(1, 1) not in all_quadrants
    assert Point(2, 2) not in all_quadrants

    # Plan should still be valid for non-queued quadrants
    is_valid, errors = validate_plan(plan)
    # Note: validation will fail because queued points are not in pre_generated
    # but the key check is that queued points are not in the plan
    covered = set(all_quadrants)
    expected = set(bounds.all_points()) - queued
    assert covered == expected, f"Expected {expected}, got {covered}"

  def test_queued_row_affects_2x1_placement(self) -> None:
    """2x1 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated: set[Point] = set()
    # Queued row below the rectangle acts like a generated edge
    queued = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 2x1 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at y=3, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"

  def test_queued_column_affects_1x2_placement(self) -> None:
    """1x2 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    generated: set[Point] = set()
    # Queued column to the left acts like a generated edge
    queued = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 1x2 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at x=-1, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"

  def test_mixed_generated_and_queued(self) -> None:
    """Plan should correctly handle both generated and queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Some quadrants are already generated
    generated = {Point(-1, 0), Point(-1, 1)}
    # Some quadrants are queued for generation
    queued = {Point(6, 0), Point(6, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles at left edge should not touch generated at (-1, 0) (-1, 1)
    # 2x2 tiles at right edge should not touch queued at (6, 0) (6, 1)
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # Check no neighbor is generated
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in generated, (
                f"2x2 at {step.quadrants} has generated neighbor {neighbor}"
              )
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_queued_quadrant_in_middle_prevents_2x2(self) -> None:
    """A queued quadrant in the middle should prevent 2x2 placement there."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queued 2x2 block in the center
    queued = {Point(1, 1), Point(2, 1), Point(1, 2), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # No step should include any queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # 2x2 tiles should not be placed adjacent to the queued block
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_from_coords_with_queued(self) -> None:
    """Test convenience function with queued set."""
    generated = {(0, 0), (1, 0)}
    queued = {(2, 0), (3, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (5, 3), generated, queued)

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    # Neither generated nor queued should be in plan
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants
    assert Point(2, 0) not in all_quadrants
    assert Point(3, 0) not in all_quadrants

  def test_fully_queued_rectangle(self) -> None:
    """Rectangle where all quadrants are queued should produce empty plan."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated: set[Point] = set()
    queued = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated, queued)

    assert len(plan.steps) == 0

  def test_queued_prevents_seam_with_future_generation(self) -> None:
    """
    Queued quadrants should be treated as if they will be generated,
    preventing seams with future generations.

    Scenario: User is generating a 2x2 at (0,0)-(1,1) and there's already
    a queued 2x2 at (2,0)-(3,1). The plan should not place tiles that
    would create a seam between them.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 3))
    generated: set[Point] = set()
    # First 2x2 is queued
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # The plan should not include the queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants

    # 2x2 tiles should not be placed at (2,0) because it would touch
    # the queued 2x2 at x=1
    for step in plan.steps:
      if step.step_type == "2x2":
        step_tl = min(q.x for q in step.quadrants), min(q.y for q in step.quadrants)
        # If there's a 2x2 at (2, 0), it would have neighbors at (1, 0) and (1, 1)
        # which are queued
        if step_tl == (2, 0):
          assert False, "2x2 at (2,0) would create seam with queued (0,0)-(1,1)"

```

```python
"""
Tests for make_rectangle_plan.py

These tests verify the rectangle generation planning algorithm handles
all cases correctly, including:
- Basic coverage of all quadrants
- 2x2 tile placement rules (no touching generated neighbors)
- 2x1/1x2 tile placement rules (extend from generated edges)
- 1x1 filling of remaining gaps
- Pre-existing generated quadrants
- Various rectangle sizes and configurations
"""

from isometric_nyc.e2e_generation.make_rectangle_plan import (
  GenerationStep,
  Point,
  RectanglePlan,
  RectBounds,
  can_place_1x2_vertical,
  can_place_2x1_horizontal,
  can_place_2x2,
  create_rectangle_plan,
  create_rectangle_plan_from_coords,
  get_2x2_neighbors,
  get_2x2_quadrants,
  get_plan_summary,
  validate_plan,
)

# =============================================================================
# Point Tests
# =============================================================================


class TestPoint:
  def test_str(self) -> None:
    p = Point(3, 5)
    assert str(p) == "(3,5)"

  def test_add(self) -> None:
    p1 = Point(1, 2)
    p2 = Point(3, 4)
    result = p1 + p2
    assert result == Point(4, 6)

  def test_from_string_simple(self) -> None:
    p = Point.from_string("3,5")
    assert p == Point(3, 5)

  def test_from_string_with_parens(self) -> None:
    p = Point.from_string("(3,5)")
    assert p == Point(3, 5)

  def test_from_string_negative(self) -> None:
    p = Point.from_string("-3,-5")
    assert p == Point(-3, -5)

  def test_to_tuple(self) -> None:
    p = Point(3, 5)
    assert p.to_tuple() == (3, 5)


# =============================================================================
# RectBounds Tests
# =============================================================================


class TestRectBounds:
  def test_width_height(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(10, 5))
    assert bounds.width == 11
    assert bounds.height == 6

  def test_area(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(3, 2))
    assert bounds.area == 12  # 4 x 3

  def test_contains(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert bounds.contains(Point(0, 0))
    assert bounds.contains(Point(5, 5))
    assert bounds.contains(Point(3, 3))
    assert not bounds.contains(Point(-1, 0))
    assert not bounds.contains(Point(6, 0))
    assert not bounds.contains(Point(0, -1))
    assert not bounds.contains(Point(0, 6))

  def test_all_points(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(2, 1))
    points = bounds.all_points()
    expected = [
      Point(0, 0),
      Point(1, 0),
      Point(2, 0),
      Point(0, 1),
      Point(1, 1),
      Point(2, 1),
    ]
    assert points == expected


# =============================================================================
# 2x2 Tile Helper Tests
# =============================================================================


class TestGet2x2Quadrants:
  def test_basic(self) -> None:
    quadrants = get_2x2_quadrants(Point(0, 0))
    assert quadrants == [
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
    ]

  def test_offset(self) -> None:
    quadrants = get_2x2_quadrants(Point(5, 3))
    assert quadrants == [
      Point(5, 3),
      Point(6, 3),
      Point(5, 4),
      Point(6, 4),
    ]


class TestGet2x2Neighbors:
  def test_basic(self) -> None:
    neighbors = get_2x2_neighbors(Point(0, 0))
    # Top, Bottom, Left, Right
    expected = [
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 2),
      Point(1, 2),  # Bottom
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(2, 0),
      Point(2, 1),  # Right
    ]
    assert set(neighbors) == set(expected)
    assert len(neighbors) == 8


# =============================================================================
# 2x2 Placement Tests
# =============================================================================


class TestCanPlace2x2:
  def test_empty_grid(self) -> None:
    """2x2 can be placed in empty rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert can_place_2x2(Point(0, 0), bounds, set(), set())

  def test_out_of_bounds(self) -> None:
    """2x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Top-left at (5, 5) would extend to (6, 6)
    assert not can_place_2x2(Point(5, 5), bounds, set(), set())
    # Top-left at (5, 0) would extend to (6, 1)
    assert not can_place_2x2(Point(5, 0), bounds, set(), set())

  def test_neighbor_generated_top(self) -> None:
    """2x2 cannot be placed if top neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Top neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_bottom(self) -> None:
    """2x2 cannot be placed if bottom neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2)}  # Bottom neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_left(self) -> None:
    """2x2 cannot be placed if left neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0)}  # Left neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_right(self) -> None:
    """2x2 cannot be placed if right neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0)}  # Right neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_generated(self) -> None:
    """2x2 cannot be placed if any quadrant is already generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 0)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_scheduled(self) -> None:
    """2x2 cannot be placed if any quadrant is already scheduled."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    scheduled = {Point(1, 1)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, set(), scheduled)

  def test_valid_with_distant_generated(self) -> None:
    """2x2 can be placed if generated quadrants are not neighbors."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(3, 3)}  # Far from (0,0) 2x2
    assert can_place_2x2(Point(0, 0), bounds, generated, set())


# =============================================================================
# 2x1 Horizontal Placement Tests
# =============================================================================


class TestCanPlace2x1Horizontal:
  def test_valid_with_top_generated(self) -> None:
    """2x1 can be placed when top row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(1, -1)}  # Top neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_with_bottom_generated(self) -> None:
    """2x1 can be placed when bottom row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 1), Point(1, 1)}  # Bottom neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_left_generated(self) -> None:
    """2x1 cannot be placed when left neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_right_generated(self) -> None:
    """2x1 cannot be placed when right neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """2x1 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """2x1 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 1),
      Point(1, 1),  # Bottom
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_only_partial_long_side(self) -> None:
    """2x1 cannot be placed when only one of two top neighbors is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Only one top neighbor
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """2x1 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(5, -1), Point(6, -1)}
    # Left at x=5 would extend to x=6
    assert not can_place_2x1_horizontal(Point(5, 0), bounds, generated, set())


# =============================================================================
# 1x2 Vertical Placement Tests
# =============================================================================


class TestCanPlace1x2Vertical:
  def test_valid_with_left_generated(self) -> None:
    """1x2 can be placed when left column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(-1, 1)}  # Left neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_with_right_generated(self) -> None:
    """1x2 can be placed when right column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(1, 0), Point(1, 1)}  # Right neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_top_generated(self) -> None:
    """1x2 cannot be placed when top neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_bottom_generated(self) -> None:
    """1x2 cannot be placed when bottom neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """1x2 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """1x2 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(1, 0),
      Point(1, 1),  # Right
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """1x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 5), Point(-1, 6)}
    # Top at y=5 would extend to y=6
    assert not can_place_1x2_vertical(Point(0, 5), bounds, generated, set())


# =============================================================================
# Full Rectangle Plan Tests
# =============================================================================


class TestCreateRectanglePlan:
  def test_empty_rectangle_no_generated(self) -> None:
    """Empty rectangle with no pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant(self) -> None:
    """Single quadrant rectangle."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_2x2_rectangle(self) -> None:
    """2x2 rectangle should be a single 2x2 tile."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    plan = create_rectangle_plan(bounds)

    # Should have exactly one 2x2 step
    assert len(plan.steps) == 1
    assert len(plan.steps[0].quadrants) == 4
    assert plan.steps[0].step_type == "2x2"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_3x3_rectangle(self) -> None:
    """3x3 rectangle - mix of tiles."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_4x4_rectangle(self) -> None:
    """4x4 rectangle - should fit multiple 2x2 tiles."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have multiple 2x2 tiles
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 1

  def test_wide_rectangle(self) -> None:
    """Wide rectangle (10x2)."""
    bounds = RectBounds(Point(0, 0), Point(9, 1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_tall_rectangle(self) -> None:
    """Tall rectangle (2x10)."""
    bounds = RectBounds(Point(0, 0), Point(1, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_corner(self) -> None:
    """Rectangle with one corner already generated."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should not include (0,0) in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants

  def test_with_pre_generated_edge(self) -> None:
    """Rectangle with one edge already generated (outside the bounds)."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generated row above the rectangle
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_interior(self) -> None:
    """Rectangle with some interior quadrants already generated."""
    bounds = RectBounds(Point(0, 0), Point(4, 4))
    # Some interior points generated
    generated = {Point(2, 2), Point(2, 3)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should not include generated points
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(2, 2) not in all_quadrants
    assert Point(2, 3) not in all_quadrants

  def test_fully_generated(self) -> None:
    """Rectangle where all quadrants are already generated."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 0
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_negative_coordinates(self) -> None:
    """Rectangle in negative coordinate space."""
    bounds = RectBounds(Point(-5, -3), Point(-2, -1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_convenience(self) -> None:
    """Test the convenience function with tuples."""
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3))

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_with_generated(self) -> None:
    """Test convenience function with pre-generated set."""
    generated = {(0, 0), (1, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3), generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants


# =============================================================================
# 2x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x2RuleEnforcement:
  def test_2x2_not_touching_pre_generated(self) -> None:
    """2x2 tiles should not touch pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Pre-generated quadrant at (2, -1) - above the rectangle
    generated = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    # Find all 2x2 steps
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        # Subtract the tile itself
        neighbors -= set(step.quadrants)
        # No neighbor should be pre-generated
        for n in neighbors:
          assert n not in generated, (
            f"2x2 at {step.quadrants} has pre-generated neighbor {n}"
          )

  def test_2x2_not_touching_other_scheduled(self) -> None:
    """2x2 tiles should not touch other scheduled tiles (at placement time)."""
    # This is verified by the algorithm itself - 2x2 tiles can only be placed
    # where no neighbor is scheduled. We verify by checking no 2x2 tiles share edges.
    bounds = RectBounds(Point(0, 0), Point(7, 7))
    plan = create_rectangle_plan(bounds)

    # Collect all 2x2 tile quadrants
    all_2x2_quadrants: set[Point] = set()
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          all_2x2_quadrants.add(q)

    # Check that no 2x2 tiles share edges (they should have gaps)
    # Actually, 2x2 tiles CAN share edges with OTHER 2x2 tiles if they were
    # placed later. The rule is only about pre-existing generated content.
    # Let's just verify the plan is valid.
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# 2x1/1x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x1RuleEnforcement:
  def test_2x1_extends_from_generated_edge(self) -> None:
    """2x1 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Pre-generated row above
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x2_extends_from_generated_edge(self) -> None:
    """1x2 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Pre-generated column to the left
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Plan Summary Tests
# =============================================================================


class TestPlanSummary:
  def test_summary_basic(self) -> None:
    """Test plan summary generation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    summary = get_plan_summary(plan)

    assert summary["bounds"]["width"] == 4
    assert summary["bounds"]["height"] == 4
    assert summary["total_quadrants"] == 16
    assert summary["total_steps"] > 0

  def test_summary_with_pre_generated(self) -> None:
    """Test summary with pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0), Point(0, 1)}
    plan = create_rectangle_plan(bounds, generated)
    summary = get_plan_summary(plan)

    assert summary["pre_generated_count"] == 2
    assert summary["total_quadrants"] == 14  # 16 - 2


# =============================================================================
# Edge Case Tests
# =============================================================================


class TestEdgeCases:
  def test_1x1_rectangle(self) -> None:
    """Smallest possible rectangle."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid

  def test_1x10_strip(self) -> None:
    """Very thin horizontal strip."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_10x1_strip(self) -> None:
    """Very thin vertical strip."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_large_rectangle(self) -> None:
    """Large rectangle (20x20)."""
    bounds = RectBounds(Point(0, 0), Point(19, 19))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have many 2x2 tiles (greedy algorithm may not be optimal)
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 40  # Should have a reasonable number of 2x2 tiles

  def test_checkerboard_pre_generated(self) -> None:
    """Checkerboard pattern of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Checkerboard: every other quadrant
    generated = {Point(x, y) for y in range(6) for x in range(6) if (x + y) % 2 == 0}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # All steps should be 1x1 due to checkerboard pattern
    for step in plan.steps:
      assert step.step_type == "1x1"

  def test_surrounded_by_generated(self) -> None:
    """Rectangle completely surrounded by generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    # Generate a border around the rectangle
    generated: set[Point] = set()
    for x in range(-1, 5):
      generated.add(Point(x, -1))  # Top
      generated.add(Point(x, 4))  # Bottom
    for y in range(0, 4):
      generated.add(Point(-1, y))  # Left
      generated.add(Point(4, y))  # Right

    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles CAN be placed in the interior (shielded by outer ring)
    # But edges should use smaller tiles
    # Check that all 2x2 tiles don't touch the generated border
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # 2x2 at edge positions would have generated neighbors
          # Interior 2x2 (at 1,1 or 1,2 etc.) is OK
          neighbors = [
            Point(q.x - 1, q.y),
            Point(q.x + 1, q.y),
            Point(q.x, q.y - 1),
            Point(q.x, q.y + 1),
          ]
          for n in neighbors:
            if n not in step.quadrants:  # Not part of the tile itself
              assert n not in generated, (
                f"2x2 at {step.quadrants} has neighbor {n} in generated"
              )


# =============================================================================
# Integration Tests - Complex Scenarios
# =============================================================================


class TestComplexScenarios:
  def test_partial_strip_extension(self) -> None:
    """Extending from a partially generated strip."""
    bounds = RectBounds(Point(0, 0), Point(7, 3))
    # Some quadrants above are generated
    generated = {Point(0, -1), Point(1, -1), Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_l_shaped_pre_generated(self) -> None:
    """L-shaped region of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # L-shape in top-left
    generated = {
      Point(-1, 0),
      Point(-1, 1),
      Point(-1, 2),
      Point(0, -1),
      Point(1, -1),
      Point(2, -1),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_island_of_generated(self) -> None:
    """Island of pre-generated quadrants in the middle."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # 2x2 island in the center
    generated = {Point(4, 4), Point(5, 4), Point(4, 5), Point(5, 5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Generated island should not be in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for g in generated:
      assert g not in all_quadrants

  def test_multiple_disjoint_pre_generated(self) -> None:
    """Multiple disjoint pre-generated regions."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # Two separate 2x2 regions
    generated = {
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
      Point(7, 7),
      Point(8, 7),
      Point(7, 8),
      Point(8, 8),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Serialization Tests
# =============================================================================


# =============================================================================
# Task 019 Strip Plan Pattern Tests
# =============================================================================


class TestStripPlanPattern:
  """
  Tests that verify the algorithm follows the 019 strip plan pattern:
  1. 2x2 tiles placed with gaps (every 3rd column)
  2. 1x2 bridges between 2x2 tiles
  3. 2x1 bridges connecting to generation edge
  4. 1x1 fills for remaining gaps
  """

  def test_depth_3_horizontal_pattern(self) -> None:
    """
    Test 6x3 rectangle with bottom edge generated.

    Expected pattern (following 019):
    Row 0-1: 2x2 at (0,0), (3,0) with 1x2 bridges at (2,0), (5,0)
    Row 2:   2x1 at (0,2), (3,2) with 1x1 at (2,2), (5,2)

    Visual:
    A A C B B D   <- row 0 (A=2x2, B=2x2, C=1x2, D=1x2)
    A A C B B D   <- row 1
    E E G F F H   <- row 2 (E=2x1, F=2x1, G=1x1, H=1x1)
    G G G G G G   <- generation edge (y=3, outside rectangle)
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generation edge at y=3 (below rectangle)
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 1x2, 2 2x1, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

    # Verify 2x2 positions
    two_by_two = [s for s in plan.steps if s.step_type == "2x2"]
    two_by_two_positions = [
      (min(q.x for q in s.quadrants), min(q.y for q in s.quadrants)) for s in two_by_two
    ]
    assert (0, 0) in two_by_two_positions
    assert (3, 0) in two_by_two_positions

    # Verify 1x2 positions (between 2x2 tiles)
    one_by_two = [s for s in plan.steps if s.step_type == "1x2"]
    one_by_two_positions = [s.quadrants[0] for s in one_by_two]
    assert Point(2, 0) in one_by_two_positions
    assert Point(5, 0) in one_by_two_positions

    # Verify 2x1 positions (connecting to edge)
    two_by_one = [s for s in plan.steps if s.step_type == "2x1"]
    two_by_one_positions = [
      (min(q.x for q in s.quadrants), s.quadrants[0].y) for s in two_by_one
    ]
    assert (0, 2) in two_by_one_positions
    assert (3, 2) in two_by_one_positions

  def test_depth_3_vertical_pattern(self) -> None:
    """
    Test 3x6 rectangle with left edge generated.

    Similar pattern but rotated 90 degrees.
    """
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Generation edge at x=-1 (left of rectangle)
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type - pattern should be similar
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 2x1, 2 1x2, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

  def test_1x2_bridges_between_2x2(self) -> None:
    """Test that 1x2 bridges correctly connect two 2x2 tiles."""
    # 5x3 rectangle (need 3 rows for 2x2 + bridge pattern)
    # With generation edge at y=3 (one row gap from 2x2 tiles)
    bounds = RectBounds(Point(0, 0), Point(4, 2))
    generated = {Point(x, 3) for x in range(5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Visual:
    # A A C B B   <- row 0 (A=2x2 at 0,0; B=2x2 at 3,0; C=1x2 at 2,0)
    # A A C B B   <- row 1
    # D D E F F   <- row 2 (D=2x1 at 0,2; E=1x1 at 2,2; F=2x1 at 3,2)
    # G G G G G   <- generation edge

    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # 2 2x2 tiles, 1 1x2 bridge, 2 2x1, 1 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 1, f"Expected 1 1x2 bridge, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 1, f"Expected 1 1x1 fill, got {types}"

  def test_order_matches_019_pattern(self) -> None:
    """
    Verify that generation order follows 019:
    1. 2x2 tiles first
    2. 1x2 bridges second
    3. 2x1 bridges third
    4. 1x1 fills last
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Check order
    current_phase = 0
    phase_order = {"2x2": 0, "1x2": 1, "2x1": 2, "1x1": 3}

    for step in plan.steps:
      phase = phase_order.get(step.step_type, 4)
      assert phase >= current_phase, (
        f"Step {step.step_type} appears after later phase. "
        f"Expected order: 2x2, 1x2, 2x1, 1x1"
      )
      current_phase = phase


class TestSerialization:
  def test_step_to_dict(self) -> None:
    """Test GenerationStep serialization."""
    step = GenerationStep(quadrants=[Point(0, 0), Point(1, 0)], step_type="2x1")
    d = step.to_dict()
    assert d["quadrants"] == [(0, 0), (1, 0)]
    assert d["type"] == "2x1"

  def test_plan_to_dict(self) -> None:
    """Test RectanglePlan serialization."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    d = plan.to_dict()

    assert d["bounds"]["top_left"] == (0, 0)
    assert d["bounds"]["bottom_right"] == (3, 3)
    assert len(d["steps"]) > 0


# =============================================================================
# Validation Tests
# =============================================================================


class TestValidation:
  def test_valid_plan(self) -> None:
    """Valid plan should pass validation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid
    assert len(errors) == 0

  def test_detect_duplicate_coverage(self) -> None:
    """Validation should detect duplicate coverage."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with duplicates
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0)]),
        GenerationStep(quadrants=[Point(0, 0), Point(0, 1)]),  # Duplicate!
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("multiple times" in e for e in errors)

  def test_detect_missing_quadrants(self) -> None:
    """Validation should detect missing quadrants."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with missing quadrant
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0), Point(0, 1)]),
        # Missing (1, 1)
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("Missing" in e for e in errors)


# =============================================================================
# Queued Quadrant Tests - Seam Detection with In-Progress/Queued Generations
# =============================================================================


class TestQueuedQuadrants:
  """
  Tests that verify the algorithm correctly considers in-progress and queued
  generations when determining if a seam will be formed.

  Queued quadrants are treated the same as generated quadrants for seam
  detection purposes - tiles cannot be placed adjacent to them.
  """

  def test_queued_quadrants_prevent_2x2_placement(self) -> None:
    """2x2 tiles cannot be placed adjacent to queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # No generated quadrants
    generated: set[Point] = set()
    # But there's a queued generation at (2, -1) - above the rectangle
    queued = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Find all 2x2 steps and verify none touch the queued quadrant
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        neighbors -= set(step.quadrants)
        for n in neighbors:
          assert n not in queued, (
            f"2x2 at {step.quadrants} has queued neighbor {n}"
          )

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_queued_quadrants_excluded_from_plan(self) -> None:
    """Queued quadrants within bounds should not be included in the plan."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Some interior points are queued
    queued = {Point(1, 1), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Should not include queued points in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(1, 1) not in all_quadrants
    assert Point(2, 2) not in all_quadrants

    # Plan should still be valid for non-queued quadrants
    is_valid, errors = validate_plan(plan)
    # Note: validation will fail because queued points are not in pre_generated
    # but the key check is that queued points are not in the plan
    covered = set(all_quadrants)
    expected = set(bounds.all_points()) - queued
    assert covered == expected, f"Expected {expected}, got {covered}"

  def test_queued_row_affects_2x1_placement(self) -> None:
    """2x1 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated: set[Point] = set()
    # Queued row below the rectangle acts like a generated edge
    queued = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 2x1 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at y=3, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"

  def test_queued_column_affects_1x2_placement(self) -> None:
    """1x2 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    generated: set[Point] = set()
    # Queued column to the left acts like a generated edge
    queued = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 1x2 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at x=-1, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"

  def test_mixed_generated_and_queued(self) -> None:
    """Plan should correctly handle both generated and queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Some quadrants are already generated
    generated = {Point(-1, 0), Point(-1, 1)}
    # Some quadrants are queued for generation
    queued = {Point(6, 0), Point(6, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles at left edge should not touch generated at (-1, 0) (-1, 1)
    # 2x2 tiles at right edge should not touch queued at (6, 0) (6, 1)
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # Check no neighbor is generated
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in generated, (
                f"2x2 at {step.quadrants} has generated neighbor {neighbor}"
              )
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_queued_quadrant_in_middle_prevents_2x2(self) -> None:
    """A queued quadrant in the middle should prevent 2x2 placement there."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queued 2x2 block in the center
    queued = {Point(1, 1), Point(2, 1), Point(1, 2), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # No step should include any queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # 2x2 tiles should not be placed adjacent to the queued block
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_from_coords_with_queued(self) -> None:
    """Test convenience function with queued set."""
    generated = {(0, 0), (1, 0)}
    queued = {(2, 0), (3, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (5, 3), generated, queued)

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    # Neither generated nor queued should be in plan
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants
    assert Point(2, 0) not in all_quadrants
    assert Point(3, 0) not in all_quadrants

  def test_fully_queued_rectangle(self) -> None:
    """Rectangle where all quadrants are queued should produce empty plan."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated: set[Point] = set()
    queued = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated, queued)

    assert len(plan.steps) == 0

  def test_queued_prevents_seam_with_future_generation(self) -> None:
    """
    Queued quadrants should be treated as if they will be generated,
    preventing seams with future generations.

    Scenario: User is generating a 2x2 at (0,0)-(1,1) and there's already
    a queued 2x2 at (2,0)-(3,1). The plan should not place tiles that
    would create a seam between them.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 3))
    generated: set[Point] = set()
    # First 2x2 is queued
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # The plan should not include the queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants

    # Verify the plan covers exactly the non-queued quadrants
    expected = set(bounds.all_points()) - queued
    covered = set(all_quadrants)
    assert covered == expected, f"Expected {expected}, got {covered}"

    # 2x2 tiles should not be placed at (2,0) because it would touch
    # the queued 2x2 at x=1
    for step in plan.steps:
      if step.step_type == "2x2":
        step_tl = min(q.x for q in step.quadrants), min(q.y for q in step.quadrants)
        # If there's a 2x2 at (2, 0), it would have neighbors at (1, 0) and (1, 1)
        # which are queued
        if step_tl == (2, 0):
          assert False, "2x2 at (2,0) would create seam with queued (0,0)-(1,1)"

```

Done! I've updated the rectangle plan generation to consider in-progress and queued generations when determining seam formation.

**Changes to `make_rectangle_plan.py`:**

1. **`create_rectangle_plan()`** - Added a new `queued` parameter:
   - Accepts `queued: set[Point] | None` for quadrants that are in-progress or queued
   - Combines `generated` and `queued` into `effective_generated` for seam detection
   - Tiles cannot be placed adjacent to queued quadrants (same as generated)
   - Queued quadrants within bounds are excluded from the plan

2. **`create_rectangle_plan_from_coords()`** - Added corresponding `queued` parameter:
   - Accepts `queued: set[tuple[int, int]] | None` for convenience
   - Converts tuples to Points and passes to `create_rectangle_plan`

**New tests added (`TestQueuedQuadrants` class):**

| Test | Description |
|------|-------------|
| `test_queued_quadrants_prevent_2x2_placement` | 2x2 tiles cannot be placed adjacent to queued quadrants |
| `test_queued_quadrants_excluded_from_plan` | Queued quadrants within bounds are not included in the plan |
| `test_queued_row_affects_2x1_placement` | Queued row acts as a generated edge for 2x1 placement |
| `test_queued_column_affects_1x2_placement` | Queued column acts as a generated edge for 1x2 placement |
| `test_mixed_generated_and_queued` | Both generated and queued are considered for seam detection |
| `test_queued_quadrant_in_middle_prevents_2x2` | Middle queued block prevents adjacent 2x2 placement |
| `test_from_coords_with_queued` | Convenience function works with queued parameter |
| `test_fully_queued_rectangle` | Fully queued rectangle produces empty plan |
| `test_queued_prevents_seam_with_future_generation` | Validates no seam between plan and queued 2x2 |

All 143 tests pass!

---

**User**

OK next thing to fix - a lot of the generations are failing because of "Context quadrants missing" erorrs - remember, a generation *must* have a 2x2 set of quadrants that are either already generated or to be generated. Please update the tests and logic accordingly

---

**Cursor**

I need to understand the context requirements better. Let me look at the current placement logic:

I understand the issue. The context requirement is:
- **2x2**: Self-contained (all 4 quadrants being generated)
- **2x1/1x2**: Needs the other 2 quadrants of a 2x2 block to be generated/scheduled
- **1x1**: Needs 3 of 4 quadrants in a 2x2 block to be generated/scheduled

The current 2x1/1x2 logic already enforces this, but 1x1 only *prefers* it (for ordering) without *requiring* it. Let me fix this:

```python
"""
Rectangle generation plan algorithm.

Creates a sequence of generation steps for filling a rectangular region
of quadrants, respecting pre-existing generated quadrants and following
tile placement rules.

Tile Placement Rules:
- 2x2: No side of the tile may touch any previously generated quadrants.
- 2x1/1x2: Both quadrants of the 2-long side must touch previously generated
  quadrants along that axis on ONE side. Neither quadrant may touch previously
  generated quadrants along the transverse (short) side.
- 1x1: Ideally generated when 3 other quadrants in a 2x2 block are generated.

Algorithm:
1. Place as many 2x2 tiles as possible
2. Place 2x1/1x2 tiles for remaining gaps
3. Fill remaining single quadrants with 1x1 tiles
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any


@dataclass(frozen=True)
class Point:
  """A 2D point representing a quadrant coordinate."""

  x: int
  y: int

  def __str__(self) -> str:
    return f"({self.x},{self.y})"

  def __add__(self, other: Point) -> Point:
    return Point(self.x + other.x, self.y + other.y)

  @classmethod
  def from_string(cls, s: str) -> Point:
    """Parse a string like '(x,y)' or 'x,y' into a Point."""
    s = s.strip().replace("(", "").replace(")", "").replace(" ", "")
    parts = s.split(",")
    if len(parts) != 2:
      raise ValueError(f"Invalid coordinate format: {s}")
    return cls(int(parts[0]), int(parts[1]))

  def to_tuple(self) -> tuple[int, int]:
    """Convert to a tuple."""
    return (self.x, self.y)


@dataclass
class RectBounds:
  """Bounds of the rectangle to generate."""

  top_left: Point
  bottom_right: Point

  @property
  def width(self) -> int:
    """Width of the rectangle (x extent)."""
    return self.bottom_right.x - self.top_left.x + 1

  @property
  def height(self) -> int:
    """Height of the rectangle (y extent)."""
    return self.bottom_right.y - self.top_left.y + 1

  @property
  def area(self) -> int:
    """Total number of quadrants in the rectangle."""
    return self.width * self.height

  def contains(self, p: Point) -> bool:
    """Check if a point is within the rectangle bounds."""
    return (
      self.top_left.x <= p.x <= self.bottom_right.x
      and self.top_left.y <= p.y <= self.bottom_right.y
    )

  def all_points(self) -> list[Point]:
    """Return all points within the rectangle bounds."""
    return [
      Point(x, y)
      for y in range(self.top_left.y, self.bottom_right.y + 1)
      for x in range(self.top_left.x, self.bottom_right.x + 1)
    ]


@dataclass
class GenerationStep:
  """A single generation step containing quadrants to generate together."""

  quadrants: list[Point]
  step_type: str = ""  # "2x2", "2x1", "1x2", "1x1" for debugging

  def to_dict(self) -> dict[str, Any]:
    """Convert to JSON-serializable dict."""
    return {
      "quadrants": [(q.x, q.y) for q in self.quadrants],
      "type": self.step_type,
    }


@dataclass
class RectanglePlan:
  """A complete generation plan for a rectangle."""

  bounds: RectBounds
  steps: list[GenerationStep] = field(default_factory=list)
  pre_generated: set[Point] = field(default_factory=set)

  def to_dict(self) -> dict[str, Any]:
    """Convert to JSON-serializable dict."""
    return {
      "bounds": {
        "top_left": self.bounds.top_left.to_tuple(),
        "bottom_right": self.bounds.bottom_right.to_tuple(),
      },
      "steps": [step.to_dict() for step in self.steps],
      "pre_generated": [p.to_tuple() for p in self.pre_generated],
    }


# =============================================================================
# 2x2 Tile Placement
# =============================================================================


def get_2x2_quadrants(top_left: Point) -> list[Point]:
  """Get the 4 quadrants of a 2x2 tile given its top-left corner."""
  x, y = top_left.x, top_left.y
  return [
    Point(x, y),
    Point(x + 1, y),
    Point(x, y + 1),
    Point(x + 1, y + 1),
  ]


def get_2x2_neighbors(top_left: Point) -> list[Point]:
  """
  Get all 8 exterior neighbors of a 2x2 tile.

  For a 2x2 at (x,y), (x+1,y), (x,y+1), (x+1,y+1):
  - Top: (x, y-1), (x+1, y-1)
  - Bottom: (x, y+2), (x+1, y+2)
  - Left: (x-1, y), (x-1, y+1)
  - Right: (x+2, y), (x+2, y+1)
  """
  x, y = top_left.x, top_left.y
  return [
    # Top
    Point(x, y - 1),
    Point(x + 1, y - 1),
    # Bottom
    Point(x, y + 2),
    Point(x + 1, y + 2),
    # Left
    Point(x - 1, y),
    Point(x - 1, y + 1),
    # Right
    Point(x + 2, y),
    Point(x + 2, y + 1),
  ]


def can_place_2x2(
  top_left: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a 2x2 tile can be placed at the given top-left position.

  Rules:
  - All 4 quadrants must be within bounds
  - All 4 quadrants must not be already generated or scheduled
  - No neighbor of the 2x2 may be generated (outside bounds is OK if not generated)
  """
  quadrants = get_2x2_quadrants(top_left)

  # All quadrants must be within bounds and unscheduled
  for q in quadrants:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # No neighbor may be generated
  neighbors = get_2x2_neighbors(top_left)
  for n in neighbors:
    if n in generated:
      return False
    # If neighbor is scheduled but not yet generated, that's also a problem
    # because we're building the plan incrementally
    if n in scheduled:
      return False

  return True


def find_all_valid_2x2_positions(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[Point]:
  """Find all valid top-left positions for 2x2 tiles."""
  valid = []
  # Check all possible 2x2 positions (need room for 2x2)
  for y in range(bounds.top_left.y, bounds.bottom_right.y):  # -1 for 2x2
    for x in range(bounds.top_left.x, bounds.bottom_right.x):
      tl = Point(x, y)
      if can_place_2x2(tl, bounds, generated, scheduled):
        valid.append(tl)
  return valid


def place_2x2_tiles(
  bounds: RectBounds,
  generated: set[Point],
) -> tuple[list[GenerationStep], set[Point]]:
  """
  Place as many 2x2 tiles as possible.

  Returns the generation steps and the set of scheduled quadrants.

  Strategy: Use a greedy approach with gap-leaving pattern.
  We alternate rows of 2x2s with single-column gaps to maximize coverage.
  """
  steps: list[GenerationStep] = []
  scheduled: set[Point] = set()

  # Keep placing 2x2 tiles until no more can be placed
  # Use a simple greedy approach: iterate through all valid positions
  while True:
    valid_positions = find_all_valid_2x2_positions(bounds, generated, scheduled)
    if not valid_positions:
      break

    # Pick the first valid position (top-left to bottom-right order)
    # This creates a natural tiling pattern
    tl = valid_positions[0]
    quadrants = get_2x2_quadrants(tl)

    steps.append(GenerationStep(quadrants=quadrants, step_type="2x2"))
    for q in quadrants:
      scheduled.add(q)

  return steps, scheduled


# =============================================================================
# 2x1 / 1x2 Tile Placement
# =============================================================================


def can_place_2x1_horizontal(
  left: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a horizontal 2x1 tile can be placed at (left.x, left.y) and (left.x+1, left.y).

  Rules (following task 019 strip plan):
  - Both quadrants must be within bounds and unscheduled
  - At least one of top/bottom side must have BOTH neighbors generated
    (can be both sides, like when bridging between two 2x2 tiles)
  - Neither left nor right neighbor may be generated (transverse sides)
  """
  right = Point(left.x + 1, left.y)

  # Both must be in bounds and not already covered
  for q in [left, right]:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # Check transverse (short) sides - must NOT be generated
  left_neighbor = Point(left.x - 1, left.y)
  right_neighbor = Point(right.x + 1, right.y)
  if left_neighbor in generated or left_neighbor in scheduled:
    return False
  if right_neighbor in generated or right_neighbor in scheduled:
    return False

  # Check long sides - AT LEAST ONE side must have BOTH neighbors generated
  # Note: Both sides CAN be generated (e.g., bridging between two 2x2 tiles)
  top_left = Point(left.x, left.y - 1)
  top_right = Point(right.x, right.y - 1)
  bottom_left = Point(left.x, left.y + 1)
  bottom_right = Point(right.x, right.y + 1)

  # "Generated" for the purpose of long-side check includes both
  # pre-existing generated AND scheduled quadrants
  combined = generated | scheduled

  top_both_generated = top_left in combined and top_right in combined
  bottom_both_generated = bottom_left in combined and bottom_right in combined

  # At least one side must be fully generated
  return top_both_generated or bottom_both_generated


def can_place_1x2_vertical(
  top: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a vertical 1x2 tile can be placed at (top.x, top.y) and (top.x, top.y+1).

  Rules (following task 019 strip plan):
  - Both quadrants must be within bounds and unscheduled
  - At least one of left/right side must have BOTH neighbors generated
    (can be both sides, like when bridging between two 2x2 tiles)
  - Neither top nor bottom neighbor may be generated (transverse sides)
  """
  bottom = Point(top.x, top.y + 1)

  # Both must be in bounds and not already covered
  for q in [top, bottom]:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # Check transverse (short) sides - must NOT be generated
  top_neighbor = Point(top.x, top.y - 1)
  bottom_neighbor = Point(bottom.x, bottom.y + 1)
  if top_neighbor in generated or top_neighbor in scheduled:
    return False
  if bottom_neighbor in generated or bottom_neighbor in scheduled:
    return False

  # Check long sides - AT LEAST ONE side must have BOTH neighbors generated
  # Note: Both sides CAN be generated (e.g., bridging between two 2x2 tiles)
  left_top = Point(top.x - 1, top.y)
  left_bottom = Point(top.x - 1, bottom.y)
  right_top = Point(top.x + 1, top.y)
  right_bottom = Point(top.x + 1, bottom.y)

  combined = generated | scheduled

  left_both_generated = left_top in combined and left_bottom in combined
  right_both_generated = right_top in combined and right_bottom in combined

  # At least one side must be fully generated
  return left_both_generated or right_both_generated


def find_all_valid_2x1_positions(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[tuple[Point, str]]:
  """
  Find all valid positions for 2x1 (horizontal) and 1x2 (vertical) tiles.

  Returns list of (position, type) where type is "2x1" or "1x2".

  Following task 019 strip plan pattern:
  - Vertical bridges (1x2) are processed first to connect 2x2 tiles
  - Horizontal bridges (2x1) are processed second to connect to the edge
  """
  valid: list[tuple[Point, str]] = []

  # Check vertical 1x2 tiles FIRST (bridges between 2x2 tiles)
  for y in range(bounds.top_left.y, bounds.bottom_right.y):  # -1 for 2 tall
    for x in range(bounds.top_left.x, bounds.bottom_right.x + 1):
      top = Point(x, y)
      if can_place_1x2_vertical(top, bounds, generated, scheduled):
        valid.append((top, "1x2"))

  # Check horizontal 2x1 tiles SECOND (connect to generation edge)
  for y in range(bounds.top_left.y, bounds.bottom_right.y + 1):
    for x in range(bounds.top_left.x, bounds.bottom_right.x):  # -1 for 2 wide
      left = Point(x, y)
      if can_place_2x1_horizontal(left, bounds, generated, scheduled):
        valid.append((left, "2x1"))

  return valid


def place_2x1_tiles(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> tuple[list[GenerationStep], set[Point]]:
  """
  Place 2x1 and 1x2 tiles where possible.

  These tiles bridge gaps between 2x2 tiles and the generation edge.
  """
  steps: list[GenerationStep] = []
  new_scheduled = set(scheduled)

  # Keep placing tiles until no more can be placed
  while True:
    valid_positions = find_all_valid_2x1_positions(bounds, generated, new_scheduled)
    if not valid_positions:
      break

    # Pick the first valid position
    pos, tile_type = valid_positions[0]

    if tile_type == "2x1":
      quadrants = [pos, Point(pos.x + 1, pos.y)]
    else:  # 1x2
      quadrants = [pos, Point(pos.x, pos.y + 1)]

    steps.append(GenerationStep(quadrants=quadrants, step_type=tile_type))
    for q in quadrants:
      new_scheduled.add(q)

  return steps, new_scheduled


# =============================================================================
# 1x1 Tile Placement
# =============================================================================


def get_2x2_block_positions(p: Point) -> list[list[Point]]:
  """
  Get all 2x2 blocks that contain the point p.

  A point can be in up to 4 different 2x2 blocks:
  - As top-left
  - As top-right
  - As bottom-left
  - As bottom-right
  """
  blocks = []
  # p as top-left
  blocks.append([p, Point(p.x + 1, p.y), Point(p.x, p.y + 1), Point(p.x + 1, p.y + 1)])
  # p as top-right
  blocks.append([Point(p.x - 1, p.y), p, Point(p.x - 1, p.y + 1), Point(p.x, p.y + 1)])
  # p as bottom-left
  blocks.append([Point(p.x, p.y - 1), Point(p.x + 1, p.y - 1), p, Point(p.x + 1, p.y)])
  # p as bottom-right
  blocks.append([Point(p.x - 1, p.y - 1), Point(p.x, p.y - 1), Point(p.x - 1, p.y), p])
  return blocks


def count_generated_in_block(block: list[Point], combined: set[Point]) -> int:
  """Count how many quadrants in a 2x2 block are generated/scheduled."""
  return sum(1 for p in block if p in combined)


def has_valid_2x2_context(
  quadrants: list[Point],
  combined: set[Point],
) -> bool:
  """
  Check if the given quadrants have valid 2x2 context for generation.

  For a generation to succeed, there must exist at least one 2x2 block
  where all 4 quadrants are either:
  - Part of the generation (in quadrants list)
  - Already generated/scheduled (in combined set)

  Args:
      quadrants: The quadrants being generated
      combined: Set of already generated or scheduled quadrants

  Returns:
      True if there's at least one valid 2x2 block providing full context
  """
  quadrant_set = set(quadrants)

  # For each quadrant, check all 2x2 blocks it belongs to
  for q in quadrants:
    blocks = get_2x2_block_positions(q)
    for block in blocks:
      # Check if all 4 positions in this block are covered
      all_covered = all(p in quadrant_set or p in combined for p in block)
      if all_covered:
        return True

  return False


def can_place_1x1(p: Point, combined: set[Point]) -> bool:
  """
  Check if a 1x1 tile can be placed at point p with valid context.

  A 1x1 tile requires that 3 of 4 quadrants in at least one 2x2 block
  containing p are already generated/scheduled (providing context).
  """
  blocks = get_2x2_block_positions(p)
  for block in blocks:
    # Count how many OTHER quadrants (not p) are generated
    other_generated = sum(1 for q in block if q != p and q in combined)
    if other_generated >= 3:
      return True
  return False


def place_1x1_tiles(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[GenerationStep]:
  """
  Fill remaining gaps with 1x1 tiles.

  A 1x1 tile can only be placed if 3 of 4 quadrants in at least one
  2x2 block containing it are already generated/scheduled.
  This ensures valid context for the generation.
  """
  steps: list[GenerationStep] = []
  combined = generated | scheduled
  new_scheduled = set(scheduled)

  # Find all remaining unscheduled quadrants within bounds
  remaining = [p for p in bounds.all_points() if p not in combined]

  # Sort by priority: quadrants with more generated neighbors in 2x2 blocks first
  # This helps ensure we place tiles in an order that maintains context
  def priority(p: Point) -> int:
    blocks = get_2x2_block_positions(p)
    max_generated = max(
      count_generated_in_block(block, combined | new_scheduled) for block in blocks
    )
    return -max_generated  # Negative for descending sort

  remaining.sort(key=priority)

  # Keep iterating until no more valid placements
  # (as each placement may enable new valid placements)
  changed = True
  while changed:
    changed = False
    for p in list(remaining):
      if p in new_scheduled:
        remaining.remove(p)
        continue

      # Check if this 1x1 has valid context
      if can_place_1x1(p, combined | new_scheduled):
        steps.append(GenerationStep(quadrants=[p], step_type="1x1"))
        new_scheduled.add(p)
        remaining.remove(p)
        changed = True

  return steps


# =============================================================================
# Main Algorithm
# =============================================================================


def create_rectangle_plan(
  bounds: RectBounds,
  generated: set[Point] | None = None,
  queued: set[Point] | None = None,
) -> RectanglePlan:
  """
  Create a generation plan for filling a rectangle.

  Args:
      bounds: The rectangle bounds (top-left to bottom-right inclusive)
      generated: Set of already-generated quadrant positions
      queued: Set of quadrant positions that are in-progress or queued for generation.
              These are treated as "will be generated" for seam detection purposes,
              meaning tiles cannot be placed adjacent to them (to avoid seams).

  Returns:
      RectanglePlan with the sequence of generation steps
  """
  generated = generated or set()
  queued = queued or set()

  # Combine generated and queued for seam detection
  # Queued quadrants are treated as if they will be generated,
  # so we cannot place tiles adjacent to them
  effective_generated = generated | queued

  # Filter out quadrants that are already generated OR queued from the rectangle
  points_to_generate = set(bounds.all_points()) - effective_generated

  if not points_to_generate:
    return RectanglePlan(bounds=bounds, steps=[], pre_generated=generated)

  # Phase 1: Place 2x2 tiles
  steps_2x2, scheduled = place_2x2_tiles(bounds, effective_generated)

  # Phase 2: Place 2x1/1x2 tiles
  steps_2x1, scheduled = place_2x1_tiles(bounds, effective_generated, scheduled)

  # Phase 3: Fill with 1x1 tiles
  steps_1x1 = place_1x1_tiles(bounds, effective_generated, scheduled)

  all_steps = steps_2x2 + steps_2x1 + steps_1x1

  return RectanglePlan(
    bounds=bounds,
    steps=all_steps,
    pre_generated=generated,
  )


def create_rectangle_plan_from_coords(
  tl: tuple[int, int],
  br: tuple[int, int],
  generated: set[tuple[int, int]] | None = None,
  queued: set[tuple[int, int]] | None = None,
) -> RectanglePlan:
  """
  Convenience function to create a plan from coordinate tuples.

  Args:
      tl: Top-left corner (x, y)
      br: Bottom-right corner (x, y)
      generated: Set of already-generated quadrant positions as (x, y) tuples
      queued: Set of quadrant positions that are in-progress or queued for generation
              as (x, y) tuples. These are treated as "will be generated" for seam
              detection purposes.

  Returns:
      RectanglePlan with the sequence of generation steps
  """
  bounds = RectBounds(Point(tl[0], tl[1]), Point(br[0], br[1]))
  gen_points = {Point(x, y) for x, y in (generated or set())}
  queued_points = {Point(x, y) for x, y in (queued or set())}
  return create_rectangle_plan(bounds, gen_points, queued_points)


# =============================================================================
# Validation
# =============================================================================


def validate_plan(plan: RectanglePlan) -> tuple[bool, list[str]]:
  """
  Validate that a plan covers all required quadrants exactly once.

  Returns (is_valid, error_messages).
  """
  errors: list[str] = []

  # Check that all required quadrants are covered
  required = set(plan.bounds.all_points()) - plan.pre_generated
  covered: set[Point] = set()

  for step in plan.steps:
    for q in step.quadrants:
      if q in covered:
        errors.append(f"Quadrant {q} is covered multiple times")
      covered.add(q)

  missing = required - covered
  if missing:
    errors.append(f"Missing quadrants: {sorted(missing, key=lambda p: (p.y, p.x))}")

  extra = covered - required
  if extra:
    errors.append(f"Extra quadrants: {sorted(extra, key=lambda p: (p.y, p.x))}")

  return len(errors) == 0, errors


def get_plan_summary(plan: RectanglePlan) -> dict[str, Any]:
  """Get a summary of the plan for display."""
  by_type: dict[str, int] = {}
  for step in plan.steps:
    t = step.step_type or f"{len(step.quadrants)}-quad"
    by_type[t] = by_type.get(t, 0) + 1

  total_quadrants = sum(len(step.quadrants) for step in plan.steps)

  return {
    "bounds": {
      "tl": plan.bounds.top_left.to_tuple(),
      "br": plan.bounds.bottom_right.to_tuple(),
      "width": plan.bounds.width,
      "height": plan.bounds.height,
    },
    "pre_generated_count": len(plan.pre_generated),
    "total_steps": len(plan.steps),
    "total_quadrants": total_quadrants,
    "steps_by_type": by_type,
  }

```

```python
"""
Rectangle generation plan algorithm.

Creates a sequence of generation steps for filling a rectangular region
of quadrants, respecting pre-existing generated quadrants and following
tile placement rules.

Tile Placement Rules:
- 2x2: No side of the tile may touch any previously generated quadrants.
- 2x1/1x2: Both quadrants of the 2-long side must touch previously generated
  quadrants along that axis on ONE side. Neither quadrant may touch previously
  generated quadrants along the transverse (short) side.
- 1x1: Ideally generated when 3 other quadrants in a 2x2 block are generated.

Algorithm:
1. Place as many 2x2 tiles as possible
2. Place 2x1/1x2 tiles for remaining gaps
3. Fill remaining single quadrants with 1x1 tiles
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any


@dataclass(frozen=True)
class Point:
  """A 2D point representing a quadrant coordinate."""

  x: int
  y: int

  def __str__(self) -> str:
    return f"({self.x},{self.y})"

  def __add__(self, other: Point) -> Point:
    return Point(self.x + other.x, self.y + other.y)

  @classmethod
  def from_string(cls, s: str) -> Point:
    """Parse a string like '(x,y)' or 'x,y' into a Point."""
    s = s.strip().replace("(", "").replace(")", "").replace(" ", "")
    parts = s.split(",")
    if len(parts) != 2:
      raise ValueError(f"Invalid coordinate format: {s}")
    return cls(int(parts[0]), int(parts[1]))

  def to_tuple(self) -> tuple[int, int]:
    """Convert to a tuple."""
    return (self.x, self.y)


@dataclass
class RectBounds:
  """Bounds of the rectangle to generate."""

  top_left: Point
  bottom_right: Point

  @property
  def width(self) -> int:
    """Width of the rectangle (x extent)."""
    return self.bottom_right.x - self.top_left.x + 1

  @property
  def height(self) -> int:
    """Height of the rectangle (y extent)."""
    return self.bottom_right.y - self.top_left.y + 1

  @property
  def area(self) -> int:
    """Total number of quadrants in the rectangle."""
    return self.width * self.height

  def contains(self, p: Point) -> bool:
    """Check if a point is within the rectangle bounds."""
    return (
      self.top_left.x <= p.x <= self.bottom_right.x
      and self.top_left.y <= p.y <= self.bottom_right.y
    )

  def all_points(self) -> list[Point]:
    """Return all points within the rectangle bounds."""
    return [
      Point(x, y)
      for y in range(self.top_left.y, self.bottom_right.y + 1)
      for x in range(self.top_left.x, self.bottom_right.x + 1)
    ]


@dataclass
class GenerationStep:
  """A single generation step containing quadrants to generate together."""

  quadrants: list[Point]
  step_type: str = ""  # "2x2", "2x1", "1x2", "1x1" for debugging

  def to_dict(self) -> dict[str, Any]:
    """Convert to JSON-serializable dict."""
    return {
      "quadrants": [(q.x, q.y) for q in self.quadrants],
      "type": self.step_type,
    }


@dataclass
class RectanglePlan:
  """A complete generation plan for a rectangle."""

  bounds: RectBounds
  steps: list[GenerationStep] = field(default_factory=list)
  pre_generated: set[Point] = field(default_factory=set)

  def to_dict(self) -> dict[str, Any]:
    """Convert to JSON-serializable dict."""
    return {
      "bounds": {
        "top_left": self.bounds.top_left.to_tuple(),
        "bottom_right": self.bounds.bottom_right.to_tuple(),
      },
      "steps": [step.to_dict() for step in self.steps],
      "pre_generated": [p.to_tuple() for p in self.pre_generated],
    }


# =============================================================================
# 2x2 Tile Placement
# =============================================================================


def get_2x2_quadrants(top_left: Point) -> list[Point]:
  """Get the 4 quadrants of a 2x2 tile given its top-left corner."""
  x, y = top_left.x, top_left.y
  return [
    Point(x, y),
    Point(x + 1, y),
    Point(x, y + 1),
    Point(x + 1, y + 1),
  ]


def get_2x2_neighbors(top_left: Point) -> list[Point]:
  """
  Get all 8 exterior neighbors of a 2x2 tile.

  For a 2x2 at (x,y), (x+1,y), (x,y+1), (x+1,y+1):
  - Top: (x, y-1), (x+1, y-1)
  - Bottom: (x, y+2), (x+1, y+2)
  - Left: (x-1, y), (x-1, y+1)
  - Right: (x+2, y), (x+2, y+1)
  """
  x, y = top_left.x, top_left.y
  return [
    # Top
    Point(x, y - 1),
    Point(x + 1, y - 1),
    # Bottom
    Point(x, y + 2),
    Point(x + 1, y + 2),
    # Left
    Point(x - 1, y),
    Point(x - 1, y + 1),
    # Right
    Point(x + 2, y),
    Point(x + 2, y + 1),
  ]


def can_place_2x2(
  top_left: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a 2x2 tile can be placed at the given top-left position.

  Rules:
  - All 4 quadrants must be within bounds
  - All 4 quadrants must not be already generated or scheduled
  - No neighbor of the 2x2 may be generated (outside bounds is OK if not generated)
  """
  quadrants = get_2x2_quadrants(top_left)

  # All quadrants must be within bounds and unscheduled
  for q in quadrants:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # No neighbor may be generated
  neighbors = get_2x2_neighbors(top_left)
  for n in neighbors:
    if n in generated:
      return False
    # If neighbor is scheduled but not yet generated, that's also a problem
    # because we're building the plan incrementally
    if n in scheduled:
      return False

  return True


def find_all_valid_2x2_positions(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[Point]:
  """Find all valid top-left positions for 2x2 tiles."""
  valid = []
  # Check all possible 2x2 positions (need room for 2x2)
  for y in range(bounds.top_left.y, bounds.bottom_right.y):  # -1 for 2x2
    for x in range(bounds.top_left.x, bounds.bottom_right.x):
      tl = Point(x, y)
      if can_place_2x2(tl, bounds, generated, scheduled):
        valid.append(tl)
  return valid


def place_2x2_tiles(
  bounds: RectBounds,
  generated: set[Point],
) -> tuple[list[GenerationStep], set[Point]]:
  """
  Place as many 2x2 tiles as possible.

  Returns the generation steps and the set of scheduled quadrants.

  Strategy: Use a greedy approach with gap-leaving pattern.
  We alternate rows of 2x2s with single-column gaps to maximize coverage.
  """
  steps: list[GenerationStep] = []
  scheduled: set[Point] = set()

  # Keep placing 2x2 tiles until no more can be placed
  # Use a simple greedy approach: iterate through all valid positions
  while True:
    valid_positions = find_all_valid_2x2_positions(bounds, generated, scheduled)
    if not valid_positions:
      break

    # Pick the first valid position (top-left to bottom-right order)
    # This creates a natural tiling pattern
    tl = valid_positions[0]
    quadrants = get_2x2_quadrants(tl)

    steps.append(GenerationStep(quadrants=quadrants, step_type="2x2"))
    for q in quadrants:
      scheduled.add(q)

  return steps, scheduled


# =============================================================================
# 2x1 / 1x2 Tile Placement
# =============================================================================


def can_place_2x1_horizontal(
  left: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a horizontal 2x1 tile can be placed at (left.x, left.y) and (left.x+1, left.y).

  Rules (following task 019 strip plan):
  - Both quadrants must be within bounds and unscheduled
  - At least one of top/bottom side must have BOTH neighbors generated
    (can be both sides, like when bridging between two 2x2 tiles)
  - Neither left nor right neighbor may be generated (transverse sides)
  """
  right = Point(left.x + 1, left.y)

  # Both must be in bounds and not already covered
  for q in [left, right]:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # Check transverse (short) sides - must NOT be generated
  left_neighbor = Point(left.x - 1, left.y)
  right_neighbor = Point(right.x + 1, right.y)
  if left_neighbor in generated or left_neighbor in scheduled:
    return False
  if right_neighbor in generated or right_neighbor in scheduled:
    return False

  # Check long sides - AT LEAST ONE side must have BOTH neighbors generated
  # Note: Both sides CAN be generated (e.g., bridging between two 2x2 tiles)
  top_left = Point(left.x, left.y - 1)
  top_right = Point(right.x, right.y - 1)
  bottom_left = Point(left.x, left.y + 1)
  bottom_right = Point(right.x, right.y + 1)

  # "Generated" for the purpose of long-side check includes both
  # pre-existing generated AND scheduled quadrants
  combined = generated | scheduled

  top_both_generated = top_left in combined and top_right in combined
  bottom_both_generated = bottom_left in combined and bottom_right in combined

  # At least one side must be fully generated
  return top_both_generated or bottom_both_generated


def can_place_1x2_vertical(
  top: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a vertical 1x2 tile can be placed at (top.x, top.y) and (top.x, top.y+1).

  Rules (following task 019 strip plan):
  - Both quadrants must be within bounds and unscheduled
  - At least one of left/right side must have BOTH neighbors generated
    (can be both sides, like when bridging between two 2x2 tiles)
  - Neither top nor bottom neighbor may be generated (transverse sides)
  """
  bottom = Point(top.x, top.y + 1)

  # Both must be in bounds and not already covered
  for q in [top, bottom]:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # Check transverse (short) sides - must NOT be generated
  top_neighbor = Point(top.x, top.y - 1)
  bottom_neighbor = Point(bottom.x, bottom.y + 1)
  if top_neighbor in generated or top_neighbor in scheduled:
    return False
  if bottom_neighbor in generated or bottom_neighbor in scheduled:
    return False

  # Check long sides - AT LEAST ONE side must have BOTH neighbors generated
  # Note: Both sides CAN be generated (e.g., bridging between two 2x2 tiles)
  left_top = Point(top.x - 1, top.y)
  left_bottom = Point(top.x - 1, bottom.y)
  right_top = Point(top.x + 1, top.y)
  right_bottom = Point(top.x + 1, bottom.y)

  combined = generated | scheduled

  left_both_generated = left_top in combined and left_bottom in combined
  right_both_generated = right_top in combined and right_bottom in combined

  # At least one side must be fully generated
  return left_both_generated or right_both_generated


def find_all_valid_2x1_positions(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[tuple[Point, str]]:
  """
  Find all valid positions for 2x1 (horizontal) and 1x2 (vertical) tiles.

  Returns list of (position, type) where type is "2x1" or "1x2".

  Following task 019 strip plan pattern:
  - Vertical bridges (1x2) are processed first to connect 2x2 tiles
  - Horizontal bridges (2x1) are processed second to connect to the edge
  """
  valid: list[tuple[Point, str]] = []

  # Check vertical 1x2 tiles FIRST (bridges between 2x2 tiles)
  for y in range(bounds.top_left.y, bounds.bottom_right.y):  # -1 for 2 tall
    for x in range(bounds.top_left.x, bounds.bottom_right.x + 1):
      top = Point(x, y)
      if can_place_1x2_vertical(top, bounds, generated, scheduled):
        valid.append((top, "1x2"))

  # Check horizontal 2x1 tiles SECOND (connect to generation edge)
  for y in range(bounds.top_left.y, bounds.bottom_right.y + 1):
    for x in range(bounds.top_left.x, bounds.bottom_right.x):  # -1 for 2 wide
      left = Point(x, y)
      if can_place_2x1_horizontal(left, bounds, generated, scheduled):
        valid.append((left, "2x1"))

  return valid


def place_2x1_tiles(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> tuple[list[GenerationStep], set[Point]]:
  """
  Place 2x1 and 1x2 tiles where possible.

  These tiles bridge gaps between 2x2 tiles and the generation edge.
  """
  steps: list[GenerationStep] = []
  new_scheduled = set(scheduled)

  # Keep placing tiles until no more can be placed
  while True:
    valid_positions = find_all_valid_2x1_positions(bounds, generated, new_scheduled)
    if not valid_positions:
      break

    # Pick the first valid position
    pos, tile_type = valid_positions[0]

    if tile_type == "2x1":
      quadrants = [pos, Point(pos.x + 1, pos.y)]
    else:  # 1x2
      quadrants = [pos, Point(pos.x, pos.y + 1)]

    steps.append(GenerationStep(quadrants=quadrants, step_type=tile_type))
    for q in quadrants:
      new_scheduled.add(q)

  return steps, new_scheduled


# =============================================================================
# 1x1 Tile Placement
# =============================================================================


def get_2x2_block_positions(p: Point) -> list[list[Point]]:
  """
  Get all 2x2 blocks that contain the point p.

  A point can be in up to 4 different 2x2 blocks:
  - As top-left
  - As top-right
  - As bottom-left
  - As bottom-right
  """
  blocks = []
  # p as top-left
  blocks.append([p, Point(p.x + 1, p.y), Point(p.x, p.y + 1), Point(p.x + 1, p.y + 1)])
  # p as top-right
  blocks.append([Point(p.x - 1, p.y), p, Point(p.x - 1, p.y + 1), Point(p.x, p.y + 1)])
  # p as bottom-left
  blocks.append([Point(p.x, p.y - 1), Point(p.x + 1, p.y - 1), p, Point(p.x + 1, p.y)])
  # p as bottom-right
  blocks.append([Point(p.x - 1, p.y - 1), Point(p.x, p.y - 1), Point(p.x - 1, p.y), p])
  return blocks


def count_generated_in_block(block: list[Point], combined: set[Point]) -> int:
  """Count how many quadrants in a 2x2 block are generated/scheduled."""
  return sum(1 for p in block if p in combined)


def has_valid_2x2_context(
  quadrants: list[Point],
  combined: set[Point],
) -> bool:
  """
  Check if the given quadrants have valid 2x2 context for generation.

  For a generation to succeed, there must exist at least one 2x2 block
  where all 4 quadrants are either:
  - Part of the generation (in quadrants list)
  - Already generated/scheduled (in combined set)

  Args:
      quadrants: The quadrants being generated
      combined: Set of already generated or scheduled quadrants

  Returns:
      True if there's at least one valid 2x2 block providing full context
  """
  quadrant_set = set(quadrants)

  # For each quadrant, check all 2x2 blocks it belongs to
  for q in quadrants:
    blocks = get_2x2_block_positions(q)
    for block in blocks:
      # Check if all 4 positions in this block are covered
      all_covered = all(p in quadrant_set or p in combined for p in block)
      if all_covered:
        return True

  return False


def can_place_1x1(p: Point, combined: set[Point]) -> bool:
  """
  Check if a 1x1 tile can be placed at point p with valid context.

  A 1x1 tile requires that 3 of 4 quadrants in at least one 2x2 block
  containing p are already generated/scheduled (providing context).
  """
  blocks = get_2x2_block_positions(p)
  for block in blocks:
    # Count how many OTHER quadrants (not p) are generated
    other_generated = sum(1 for q in block if q != p and q in combined)
    if other_generated >= 3:
      return True
  return False


def place_1x1_tiles(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[GenerationStep]:
  """
  Fill remaining gaps with 1x1 tiles.

  A 1x1 tile can only be placed if 3 of 4 quadrants in at least one
  2x2 block containing it are already generated/scheduled.
  This ensures valid context for the generation.
  """
  steps: list[GenerationStep] = []
  combined = generated | scheduled
  new_scheduled = set(scheduled)

  # Find all remaining unscheduled quadrants within bounds
  remaining = [p for p in bounds.all_points() if p not in combined]

  # Sort by priority: quadrants with more generated neighbors in 2x2 blocks first
  # This helps ensure we place tiles in an order that maintains context
  def priority(p: Point) -> int:
    blocks = get_2x2_block_positions(p)
    max_generated = max(
      count_generated_in_block(block, combined | new_scheduled) for block in blocks
    )
    return -max_generated  # Negative for descending sort

  remaining.sort(key=priority)

  # Keep iterating until no more valid placements
  # (as each placement may enable new valid placements)
  changed = True
  while changed:
    changed = False
    for p in list(remaining):
      if p in new_scheduled:
        remaining.remove(p)
        continue

      # Check if this 1x1 has valid context
      if can_place_1x1(p, combined | new_scheduled):
        steps.append(GenerationStep(quadrants=[p], step_type="1x1"))
        new_scheduled.add(p)
        remaining.remove(p)
        changed = True

  return steps


# =============================================================================
# Main Algorithm
# =============================================================================


def create_rectangle_plan(
  bounds: RectBounds,
  generated: set[Point] | None = None,
  queued: set[Point] | None = None,
) -> RectanglePlan:
  """
  Create a generation plan for filling a rectangle.

  Args:
      bounds: The rectangle bounds (top-left to bottom-right inclusive)
      generated: Set of already-generated quadrant positions
      queued: Set of quadrant positions that are in-progress or queued for generation.
              These are treated as "will be generated" for seam detection purposes,
              meaning tiles cannot be placed adjacent to them (to avoid seams).

  Returns:
      RectanglePlan with the sequence of generation steps
  """
  generated = generated or set()
  queued = queued or set()

  # Combine generated and queued for seam detection
  # Queued quadrants are treated as if they will be generated,
  # so we cannot place tiles adjacent to them
  effective_generated = generated | queued

  # Filter out quadrants that are already generated OR queued from the rectangle
  points_to_generate = set(bounds.all_points()) - effective_generated

  if not points_to_generate:
    return RectanglePlan(bounds=bounds, steps=[], pre_generated=generated)

  # Phase 1: Place 2x2 tiles
  steps_2x2, scheduled = place_2x2_tiles(bounds, effective_generated)

  # Phase 2: Place 2x1/1x2 tiles
  steps_2x1, scheduled = place_2x1_tiles(bounds, effective_generated, scheduled)

  # Phase 3: Fill with 1x1 tiles
  steps_1x1 = place_1x1_tiles(bounds, effective_generated, scheduled)

  all_steps = steps_2x2 + steps_2x1 + steps_1x1

  return RectanglePlan(
    bounds=bounds,
    steps=all_steps,
    pre_generated=generated,
  )


def create_rectangle_plan_from_coords(
  tl: tuple[int, int],
  br: tuple[int, int],
  generated: set[tuple[int, int]] | None = None,
  queued: set[tuple[int, int]] | None = None,
) -> RectanglePlan:
  """
  Convenience function to create a plan from coordinate tuples.

  Args:
      tl: Top-left corner (x, y)
      br: Bottom-right corner (x, y)
      generated: Set of already-generated quadrant positions as (x, y) tuples
      queued: Set of quadrant positions that are in-progress or queued for generation
              as (x, y) tuples. These are treated as "will be generated" for seam
              detection purposes.

  Returns:
      RectanglePlan with the sequence of generation steps
  """
  bounds = RectBounds(Point(tl[0], tl[1]), Point(br[0], br[1]))
  gen_points = {Point(x, y) for x, y in (generated or set())}
  queued_points = {Point(x, y) for x, y in (queued or set())}
  return create_rectangle_plan(bounds, gen_points, queued_points)


# =============================================================================
# Validation
# =============================================================================


def validate_plan(plan: RectanglePlan) -> tuple[bool, list[str]]:
  """
  Validate that a plan covers all required quadrants exactly once.

  Returns (is_valid, error_messages).
  """
  errors: list[str] = []

  # Check that all required quadrants are covered
  required = set(plan.bounds.all_points()) - plan.pre_generated
  covered: set[Point] = set()

  for step in plan.steps:
    for q in step.quadrants:
      if q in covered:
        errors.append(f"Quadrant {q} is covered multiple times")
      covered.add(q)

  missing = required - covered
  if missing:
    errors.append(f"Missing quadrants: {sorted(missing, key=lambda p: (p.y, p.x))}")

  extra = covered - required
  if extra:
    errors.append(f"Extra quadrants: {sorted(extra, key=lambda p: (p.y, p.x))}")

  return len(errors) == 0, errors


def validate_plan_context(plan: RectanglePlan) -> tuple[bool, list[str]]:
  """
  Validate that all steps in a plan have valid 2x2 context for generation.

  Each generation step must have at least one 2x2 block where all 4 quadrants
  are either part of the step or already generated/scheduled.

  Returns (is_valid, error_messages).
  """
  errors: list[str] = []

  # Start with pre-generated quadrants as context
  generated_so_far = set(plan.pre_generated)

  for i, step in enumerate(plan.steps):
    # Check if this step has valid context
    if not has_valid_2x2_context(step.quadrants, generated_so_far):
      quadrant_strs = ", ".join(str(q) for q in step.quadrants)
      errors.append(
        f"Step {i + 1} ({step.step_type}): [{quadrant_strs}] lacks valid 2x2 context"
      )

    # Add this step's quadrants to the generated set for subsequent steps
    for q in step.quadrants:
      generated_so_far.add(q)

  return len(errors) == 0, errors


def get_plan_summary(plan: RectanglePlan) -> dict[str, Any]:
  """Get a summary of the plan for display."""
  by_type: dict[str, int] = {}
  for step in plan.steps:
    t = step.step_type or f"{len(step.quadrants)}-quad"
    by_type[t] = by_type.get(t, 0) + 1

  total_quadrants = sum(len(step.quadrants) for step in plan.steps)

  return {
    "bounds": {
      "tl": plan.bounds.top_left.to_tuple(),
      "br": plan.bounds.bottom_right.to_tuple(),
      "width": plan.bounds.width,
      "height": plan.bounds.height,
    },
    "pre_generated_count": len(plan.pre_generated),
    "total_steps": len(plan.steps),
    "total_quadrants": total_quadrants,
    "steps_by_type": by_type,
  }

```

---

**User**

keep going

---

**Cursor**

I see the issue. The 2x2 placement creates diagonal gaps that can't be bridged. The problem is that `can_place_2x2` prevents placement next to scheduled tiles, but for rectangle filling, we need adjacent 2x2s to cover the area.

The key insight is:
- When checking seams against **pre-generated** content: we must avoid adjacency (seam prevention)
- When checking against **scheduled** content (tiles in the same plan): we can allow adjacency since they'll all be generated together

Let me fix the 2x2 placement logic:

```python
"""
Rectangle generation plan algorithm.

Creates a sequence of generation steps for filling a rectangular region
of quadrants, respecting pre-existing generated quadrants and following
tile placement rules.

Tile Placement Rules:
- 2x2: No side of the tile may touch any previously generated quadrants.
- 2x1/1x2: Both quadrants of the 2-long side must touch previously generated
  quadrants along that axis on ONE side. Neither quadrant may touch previously
  generated quadrants along the transverse (short) side.
- 1x1: Ideally generated when 3 other quadrants in a 2x2 block are generated.

Algorithm:
1. Place as many 2x2 tiles as possible
2. Place 2x1/1x2 tiles for remaining gaps
3. Fill remaining single quadrants with 1x1 tiles
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any


@dataclass(frozen=True)
class Point:
  """A 2D point representing a quadrant coordinate."""

  x: int
  y: int

  def __str__(self) -> str:
    return f"({self.x},{self.y})"

  def __add__(self, other: Point) -> Point:
    return Point(self.x + other.x, self.y + other.y)

  @classmethod
  def from_string(cls, s: str) -> Point:
    """Parse a string like '(x,y)' or 'x,y' into a Point."""
    s = s.strip().replace("(", "").replace(")", "").replace(" ", "")
    parts = s.split(",")
    if len(parts) != 2:
      raise ValueError(f"Invalid coordinate format: {s}")
    return cls(int(parts[0]), int(parts[1]))

  def to_tuple(self) -> tuple[int, int]:
    """Convert to a tuple."""
    return (self.x, self.y)


@dataclass
class RectBounds:
  """Bounds of the rectangle to generate."""

  top_left: Point
  bottom_right: Point

  @property
  def width(self) -> int:
    """Width of the rectangle (x extent)."""
    return self.bottom_right.x - self.top_left.x + 1

  @property
  def height(self) -> int:
    """Height of the rectangle (y extent)."""
    return self.bottom_right.y - self.top_left.y + 1

  @property
  def area(self) -> int:
    """Total number of quadrants in the rectangle."""
    return self.width * self.height

  def contains(self, p: Point) -> bool:
    """Check if a point is within the rectangle bounds."""
    return (
      self.top_left.x <= p.x <= self.bottom_right.x
      and self.top_left.y <= p.y <= self.bottom_right.y
    )

  def all_points(self) -> list[Point]:
    """Return all points within the rectangle bounds."""
    return [
      Point(x, y)
      for y in range(self.top_left.y, self.bottom_right.y + 1)
      for x in range(self.top_left.x, self.bottom_right.x + 1)
    ]


@dataclass
class GenerationStep:
  """A single generation step containing quadrants to generate together."""

  quadrants: list[Point]
  step_type: str = ""  # "2x2", "2x1", "1x2", "1x1" for debugging

  def to_dict(self) -> dict[str, Any]:
    """Convert to JSON-serializable dict."""
    return {
      "quadrants": [(q.x, q.y) for q in self.quadrants],
      "type": self.step_type,
    }


@dataclass
class RectanglePlan:
  """A complete generation plan for a rectangle."""

  bounds: RectBounds
  steps: list[GenerationStep] = field(default_factory=list)
  pre_generated: set[Point] = field(default_factory=set)

  def to_dict(self) -> dict[str, Any]:
    """Convert to JSON-serializable dict."""
    return {
      "bounds": {
        "top_left": self.bounds.top_left.to_tuple(),
        "bottom_right": self.bounds.bottom_right.to_tuple(),
      },
      "steps": [step.to_dict() for step in self.steps],
      "pre_generated": [p.to_tuple() for p in self.pre_generated],
    }


# =============================================================================
# 2x2 Tile Placement
# =============================================================================


def get_2x2_quadrants(top_left: Point) -> list[Point]:
  """Get the 4 quadrants of a 2x2 tile given its top-left corner."""
  x, y = top_left.x, top_left.y
  return [
    Point(x, y),
    Point(x + 1, y),
    Point(x, y + 1),
    Point(x + 1, y + 1),
  ]


def get_2x2_neighbors(top_left: Point) -> list[Point]:
  """
  Get all 8 exterior neighbors of a 2x2 tile.

  For a 2x2 at (x,y), (x+1,y), (x,y+1), (x+1,y+1):
  - Top: (x, y-1), (x+1, y-1)
  - Bottom: (x, y+2), (x+1, y+2)
  - Left: (x-1, y), (x-1, y+1)
  - Right: (x+2, y), (x+2, y+1)
  """
  x, y = top_left.x, top_left.y
  return [
    # Top
    Point(x, y - 1),
    Point(x + 1, y - 1),
    # Bottom
    Point(x, y + 2),
    Point(x + 1, y + 2),
    # Left
    Point(x - 1, y),
    Point(x - 1, y + 1),
    # Right
    Point(x + 2, y),
    Point(x + 2, y + 1),
  ]


def can_place_2x2(
  top_left: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
  allow_adjacent_scheduled: bool = False,
) -> bool:
  """
  Check if a 2x2 tile can be placed at the given top-left position.

  Rules:
  - All 4 quadrants must be within bounds
  - All 4 quadrants must not be already generated or scheduled
  - No neighbor of the 2x2 may be pre-generated (seam prevention)
  - If allow_adjacent_scheduled is False, no neighbor may be scheduled either

  Args:
      top_left: Top-left corner of the 2x2 tile
      bounds: Rectangle bounds
      generated: Pre-existing generated quadrants (must avoid adjacency)
      scheduled: Quadrants scheduled in this plan
      allow_adjacent_scheduled: If True, allow placement next to scheduled tiles.
                               This enables dense 2x2 packing for rectangle filling.
  """
  quadrants = get_2x2_quadrants(top_left)

  # All quadrants must be within bounds and unscheduled
  for q in quadrants:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # No neighbor may be pre-generated (seam prevention)
  neighbors = get_2x2_neighbors(top_left)
  for n in neighbors:
    if n in generated:
      return False
    # Only check scheduled if we're not allowing adjacent scheduled tiles
    if not allow_adjacent_scheduled and n in scheduled:
      return False

  return True


def find_all_valid_2x2_positions(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[Point]:
  """Find all valid top-left positions for 2x2 tiles."""
  valid = []
  # Check all possible 2x2 positions (need room for 2x2)
  for y in range(bounds.top_left.y, bounds.bottom_right.y):  # -1 for 2x2
    for x in range(bounds.top_left.x, bounds.bottom_right.x):
      tl = Point(x, y)
      if can_place_2x2(tl, bounds, generated, scheduled):
        valid.append(tl)
  return valid


def place_2x2_tiles(
  bounds: RectBounds,
  generated: set[Point],
) -> tuple[list[GenerationStep], set[Point]]:
  """
  Place as many 2x2 tiles as possible.

  Returns the generation steps and the set of scheduled quadrants.

  Strategy: Use a greedy approach with gap-leaving pattern.
  We alternate rows of 2x2s with single-column gaps to maximize coverage.
  """
  steps: list[GenerationStep] = []
  scheduled: set[Point] = set()

  # Keep placing 2x2 tiles until no more can be placed
  # Use a simple greedy approach: iterate through all valid positions
  while True:
    valid_positions = find_all_valid_2x2_positions(bounds, generated, scheduled)
    if not valid_positions:
      break

    # Pick the first valid position (top-left to bottom-right order)
    # This creates a natural tiling pattern
    tl = valid_positions[0]
    quadrants = get_2x2_quadrants(tl)

    steps.append(GenerationStep(quadrants=quadrants, step_type="2x2"))
    for q in quadrants:
      scheduled.add(q)

  return steps, scheduled


# =============================================================================
# 2x1 / 1x2 Tile Placement
# =============================================================================


def can_place_2x1_horizontal(
  left: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a horizontal 2x1 tile can be placed at (left.x, left.y) and (left.x+1, left.y).

  Rules (following task 019 strip plan):
  - Both quadrants must be within bounds and unscheduled
  - At least one of top/bottom side must have BOTH neighbors generated
    (can be both sides, like when bridging between two 2x2 tiles)
  - Neither left nor right neighbor may be generated (transverse sides)
  """
  right = Point(left.x + 1, left.y)

  # Both must be in bounds and not already covered
  for q in [left, right]:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # Check transverse (short) sides - must NOT be generated
  left_neighbor = Point(left.x - 1, left.y)
  right_neighbor = Point(right.x + 1, right.y)
  if left_neighbor in generated or left_neighbor in scheduled:
    return False
  if right_neighbor in generated or right_neighbor in scheduled:
    return False

  # Check long sides - AT LEAST ONE side must have BOTH neighbors generated
  # Note: Both sides CAN be generated (e.g., bridging between two 2x2 tiles)
  top_left = Point(left.x, left.y - 1)
  top_right = Point(right.x, right.y - 1)
  bottom_left = Point(left.x, left.y + 1)
  bottom_right = Point(right.x, right.y + 1)

  # "Generated" for the purpose of long-side check includes both
  # pre-existing generated AND scheduled quadrants
  combined = generated | scheduled

  top_both_generated = top_left in combined and top_right in combined
  bottom_both_generated = bottom_left in combined and bottom_right in combined

  # At least one side must be fully generated
  return top_both_generated or bottom_both_generated


def can_place_1x2_vertical(
  top: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a vertical 1x2 tile can be placed at (top.x, top.y) and (top.x, top.y+1).

  Rules (following task 019 strip plan):
  - Both quadrants must be within bounds and unscheduled
  - At least one of left/right side must have BOTH neighbors generated
    (can be both sides, like when bridging between two 2x2 tiles)
  - Neither top nor bottom neighbor may be generated (transverse sides)
  """
  bottom = Point(top.x, top.y + 1)

  # Both must be in bounds and not already covered
  for q in [top, bottom]:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # Check transverse (short) sides - must NOT be generated
  top_neighbor = Point(top.x, top.y - 1)
  bottom_neighbor = Point(bottom.x, bottom.y + 1)
  if top_neighbor in generated or top_neighbor in scheduled:
    return False
  if bottom_neighbor in generated or bottom_neighbor in scheduled:
    return False

  # Check long sides - AT LEAST ONE side must have BOTH neighbors generated
  # Note: Both sides CAN be generated (e.g., bridging between two 2x2 tiles)
  left_top = Point(top.x - 1, top.y)
  left_bottom = Point(top.x - 1, bottom.y)
  right_top = Point(top.x + 1, top.y)
  right_bottom = Point(top.x + 1, bottom.y)

  combined = generated | scheduled

  left_both_generated = left_top in combined and left_bottom in combined
  right_both_generated = right_top in combined and right_bottom in combined

  # At least one side must be fully generated
  return left_both_generated or right_both_generated


def find_all_valid_2x1_positions(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[tuple[Point, str]]:
  """
  Find all valid positions for 2x1 (horizontal) and 1x2 (vertical) tiles.

  Returns list of (position, type) where type is "2x1" or "1x2".

  Following task 019 strip plan pattern:
  - Vertical bridges (1x2) are processed first to connect 2x2 tiles
  - Horizontal bridges (2x1) are processed second to connect to the edge
  """
  valid: list[tuple[Point, str]] = []

  # Check vertical 1x2 tiles FIRST (bridges between 2x2 tiles)
  for y in range(bounds.top_left.y, bounds.bottom_right.y):  # -1 for 2 tall
    for x in range(bounds.top_left.x, bounds.bottom_right.x + 1):
      top = Point(x, y)
      if can_place_1x2_vertical(top, bounds, generated, scheduled):
        valid.append((top, "1x2"))

  # Check horizontal 2x1 tiles SECOND (connect to generation edge)
  for y in range(bounds.top_left.y, bounds.bottom_right.y + 1):
    for x in range(bounds.top_left.x, bounds.bottom_right.x):  # -1 for 2 wide
      left = Point(x, y)
      if can_place_2x1_horizontal(left, bounds, generated, scheduled):
        valid.append((left, "2x1"))

  return valid


def place_2x1_tiles(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> tuple[list[GenerationStep], set[Point]]:
  """
  Place 2x1 and 1x2 tiles where possible.

  These tiles bridge gaps between 2x2 tiles and the generation edge.
  """
  steps: list[GenerationStep] = []
  new_scheduled = set(scheduled)

  # Keep placing tiles until no more can be placed
  while True:
    valid_positions = find_all_valid_2x1_positions(bounds, generated, new_scheduled)
    if not valid_positions:
      break

    # Pick the first valid position
    pos, tile_type = valid_positions[0]

    if tile_type == "2x1":
      quadrants = [pos, Point(pos.x + 1, pos.y)]
    else:  # 1x2
      quadrants = [pos, Point(pos.x, pos.y + 1)]

    steps.append(GenerationStep(quadrants=quadrants, step_type=tile_type))
    for q in quadrants:
      new_scheduled.add(q)

  return steps, new_scheduled


# =============================================================================
# 1x1 Tile Placement
# =============================================================================


def get_2x2_block_positions(p: Point) -> list[list[Point]]:
  """
  Get all 2x2 blocks that contain the point p.

  A point can be in up to 4 different 2x2 blocks:
  - As top-left
  - As top-right
  - As bottom-left
  - As bottom-right
  """
  blocks = []
  # p as top-left
  blocks.append([p, Point(p.x + 1, p.y), Point(p.x, p.y + 1), Point(p.x + 1, p.y + 1)])
  # p as top-right
  blocks.append([Point(p.x - 1, p.y), p, Point(p.x - 1, p.y + 1), Point(p.x, p.y + 1)])
  # p as bottom-left
  blocks.append([Point(p.x, p.y - 1), Point(p.x + 1, p.y - 1), p, Point(p.x + 1, p.y)])
  # p as bottom-right
  blocks.append([Point(p.x - 1, p.y - 1), Point(p.x, p.y - 1), Point(p.x - 1, p.y), p])
  return blocks


def count_generated_in_block(block: list[Point], combined: set[Point]) -> int:
  """Count how many quadrants in a 2x2 block are generated/scheduled."""
  return sum(1 for p in block if p in combined)


def has_valid_2x2_context(
  quadrants: list[Point],
  combined: set[Point],
) -> bool:
  """
  Check if the given quadrants have valid 2x2 context for generation.

  For a generation to succeed, there must exist at least one 2x2 block
  where all 4 quadrants are either:
  - Part of the generation (in quadrants list)
  - Already generated/scheduled (in combined set)

  Args:
      quadrants: The quadrants being generated
      combined: Set of already generated or scheduled quadrants

  Returns:
      True if there's at least one valid 2x2 block providing full context
  """
  quadrant_set = set(quadrants)

  # For each quadrant, check all 2x2 blocks it belongs to
  for q in quadrants:
    blocks = get_2x2_block_positions(q)
    for block in blocks:
      # Check if all 4 positions in this block are covered
      all_covered = all(p in quadrant_set or p in combined for p in block)
      if all_covered:
        return True

  return False


def can_place_1x1(p: Point, combined: set[Point]) -> bool:
  """
  Check if a 1x1 tile can be placed at point p with valid context.

  A 1x1 tile requires that 3 of 4 quadrants in at least one 2x2 block
  containing p are already generated/scheduled (providing context).
  """
  blocks = get_2x2_block_positions(p)
  for block in blocks:
    # Count how many OTHER quadrants (not p) are generated
    other_generated = sum(1 for q in block if q != p and q in combined)
    if other_generated >= 3:
      return True
  return False


def place_1x1_tiles(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[GenerationStep]:
  """
  Fill remaining gaps with 1x1 tiles.

  A 1x1 tile can only be placed if 3 of 4 quadrants in at least one
  2x2 block containing it are already generated/scheduled.
  This ensures valid context for the generation.
  """
  steps: list[GenerationStep] = []
  combined = generated | scheduled
  new_scheduled = set(scheduled)

  # Find all remaining unscheduled quadrants within bounds
  remaining = [p for p in bounds.all_points() if p not in combined]

  # Sort by priority: quadrants with more generated neighbors in 2x2 blocks first
  # This helps ensure we place tiles in an order that maintains context
  def priority(p: Point) -> int:
    blocks = get_2x2_block_positions(p)
    max_generated = max(
      count_generated_in_block(block, combined | new_scheduled) for block in blocks
    )
    return -max_generated  # Negative for descending sort

  remaining.sort(key=priority)

  # Keep iterating until no more valid placements
  # (as each placement may enable new valid placements)
  changed = True
  while changed:
    changed = False
    for p in list(remaining):
      if p in new_scheduled:
        remaining.remove(p)
        continue

      # Check if this 1x1 has valid context
      if can_place_1x1(p, combined | new_scheduled):
        steps.append(GenerationStep(quadrants=[p], step_type="1x1"))
        new_scheduled.add(p)
        remaining.remove(p)
        changed = True

  return steps


# =============================================================================
# Main Algorithm
# =============================================================================


def create_rectangle_plan(
  bounds: RectBounds,
  generated: set[Point] | None = None,
  queued: set[Point] | None = None,
) -> RectanglePlan:
  """
  Create a generation plan for filling a rectangle.

  Args:
      bounds: The rectangle bounds (top-left to bottom-right inclusive)
      generated: Set of already-generated quadrant positions
      queued: Set of quadrant positions that are in-progress or queued for generation.
              These are treated as "will be generated" for seam detection purposes,
              meaning tiles cannot be placed adjacent to them (to avoid seams).

  Returns:
      RectanglePlan with the sequence of generation steps
  """
  generated = generated or set()
  queued = queued or set()

  # Combine generated and queued for seam detection
  # Queued quadrants are treated as if they will be generated,
  # so we cannot place tiles adjacent to them
  effective_generated = generated | queued

  # Filter out quadrants that are already generated OR queued from the rectangle
  points_to_generate = set(bounds.all_points()) - effective_generated

  if not points_to_generate:
    return RectanglePlan(bounds=bounds, steps=[], pre_generated=generated)

  # Phase 1: Place 2x2 tiles
  steps_2x2, scheduled = place_2x2_tiles(bounds, effective_generated)

  # Phase 2: Place 2x1/1x2 tiles
  steps_2x1, scheduled = place_2x1_tiles(bounds, effective_generated, scheduled)

  # Phase 3: Fill with 1x1 tiles
  steps_1x1 = place_1x1_tiles(bounds, effective_generated, scheduled)

  all_steps = steps_2x2 + steps_2x1 + steps_1x1

  return RectanglePlan(
    bounds=bounds,
    steps=all_steps,
    pre_generated=generated,
  )


def create_rectangle_plan_from_coords(
  tl: tuple[int, int],
  br: tuple[int, int],
  generated: set[tuple[int, int]] | None = None,
  queued: set[tuple[int, int]] | None = None,
) -> RectanglePlan:
  """
  Convenience function to create a plan from coordinate tuples.

  Args:
      tl: Top-left corner (x, y)
      br: Bottom-right corner (x, y)
      generated: Set of already-generated quadrant positions as (x, y) tuples
      queued: Set of quadrant positions that are in-progress or queued for generation
              as (x, y) tuples. These are treated as "will be generated" for seam
              detection purposes.

  Returns:
      RectanglePlan with the sequence of generation steps
  """
  bounds = RectBounds(Point(tl[0], tl[1]), Point(br[0], br[1]))
  gen_points = {Point(x, y) for x, y in (generated or set())}
  queued_points = {Point(x, y) for x, y in (queued or set())}
  return create_rectangle_plan(bounds, gen_points, queued_points)


# =============================================================================
# Validation
# =============================================================================


def validate_plan(plan: RectanglePlan) -> tuple[bool, list[str]]:
  """
  Validate that a plan covers all required quadrants exactly once.

  Returns (is_valid, error_messages).
  """
  errors: list[str] = []

  # Check that all required quadrants are covered
  required = set(plan.bounds.all_points()) - plan.pre_generated
  covered: set[Point] = set()

  for step in plan.steps:
    for q in step.quadrants:
      if q in covered:
        errors.append(f"Quadrant {q} is covered multiple times")
      covered.add(q)

  missing = required - covered
  if missing:
    errors.append(f"Missing quadrants: {sorted(missing, key=lambda p: (p.y, p.x))}")

  extra = covered - required
  if extra:
    errors.append(f"Extra quadrants: {sorted(extra, key=lambda p: (p.y, p.x))}")

  return len(errors) == 0, errors


def validate_plan_context(plan: RectanglePlan) -> tuple[bool, list[str]]:
  """
  Validate that all steps in a plan have valid 2x2 context for generation.

  Each generation step must have at least one 2x2 block where all 4 quadrants
  are either part of the step or already generated/scheduled.

  Returns (is_valid, error_messages).
  """
  errors: list[str] = []

  # Start with pre-generated quadrants as context
  generated_so_far = set(plan.pre_generated)

  for i, step in enumerate(plan.steps):
    # Check if this step has valid context
    if not has_valid_2x2_context(step.quadrants, generated_so_far):
      quadrant_strs = ", ".join(str(q) for q in step.quadrants)
      errors.append(
        f"Step {i + 1} ({step.step_type}): [{quadrant_strs}] lacks valid 2x2 context"
      )

    # Add this step's quadrants to the generated set for subsequent steps
    for q in step.quadrants:
      generated_so_far.add(q)

  return len(errors) == 0, errors


def get_plan_summary(plan: RectanglePlan) -> dict[str, Any]:
  """Get a summary of the plan for display."""
  by_type: dict[str, int] = {}
  for step in plan.steps:
    t = step.step_type or f"{len(step.quadrants)}-quad"
    by_type[t] = by_type.get(t, 0) + 1

  total_quadrants = sum(len(step.quadrants) for step in plan.steps)

  return {
    "bounds": {
      "tl": plan.bounds.top_left.to_tuple(),
      "br": plan.bounds.bottom_right.to_tuple(),
      "width": plan.bounds.width,
      "height": plan.bounds.height,
    },
    "pre_generated_count": len(plan.pre_generated),
    "total_steps": len(plan.steps),
    "total_quadrants": total_quadrants,
    "steps_by_type": by_type,
  }

```

```python
"""
Rectangle generation plan algorithm.

Creates a sequence of generation steps for filling a rectangular region
of quadrants, respecting pre-existing generated quadrants and following
tile placement rules.

Tile Placement Rules:
- 2x2: No side of the tile may touch any previously generated quadrants.
- 2x1/1x2: Both quadrants of the 2-long side must touch previously generated
  quadrants along that axis on ONE side. Neither quadrant may touch previously
  generated quadrants along the transverse (short) side.
- 1x1: Ideally generated when 3 other quadrants in a 2x2 block are generated.

Algorithm:
1. Place as many 2x2 tiles as possible
2. Place 2x1/1x2 tiles for remaining gaps
3. Fill remaining single quadrants with 1x1 tiles
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any


@dataclass(frozen=True)
class Point:
  """A 2D point representing a quadrant coordinate."""

  x: int
  y: int

  def __str__(self) -> str:
    return f"({self.x},{self.y})"

  def __add__(self, other: Point) -> Point:
    return Point(self.x + other.x, self.y + other.y)

  @classmethod
  def from_string(cls, s: str) -> Point:
    """Parse a string like '(x,y)' or 'x,y' into a Point."""
    s = s.strip().replace("(", "").replace(")", "").replace(" ", "")
    parts = s.split(",")
    if len(parts) != 2:
      raise ValueError(f"Invalid coordinate format: {s}")
    return cls(int(parts[0]), int(parts[1]))

  def to_tuple(self) -> tuple[int, int]:
    """Convert to a tuple."""
    return (self.x, self.y)


@dataclass
class RectBounds:
  """Bounds of the rectangle to generate."""

  top_left: Point
  bottom_right: Point

  @property
  def width(self) -> int:
    """Width of the rectangle (x extent)."""
    return self.bottom_right.x - self.top_left.x + 1

  @property
  def height(self) -> int:
    """Height of the rectangle (y extent)."""
    return self.bottom_right.y - self.top_left.y + 1

  @property
  def area(self) -> int:
    """Total number of quadrants in the rectangle."""
    return self.width * self.height

  def contains(self, p: Point) -> bool:
    """Check if a point is within the rectangle bounds."""
    return (
      self.top_left.x <= p.x <= self.bottom_right.x
      and self.top_left.y <= p.y <= self.bottom_right.y
    )

  def all_points(self) -> list[Point]:
    """Return all points within the rectangle bounds."""
    return [
      Point(x, y)
      for y in range(self.top_left.y, self.bottom_right.y + 1)
      for x in range(self.top_left.x, self.bottom_right.x + 1)
    ]


@dataclass
class GenerationStep:
  """A single generation step containing quadrants to generate together."""

  quadrants: list[Point]
  step_type: str = ""  # "2x2", "2x1", "1x2", "1x1" for debugging

  def to_dict(self) -> dict[str, Any]:
    """Convert to JSON-serializable dict."""
    return {
      "quadrants": [(q.x, q.y) for q in self.quadrants],
      "type": self.step_type,
    }


@dataclass
class RectanglePlan:
  """A complete generation plan for a rectangle."""

  bounds: RectBounds
  steps: list[GenerationStep] = field(default_factory=list)
  pre_generated: set[Point] = field(default_factory=set)

  def to_dict(self) -> dict[str, Any]:
    """Convert to JSON-serializable dict."""
    return {
      "bounds": {
        "top_left": self.bounds.top_left.to_tuple(),
        "bottom_right": self.bounds.bottom_right.to_tuple(),
      },
      "steps": [step.to_dict() for step in self.steps],
      "pre_generated": [p.to_tuple() for p in self.pre_generated],
    }


# =============================================================================
# 2x2 Tile Placement
# =============================================================================


def get_2x2_quadrants(top_left: Point) -> list[Point]:
  """Get the 4 quadrants of a 2x2 tile given its top-left corner."""
  x, y = top_left.x, top_left.y
  return [
    Point(x, y),
    Point(x + 1, y),
    Point(x, y + 1),
    Point(x + 1, y + 1),
  ]


def get_2x2_neighbors(top_left: Point) -> list[Point]:
  """
  Get all 8 exterior neighbors of a 2x2 tile.

  For a 2x2 at (x,y), (x+1,y), (x,y+1), (x+1,y+1):
  - Top: (x, y-1), (x+1, y-1)
  - Bottom: (x, y+2), (x+1, y+2)
  - Left: (x-1, y), (x-1, y+1)
  - Right: (x+2, y), (x+2, y+1)
  """
  x, y = top_left.x, top_left.y
  return [
    # Top
    Point(x, y - 1),
    Point(x + 1, y - 1),
    # Bottom
    Point(x, y + 2),
    Point(x + 1, y + 2),
    # Left
    Point(x - 1, y),
    Point(x - 1, y + 1),
    # Right
    Point(x + 2, y),
    Point(x + 2, y + 1),
  ]


def can_place_2x2(
  top_left: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
  allow_adjacent_scheduled: bool = False,
) -> bool:
  """
  Check if a 2x2 tile can be placed at the given top-left position.

  Rules:
  - All 4 quadrants must be within bounds
  - All 4 quadrants must not be already generated or scheduled
  - No neighbor of the 2x2 may be pre-generated (seam prevention)
  - If allow_adjacent_scheduled is False, no neighbor may be scheduled either

  Args:
      top_left: Top-left corner of the 2x2 tile
      bounds: Rectangle bounds
      generated: Pre-existing generated quadrants (must avoid adjacency)
      scheduled: Quadrants scheduled in this plan
      allow_adjacent_scheduled: If True, allow placement next to scheduled tiles.
                               This enables dense 2x2 packing for rectangle filling.
  """
  quadrants = get_2x2_quadrants(top_left)

  # All quadrants must be within bounds and unscheduled
  for q in quadrants:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # No neighbor may be pre-generated (seam prevention)
  neighbors = get_2x2_neighbors(top_left)
  for n in neighbors:
    if n in generated:
      return False
    # Only check scheduled if we're not allowing adjacent scheduled tiles
    if not allow_adjacent_scheduled and n in scheduled:
      return False

  return True


def find_all_valid_2x2_positions(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
  allow_adjacent_scheduled: bool = False,
) -> list[Point]:
  """Find all valid top-left positions for 2x2 tiles."""
  valid = []
  # Check all possible 2x2 positions (need room for 2x2)
  for y in range(bounds.top_left.y, bounds.bottom_right.y):  # -1 for 2x2
    for x in range(bounds.top_left.x, bounds.bottom_right.x):
      tl = Point(x, y)
      if can_place_2x2(tl, bounds, generated, scheduled, allow_adjacent_scheduled):
        valid.append(tl)
  return valid


def place_2x2_tiles(
  bounds: RectBounds,
  generated: set[Point],
) -> tuple[list[GenerationStep], set[Point]]:
  """
  Place as many 2x2 tiles as possible.

  Returns the generation steps and the set of scheduled quadrants.

  Strategy:
  1. First pass: Place 2x2 tiles with gaps to avoid pre-generated neighbors
  2. Second pass: Fill remaining 2x2-sized gaps (allow adjacent to scheduled)

  This allows dense packing when filling empty rectangles while still
  avoiding seams with pre-generated content.
  """
  steps: list[GenerationStep] = []
  scheduled: set[Point] = set()

  # First pass: Place 2x2 tiles avoiding both generated AND scheduled neighbors
  # This creates a pattern with gaps for bridging
  while True:
    valid_positions = find_all_valid_2x2_positions(
      bounds, generated, scheduled, allow_adjacent_scheduled=False
    )
    if not valid_positions:
      break

    tl = valid_positions[0]
    quadrants = get_2x2_quadrants(tl)
    steps.append(GenerationStep(quadrants=quadrants, step_type="2x2"))
    for q in quadrants:
      scheduled.add(q)

  # Second pass: Fill remaining 2x2-sized gaps by allowing adjacent to scheduled
  # This helps cover areas that can't be reached by bridges
  while True:
    valid_positions = find_all_valid_2x2_positions(
      bounds, generated, scheduled, allow_adjacent_scheduled=True
    )
    if not valid_positions:
      break

    tl = valid_positions[0]
    quadrants = get_2x2_quadrants(tl)
    steps.append(GenerationStep(quadrants=quadrants, step_type="2x2"))
    for q in quadrants:
      scheduled.add(q)

  return steps, scheduled


# =============================================================================
# 2x1 / 1x2 Tile Placement
# =============================================================================


def can_place_2x1_horizontal(
  left: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a horizontal 2x1 tile can be placed at (left.x, left.y) and (left.x+1, left.y).

  Rules (following task 019 strip plan):
  - Both quadrants must be within bounds and unscheduled
  - At least one of top/bottom side must have BOTH neighbors generated
    (can be both sides, like when bridging between two 2x2 tiles)
  - Neither left nor right neighbor may be generated (transverse sides)
  """
  right = Point(left.x + 1, left.y)

  # Both must be in bounds and not already covered
  for q in [left, right]:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # Check transverse (short) sides - must NOT be generated
  left_neighbor = Point(left.x - 1, left.y)
  right_neighbor = Point(right.x + 1, right.y)
  if left_neighbor in generated or left_neighbor in scheduled:
    return False
  if right_neighbor in generated or right_neighbor in scheduled:
    return False

  # Check long sides - AT LEAST ONE side must have BOTH neighbors generated
  # Note: Both sides CAN be generated (e.g., bridging between two 2x2 tiles)
  top_left = Point(left.x, left.y - 1)
  top_right = Point(right.x, right.y - 1)
  bottom_left = Point(left.x, left.y + 1)
  bottom_right = Point(right.x, right.y + 1)

  # "Generated" for the purpose of long-side check includes both
  # pre-existing generated AND scheduled quadrants
  combined = generated | scheduled

  top_both_generated = top_left in combined and top_right in combined
  bottom_both_generated = bottom_left in combined and bottom_right in combined

  # At least one side must be fully generated
  return top_both_generated or bottom_both_generated


def can_place_1x2_vertical(
  top: Point,
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> bool:
  """
  Check if a vertical 1x2 tile can be placed at (top.x, top.y) and (top.x, top.y+1).

  Rules (following task 019 strip plan):
  - Both quadrants must be within bounds and unscheduled
  - At least one of left/right side must have BOTH neighbors generated
    (can be both sides, like when bridging between two 2x2 tiles)
  - Neither top nor bottom neighbor may be generated (transverse sides)
  """
  bottom = Point(top.x, top.y + 1)

  # Both must be in bounds and not already covered
  for q in [top, bottom]:
    if not bounds.contains(q):
      return False
    if q in generated or q in scheduled:
      return False

  # Check transverse (short) sides - must NOT be generated
  top_neighbor = Point(top.x, top.y - 1)
  bottom_neighbor = Point(bottom.x, bottom.y + 1)
  if top_neighbor in generated or top_neighbor in scheduled:
    return False
  if bottom_neighbor in generated or bottom_neighbor in scheduled:
    return False

  # Check long sides - AT LEAST ONE side must have BOTH neighbors generated
  # Note: Both sides CAN be generated (e.g., bridging between two 2x2 tiles)
  left_top = Point(top.x - 1, top.y)
  left_bottom = Point(top.x - 1, bottom.y)
  right_top = Point(top.x + 1, top.y)
  right_bottom = Point(top.x + 1, bottom.y)

  combined = generated | scheduled

  left_both_generated = left_top in combined and left_bottom in combined
  right_both_generated = right_top in combined and right_bottom in combined

  # At least one side must be fully generated
  return left_both_generated or right_both_generated


def find_all_valid_2x1_positions(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[tuple[Point, str]]:
  """
  Find all valid positions for 2x1 (horizontal) and 1x2 (vertical) tiles.

  Returns list of (position, type) where type is "2x1" or "1x2".

  Following task 019 strip plan pattern:
  - Vertical bridges (1x2) are processed first to connect 2x2 tiles
  - Horizontal bridges (2x1) are processed second to connect to the edge
  """
  valid: list[tuple[Point, str]] = []

  # Check vertical 1x2 tiles FIRST (bridges between 2x2 tiles)
  for y in range(bounds.top_left.y, bounds.bottom_right.y):  # -1 for 2 tall
    for x in range(bounds.top_left.x, bounds.bottom_right.x + 1):
      top = Point(x, y)
      if can_place_1x2_vertical(top, bounds, generated, scheduled):
        valid.append((top, "1x2"))

  # Check horizontal 2x1 tiles SECOND (connect to generation edge)
  for y in range(bounds.top_left.y, bounds.bottom_right.y + 1):
    for x in range(bounds.top_left.x, bounds.bottom_right.x):  # -1 for 2 wide
      left = Point(x, y)
      if can_place_2x1_horizontal(left, bounds, generated, scheduled):
        valid.append((left, "2x1"))

  return valid


def place_2x1_tiles(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> tuple[list[GenerationStep], set[Point]]:
  """
  Place 2x1 and 1x2 tiles where possible.

  These tiles bridge gaps between 2x2 tiles and the generation edge.
  """
  steps: list[GenerationStep] = []
  new_scheduled = set(scheduled)

  # Keep placing tiles until no more can be placed
  while True:
    valid_positions = find_all_valid_2x1_positions(bounds, generated, new_scheduled)
    if not valid_positions:
      break

    # Pick the first valid position
    pos, tile_type = valid_positions[0]

    if tile_type == "2x1":
      quadrants = [pos, Point(pos.x + 1, pos.y)]
    else:  # 1x2
      quadrants = [pos, Point(pos.x, pos.y + 1)]

    steps.append(GenerationStep(quadrants=quadrants, step_type=tile_type))
    for q in quadrants:
      new_scheduled.add(q)

  return steps, new_scheduled


# =============================================================================
# 1x1 Tile Placement
# =============================================================================


def get_2x2_block_positions(p: Point) -> list[list[Point]]:
  """
  Get all 2x2 blocks that contain the point p.

  A point can be in up to 4 different 2x2 blocks:
  - As top-left
  - As top-right
  - As bottom-left
  - As bottom-right
  """
  blocks = []
  # p as top-left
  blocks.append([p, Point(p.x + 1, p.y), Point(p.x, p.y + 1), Point(p.x + 1, p.y + 1)])
  # p as top-right
  blocks.append([Point(p.x - 1, p.y), p, Point(p.x - 1, p.y + 1), Point(p.x, p.y + 1)])
  # p as bottom-left
  blocks.append([Point(p.x, p.y - 1), Point(p.x + 1, p.y - 1), p, Point(p.x + 1, p.y)])
  # p as bottom-right
  blocks.append([Point(p.x - 1, p.y - 1), Point(p.x, p.y - 1), Point(p.x - 1, p.y), p])
  return blocks


def count_generated_in_block(block: list[Point], combined: set[Point]) -> int:
  """Count how many quadrants in a 2x2 block are generated/scheduled."""
  return sum(1 for p in block if p in combined)


def has_valid_2x2_context(
  quadrants: list[Point],
  combined: set[Point],
) -> bool:
  """
  Check if the given quadrants have valid 2x2 context for generation.

  For a generation to succeed, there must exist at least one 2x2 block
  where all 4 quadrants are either:
  - Part of the generation (in quadrants list)
  - Already generated/scheduled (in combined set)

  Args:
      quadrants: The quadrants being generated
      combined: Set of already generated or scheduled quadrants

  Returns:
      True if there's at least one valid 2x2 block providing full context
  """
  quadrant_set = set(quadrants)

  # For each quadrant, check all 2x2 blocks it belongs to
  for q in quadrants:
    blocks = get_2x2_block_positions(q)
    for block in blocks:
      # Check if all 4 positions in this block are covered
      all_covered = all(p in quadrant_set or p in combined for p in block)
      if all_covered:
        return True

  return False


def can_place_1x1(p: Point, combined: set[Point]) -> bool:
  """
  Check if a 1x1 tile can be placed at point p with valid context.

  A 1x1 tile requires that 3 of 4 quadrants in at least one 2x2 block
  containing p are already generated/scheduled (providing context).
  """
  blocks = get_2x2_block_positions(p)
  for block in blocks:
    # Count how many OTHER quadrants (not p) are generated
    other_generated = sum(1 for q in block if q != p and q in combined)
    if other_generated >= 3:
      return True
  return False


def place_1x1_tiles(
  bounds: RectBounds,
  generated: set[Point],
  scheduled: set[Point],
) -> list[GenerationStep]:
  """
  Fill remaining gaps with 1x1 tiles.

  A 1x1 tile can only be placed if 3 of 4 quadrants in at least one
  2x2 block containing it are already generated/scheduled.
  This ensures valid context for the generation.
  """
  steps: list[GenerationStep] = []
  combined = generated | scheduled
  new_scheduled = set(scheduled)

  # Find all remaining unscheduled quadrants within bounds
  remaining = [p for p in bounds.all_points() if p not in combined]

  # Sort by priority: quadrants with more generated neighbors in 2x2 blocks first
  # This helps ensure we place tiles in an order that maintains context
  def priority(p: Point) -> int:
    blocks = get_2x2_block_positions(p)
    max_generated = max(
      count_generated_in_block(block, combined | new_scheduled) for block in blocks
    )
    return -max_generated  # Negative for descending sort

  remaining.sort(key=priority)

  # Keep iterating until no more valid placements
  # (as each placement may enable new valid placements)
  changed = True
  while changed:
    changed = False
    for p in list(remaining):
      if p in new_scheduled:
        remaining.remove(p)
        continue

      # Check if this 1x1 has valid context
      if can_place_1x1(p, combined | new_scheduled):
        steps.append(GenerationStep(quadrants=[p], step_type="1x1"))
        new_scheduled.add(p)
        remaining.remove(p)
        changed = True

  return steps


# =============================================================================
# Main Algorithm
# =============================================================================


def create_rectangle_plan(
  bounds: RectBounds,
  generated: set[Point] | None = None,
  queued: set[Point] | None = None,
) -> RectanglePlan:
  """
  Create a generation plan for filling a rectangle.

  Args:
      bounds: The rectangle bounds (top-left to bottom-right inclusive)
      generated: Set of already-generated quadrant positions
      queued: Set of quadrant positions that are in-progress or queued for generation.
              These are treated as "will be generated" for seam detection purposes,
              meaning tiles cannot be placed adjacent to them (to avoid seams).

  Returns:
      RectanglePlan with the sequence of generation steps
  """
  generated = generated or set()
  queued = queued or set()

  # Combine generated and queued for seam detection
  # Queued quadrants are treated as if they will be generated,
  # so we cannot place tiles adjacent to them
  effective_generated = generated | queued

  # Filter out quadrants that are already generated OR queued from the rectangle
  points_to_generate = set(bounds.all_points()) - effective_generated

  if not points_to_generate:
    return RectanglePlan(bounds=bounds, steps=[], pre_generated=generated)

  # Phase 1: Place 2x2 tiles
  steps_2x2, scheduled = place_2x2_tiles(bounds, effective_generated)

  # Phase 2: Place 2x1/1x2 tiles
  steps_2x1, scheduled = place_2x1_tiles(bounds, effective_generated, scheduled)

  # Phase 3: Fill with 1x1 tiles
  steps_1x1 = place_1x1_tiles(bounds, effective_generated, scheduled)

  all_steps = steps_2x2 + steps_2x1 + steps_1x1

  return RectanglePlan(
    bounds=bounds,
    steps=all_steps,
    pre_generated=generated,
  )


def create_rectangle_plan_from_coords(
  tl: tuple[int, int],
  br: tuple[int, int],
  generated: set[tuple[int, int]] | None = None,
  queued: set[tuple[int, int]] | None = None,
) -> RectanglePlan:
  """
  Convenience function to create a plan from coordinate tuples.

  Args:
      tl: Top-left corner (x, y)
      br: Bottom-right corner (x, y)
      generated: Set of already-generated quadrant positions as (x, y) tuples
      queued: Set of quadrant positions that are in-progress or queued for generation
              as (x, y) tuples. These are treated as "will be generated" for seam
              detection purposes.

  Returns:
      RectanglePlan with the sequence of generation steps
  """
  bounds = RectBounds(Point(tl[0], tl[1]), Point(br[0], br[1]))
  gen_points = {Point(x, y) for x, y in (generated or set())}
  queued_points = {Point(x, y) for x, y in (queued or set())}
  return create_rectangle_plan(bounds, gen_points, queued_points)


# =============================================================================
# Validation
# =============================================================================


def validate_plan(plan: RectanglePlan) -> tuple[bool, list[str]]:
  """
  Validate that a plan covers all required quadrants exactly once.

  Returns (is_valid, error_messages).
  """
  errors: list[str] = []

  # Check that all required quadrants are covered
  required = set(plan.bounds.all_points()) - plan.pre_generated
  covered: set[Point] = set()

  for step in plan.steps:
    for q in step.quadrants:
      if q in covered:
        errors.append(f"Quadrant {q} is covered multiple times")
      covered.add(q)

  missing = required - covered
  if missing:
    errors.append(f"Missing quadrants: {sorted(missing, key=lambda p: (p.y, p.x))}")

  extra = covered - required
  if extra:
    errors.append(f"Extra quadrants: {sorted(extra, key=lambda p: (p.y, p.x))}")

  return len(errors) == 0, errors


def validate_plan_context(plan: RectanglePlan) -> tuple[bool, list[str]]:
  """
  Validate that all steps in a plan have valid 2x2 context for generation.

  Each generation step must have at least one 2x2 block where all 4 quadrants
  are either part of the step or already generated/scheduled.

  Returns (is_valid, error_messages).
  """
  errors: list[str] = []

  # Start with pre-generated quadrants as context
  generated_so_far = set(plan.pre_generated)

  for i, step in enumerate(plan.steps):
    # Check if this step has valid context
    if not has_valid_2x2_context(step.quadrants, generated_so_far):
      quadrant_strs = ", ".join(str(q) for q in step.quadrants)
      errors.append(
        f"Step {i + 1} ({step.step_type}): [{quadrant_strs}] lacks valid 2x2 context"
      )

    # Add this step's quadrants to the generated set for subsequent steps
    for q in step.quadrants:
      generated_so_far.add(q)

  return len(errors) == 0, errors


def get_plan_summary(plan: RectanglePlan) -> dict[str, Any]:
  """Get a summary of the plan for display."""
  by_type: dict[str, int] = {}
  for step in plan.steps:
    t = step.step_type or f"{len(step.quadrants)}-quad"
    by_type[t] = by_type.get(t, 0) + 1

  total_quadrants = sum(len(step.quadrants) for step in plan.steps)

  return {
    "bounds": {
      "tl": plan.bounds.top_left.to_tuple(),
      "br": plan.bounds.bottom_right.to_tuple(),
      "width": plan.bounds.width,
      "height": plan.bounds.height,
    },
    "pre_generated_count": len(plan.pre_generated),
    "total_steps": len(plan.steps),
    "total_quadrants": total_quadrants,
    "steps_by_type": by_type,
  }

```

The algorithm works correctly when there's context. Now I need to update the tests to reflect the new context requirements:

```python
"""
Tests for make_rectangle_plan.py

These tests verify the rectangle generation planning algorithm handles
all cases correctly, including:
- Basic coverage of all quadrants
- 2x2 tile placement rules (no touching generated neighbors)
- 2x1/1x2 tile placement rules (extend from generated edges)
- 1x1 filling of remaining gaps
- Pre-existing generated quadrants
- Various rectangle sizes and configurations
"""

from isometric_nyc.e2e_generation.make_rectangle_plan import (
  GenerationStep,
  Point,
  RectanglePlan,
  RectBounds,
  can_place_1x2_vertical,
  can_place_2x1_horizontal,
  can_place_2x2,
  create_rectangle_plan,
  create_rectangle_plan_from_coords,
  get_2x2_neighbors,
  get_2x2_quadrants,
  get_plan_summary,
  validate_plan,
)

# =============================================================================
# Point Tests
# =============================================================================


class TestPoint:
  def test_str(self) -> None:
    p = Point(3, 5)
    assert str(p) == "(3,5)"

  def test_add(self) -> None:
    p1 = Point(1, 2)
    p2 = Point(3, 4)
    result = p1 + p2
    assert result == Point(4, 6)

  def test_from_string_simple(self) -> None:
    p = Point.from_string("3,5")
    assert p == Point(3, 5)

  def test_from_string_with_parens(self) -> None:
    p = Point.from_string("(3,5)")
    assert p == Point(3, 5)

  def test_from_string_negative(self) -> None:
    p = Point.from_string("-3,-5")
    assert p == Point(-3, -5)

  def test_to_tuple(self) -> None:
    p = Point(3, 5)
    assert p.to_tuple() == (3, 5)


# =============================================================================
# RectBounds Tests
# =============================================================================


class TestRectBounds:
  def test_width_height(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(10, 5))
    assert bounds.width == 11
    assert bounds.height == 6

  def test_area(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(3, 2))
    assert bounds.area == 12  # 4 x 3

  def test_contains(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert bounds.contains(Point(0, 0))
    assert bounds.contains(Point(5, 5))
    assert bounds.contains(Point(3, 3))
    assert not bounds.contains(Point(-1, 0))
    assert not bounds.contains(Point(6, 0))
    assert not bounds.contains(Point(0, -1))
    assert not bounds.contains(Point(0, 6))

  def test_all_points(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(2, 1))
    points = bounds.all_points()
    expected = [
      Point(0, 0),
      Point(1, 0),
      Point(2, 0),
      Point(0, 1),
      Point(1, 1),
      Point(2, 1),
    ]
    assert points == expected


# =============================================================================
# 2x2 Tile Helper Tests
# =============================================================================


class TestGet2x2Quadrants:
  def test_basic(self) -> None:
    quadrants = get_2x2_quadrants(Point(0, 0))
    assert quadrants == [
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
    ]

  def test_offset(self) -> None:
    quadrants = get_2x2_quadrants(Point(5, 3))
    assert quadrants == [
      Point(5, 3),
      Point(6, 3),
      Point(5, 4),
      Point(6, 4),
    ]


class TestGet2x2Neighbors:
  def test_basic(self) -> None:
    neighbors = get_2x2_neighbors(Point(0, 0))
    # Top, Bottom, Left, Right
    expected = [
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 2),
      Point(1, 2),  # Bottom
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(2, 0),
      Point(2, 1),  # Right
    ]
    assert set(neighbors) == set(expected)
    assert len(neighbors) == 8


# =============================================================================
# 2x2 Placement Tests
# =============================================================================


class TestCanPlace2x2:
  def test_empty_grid(self) -> None:
    """2x2 can be placed in empty rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert can_place_2x2(Point(0, 0), bounds, set(), set())

  def test_out_of_bounds(self) -> None:
    """2x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Top-left at (5, 5) would extend to (6, 6)
    assert not can_place_2x2(Point(5, 5), bounds, set(), set())
    # Top-left at (5, 0) would extend to (6, 1)
    assert not can_place_2x2(Point(5, 0), bounds, set(), set())

  def test_neighbor_generated_top(self) -> None:
    """2x2 cannot be placed if top neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Top neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_bottom(self) -> None:
    """2x2 cannot be placed if bottom neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2)}  # Bottom neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_left(self) -> None:
    """2x2 cannot be placed if left neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0)}  # Left neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_right(self) -> None:
    """2x2 cannot be placed if right neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0)}  # Right neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_generated(self) -> None:
    """2x2 cannot be placed if any quadrant is already generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 0)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_scheduled(self) -> None:
    """2x2 cannot be placed if any quadrant is already scheduled."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    scheduled = {Point(1, 1)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, set(), scheduled)

  def test_valid_with_distant_generated(self) -> None:
    """2x2 can be placed if generated quadrants are not neighbors."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(3, 3)}  # Far from (0,0) 2x2
    assert can_place_2x2(Point(0, 0), bounds, generated, set())


# =============================================================================
# 2x1 Horizontal Placement Tests
# =============================================================================


class TestCanPlace2x1Horizontal:
  def test_valid_with_top_generated(self) -> None:
    """2x1 can be placed when top row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(1, -1)}  # Top neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_with_bottom_generated(self) -> None:
    """2x1 can be placed when bottom row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 1), Point(1, 1)}  # Bottom neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_left_generated(self) -> None:
    """2x1 cannot be placed when left neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_right_generated(self) -> None:
    """2x1 cannot be placed when right neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """2x1 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """2x1 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 1),
      Point(1, 1),  # Bottom
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_only_partial_long_side(self) -> None:
    """2x1 cannot be placed when only one of two top neighbors is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Only one top neighbor
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """2x1 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(5, -1), Point(6, -1)}
    # Left at x=5 would extend to x=6
    assert not can_place_2x1_horizontal(Point(5, 0), bounds, generated, set())


# =============================================================================
# 1x2 Vertical Placement Tests
# =============================================================================


class TestCanPlace1x2Vertical:
  def test_valid_with_left_generated(self) -> None:
    """1x2 can be placed when left column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(-1, 1)}  # Left neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_with_right_generated(self) -> None:
    """1x2 can be placed when right column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(1, 0), Point(1, 1)}  # Right neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_top_generated(self) -> None:
    """1x2 cannot be placed when top neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_bottom_generated(self) -> None:
    """1x2 cannot be placed when bottom neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """1x2 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """1x2 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(1, 0),
      Point(1, 1),  # Right
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """1x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 5), Point(-1, 6)}
    # Top at y=5 would extend to y=6
    assert not can_place_1x2_vertical(Point(0, 5), bounds, generated, set())


# =============================================================================
# Full Rectangle Plan Tests
# =============================================================================


class TestCreateRectanglePlan:
  def test_empty_rectangle_no_generated(self) -> None:
    """Empty rectangle with no pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_with_context(self) -> None:
    """Single quadrant rectangle requires 3 neighbors for context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 requires 3 of 4 quadrants in a 2x2 block to be generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_without_context(self) -> None:
    """Single quadrant without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_2x2_rectangle(self) -> None:
    """2x2 rectangle should be a single 2x2 tile."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    plan = create_rectangle_plan(bounds)

    # Should have exactly one 2x2 step
    assert len(plan.steps) == 1
    assert len(plan.steps[0].quadrants) == 4
    assert plan.steps[0].step_type == "2x2"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_3x3_rectangle(self) -> None:
    """3x3 rectangle - mix of tiles."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_4x4_rectangle(self) -> None:
    """4x4 rectangle - should fit multiple 2x2 tiles."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have multiple 2x2 tiles
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 1

  def test_wide_rectangle(self) -> None:
    """Wide rectangle (10x2)."""
    bounds = RectBounds(Point(0, 0), Point(9, 1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_tall_rectangle(self) -> None:
    """Tall rectangle (2x10)."""
    bounds = RectBounds(Point(0, 0), Point(1, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_corner(self) -> None:
    """Rectangle with one corner already generated."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should not include (0,0) in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants

  def test_with_pre_generated_edge(self) -> None:
    """Rectangle with one edge already generated (outside the bounds)."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generated row above the rectangle
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_interior(self) -> None:
    """Rectangle with some interior quadrants already generated."""
    bounds = RectBounds(Point(0, 0), Point(4, 4))
    # Some interior points generated
    generated = {Point(2, 2), Point(2, 3)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should not include generated points
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(2, 2) not in all_quadrants
    assert Point(2, 3) not in all_quadrants

  def test_fully_generated(self) -> None:
    """Rectangle where all quadrants are already generated."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 0
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_negative_coordinates(self) -> None:
    """Rectangle in negative coordinate space."""
    bounds = RectBounds(Point(-5, -3), Point(-2, -1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_convenience(self) -> None:
    """Test the convenience function with tuples."""
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3))

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_with_generated(self) -> None:
    """Test convenience function with pre-generated set."""
    generated = {(0, 0), (1, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3), generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants


# =============================================================================
# 2x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x2RuleEnforcement:
  def test_2x2_not_touching_pre_generated(self) -> None:
    """2x2 tiles should not touch pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Pre-generated quadrant at (2, -1) - above the rectangle
    generated = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    # Find all 2x2 steps
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        # Subtract the tile itself
        neighbors -= set(step.quadrants)
        # No neighbor should be pre-generated
        for n in neighbors:
          assert n not in generated, (
            f"2x2 at {step.quadrants} has pre-generated neighbor {n}"
          )

  def test_2x2_not_touching_other_scheduled(self) -> None:
    """2x2 tiles should not touch other scheduled tiles (at placement time)."""
    # This is verified by the algorithm itself - 2x2 tiles can only be placed
    # where no neighbor is scheduled. We verify by checking no 2x2 tiles share edges.
    bounds = RectBounds(Point(0, 0), Point(7, 7))
    plan = create_rectangle_plan(bounds)

    # Collect all 2x2 tile quadrants
    all_2x2_quadrants: set[Point] = set()
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          all_2x2_quadrants.add(q)

    # Check that no 2x2 tiles share edges (they should have gaps)
    # Actually, 2x2 tiles CAN share edges with OTHER 2x2 tiles if they were
    # placed later. The rule is only about pre-existing generated content.
    # Let's just verify the plan is valid.
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# 2x1/1x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x1RuleEnforcement:
  def test_2x1_extends_from_generated_edge(self) -> None:
    """2x1 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Pre-generated row above
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x2_extends_from_generated_edge(self) -> None:
    """1x2 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Pre-generated column to the left
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Plan Summary Tests
# =============================================================================


class TestPlanSummary:
  def test_summary_basic(self) -> None:
    """Test plan summary generation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    summary = get_plan_summary(plan)

    assert summary["bounds"]["width"] == 4
    assert summary["bounds"]["height"] == 4
    assert summary["total_quadrants"] == 16
    assert summary["total_steps"] > 0

  def test_summary_with_pre_generated(self) -> None:
    """Test summary with pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0), Point(0, 1)}
    plan = create_rectangle_plan(bounds, generated)
    summary = get_plan_summary(plan)

    assert summary["pre_generated_count"] == 2
    assert summary["total_quadrants"] == 14  # 16 - 2


# =============================================================================
# Edge Case Tests
# =============================================================================


class TestEdgeCases:
  def test_1x1_rectangle(self) -> None:
    """Smallest possible rectangle."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid

  def test_1x10_strip(self) -> None:
    """Very thin horizontal strip."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_10x1_strip(self) -> None:
    """Very thin vertical strip."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_large_rectangle(self) -> None:
    """Large rectangle (20x20)."""
    bounds = RectBounds(Point(0, 0), Point(19, 19))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have many 2x2 tiles (greedy algorithm may not be optimal)
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 40  # Should have a reasonable number of 2x2 tiles

  def test_checkerboard_pre_generated(self) -> None:
    """Checkerboard pattern of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Checkerboard: every other quadrant
    generated = {Point(x, y) for y in range(6) for x in range(6) if (x + y) % 2 == 0}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # All steps should be 1x1 due to checkerboard pattern
    for step in plan.steps:
      assert step.step_type == "1x1"

  def test_surrounded_by_generated(self) -> None:
    """Rectangle completely surrounded by generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    # Generate a border around the rectangle
    generated: set[Point] = set()
    for x in range(-1, 5):
      generated.add(Point(x, -1))  # Top
      generated.add(Point(x, 4))  # Bottom
    for y in range(0, 4):
      generated.add(Point(-1, y))  # Left
      generated.add(Point(4, y))  # Right

    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles CAN be placed in the interior (shielded by outer ring)
    # But edges should use smaller tiles
    # Check that all 2x2 tiles don't touch the generated border
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # 2x2 at edge positions would have generated neighbors
          # Interior 2x2 (at 1,1 or 1,2 etc.) is OK
          neighbors = [
            Point(q.x - 1, q.y),
            Point(q.x + 1, q.y),
            Point(q.x, q.y - 1),
            Point(q.x, q.y + 1),
          ]
          for n in neighbors:
            if n not in step.quadrants:  # Not part of the tile itself
              assert n not in generated, (
                f"2x2 at {step.quadrants} has neighbor {n} in generated"
              )


# =============================================================================
# Integration Tests - Complex Scenarios
# =============================================================================


class TestComplexScenarios:
  def test_partial_strip_extension(self) -> None:
    """Extending from a partially generated strip."""
    bounds = RectBounds(Point(0, 0), Point(7, 3))
    # Some quadrants above are generated
    generated = {Point(0, -1), Point(1, -1), Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_l_shaped_pre_generated(self) -> None:
    """L-shaped region of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # L-shape in top-left
    generated = {
      Point(-1, 0),
      Point(-1, 1),
      Point(-1, 2),
      Point(0, -1),
      Point(1, -1),
      Point(2, -1),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_island_of_generated(self) -> None:
    """Island of pre-generated quadrants in the middle."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # 2x2 island in the center
    generated = {Point(4, 4), Point(5, 4), Point(4, 5), Point(5, 5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Generated island should not be in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for g in generated:
      assert g not in all_quadrants

  def test_multiple_disjoint_pre_generated(self) -> None:
    """Multiple disjoint pre-generated regions."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # Two separate 2x2 regions
    generated = {
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
      Point(7, 7),
      Point(8, 7),
      Point(7, 8),
      Point(8, 8),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Serialization Tests
# =============================================================================


# =============================================================================
# Task 019 Strip Plan Pattern Tests
# =============================================================================


class TestStripPlanPattern:
  """
  Tests that verify the algorithm follows the 019 strip plan pattern:
  1. 2x2 tiles placed with gaps (every 3rd column)
  2. 1x2 bridges between 2x2 tiles
  3. 2x1 bridges connecting to generation edge
  4. 1x1 fills for remaining gaps
  """

  def test_depth_3_horizontal_pattern(self) -> None:
    """
    Test 6x3 rectangle with bottom edge generated.

    Expected pattern (following 019):
    Row 0-1: 2x2 at (0,0), (3,0) with 1x2 bridges at (2,0), (5,0)
    Row 2:   2x1 at (0,2), (3,2) with 1x1 at (2,2), (5,2)

    Visual:
    A A C B B D   <- row 0 (A=2x2, B=2x2, C=1x2, D=1x2)
    A A C B B D   <- row 1
    E E G F F H   <- row 2 (E=2x1, F=2x1, G=1x1, H=1x1)
    G G G G G G   <- generation edge (y=3, outside rectangle)
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generation edge at y=3 (below rectangle)
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 1x2, 2 2x1, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

    # Verify 2x2 positions
    two_by_two = [s for s in plan.steps if s.step_type == "2x2"]
    two_by_two_positions = [
      (min(q.x for q in s.quadrants), min(q.y for q in s.quadrants)) for s in two_by_two
    ]
    assert (0, 0) in two_by_two_positions
    assert (3, 0) in two_by_two_positions

    # Verify 1x2 positions (between 2x2 tiles)
    one_by_two = [s for s in plan.steps if s.step_type == "1x2"]
    one_by_two_positions = [s.quadrants[0] for s in one_by_two]
    assert Point(2, 0) in one_by_two_positions
    assert Point(5, 0) in one_by_two_positions

    # Verify 2x1 positions (connecting to edge)
    two_by_one = [s for s in plan.steps if s.step_type == "2x1"]
    two_by_one_positions = [
      (min(q.x for q in s.quadrants), s.quadrants[0].y) for s in two_by_one
    ]
    assert (0, 2) in two_by_one_positions
    assert (3, 2) in two_by_one_positions

  def test_depth_3_vertical_pattern(self) -> None:
    """
    Test 3x6 rectangle with left edge generated.

    Similar pattern but rotated 90 degrees.
    """
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Generation edge at x=-1 (left of rectangle)
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type - pattern should be similar
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 2x1, 2 1x2, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

  def test_1x2_bridges_between_2x2(self) -> None:
    """Test that 1x2 bridges correctly connect two 2x2 tiles."""
    # 5x3 rectangle (need 3 rows for 2x2 + bridge pattern)
    # With generation edge at y=3 (one row gap from 2x2 tiles)
    bounds = RectBounds(Point(0, 0), Point(4, 2))
    generated = {Point(x, 3) for x in range(5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Visual:
    # A A C B B   <- row 0 (A=2x2 at 0,0; B=2x2 at 3,0; C=1x2 at 2,0)
    # A A C B B   <- row 1
    # D D E F F   <- row 2 (D=2x1 at 0,2; E=1x1 at 2,2; F=2x1 at 3,2)
    # G G G G G   <- generation edge

    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # 2 2x2 tiles, 1 1x2 bridge, 2 2x1, 1 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 1, f"Expected 1 1x2 bridge, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 1, f"Expected 1 1x1 fill, got {types}"

  def test_order_matches_019_pattern(self) -> None:
    """
    Verify that generation order follows 019:
    1. 2x2 tiles first
    2. 1x2 bridges second
    3. 2x1 bridges third
    4. 1x1 fills last
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Check order
    current_phase = 0
    phase_order = {"2x2": 0, "1x2": 1, "2x1": 2, "1x1": 3}

    for step in plan.steps:
      phase = phase_order.get(step.step_type, 4)
      assert phase >= current_phase, (
        f"Step {step.step_type} appears after later phase. "
        f"Expected order: 2x2, 1x2, 2x1, 1x1"
      )
      current_phase = phase


class TestSerialization:
  def test_step_to_dict(self) -> None:
    """Test GenerationStep serialization."""
    step = GenerationStep(quadrants=[Point(0, 0), Point(1, 0)], step_type="2x1")
    d = step.to_dict()
    assert d["quadrants"] == [(0, 0), (1, 0)]
    assert d["type"] == "2x1"

  def test_plan_to_dict(self) -> None:
    """Test RectanglePlan serialization."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    d = plan.to_dict()

    assert d["bounds"]["top_left"] == (0, 0)
    assert d["bounds"]["bottom_right"] == (3, 3)
    assert len(d["steps"]) > 0


# =============================================================================
# Validation Tests
# =============================================================================


class TestValidation:
  def test_valid_plan(self) -> None:
    """Valid plan should pass validation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid
    assert len(errors) == 0

  def test_detect_duplicate_coverage(self) -> None:
    """Validation should detect duplicate coverage."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with duplicates
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0)]),
        GenerationStep(quadrants=[Point(0, 0), Point(0, 1)]),  # Duplicate!
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("multiple times" in e for e in errors)

  def test_detect_missing_quadrants(self) -> None:
    """Validation should detect missing quadrants."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with missing quadrant
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0), Point(0, 1)]),
        # Missing (1, 1)
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("Missing" in e for e in errors)


# =============================================================================
# Queued Quadrant Tests - Seam Detection with In-Progress/Queued Generations
# =============================================================================


class TestQueuedQuadrants:
  """
  Tests that verify the algorithm correctly considers in-progress and queued
  generations when determining if a seam will be formed.

  Queued quadrants are treated the same as generated quadrants for seam
  detection purposes - tiles cannot be placed adjacent to them.
  """

  def test_queued_quadrants_prevent_2x2_placement(self) -> None:
    """2x2 tiles cannot be placed adjacent to queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # No generated quadrants
    generated: set[Point] = set()
    # But there's a queued generation at (2, -1) - above the rectangle
    queued = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Find all 2x2 steps and verify none touch the queued quadrant
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        neighbors -= set(step.quadrants)
        for n in neighbors:
          assert n not in queued, f"2x2 at {step.quadrants} has queued neighbor {n}"

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_queued_quadrants_excluded_from_plan(self) -> None:
    """Queued quadrants within bounds should not be included in the plan."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Some interior points are queued
    queued = {Point(1, 1), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Should not include queued points in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(1, 1) not in all_quadrants
    assert Point(2, 2) not in all_quadrants

    # Plan should still be valid for non-queued quadrants
    is_valid, errors = validate_plan(plan)
    # Note: validation will fail because queued points are not in pre_generated
    # but the key check is that queued points are not in the plan
    covered = set(all_quadrants)
    expected = set(bounds.all_points()) - queued
    assert covered == expected, f"Expected {expected}, got {covered}"

  def test_queued_row_affects_2x1_placement(self) -> None:
    """2x1 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated: set[Point] = set()
    # Queued row below the rectangle acts like a generated edge
    queued = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 2x1 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at y=3, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"

  def test_queued_column_affects_1x2_placement(self) -> None:
    """1x2 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    generated: set[Point] = set()
    # Queued column to the left acts like a generated edge
    queued = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 1x2 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at x=-1, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"

  def test_mixed_generated_and_queued(self) -> None:
    """Plan should correctly handle both generated and queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Some quadrants are already generated
    generated = {Point(-1, 0), Point(-1, 1)}
    # Some quadrants are queued for generation
    queued = {Point(6, 0), Point(6, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles at left edge should not touch generated at (-1, 0) (-1, 1)
    # 2x2 tiles at right edge should not touch queued at (6, 0) (6, 1)
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # Check no neighbor is generated
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in generated, (
                f"2x2 at {step.quadrants} has generated neighbor {neighbor}"
              )
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_queued_quadrant_in_middle_prevents_2x2(self) -> None:
    """A queued quadrant in the middle should prevent 2x2 placement there."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queued 2x2 block in the center
    queued = {Point(1, 1), Point(2, 1), Point(1, 2), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # No step should include any queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # 2x2 tiles should not be placed adjacent to the queued block
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_from_coords_with_queued(self) -> None:
    """Test convenience function with queued set."""
    generated = {(0, 0), (1, 0)}
    queued = {(2, 0), (3, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (5, 3), generated, queued)

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    # Neither generated nor queued should be in plan
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants
    assert Point(2, 0) not in all_quadrants
    assert Point(3, 0) not in all_quadrants

  def test_fully_queued_rectangle(self) -> None:
    """Rectangle where all quadrants are queued should produce empty plan."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated: set[Point] = set()
    queued = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated, queued)

    assert len(plan.steps) == 0

  def test_queued_prevents_seam_with_future_generation(self) -> None:
    """
    Queued quadrants should be treated as if they will be generated,
    preventing seams with future generations.

    Scenario: User is generating a 2x2 at (0,0)-(1,1) and there's already
    a queued 2x2 at (2,0)-(3,1). The plan should not place tiles that
    would create a seam between them.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 3))
    generated: set[Point] = set()
    # First 2x2 is queued
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # The plan should not include the queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants

    # Verify the plan covers exactly the non-queued quadrants
    expected = set(bounds.all_points()) - queued
    covered = set(all_quadrants)
    assert covered == expected, f"Expected {expected}, got {covered}"

    # 2x2 tiles should not be placed at (2,0) because it would touch
    # the queued 2x2 at x=1
    for step in plan.steps:
      if step.step_type == "2x2":
        step_tl = min(q.x for q in step.quadrants), min(q.y for q in step.quadrants)
        # If there's a 2x2 at (2, 0), it would have neighbors at (1, 0) and (1, 1)
        # which are queued
        if step_tl == (2, 0):
          assert False, "2x2 at (2,0) would create seam with queued (0,0)-(1,1)"

```

```python
"""
Tests for make_rectangle_plan.py

These tests verify the rectangle generation planning algorithm handles
all cases correctly, including:
- Basic coverage of all quadrants
- 2x2 tile placement rules (no touching generated neighbors)
- 2x1/1x2 tile placement rules (extend from generated edges)
- 1x1 filling of remaining gaps
- Pre-existing generated quadrants
- Various rectangle sizes and configurations
"""

from isometric_nyc.e2e_generation.make_rectangle_plan import (
  GenerationStep,
  Point,
  RectanglePlan,
  RectBounds,
  can_place_1x2_vertical,
  can_place_2x1_horizontal,
  can_place_2x2,
  create_rectangle_plan,
  create_rectangle_plan_from_coords,
  get_2x2_neighbors,
  get_2x2_quadrants,
  get_plan_summary,
  validate_plan,
)

# =============================================================================
# Point Tests
# =============================================================================


class TestPoint:
  def test_str(self) -> None:
    p = Point(3, 5)
    assert str(p) == "(3,5)"

  def test_add(self) -> None:
    p1 = Point(1, 2)
    p2 = Point(3, 4)
    result = p1 + p2
    assert result == Point(4, 6)

  def test_from_string_simple(self) -> None:
    p = Point.from_string("3,5")
    assert p == Point(3, 5)

  def test_from_string_with_parens(self) -> None:
    p = Point.from_string("(3,5)")
    assert p == Point(3, 5)

  def test_from_string_negative(self) -> None:
    p = Point.from_string("-3,-5")
    assert p == Point(-3, -5)

  def test_to_tuple(self) -> None:
    p = Point(3, 5)
    assert p.to_tuple() == (3, 5)


# =============================================================================
# RectBounds Tests
# =============================================================================


class TestRectBounds:
  def test_width_height(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(10, 5))
    assert bounds.width == 11
    assert bounds.height == 6

  def test_area(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(3, 2))
    assert bounds.area == 12  # 4 x 3

  def test_contains(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert bounds.contains(Point(0, 0))
    assert bounds.contains(Point(5, 5))
    assert bounds.contains(Point(3, 3))
    assert not bounds.contains(Point(-1, 0))
    assert not bounds.contains(Point(6, 0))
    assert not bounds.contains(Point(0, -1))
    assert not bounds.contains(Point(0, 6))

  def test_all_points(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(2, 1))
    points = bounds.all_points()
    expected = [
      Point(0, 0),
      Point(1, 0),
      Point(2, 0),
      Point(0, 1),
      Point(1, 1),
      Point(2, 1),
    ]
    assert points == expected


# =============================================================================
# 2x2 Tile Helper Tests
# =============================================================================


class TestGet2x2Quadrants:
  def test_basic(self) -> None:
    quadrants = get_2x2_quadrants(Point(0, 0))
    assert quadrants == [
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
    ]

  def test_offset(self) -> None:
    quadrants = get_2x2_quadrants(Point(5, 3))
    assert quadrants == [
      Point(5, 3),
      Point(6, 3),
      Point(5, 4),
      Point(6, 4),
    ]


class TestGet2x2Neighbors:
  def test_basic(self) -> None:
    neighbors = get_2x2_neighbors(Point(0, 0))
    # Top, Bottom, Left, Right
    expected = [
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 2),
      Point(1, 2),  # Bottom
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(2, 0),
      Point(2, 1),  # Right
    ]
    assert set(neighbors) == set(expected)
    assert len(neighbors) == 8


# =============================================================================
# 2x2 Placement Tests
# =============================================================================


class TestCanPlace2x2:
  def test_empty_grid(self) -> None:
    """2x2 can be placed in empty rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert can_place_2x2(Point(0, 0), bounds, set(), set())

  def test_out_of_bounds(self) -> None:
    """2x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Top-left at (5, 5) would extend to (6, 6)
    assert not can_place_2x2(Point(5, 5), bounds, set(), set())
    # Top-left at (5, 0) would extend to (6, 1)
    assert not can_place_2x2(Point(5, 0), bounds, set(), set())

  def test_neighbor_generated_top(self) -> None:
    """2x2 cannot be placed if top neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Top neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_bottom(self) -> None:
    """2x2 cannot be placed if bottom neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2)}  # Bottom neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_left(self) -> None:
    """2x2 cannot be placed if left neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0)}  # Left neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_right(self) -> None:
    """2x2 cannot be placed if right neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0)}  # Right neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_generated(self) -> None:
    """2x2 cannot be placed if any quadrant is already generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 0)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_scheduled(self) -> None:
    """2x2 cannot be placed if any quadrant is already scheduled."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    scheduled = {Point(1, 1)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, set(), scheduled)

  def test_valid_with_distant_generated(self) -> None:
    """2x2 can be placed if generated quadrants are not neighbors."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(3, 3)}  # Far from (0,0) 2x2
    assert can_place_2x2(Point(0, 0), bounds, generated, set())


# =============================================================================
# 2x1 Horizontal Placement Tests
# =============================================================================


class TestCanPlace2x1Horizontal:
  def test_valid_with_top_generated(self) -> None:
    """2x1 can be placed when top row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(1, -1)}  # Top neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_with_bottom_generated(self) -> None:
    """2x1 can be placed when bottom row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 1), Point(1, 1)}  # Bottom neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_left_generated(self) -> None:
    """2x1 cannot be placed when left neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_right_generated(self) -> None:
    """2x1 cannot be placed when right neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """2x1 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """2x1 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 1),
      Point(1, 1),  # Bottom
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_only_partial_long_side(self) -> None:
    """2x1 cannot be placed when only one of two top neighbors is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Only one top neighbor
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """2x1 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(5, -1), Point(6, -1)}
    # Left at x=5 would extend to x=6
    assert not can_place_2x1_horizontal(Point(5, 0), bounds, generated, set())


# =============================================================================
# 1x2 Vertical Placement Tests
# =============================================================================


class TestCanPlace1x2Vertical:
  def test_valid_with_left_generated(self) -> None:
    """1x2 can be placed when left column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(-1, 1)}  # Left neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_with_right_generated(self) -> None:
    """1x2 can be placed when right column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(1, 0), Point(1, 1)}  # Right neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_top_generated(self) -> None:
    """1x2 cannot be placed when top neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_bottom_generated(self) -> None:
    """1x2 cannot be placed when bottom neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """1x2 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """1x2 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(1, 0),
      Point(1, 1),  # Right
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """1x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 5), Point(-1, 6)}
    # Top at y=5 would extend to y=6
    assert not can_place_1x2_vertical(Point(0, 5), bounds, generated, set())


# =============================================================================
# Full Rectangle Plan Tests
# =============================================================================


class TestCreateRectanglePlan:
  def test_empty_rectangle_no_generated(self) -> None:
    """Empty rectangle with no pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_with_context(self) -> None:
    """Single quadrant rectangle requires 3 neighbors for context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 requires 3 of 4 quadrants in a 2x2 block to be generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_without_context(self) -> None:
    """Single quadrant without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_2x2_rectangle(self) -> None:
    """2x2 rectangle should be a single 2x2 tile."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    plan = create_rectangle_plan(bounds)

    # Should have exactly one 2x2 step
    assert len(plan.steps) == 1
    assert len(plan.steps[0].quadrants) == 4
    assert plan.steps[0].step_type == "2x2"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_3x3_rectangle(self) -> None:
    """3x3 rectangle - mix of tiles."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_4x4_rectangle(self) -> None:
    """4x4 rectangle - should fit multiple 2x2 tiles."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have multiple 2x2 tiles
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 1

  def test_wide_rectangle(self) -> None:
    """Wide rectangle (10x2)."""
    bounds = RectBounds(Point(0, 0), Point(9, 1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_tall_rectangle(self) -> None:
    """Tall rectangle (2x10)."""
    bounds = RectBounds(Point(0, 0), Point(1, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_corner(self) -> None:
    """Rectangle with one corner already generated."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should not include (0,0) in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants

  def test_with_pre_generated_edge(self) -> None:
    """Rectangle with one edge already generated (outside the bounds)."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generated row above the rectangle
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_interior(self) -> None:
    """Rectangle with some interior quadrants already generated."""
    bounds = RectBounds(Point(0, 0), Point(4, 4))
    # Some interior points generated - form a vertical 1x2 block
    # This provides context for adjacent tiles
    generated = {Point(2, 2), Point(2, 3)}
    plan = create_rectangle_plan(bounds, generated)

    # Should not include generated points
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(2, 2) not in all_quadrants
    assert Point(2, 3) not in all_quadrants

    # The plan should cover the remaining quadrants
    # Note: Some gaps may remain if there's no valid context
    covered = set(all_quadrants)
    expected_to_cover = set(bounds.all_points()) - generated

    # Verify no extra quadrants are covered
    extra = covered - expected_to_cover
    assert not extra, f"Extra quadrants covered: {extra}"

  def test_fully_generated(self) -> None:
    """Rectangle where all quadrants are already generated."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 0
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_negative_coordinates(self) -> None:
    """Rectangle in negative coordinate space."""
    bounds = RectBounds(Point(-5, -3), Point(-2, -1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_convenience(self) -> None:
    """Test the convenience function with tuples."""
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3))

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_with_generated(self) -> None:
    """Test convenience function with pre-generated set."""
    generated = {(0, 0), (1, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3), generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants


# =============================================================================
# 2x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x2RuleEnforcement:
  def test_2x2_not_touching_pre_generated(self) -> None:
    """2x2 tiles should not touch pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Pre-generated quadrant at (2, -1) - above the rectangle
    generated = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    # Find all 2x2 steps
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        # Subtract the tile itself
        neighbors -= set(step.quadrants)
        # No neighbor should be pre-generated
        for n in neighbors:
          assert n not in generated, (
            f"2x2 at {step.quadrants} has pre-generated neighbor {n}"
          )

  def test_2x2_not_touching_other_scheduled(self) -> None:
    """2x2 tiles should not touch other scheduled tiles (at placement time)."""
    # This is verified by the algorithm itself - 2x2 tiles can only be placed
    # where no neighbor is scheduled. We verify by checking no 2x2 tiles share edges.
    bounds = RectBounds(Point(0, 0), Point(7, 7))
    plan = create_rectangle_plan(bounds)

    # Collect all 2x2 tile quadrants
    all_2x2_quadrants: set[Point] = set()
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          all_2x2_quadrants.add(q)

    # Check that no 2x2 tiles share edges (they should have gaps)
    # Actually, 2x2 tiles CAN share edges with OTHER 2x2 tiles if they were
    # placed later. The rule is only about pre-existing generated content.
    # Let's just verify the plan is valid.
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# 2x1/1x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x1RuleEnforcement:
  def test_2x1_extends_from_generated_edge(self) -> None:
    """2x1 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Pre-generated row above
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x2_extends_from_generated_edge(self) -> None:
    """1x2 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Pre-generated column to the left
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Plan Summary Tests
# =============================================================================


class TestPlanSummary:
  def test_summary_basic(self) -> None:
    """Test plan summary generation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    summary = get_plan_summary(plan)

    assert summary["bounds"]["width"] == 4
    assert summary["bounds"]["height"] == 4
    assert summary["total_quadrants"] == 16
    assert summary["total_steps"] > 0

  def test_summary_with_pre_generated(self) -> None:
    """Test summary with pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0), Point(0, 1)}
    plan = create_rectangle_plan(bounds, generated)
    summary = get_plan_summary(plan)

    assert summary["pre_generated_count"] == 2
    assert summary["total_quadrants"] == 14  # 16 - 2


# =============================================================================
# Edge Case Tests
# =============================================================================


class TestEdgeCases:
  def test_1x1_rectangle(self) -> None:
    """Smallest possible rectangle."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid

  def test_1x10_strip(self) -> None:
    """Very thin horizontal strip."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_10x1_strip(self) -> None:
    """Very thin vertical strip."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_large_rectangle(self) -> None:
    """Large rectangle (20x20)."""
    bounds = RectBounds(Point(0, 0), Point(19, 19))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have many 2x2 tiles (greedy algorithm may not be optimal)
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 40  # Should have a reasonable number of 2x2 tiles

  def test_checkerboard_pre_generated(self) -> None:
    """Checkerboard pattern of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Checkerboard: every other quadrant
    generated = {Point(x, y) for y in range(6) for x in range(6) if (x + y) % 2 == 0}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # All steps should be 1x1 due to checkerboard pattern
    for step in plan.steps:
      assert step.step_type == "1x1"

  def test_surrounded_by_generated(self) -> None:
    """Rectangle completely surrounded by generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    # Generate a border around the rectangle
    generated: set[Point] = set()
    for x in range(-1, 5):
      generated.add(Point(x, -1))  # Top
      generated.add(Point(x, 4))  # Bottom
    for y in range(0, 4):
      generated.add(Point(-1, y))  # Left
      generated.add(Point(4, y))  # Right

    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles CAN be placed in the interior (shielded by outer ring)
    # But edges should use smaller tiles
    # Check that all 2x2 tiles don't touch the generated border
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # 2x2 at edge positions would have generated neighbors
          # Interior 2x2 (at 1,1 or 1,2 etc.) is OK
          neighbors = [
            Point(q.x - 1, q.y),
            Point(q.x + 1, q.y),
            Point(q.x, q.y - 1),
            Point(q.x, q.y + 1),
          ]
          for n in neighbors:
            if n not in step.quadrants:  # Not part of the tile itself
              assert n not in generated, (
                f"2x2 at {step.quadrants} has neighbor {n} in generated"
              )


# =============================================================================
# Integration Tests - Complex Scenarios
# =============================================================================


class TestComplexScenarios:
  def test_partial_strip_extension(self) -> None:
    """Extending from a partially generated strip."""
    bounds = RectBounds(Point(0, 0), Point(7, 3))
    # Some quadrants above are generated
    generated = {Point(0, -1), Point(1, -1), Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_l_shaped_pre_generated(self) -> None:
    """L-shaped region of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # L-shape in top-left
    generated = {
      Point(-1, 0),
      Point(-1, 1),
      Point(-1, 2),
      Point(0, -1),
      Point(1, -1),
      Point(2, -1),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_island_of_generated(self) -> None:
    """Island of pre-generated quadrants in the middle."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # 2x2 island in the center
    generated = {Point(4, 4), Point(5, 4), Point(4, 5), Point(5, 5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Generated island should not be in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for g in generated:
      assert g not in all_quadrants

  def test_multiple_disjoint_pre_generated(self) -> None:
    """Multiple disjoint pre-generated regions."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # Two separate 2x2 regions
    generated = {
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
      Point(7, 7),
      Point(8, 7),
      Point(7, 8),
      Point(8, 8),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Serialization Tests
# =============================================================================


# =============================================================================
# Task 019 Strip Plan Pattern Tests
# =============================================================================


class TestStripPlanPattern:
  """
  Tests that verify the algorithm follows the 019 strip plan pattern:
  1. 2x2 tiles placed with gaps (every 3rd column)
  2. 1x2 bridges between 2x2 tiles
  3. 2x1 bridges connecting to generation edge
  4. 1x1 fills for remaining gaps
  """

  def test_depth_3_horizontal_pattern(self) -> None:
    """
    Test 6x3 rectangle with bottom edge generated.

    Expected pattern (following 019):
    Row 0-1: 2x2 at (0,0), (3,0) with 1x2 bridges at (2,0), (5,0)
    Row 2:   2x1 at (0,2), (3,2) with 1x1 at (2,2), (5,2)

    Visual:
    A A C B B D   <- row 0 (A=2x2, B=2x2, C=1x2, D=1x2)
    A A C B B D   <- row 1
    E E G F F H   <- row 2 (E=2x1, F=2x1, G=1x1, H=1x1)
    G G G G G G   <- generation edge (y=3, outside rectangle)
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generation edge at y=3 (below rectangle)
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 1x2, 2 2x1, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

    # Verify 2x2 positions
    two_by_two = [s for s in plan.steps if s.step_type == "2x2"]
    two_by_two_positions = [
      (min(q.x for q in s.quadrants), min(q.y for q in s.quadrants)) for s in two_by_two
    ]
    assert (0, 0) in two_by_two_positions
    assert (3, 0) in two_by_two_positions

    # Verify 1x2 positions (between 2x2 tiles)
    one_by_two = [s for s in plan.steps if s.step_type == "1x2"]
    one_by_two_positions = [s.quadrants[0] for s in one_by_two]
    assert Point(2, 0) in one_by_two_positions
    assert Point(5, 0) in one_by_two_positions

    # Verify 2x1 positions (connecting to edge)
    two_by_one = [s for s in plan.steps if s.step_type == "2x1"]
    two_by_one_positions = [
      (min(q.x for q in s.quadrants), s.quadrants[0].y) for s in two_by_one
    ]
    assert (0, 2) in two_by_one_positions
    assert (3, 2) in two_by_one_positions

  def test_depth_3_vertical_pattern(self) -> None:
    """
    Test 3x6 rectangle with left edge generated.

    Similar pattern but rotated 90 degrees.
    """
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Generation edge at x=-1 (left of rectangle)
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type - pattern should be similar
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 2x1, 2 1x2, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

  def test_1x2_bridges_between_2x2(self) -> None:
    """Test that 1x2 bridges correctly connect two 2x2 tiles."""
    # 5x3 rectangle (need 3 rows for 2x2 + bridge pattern)
    # With generation edge at y=3 (one row gap from 2x2 tiles)
    bounds = RectBounds(Point(0, 0), Point(4, 2))
    generated = {Point(x, 3) for x in range(5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Visual:
    # A A C B B   <- row 0 (A=2x2 at 0,0; B=2x2 at 3,0; C=1x2 at 2,0)
    # A A C B B   <- row 1
    # D D E F F   <- row 2 (D=2x1 at 0,2; E=1x1 at 2,2; F=2x1 at 3,2)
    # G G G G G   <- generation edge

    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # 2 2x2 tiles, 1 1x2 bridge, 2 2x1, 1 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 1, f"Expected 1 1x2 bridge, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 1, f"Expected 1 1x1 fill, got {types}"

  def test_order_matches_019_pattern(self) -> None:
    """
    Verify that generation order follows 019:
    1. 2x2 tiles first
    2. 1x2 bridges second
    3. 2x1 bridges third
    4. 1x1 fills last
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Check order
    current_phase = 0
    phase_order = {"2x2": 0, "1x2": 1, "2x1": 2, "1x1": 3}

    for step in plan.steps:
      phase = phase_order.get(step.step_type, 4)
      assert phase >= current_phase, (
        f"Step {step.step_type} appears after later phase. "
        f"Expected order: 2x2, 1x2, 2x1, 1x1"
      )
      current_phase = phase


class TestSerialization:
  def test_step_to_dict(self) -> None:
    """Test GenerationStep serialization."""
    step = GenerationStep(quadrants=[Point(0, 0), Point(1, 0)], step_type="2x1")
    d = step.to_dict()
    assert d["quadrants"] == [(0, 0), (1, 0)]
    assert d["type"] == "2x1"

  def test_plan_to_dict(self) -> None:
    """Test RectanglePlan serialization."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    d = plan.to_dict()

    assert d["bounds"]["top_left"] == (0, 0)
    assert d["bounds"]["bottom_right"] == (3, 3)
    assert len(d["steps"]) > 0


# =============================================================================
# Validation Tests
# =============================================================================


class TestValidation:
  def test_valid_plan(self) -> None:
    """Valid plan should pass validation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid
    assert len(errors) == 0

  def test_detect_duplicate_coverage(self) -> None:
    """Validation should detect duplicate coverage."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with duplicates
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0)]),
        GenerationStep(quadrants=[Point(0, 0), Point(0, 1)]),  # Duplicate!
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("multiple times" in e for e in errors)

  def test_detect_missing_quadrants(self) -> None:
    """Validation should detect missing quadrants."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with missing quadrant
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0), Point(0, 1)]),
        # Missing (1, 1)
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("Missing" in e for e in errors)


# =============================================================================
# Queued Quadrant Tests - Seam Detection with In-Progress/Queued Generations
# =============================================================================


class TestQueuedQuadrants:
  """
  Tests that verify the algorithm correctly considers in-progress and queued
  generations when determining if a seam will be formed.

  Queued quadrants are treated the same as generated quadrants for seam
  detection purposes - tiles cannot be placed adjacent to them.
  """

  def test_queued_quadrants_prevent_2x2_placement(self) -> None:
    """2x2 tiles cannot be placed adjacent to queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # No generated quadrants
    generated: set[Point] = set()
    # But there's a queued generation at (2, -1) - above the rectangle
    queued = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Find all 2x2 steps and verify none touch the queued quadrant
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        neighbors -= set(step.quadrants)
        for n in neighbors:
          assert n not in queued, f"2x2 at {step.quadrants} has queued neighbor {n}"

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_queued_quadrants_excluded_from_plan(self) -> None:
    """Queued quadrants within bounds should not be included in the plan."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Some interior points are queued
    queued = {Point(1, 1), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Should not include queued points in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(1, 1) not in all_quadrants
    assert Point(2, 2) not in all_quadrants

    # Plan should still be valid for non-queued quadrants
    is_valid, errors = validate_plan(plan)
    # Note: validation will fail because queued points are not in pre_generated
    # but the key check is that queued points are not in the plan
    covered = set(all_quadrants)
    expected = set(bounds.all_points()) - queued
    assert covered == expected, f"Expected {expected}, got {covered}"

  def test_queued_row_affects_2x1_placement(self) -> None:
    """2x1 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated: set[Point] = set()
    # Queued row below the rectangle acts like a generated edge
    queued = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 2x1 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at y=3, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"

  def test_queued_column_affects_1x2_placement(self) -> None:
    """1x2 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    generated: set[Point] = set()
    # Queued column to the left acts like a generated edge
    queued = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 1x2 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at x=-1, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"

  def test_mixed_generated_and_queued(self) -> None:
    """Plan should correctly handle both generated and queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Some quadrants are already generated
    generated = {Point(-1, 0), Point(-1, 1)}
    # Some quadrants are queued for generation
    queued = {Point(6, 0), Point(6, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles at left edge should not touch generated at (-1, 0) (-1, 1)
    # 2x2 tiles at right edge should not touch queued at (6, 0) (6, 1)
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # Check no neighbor is generated
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in generated, (
                f"2x2 at {step.quadrants} has generated neighbor {neighbor}"
              )
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_queued_quadrant_in_middle_prevents_2x2(self) -> None:
    """A queued quadrant in the middle should prevent 2x2 placement there."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queued 2x2 block in the center
    queued = {Point(1, 1), Point(2, 1), Point(1, 2), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # No step should include any queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # 2x2 tiles should not be placed adjacent to the queued block
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_from_coords_with_queued(self) -> None:
    """Test convenience function with queued set."""
    generated = {(0, 0), (1, 0)}
    queued = {(2, 0), (3, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (5, 3), generated, queued)

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    # Neither generated nor queued should be in plan
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants
    assert Point(2, 0) not in all_quadrants
    assert Point(3, 0) not in all_quadrants

  def test_fully_queued_rectangle(self) -> None:
    """Rectangle where all quadrants are queued should produce empty plan."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated: set[Point] = set()
    queued = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated, queued)

    assert len(plan.steps) == 0

  def test_queued_prevents_seam_with_future_generation(self) -> None:
    """
    Queued quadrants should be treated as if they will be generated,
    preventing seams with future generations.

    Scenario: User is generating a 2x2 at (0,0)-(1,1) and there's already
    a queued 2x2 at (2,0)-(3,1). The plan should not place tiles that
    would create a seam between them.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 3))
    generated: set[Point] = set()
    # First 2x2 is queued
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # The plan should not include the queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants

    # Verify the plan covers exactly the non-queued quadrants
    expected = set(bounds.all_points()) - queued
    covered = set(all_quadrants)
    assert covered == expected, f"Expected {expected}, got {covered}"

    # 2x2 tiles should not be placed at (2,0) because it would touch
    # the queued 2x2 at x=1
    for step in plan.steps:
      if step.step_type == "2x2":
        step_tl = min(q.x for q in step.quadrants), min(q.y for q in step.quadrants)
        # If there's a 2x2 at (2, 0), it would have neighbors at (1, 0) and (1, 1)
        # which are queued
        if step_tl == (2, 0):
          assert False, "2x2 at (2,0) would create seam with queued (0,0)-(1,1)"

```

```python
"""
Tests for make_rectangle_plan.py

These tests verify the rectangle generation planning algorithm handles
all cases correctly, including:
- Basic coverage of all quadrants
- 2x2 tile placement rules (no touching generated neighbors)
- 2x1/1x2 tile placement rules (extend from generated edges)
- 1x1 filling of remaining gaps
- Pre-existing generated quadrants
- Various rectangle sizes and configurations
"""

from isometric_nyc.e2e_generation.make_rectangle_plan import (
  GenerationStep,
  Point,
  RectanglePlan,
  RectBounds,
  can_place_1x2_vertical,
  can_place_2x1_horizontal,
  can_place_2x2,
  create_rectangle_plan,
  create_rectangle_plan_from_coords,
  get_2x2_neighbors,
  get_2x2_quadrants,
  get_plan_summary,
  validate_plan,
)

# =============================================================================
# Point Tests
# =============================================================================


class TestPoint:
  def test_str(self) -> None:
    p = Point(3, 5)
    assert str(p) == "(3,5)"

  def test_add(self) -> None:
    p1 = Point(1, 2)
    p2 = Point(3, 4)
    result = p1 + p2
    assert result == Point(4, 6)

  def test_from_string_simple(self) -> None:
    p = Point.from_string("3,5")
    assert p == Point(3, 5)

  def test_from_string_with_parens(self) -> None:
    p = Point.from_string("(3,5)")
    assert p == Point(3, 5)

  def test_from_string_negative(self) -> None:
    p = Point.from_string("-3,-5")
    assert p == Point(-3, -5)

  def test_to_tuple(self) -> None:
    p = Point(3, 5)
    assert p.to_tuple() == (3, 5)


# =============================================================================
# RectBounds Tests
# =============================================================================


class TestRectBounds:
  def test_width_height(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(10, 5))
    assert bounds.width == 11
    assert bounds.height == 6

  def test_area(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(3, 2))
    assert bounds.area == 12  # 4 x 3

  def test_contains(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert bounds.contains(Point(0, 0))
    assert bounds.contains(Point(5, 5))
    assert bounds.contains(Point(3, 3))
    assert not bounds.contains(Point(-1, 0))
    assert not bounds.contains(Point(6, 0))
    assert not bounds.contains(Point(0, -1))
    assert not bounds.contains(Point(0, 6))

  def test_all_points(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(2, 1))
    points = bounds.all_points()
    expected = [
      Point(0, 0),
      Point(1, 0),
      Point(2, 0),
      Point(0, 1),
      Point(1, 1),
      Point(2, 1),
    ]
    assert points == expected


# =============================================================================
# 2x2 Tile Helper Tests
# =============================================================================


class TestGet2x2Quadrants:
  def test_basic(self) -> None:
    quadrants = get_2x2_quadrants(Point(0, 0))
    assert quadrants == [
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
    ]

  def test_offset(self) -> None:
    quadrants = get_2x2_quadrants(Point(5, 3))
    assert quadrants == [
      Point(5, 3),
      Point(6, 3),
      Point(5, 4),
      Point(6, 4),
    ]


class TestGet2x2Neighbors:
  def test_basic(self) -> None:
    neighbors = get_2x2_neighbors(Point(0, 0))
    # Top, Bottom, Left, Right
    expected = [
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 2),
      Point(1, 2),  # Bottom
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(2, 0),
      Point(2, 1),  # Right
    ]
    assert set(neighbors) == set(expected)
    assert len(neighbors) == 8


# =============================================================================
# 2x2 Placement Tests
# =============================================================================


class TestCanPlace2x2:
  def test_empty_grid(self) -> None:
    """2x2 can be placed in empty rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert can_place_2x2(Point(0, 0), bounds, set(), set())

  def test_out_of_bounds(self) -> None:
    """2x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Top-left at (5, 5) would extend to (6, 6)
    assert not can_place_2x2(Point(5, 5), bounds, set(), set())
    # Top-left at (5, 0) would extend to (6, 1)
    assert not can_place_2x2(Point(5, 0), bounds, set(), set())

  def test_neighbor_generated_top(self) -> None:
    """2x2 cannot be placed if top neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Top neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_bottom(self) -> None:
    """2x2 cannot be placed if bottom neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2)}  # Bottom neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_left(self) -> None:
    """2x2 cannot be placed if left neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0)}  # Left neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_right(self) -> None:
    """2x2 cannot be placed if right neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0)}  # Right neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_generated(self) -> None:
    """2x2 cannot be placed if any quadrant is already generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 0)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_scheduled(self) -> None:
    """2x2 cannot be placed if any quadrant is already scheduled."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    scheduled = {Point(1, 1)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, set(), scheduled)

  def test_valid_with_distant_generated(self) -> None:
    """2x2 can be placed if generated quadrants are not neighbors."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(3, 3)}  # Far from (0,0) 2x2
    assert can_place_2x2(Point(0, 0), bounds, generated, set())


# =============================================================================
# 2x1 Horizontal Placement Tests
# =============================================================================


class TestCanPlace2x1Horizontal:
  def test_valid_with_top_generated(self) -> None:
    """2x1 can be placed when top row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(1, -1)}  # Top neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_with_bottom_generated(self) -> None:
    """2x1 can be placed when bottom row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 1), Point(1, 1)}  # Bottom neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_left_generated(self) -> None:
    """2x1 cannot be placed when left neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_right_generated(self) -> None:
    """2x1 cannot be placed when right neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """2x1 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """2x1 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 1),
      Point(1, 1),  # Bottom
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_only_partial_long_side(self) -> None:
    """2x1 cannot be placed when only one of two top neighbors is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Only one top neighbor
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """2x1 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(5, -1), Point(6, -1)}
    # Left at x=5 would extend to x=6
    assert not can_place_2x1_horizontal(Point(5, 0), bounds, generated, set())


# =============================================================================
# 1x2 Vertical Placement Tests
# =============================================================================


class TestCanPlace1x2Vertical:
  def test_valid_with_left_generated(self) -> None:
    """1x2 can be placed when left column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(-1, 1)}  # Left neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_with_right_generated(self) -> None:
    """1x2 can be placed when right column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(1, 0), Point(1, 1)}  # Right neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_top_generated(self) -> None:
    """1x2 cannot be placed when top neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_bottom_generated(self) -> None:
    """1x2 cannot be placed when bottom neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """1x2 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """1x2 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(1, 0),
      Point(1, 1),  # Right
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """1x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 5), Point(-1, 6)}
    # Top at y=5 would extend to y=6
    assert not can_place_1x2_vertical(Point(0, 5), bounds, generated, set())


# =============================================================================
# Full Rectangle Plan Tests
# =============================================================================


class TestCreateRectanglePlan:
  def test_empty_rectangle_no_generated(self) -> None:
    """Empty rectangle with no pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_with_context(self) -> None:
    """Single quadrant rectangle requires 3 neighbors for context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 requires 3 of 4 quadrants in a 2x2 block to be generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_without_context(self) -> None:
    """Single quadrant without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_2x2_rectangle(self) -> None:
    """2x2 rectangle should be a single 2x2 tile."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    plan = create_rectangle_plan(bounds)

    # Should have exactly one 2x2 step
    assert len(plan.steps) == 1
    assert len(plan.steps[0].quadrants) == 4
    assert plan.steps[0].step_type == "2x2"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_3x3_rectangle(self) -> None:
    """3x3 rectangle - mix of tiles."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_4x4_rectangle(self) -> None:
    """4x4 rectangle - should fit multiple 2x2 tiles."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have multiple 2x2 tiles
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 1

  def test_wide_rectangle(self) -> None:
    """Wide rectangle (10x2)."""
    bounds = RectBounds(Point(0, 0), Point(9, 1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_tall_rectangle(self) -> None:
    """Tall rectangle (2x10)."""
    bounds = RectBounds(Point(0, 0), Point(1, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_corner(self) -> None:
    """Rectangle with one corner already generated."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should not include (0,0) in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants

  def test_with_pre_generated_edge(self) -> None:
    """Rectangle with one edge already generated (outside the bounds)."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generated row above the rectangle
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_interior(self) -> None:
    """Rectangle with some interior quadrants already generated."""
    bounds = RectBounds(Point(0, 0), Point(4, 4))
    # Some interior points generated - form a vertical 1x2 block
    # This provides context for adjacent tiles
    generated = {Point(2, 2), Point(2, 3)}
    plan = create_rectangle_plan(bounds, generated)

    # Should not include generated points
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(2, 2) not in all_quadrants
    assert Point(2, 3) not in all_quadrants

    # The plan should cover the remaining quadrants
    # Note: Some gaps may remain if there's no valid context
    covered = set(all_quadrants)
    expected_to_cover = set(bounds.all_points()) - generated

    # Verify no extra quadrants are covered
    extra = covered - expected_to_cover
    assert not extra, f"Extra quadrants covered: {extra}"

  def test_fully_generated(self) -> None:
    """Rectangle where all quadrants are already generated."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 0
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_negative_coordinates(self) -> None:
    """Rectangle in negative coordinate space."""
    bounds = RectBounds(Point(-5, -3), Point(-2, -1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_convenience(self) -> None:
    """Test the convenience function with tuples."""
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3))

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_with_generated(self) -> None:
    """Test convenience function with pre-generated set."""
    generated = {(0, 0), (1, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3), generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants


# =============================================================================
# 2x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x2RuleEnforcement:
  def test_2x2_not_touching_pre_generated(self) -> None:
    """2x2 tiles should not touch pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Pre-generated quadrant at (2, -1) - above the rectangle
    generated = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    # Find all 2x2 steps
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        # Subtract the tile itself
        neighbors -= set(step.quadrants)
        # No neighbor should be pre-generated
        for n in neighbors:
          assert n not in generated, (
            f"2x2 at {step.quadrants} has pre-generated neighbor {n}"
          )

  def test_2x2_not_touching_other_scheduled(self) -> None:
    """2x2 tiles should not touch other scheduled tiles (at placement time)."""
    # This is verified by the algorithm itself - 2x2 tiles can only be placed
    # where no neighbor is scheduled. We verify by checking no 2x2 tiles share edges.
    bounds = RectBounds(Point(0, 0), Point(7, 7))
    plan = create_rectangle_plan(bounds)

    # Collect all 2x2 tile quadrants
    all_2x2_quadrants: set[Point] = set()
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          all_2x2_quadrants.add(q)

    # Check that no 2x2 tiles share edges (they should have gaps)
    # Actually, 2x2 tiles CAN share edges with OTHER 2x2 tiles if they were
    # placed later. The rule is only about pre-existing generated content.
    # Let's just verify the plan is valid.
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# 2x1/1x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x1RuleEnforcement:
  def test_2x1_extends_from_generated_edge(self) -> None:
    """2x1 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Pre-generated row above
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x2_extends_from_generated_edge(self) -> None:
    """1x2 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Pre-generated column to the left
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Plan Summary Tests
# =============================================================================


class TestPlanSummary:
  def test_summary_basic(self) -> None:
    """Test plan summary generation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    summary = get_plan_summary(plan)

    assert summary["bounds"]["width"] == 4
    assert summary["bounds"]["height"] == 4
    assert summary["total_quadrants"] == 16
    assert summary["total_steps"] > 0

  def test_summary_with_pre_generated(self) -> None:
    """Test summary with pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0), Point(0, 1)}
    plan = create_rectangle_plan(bounds, generated)
    summary = get_plan_summary(plan)

    assert summary["pre_generated_count"] == 2
    assert summary["total_quadrants"] == 14  # 16 - 2


# =============================================================================
# Edge Case Tests
# =============================================================================


class TestEdgeCases:
  def test_1x1_rectangle_with_context(self) -> None:
    """Smallest possible rectangle with 3-neighbor context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 needs 3 of 4 quadrants in a 2x2 block generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid

  def test_1x1_rectangle_without_context(self) -> None:
    """1x1 rectangle without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_1x10_strip_with_context(self) -> None:
    """Very thin horizontal strip with bottom edge context."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    # Add context row below the strip
    generated = {Point(x, 1) for x in range(10)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x10_strip_without_context(self) -> None:
    """Thin strip without context cannot be fully generated."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed (can't place 2x2 in 1-row strip)
    assert len(plan.steps) == 0

  def test_10x1_strip_with_context(self) -> None:
    """Very thin vertical strip with right edge context."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    # Add context column to the right
    generated = {Point(1, y) for y in range(10)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_10x1_strip_without_context(self) -> None:
    """Thin strip without context cannot be fully generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed (can't place 2x2 in 1-col strip)
    assert len(plan.steps) == 0

  def test_large_rectangle(self) -> None:
    """Large rectangle (20x20)."""
    bounds = RectBounds(Point(0, 0), Point(19, 19))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have many 2x2 tiles (greedy algorithm may not be optimal)
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 40  # Should have a reasonable number of 2x2 tiles

  def test_checkerboard_pre_generated(self) -> None:
    """Checkerboard pattern of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Checkerboard: every other quadrant
    generated = {Point(x, y) for y in range(6) for x in range(6) if (x + y) % 2 == 0}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # All steps should be 1x1 due to checkerboard pattern
    for step in plan.steps:
      assert step.step_type == "1x1"

  def test_surrounded_by_generated(self) -> None:
    """Rectangle completely surrounded by generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    # Generate a border around the rectangle
    generated: set[Point] = set()
    for x in range(-1, 5):
      generated.add(Point(x, -1))  # Top
      generated.add(Point(x, 4))  # Bottom
    for y in range(0, 4):
      generated.add(Point(-1, y))  # Left
      generated.add(Point(4, y))  # Right

    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles CAN be placed in the interior (shielded by outer ring)
    # But edges should use smaller tiles
    # Check that all 2x2 tiles don't touch the generated border
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # 2x2 at edge positions would have generated neighbors
          # Interior 2x2 (at 1,1 or 1,2 etc.) is OK
          neighbors = [
            Point(q.x - 1, q.y),
            Point(q.x + 1, q.y),
            Point(q.x, q.y - 1),
            Point(q.x, q.y + 1),
          ]
          for n in neighbors:
            if n not in step.quadrants:  # Not part of the tile itself
              assert n not in generated, (
                f"2x2 at {step.quadrants} has neighbor {n} in generated"
              )


# =============================================================================
# Integration Tests - Complex Scenarios
# =============================================================================


class TestComplexScenarios:
  def test_partial_strip_extension(self) -> None:
    """Extending from a partially generated strip."""
    bounds = RectBounds(Point(0, 0), Point(7, 3))
    # Some quadrants above are generated
    generated = {Point(0, -1), Point(1, -1), Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_l_shaped_pre_generated(self) -> None:
    """L-shaped region of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # L-shape in top-left
    generated = {
      Point(-1, 0),
      Point(-1, 1),
      Point(-1, 2),
      Point(0, -1),
      Point(1, -1),
      Point(2, -1),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_island_of_generated(self) -> None:
    """Island of pre-generated quadrants in the middle."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # 2x2 island in the center
    generated = {Point(4, 4), Point(5, 4), Point(4, 5), Point(5, 5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Generated island should not be in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for g in generated:
      assert g not in all_quadrants

  def test_multiple_disjoint_pre_generated(self) -> None:
    """Multiple disjoint pre-generated regions."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # Two separate 2x2 regions
    generated = {
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
      Point(7, 7),
      Point(8, 7),
      Point(7, 8),
      Point(8, 8),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Serialization Tests
# =============================================================================


# =============================================================================
# Task 019 Strip Plan Pattern Tests
# =============================================================================


class TestStripPlanPattern:
  """
  Tests that verify the algorithm follows the 019 strip plan pattern:
  1. 2x2 tiles placed with gaps (every 3rd column)
  2. 1x2 bridges between 2x2 tiles
  3. 2x1 bridges connecting to generation edge
  4. 1x1 fills for remaining gaps
  """

  def test_depth_3_horizontal_pattern(self) -> None:
    """
    Test 6x3 rectangle with bottom edge generated.

    Expected pattern (following 019):
    Row 0-1: 2x2 at (0,0), (3,0) with 1x2 bridges at (2,0), (5,0)
    Row 2:   2x1 at (0,2), (3,2) with 1x1 at (2,2), (5,2)

    Visual:
    A A C B B D   <- row 0 (A=2x2, B=2x2, C=1x2, D=1x2)
    A A C B B D   <- row 1
    E E G F F H   <- row 2 (E=2x1, F=2x1, G=1x1, H=1x1)
    G G G G G G   <- generation edge (y=3, outside rectangle)
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generation edge at y=3 (below rectangle)
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 1x2, 2 2x1, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

    # Verify 2x2 positions
    two_by_two = [s for s in plan.steps if s.step_type == "2x2"]
    two_by_two_positions = [
      (min(q.x for q in s.quadrants), min(q.y for q in s.quadrants)) for s in two_by_two
    ]
    assert (0, 0) in two_by_two_positions
    assert (3, 0) in two_by_two_positions

    # Verify 1x2 positions (between 2x2 tiles)
    one_by_two = [s for s in plan.steps if s.step_type == "1x2"]
    one_by_two_positions = [s.quadrants[0] for s in one_by_two]
    assert Point(2, 0) in one_by_two_positions
    assert Point(5, 0) in one_by_two_positions

    # Verify 2x1 positions (connecting to edge)
    two_by_one = [s for s in plan.steps if s.step_type == "2x1"]
    two_by_one_positions = [
      (min(q.x for q in s.quadrants), s.quadrants[0].y) for s in two_by_one
    ]
    assert (0, 2) in two_by_one_positions
    assert (3, 2) in two_by_one_positions

  def test_depth_3_vertical_pattern(self) -> None:
    """
    Test 3x6 rectangle with left edge generated.

    Similar pattern but rotated 90 degrees.
    """
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Generation edge at x=-1 (left of rectangle)
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type - pattern should be similar
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 2x1, 2 1x2, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

  def test_1x2_bridges_between_2x2(self) -> None:
    """Test that 1x2 bridges correctly connect two 2x2 tiles."""
    # 5x3 rectangle (need 3 rows for 2x2 + bridge pattern)
    # With generation edge at y=3 (one row gap from 2x2 tiles)
    bounds = RectBounds(Point(0, 0), Point(4, 2))
    generated = {Point(x, 3) for x in range(5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Visual:
    # A A C B B   <- row 0 (A=2x2 at 0,0; B=2x2 at 3,0; C=1x2 at 2,0)
    # A A C B B   <- row 1
    # D D E F F   <- row 2 (D=2x1 at 0,2; E=1x1 at 2,2; F=2x1 at 3,2)
    # G G G G G   <- generation edge

    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # 2 2x2 tiles, 1 1x2 bridge, 2 2x1, 1 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 1, f"Expected 1 1x2 bridge, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 1, f"Expected 1 1x1 fill, got {types}"

  def test_order_matches_019_pattern(self) -> None:
    """
    Verify that generation order follows 019:
    1. 2x2 tiles first
    2. 1x2 bridges second
    3. 2x1 bridges third
    4. 1x1 fills last
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Check order
    current_phase = 0
    phase_order = {"2x2": 0, "1x2": 1, "2x1": 2, "1x1": 3}

    for step in plan.steps:
      phase = phase_order.get(step.step_type, 4)
      assert phase >= current_phase, (
        f"Step {step.step_type} appears after later phase. "
        f"Expected order: 2x2, 1x2, 2x1, 1x1"
      )
      current_phase = phase


class TestSerialization:
  def test_step_to_dict(self) -> None:
    """Test GenerationStep serialization."""
    step = GenerationStep(quadrants=[Point(0, 0), Point(1, 0)], step_type="2x1")
    d = step.to_dict()
    assert d["quadrants"] == [(0, 0), (1, 0)]
    assert d["type"] == "2x1"

  def test_plan_to_dict(self) -> None:
    """Test RectanglePlan serialization."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    d = plan.to_dict()

    assert d["bounds"]["top_left"] == (0, 0)
    assert d["bounds"]["bottom_right"] == (3, 3)
    assert len(d["steps"]) > 0


# =============================================================================
# Validation Tests
# =============================================================================


class TestValidation:
  def test_valid_plan(self) -> None:
    """Valid plan should pass validation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid
    assert len(errors) == 0

  def test_detect_duplicate_coverage(self) -> None:
    """Validation should detect duplicate coverage."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with duplicates
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0)]),
        GenerationStep(quadrants=[Point(0, 0), Point(0, 1)]),  # Duplicate!
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("multiple times" in e for e in errors)

  def test_detect_missing_quadrants(self) -> None:
    """Validation should detect missing quadrants."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with missing quadrant
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0), Point(0, 1)]),
        # Missing (1, 1)
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("Missing" in e for e in errors)


# =============================================================================
# Queued Quadrant Tests - Seam Detection with In-Progress/Queued Generations
# =============================================================================


class TestQueuedQuadrants:
  """
  Tests that verify the algorithm correctly considers in-progress and queued
  generations when determining if a seam will be formed.

  Queued quadrants are treated the same as generated quadrants for seam
  detection purposes - tiles cannot be placed adjacent to them.
  """

  def test_queued_quadrants_prevent_2x2_placement(self) -> None:
    """2x2 tiles cannot be placed adjacent to queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # No generated quadrants
    generated: set[Point] = set()
    # But there's a queued generation at (2, -1) - above the rectangle
    queued = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Find all 2x2 steps and verify none touch the queued quadrant
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        neighbors -= set(step.quadrants)
        for n in neighbors:
          assert n not in queued, f"2x2 at {step.quadrants} has queued neighbor {n}"

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_queued_quadrants_excluded_from_plan(self) -> None:
    """Queued quadrants within bounds should not be included in the plan."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Some interior points are queued
    queued = {Point(1, 1), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Should not include queued points in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(1, 1) not in all_quadrants
    assert Point(2, 2) not in all_quadrants

    # Plan should still be valid for non-queued quadrants
    is_valid, errors = validate_plan(plan)
    # Note: validation will fail because queued points are not in pre_generated
    # but the key check is that queued points are not in the plan
    covered = set(all_quadrants)
    expected = set(bounds.all_points()) - queued
    assert covered == expected, f"Expected {expected}, got {covered}"

  def test_queued_row_affects_2x1_placement(self) -> None:
    """2x1 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated: set[Point] = set()
    # Queued row below the rectangle acts like a generated edge
    queued = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 2x1 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at y=3, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"

  def test_queued_column_affects_1x2_placement(self) -> None:
    """1x2 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    generated: set[Point] = set()
    # Queued column to the left acts like a generated edge
    queued = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 1x2 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at x=-1, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"

  def test_mixed_generated_and_queued(self) -> None:
    """Plan should correctly handle both generated and queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Some quadrants are already generated
    generated = {Point(-1, 0), Point(-1, 1)}
    # Some quadrants are queued for generation
    queued = {Point(6, 0), Point(6, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles at left edge should not touch generated at (-1, 0) (-1, 1)
    # 2x2 tiles at right edge should not touch queued at (6, 0) (6, 1)
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # Check no neighbor is generated
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in generated, (
                f"2x2 at {step.quadrants} has generated neighbor {neighbor}"
              )
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_queued_quadrant_in_middle_prevents_2x2(self) -> None:
    """A queued quadrant in the middle should prevent 2x2 placement there."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queued 2x2 block in the center
    queued = {Point(1, 1), Point(2, 1), Point(1, 2), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # No step should include any queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # 2x2 tiles should not be placed adjacent to the queued block
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_from_coords_with_queued(self) -> None:
    """Test convenience function with queued set."""
    generated = {(0, 0), (1, 0)}
    queued = {(2, 0), (3, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (5, 3), generated, queued)

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    # Neither generated nor queued should be in plan
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants
    assert Point(2, 0) not in all_quadrants
    assert Point(3, 0) not in all_quadrants

  def test_fully_queued_rectangle(self) -> None:
    """Rectangle where all quadrants are queued should produce empty plan."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated: set[Point] = set()
    queued = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated, queued)

    assert len(plan.steps) == 0

  def test_queued_prevents_seam_with_future_generation(self) -> None:
    """
    Queued quadrants should be treated as if they will be generated,
    preventing seams with future generations.

    Scenario: User is generating a 2x2 at (0,0)-(1,1) and there's already
    a queued 2x2 at (2,0)-(3,1). The plan should not place tiles that
    would create a seam between them.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 3))
    generated: set[Point] = set()
    # First 2x2 is queued
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # The plan should not include the queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants

    # Verify the plan covers exactly the non-queued quadrants
    expected = set(bounds.all_points()) - queued
    covered = set(all_quadrants)
    assert covered == expected, f"Expected {expected}, got {covered}"

    # 2x2 tiles should not be placed at (2,0) because it would touch
    # the queued 2x2 at x=1
    for step in plan.steps:
      if step.step_type == "2x2":
        step_tl = min(q.x for q in step.quadrants), min(q.y for q in step.quadrants)
        # If there's a 2x2 at (2, 0), it would have neighbors at (1, 0) and (1, 1)
        # which are queued
        if step_tl == (2, 0):
          assert False, "2x2 at (2,0) would create seam with queued (0,0)-(1,1)"

```

```python
"""
Tests for make_rectangle_plan.py

These tests verify the rectangle generation planning algorithm handles
all cases correctly, including:
- Basic coverage of all quadrants
- 2x2 tile placement rules (no touching generated neighbors)
- 2x1/1x2 tile placement rules (extend from generated edges)
- 1x1 filling of remaining gaps
- Pre-existing generated quadrants
- Various rectangle sizes and configurations
"""

from isometric_nyc.e2e_generation.make_rectangle_plan import (
  GenerationStep,
  Point,
  RectanglePlan,
  RectBounds,
  can_place_1x2_vertical,
  can_place_2x1_horizontal,
  can_place_2x2,
  create_rectangle_plan,
  create_rectangle_plan_from_coords,
  get_2x2_neighbors,
  get_2x2_quadrants,
  get_plan_summary,
  validate_plan,
)

# =============================================================================
# Point Tests
# =============================================================================


class TestPoint:
  def test_str(self) -> None:
    p = Point(3, 5)
    assert str(p) == "(3,5)"

  def test_add(self) -> None:
    p1 = Point(1, 2)
    p2 = Point(3, 4)
    result = p1 + p2
    assert result == Point(4, 6)

  def test_from_string_simple(self) -> None:
    p = Point.from_string("3,5")
    assert p == Point(3, 5)

  def test_from_string_with_parens(self) -> None:
    p = Point.from_string("(3,5)")
    assert p == Point(3, 5)

  def test_from_string_negative(self) -> None:
    p = Point.from_string("-3,-5")
    assert p == Point(-3, -5)

  def test_to_tuple(self) -> None:
    p = Point(3, 5)
    assert p.to_tuple() == (3, 5)


# =============================================================================
# RectBounds Tests
# =============================================================================


class TestRectBounds:
  def test_width_height(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(10, 5))
    assert bounds.width == 11
    assert bounds.height == 6

  def test_area(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(3, 2))
    assert bounds.area == 12  # 4 x 3

  def test_contains(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert bounds.contains(Point(0, 0))
    assert bounds.contains(Point(5, 5))
    assert bounds.contains(Point(3, 3))
    assert not bounds.contains(Point(-1, 0))
    assert not bounds.contains(Point(6, 0))
    assert not bounds.contains(Point(0, -1))
    assert not bounds.contains(Point(0, 6))

  def test_all_points(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(2, 1))
    points = bounds.all_points()
    expected = [
      Point(0, 0),
      Point(1, 0),
      Point(2, 0),
      Point(0, 1),
      Point(1, 1),
      Point(2, 1),
    ]
    assert points == expected


# =============================================================================
# 2x2 Tile Helper Tests
# =============================================================================


class TestGet2x2Quadrants:
  def test_basic(self) -> None:
    quadrants = get_2x2_quadrants(Point(0, 0))
    assert quadrants == [
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
    ]

  def test_offset(self) -> None:
    quadrants = get_2x2_quadrants(Point(5, 3))
    assert quadrants == [
      Point(5, 3),
      Point(6, 3),
      Point(5, 4),
      Point(6, 4),
    ]


class TestGet2x2Neighbors:
  def test_basic(self) -> None:
    neighbors = get_2x2_neighbors(Point(0, 0))
    # Top, Bottom, Left, Right
    expected = [
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 2),
      Point(1, 2),  # Bottom
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(2, 0),
      Point(2, 1),  # Right
    ]
    assert set(neighbors) == set(expected)
    assert len(neighbors) == 8


# =============================================================================
# 2x2 Placement Tests
# =============================================================================


class TestCanPlace2x2:
  def test_empty_grid(self) -> None:
    """2x2 can be placed in empty rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert can_place_2x2(Point(0, 0), bounds, set(), set())

  def test_out_of_bounds(self) -> None:
    """2x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Top-left at (5, 5) would extend to (6, 6)
    assert not can_place_2x2(Point(5, 5), bounds, set(), set())
    # Top-left at (5, 0) would extend to (6, 1)
    assert not can_place_2x2(Point(5, 0), bounds, set(), set())

  def test_neighbor_generated_top(self) -> None:
    """2x2 cannot be placed if top neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Top neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_bottom(self) -> None:
    """2x2 cannot be placed if bottom neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2)}  # Bottom neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_left(self) -> None:
    """2x2 cannot be placed if left neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0)}  # Left neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_right(self) -> None:
    """2x2 cannot be placed if right neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0)}  # Right neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_generated(self) -> None:
    """2x2 cannot be placed if any quadrant is already generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 0)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_scheduled(self) -> None:
    """2x2 cannot be placed if any quadrant is already scheduled."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    scheduled = {Point(1, 1)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, set(), scheduled)

  def test_valid_with_distant_generated(self) -> None:
    """2x2 can be placed if generated quadrants are not neighbors."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(3, 3)}  # Far from (0,0) 2x2
    assert can_place_2x2(Point(0, 0), bounds, generated, set())


# =============================================================================
# 2x1 Horizontal Placement Tests
# =============================================================================


class TestCanPlace2x1Horizontal:
  def test_valid_with_top_generated(self) -> None:
    """2x1 can be placed when top row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(1, -1)}  # Top neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_with_bottom_generated(self) -> None:
    """2x1 can be placed when bottom row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 1), Point(1, 1)}  # Bottom neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_left_generated(self) -> None:
    """2x1 cannot be placed when left neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_right_generated(self) -> None:
    """2x1 cannot be placed when right neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """2x1 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """2x1 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 1),
      Point(1, 1),  # Bottom
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_only_partial_long_side(self) -> None:
    """2x1 cannot be placed when only one of two top neighbors is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Only one top neighbor
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """2x1 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(5, -1), Point(6, -1)}
    # Left at x=5 would extend to x=6
    assert not can_place_2x1_horizontal(Point(5, 0), bounds, generated, set())


# =============================================================================
# 1x2 Vertical Placement Tests
# =============================================================================


class TestCanPlace1x2Vertical:
  def test_valid_with_left_generated(self) -> None:
    """1x2 can be placed when left column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(-1, 1)}  # Left neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_with_right_generated(self) -> None:
    """1x2 can be placed when right column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(1, 0), Point(1, 1)}  # Right neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_top_generated(self) -> None:
    """1x2 cannot be placed when top neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_bottom_generated(self) -> None:
    """1x2 cannot be placed when bottom neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """1x2 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """1x2 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(1, 0),
      Point(1, 1),  # Right
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """1x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 5), Point(-1, 6)}
    # Top at y=5 would extend to y=6
    assert not can_place_1x2_vertical(Point(0, 5), bounds, generated, set())


# =============================================================================
# Full Rectangle Plan Tests
# =============================================================================


class TestCreateRectanglePlan:
  def test_empty_rectangle_no_generated(self) -> None:
    """Empty rectangle with no pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_with_context(self) -> None:
    """Single quadrant rectangle requires 3 neighbors for context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 requires 3 of 4 quadrants in a 2x2 block to be generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_without_context(self) -> None:
    """Single quadrant without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_2x2_rectangle(self) -> None:
    """2x2 rectangle should be a single 2x2 tile."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    plan = create_rectangle_plan(bounds)

    # Should have exactly one 2x2 step
    assert len(plan.steps) == 1
    assert len(plan.steps[0].quadrants) == 4
    assert plan.steps[0].step_type == "2x2"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_3x3_rectangle(self) -> None:
    """3x3 rectangle - mix of tiles."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_4x4_rectangle(self) -> None:
    """4x4 rectangle - should fit multiple 2x2 tiles."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have multiple 2x2 tiles
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 1

  def test_wide_rectangle(self) -> None:
    """Wide rectangle (10x2)."""
    bounds = RectBounds(Point(0, 0), Point(9, 1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_tall_rectangle(self) -> None:
    """Tall rectangle (2x10)."""
    bounds = RectBounds(Point(0, 0), Point(1, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_corner(self) -> None:
    """Rectangle with one corner already generated."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should not include (0,0) in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants

  def test_with_pre_generated_edge(self) -> None:
    """Rectangle with one edge already generated (outside the bounds)."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generated row above the rectangle
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_interior(self) -> None:
    """Rectangle with some interior quadrants already generated."""
    bounds = RectBounds(Point(0, 0), Point(4, 4))
    # Some interior points generated - form a vertical 1x2 block
    # This provides context for adjacent tiles
    generated = {Point(2, 2), Point(2, 3)}
    plan = create_rectangle_plan(bounds, generated)

    # Should not include generated points
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(2, 2) not in all_quadrants
    assert Point(2, 3) not in all_quadrants

    # The plan should cover the remaining quadrants
    # Note: Some gaps may remain if there's no valid context
    covered = set(all_quadrants)
    expected_to_cover = set(bounds.all_points()) - generated

    # Verify no extra quadrants are covered
    extra = covered - expected_to_cover
    assert not extra, f"Extra quadrants covered: {extra}"

  def test_fully_generated(self) -> None:
    """Rectangle where all quadrants are already generated."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 0
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_negative_coordinates(self) -> None:
    """Rectangle in negative coordinate space."""
    bounds = RectBounds(Point(-5, -3), Point(-2, -1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_convenience(self) -> None:
    """Test the convenience function with tuples."""
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3))

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_with_generated(self) -> None:
    """Test convenience function with pre-generated set."""
    generated = {(0, 0), (1, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3), generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants


# =============================================================================
# 2x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x2RuleEnforcement:
  def test_2x2_not_touching_pre_generated(self) -> None:
    """2x2 tiles should not touch pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Pre-generated quadrant at (2, -1) - above the rectangle
    generated = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    # Find all 2x2 steps
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        # Subtract the tile itself
        neighbors -= set(step.quadrants)
        # No neighbor should be pre-generated
        for n in neighbors:
          assert n not in generated, (
            f"2x2 at {step.quadrants} has pre-generated neighbor {n}"
          )

  def test_2x2_not_touching_other_scheduled(self) -> None:
    """2x2 tiles should not touch other scheduled tiles (at placement time)."""
    # This is verified by the algorithm itself - 2x2 tiles can only be placed
    # where no neighbor is scheduled. We verify by checking no 2x2 tiles share edges.
    bounds = RectBounds(Point(0, 0), Point(7, 7))
    plan = create_rectangle_plan(bounds)

    # Collect all 2x2 tile quadrants
    all_2x2_quadrants: set[Point] = set()
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          all_2x2_quadrants.add(q)

    # Check that no 2x2 tiles share edges (they should have gaps)
    # Actually, 2x2 tiles CAN share edges with OTHER 2x2 tiles if they were
    # placed later. The rule is only about pre-existing generated content.
    # Let's just verify the plan is valid.
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# 2x1/1x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x1RuleEnforcement:
  def test_2x1_extends_from_generated_edge(self) -> None:
    """2x1 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Pre-generated row above
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x2_extends_from_generated_edge(self) -> None:
    """1x2 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Pre-generated column to the left
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Plan Summary Tests
# =============================================================================


class TestPlanSummary:
  def test_summary_basic(self) -> None:
    """Test plan summary generation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    summary = get_plan_summary(plan)

    assert summary["bounds"]["width"] == 4
    assert summary["bounds"]["height"] == 4
    assert summary["total_quadrants"] == 16
    assert summary["total_steps"] > 0

  def test_summary_with_pre_generated(self) -> None:
    """Test summary with pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0), Point(0, 1)}
    plan = create_rectangle_plan(bounds, generated)
    summary = get_plan_summary(plan)

    assert summary["pre_generated_count"] == 2
    assert summary["total_quadrants"] == 14  # 16 - 2


# =============================================================================
# Edge Case Tests
# =============================================================================


class TestEdgeCases:
  def test_1x1_rectangle_with_context(self) -> None:
    """Smallest possible rectangle with 3-neighbor context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 needs 3 of 4 quadrants in a 2x2 block generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid

  def test_1x1_rectangle_without_context(self) -> None:
    """1x1 rectangle without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_1x10_strip_with_context(self) -> None:
    """Very thin horizontal strip with bottom edge context."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    # Add context row below the strip
    generated = {Point(x, 1) for x in range(10)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x10_strip_without_context(self) -> None:
    """Thin strip without context cannot be fully generated."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed (can't place 2x2 in 1-row strip)
    assert len(plan.steps) == 0

  def test_10x1_strip_with_context(self) -> None:
    """Very thin vertical strip with right edge context."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    # Add context column to the right
    generated = {Point(1, y) for y in range(10)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_10x1_strip_without_context(self) -> None:
    """Thin strip without context cannot be fully generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed (can't place 2x2 in 1-col strip)
    assert len(plan.steps) == 0

  def test_large_rectangle(self) -> None:
    """Large rectangle (20x20)."""
    bounds = RectBounds(Point(0, 0), Point(19, 19))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have many 2x2 tiles (greedy algorithm may not be optimal)
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 40  # Should have a reasonable number of 2x2 tiles

  def test_checkerboard_pre_generated(self) -> None:
    """Checkerboard pattern of pre-generated quadrants.

    In a checkerboard pattern, each non-generated quadrant is surrounded
    by generated quadrants on all 4 sides, providing full 3-of-4 context
    for 1x1 generation.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Checkerboard: every other quadrant (including outside bounds for context)
    generated = {
      Point(x, y)
      for y in range(-1, 7)
      for x in range(-1, 7)
      if (x + y) % 2 == 0
    }
    plan = create_rectangle_plan(bounds, generated)

    # Get the non-generated quadrants within bounds
    to_generate = {p for p in bounds.all_points() if p not in generated}
    all_quadrants = [q for s in plan.steps for q in s.quadrants]

    # All generated should be 1x1
    for step in plan.steps:
      assert step.step_type == "1x1"

    # Should cover all non-generated quadrants
    assert set(all_quadrants) == to_generate

  def test_surrounded_by_generated(self) -> None:
    """Rectangle completely surrounded by generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    # Generate a border around the rectangle
    generated: set[Point] = set()
    for x in range(-1, 5):
      generated.add(Point(x, -1))  # Top
      generated.add(Point(x, 4))  # Bottom
    for y in range(0, 4):
      generated.add(Point(-1, y))  # Left
      generated.add(Point(4, y))  # Right

    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles CAN be placed in the interior (shielded by outer ring)
    # But edges should use smaller tiles
    # Check that all 2x2 tiles don't touch the generated border
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # 2x2 at edge positions would have generated neighbors
          # Interior 2x2 (at 1,1 or 1,2 etc.) is OK
          neighbors = [
            Point(q.x - 1, q.y),
            Point(q.x + 1, q.y),
            Point(q.x, q.y - 1),
            Point(q.x, q.y + 1),
          ]
          for n in neighbors:
            if n not in step.quadrants:  # Not part of the tile itself
              assert n not in generated, (
                f"2x2 at {step.quadrants} has neighbor {n} in generated"
              )


# =============================================================================
# Integration Tests - Complex Scenarios
# =============================================================================


class TestComplexScenarios:
  def test_partial_strip_extension(self) -> None:
    """Extending from a partially generated strip."""
    bounds = RectBounds(Point(0, 0), Point(7, 3))
    # Some quadrants above are generated
    generated = {Point(0, -1), Point(1, -1), Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_l_shaped_pre_generated(self) -> None:
    """L-shaped region of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # L-shape in top-left
    generated = {
      Point(-1, 0),
      Point(-1, 1),
      Point(-1, 2),
      Point(0, -1),
      Point(1, -1),
      Point(2, -1),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_island_of_generated(self) -> None:
    """Island of pre-generated quadrants in the middle."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # 2x2 island in the center
    generated = {Point(4, 4), Point(5, 4), Point(4, 5), Point(5, 5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Generated island should not be in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for g in generated:
      assert g not in all_quadrants

  def test_multiple_disjoint_pre_generated(self) -> None:
    """Multiple disjoint pre-generated regions."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # Two separate 2x2 regions
    generated = {
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
      Point(7, 7),
      Point(8, 7),
      Point(7, 8),
      Point(8, 8),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Serialization Tests
# =============================================================================


# =============================================================================
# Task 019 Strip Plan Pattern Tests
# =============================================================================


class TestStripPlanPattern:
  """
  Tests that verify the algorithm follows the 019 strip plan pattern:
  1. 2x2 tiles placed with gaps (every 3rd column)
  2. 1x2 bridges between 2x2 tiles
  3. 2x1 bridges connecting to generation edge
  4. 1x1 fills for remaining gaps
  """

  def test_depth_3_horizontal_pattern(self) -> None:
    """
    Test 6x3 rectangle with bottom edge generated.

    Expected pattern (following 019):
    Row 0-1: 2x2 at (0,0), (3,0) with 1x2 bridges at (2,0), (5,0)
    Row 2:   2x1 at (0,2), (3,2) with 1x1 at (2,2), (5,2)

    Visual:
    A A C B B D   <- row 0 (A=2x2, B=2x2, C=1x2, D=1x2)
    A A C B B D   <- row 1
    E E G F F H   <- row 2 (E=2x1, F=2x1, G=1x1, H=1x1)
    G G G G G G   <- generation edge (y=3, outside rectangle)
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generation edge at y=3 (below rectangle)
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 1x2, 2 2x1, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

    # Verify 2x2 positions
    two_by_two = [s for s in plan.steps if s.step_type == "2x2"]
    two_by_two_positions = [
      (min(q.x for q in s.quadrants), min(q.y for q in s.quadrants)) for s in two_by_two
    ]
    assert (0, 0) in two_by_two_positions
    assert (3, 0) in two_by_two_positions

    # Verify 1x2 positions (between 2x2 tiles)
    one_by_two = [s for s in plan.steps if s.step_type == "1x2"]
    one_by_two_positions = [s.quadrants[0] for s in one_by_two]
    assert Point(2, 0) in one_by_two_positions
    assert Point(5, 0) in one_by_two_positions

    # Verify 2x1 positions (connecting to edge)
    two_by_one = [s for s in plan.steps if s.step_type == "2x1"]
    two_by_one_positions = [
      (min(q.x for q in s.quadrants), s.quadrants[0].y) for s in two_by_one
    ]
    assert (0, 2) in two_by_one_positions
    assert (3, 2) in two_by_one_positions

  def test_depth_3_vertical_pattern(self) -> None:
    """
    Test 3x6 rectangle with left edge generated.

    Similar pattern but rotated 90 degrees.
    """
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Generation edge at x=-1 (left of rectangle)
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type - pattern should be similar
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 2x1, 2 1x2, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

  def test_1x2_bridges_between_2x2(self) -> None:
    """Test that 1x2 bridges correctly connect two 2x2 tiles."""
    # 5x3 rectangle (need 3 rows for 2x2 + bridge pattern)
    # With generation edge at y=3 (one row gap from 2x2 tiles)
    bounds = RectBounds(Point(0, 0), Point(4, 2))
    generated = {Point(x, 3) for x in range(5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Visual:
    # A A C B B   <- row 0 (A=2x2 at 0,0; B=2x2 at 3,0; C=1x2 at 2,0)
    # A A C B B   <- row 1
    # D D E F F   <- row 2 (D=2x1 at 0,2; E=1x1 at 2,2; F=2x1 at 3,2)
    # G G G G G   <- generation edge

    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # 2 2x2 tiles, 1 1x2 bridge, 2 2x1, 1 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 1, f"Expected 1 1x2 bridge, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 1, f"Expected 1 1x1 fill, got {types}"

  def test_order_matches_019_pattern(self) -> None:
    """
    Verify that generation order follows 019:
    1. 2x2 tiles first
    2. 1x2 bridges second
    3. 2x1 bridges third
    4. 1x1 fills last
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Check order
    current_phase = 0
    phase_order = {"2x2": 0, "1x2": 1, "2x1": 2, "1x1": 3}

    for step in plan.steps:
      phase = phase_order.get(step.step_type, 4)
      assert phase >= current_phase, (
        f"Step {step.step_type} appears after later phase. "
        f"Expected order: 2x2, 1x2, 2x1, 1x1"
      )
      current_phase = phase


class TestSerialization:
  def test_step_to_dict(self) -> None:
    """Test GenerationStep serialization."""
    step = GenerationStep(quadrants=[Point(0, 0), Point(1, 0)], step_type="2x1")
    d = step.to_dict()
    assert d["quadrants"] == [(0, 0), (1, 0)]
    assert d["type"] == "2x1"

  def test_plan_to_dict(self) -> None:
    """Test RectanglePlan serialization."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    d = plan.to_dict()

    assert d["bounds"]["top_left"] == (0, 0)
    assert d["bounds"]["bottom_right"] == (3, 3)
    assert len(d["steps"]) > 0


# =============================================================================
# Validation Tests
# =============================================================================


class TestValidation:
  def test_valid_plan(self) -> None:
    """Valid plan should pass validation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid
    assert len(errors) == 0

  def test_detect_duplicate_coverage(self) -> None:
    """Validation should detect duplicate coverage."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with duplicates
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0)]),
        GenerationStep(quadrants=[Point(0, 0), Point(0, 1)]),  # Duplicate!
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("multiple times" in e for e in errors)

  def test_detect_missing_quadrants(self) -> None:
    """Validation should detect missing quadrants."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with missing quadrant
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0), Point(0, 1)]),
        # Missing (1, 1)
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("Missing" in e for e in errors)


# =============================================================================
# Queued Quadrant Tests - Seam Detection with In-Progress/Queued Generations
# =============================================================================


class TestQueuedQuadrants:
  """
  Tests that verify the algorithm correctly considers in-progress and queued
  generations when determining if a seam will be formed.

  Queued quadrants are treated the same as generated quadrants for seam
  detection purposes - tiles cannot be placed adjacent to them.
  """

  def test_queued_quadrants_prevent_2x2_placement(self) -> None:
    """2x2 tiles cannot be placed adjacent to queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # No generated quadrants
    generated: set[Point] = set()
    # But there's a queued generation at (2, -1) - above the rectangle
    queued = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Find all 2x2 steps and verify none touch the queued quadrant
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        neighbors -= set(step.quadrants)
        for n in neighbors:
          assert n not in queued, f"2x2 at {step.quadrants} has queued neighbor {n}"

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_queued_quadrants_excluded_from_plan(self) -> None:
    """Queued quadrants within bounds should not be included in the plan."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Some interior points are queued
    queued = {Point(1, 1), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Should not include queued points in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(1, 1) not in all_quadrants
    assert Point(2, 2) not in all_quadrants

    # Plan should still be valid for non-queued quadrants
    is_valid, errors = validate_plan(plan)
    # Note: validation will fail because queued points are not in pre_generated
    # but the key check is that queued points are not in the plan
    covered = set(all_quadrants)
    expected = set(bounds.all_points()) - queued
    assert covered == expected, f"Expected {expected}, got {covered}"

  def test_queued_row_affects_2x1_placement(self) -> None:
    """2x1 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated: set[Point] = set()
    # Queued row below the rectangle acts like a generated edge
    queued = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 2x1 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at y=3, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"

  def test_queued_column_affects_1x2_placement(self) -> None:
    """1x2 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    generated: set[Point] = set()
    # Queued column to the left acts like a generated edge
    queued = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 1x2 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at x=-1, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"

  def test_mixed_generated_and_queued(self) -> None:
    """Plan should correctly handle both generated and queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Some quadrants are already generated
    generated = {Point(-1, 0), Point(-1, 1)}
    # Some quadrants are queued for generation
    queued = {Point(6, 0), Point(6, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles at left edge should not touch generated at (-1, 0) (-1, 1)
    # 2x2 tiles at right edge should not touch queued at (6, 0) (6, 1)
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # Check no neighbor is generated
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in generated, (
                f"2x2 at {step.quadrants} has generated neighbor {neighbor}"
              )
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_queued_quadrant_in_middle_prevents_2x2(self) -> None:
    """A queued quadrant in the middle should prevent 2x2 placement there."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queued 2x2 block in the center
    queued = {Point(1, 1), Point(2, 1), Point(1, 2), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # No step should include any queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # 2x2 tiles should not be placed adjacent to the queued block
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_from_coords_with_queued(self) -> None:
    """Test convenience function with queued set."""
    generated = {(0, 0), (1, 0)}
    queued = {(2, 0), (3, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (5, 3), generated, queued)

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    # Neither generated nor queued should be in plan
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants
    assert Point(2, 0) not in all_quadrants
    assert Point(3, 0) not in all_quadrants

  def test_fully_queued_rectangle(self) -> None:
    """Rectangle where all quadrants are queued should produce empty plan."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated: set[Point] = set()
    queued = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated, queued)

    assert len(plan.steps) == 0

  def test_queued_prevents_seam_with_future_generation(self) -> None:
    """
    Queued quadrants should be treated as if they will be generated,
    preventing seams with future generations.

    Scenario: User is generating a 2x2 at (0,0)-(1,1) and there's already
    a queued 2x2 at (2,0)-(3,1). The plan should not place tiles that
    would create a seam between them.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 3))
    generated: set[Point] = set()
    # First 2x2 is queued
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # The plan should not include the queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants

    # Verify the plan covers exactly the non-queued quadrants
    expected = set(bounds.all_points()) - queued
    covered = set(all_quadrants)
    assert covered == expected, f"Expected {expected}, got {covered}"

    # 2x2 tiles should not be placed at (2,0) because it would touch
    # the queued 2x2 at x=1
    for step in plan.steps:
      if step.step_type == "2x2":
        step_tl = min(q.x for q in step.quadrants), min(q.y for q in step.quadrants)
        # If there's a 2x2 at (2, 0), it would have neighbors at (1, 0) and (1, 1)
        # which are queued
        if step_tl == (2, 0):
          assert False, "2x2 at (2,0) would create seam with queued (0,0)-(1,1)"

```

```python
"""
Tests for make_rectangle_plan.py

These tests verify the rectangle generation planning algorithm handles
all cases correctly, including:
- Basic coverage of all quadrants
- 2x2 tile placement rules (no touching generated neighbors)
- 2x1/1x2 tile placement rules (extend from generated edges)
- 1x1 filling of remaining gaps
- Pre-existing generated quadrants
- Various rectangle sizes and configurations
"""

from isometric_nyc.e2e_generation.make_rectangle_plan import (
  GenerationStep,
  Point,
  RectanglePlan,
  RectBounds,
  can_place_1x2_vertical,
  can_place_2x1_horizontal,
  can_place_2x2,
  create_rectangle_plan,
  create_rectangle_plan_from_coords,
  get_2x2_neighbors,
  get_2x2_quadrants,
  get_plan_summary,
  validate_plan,
)

# =============================================================================
# Point Tests
# =============================================================================


class TestPoint:
  def test_str(self) -> None:
    p = Point(3, 5)
    assert str(p) == "(3,5)"

  def test_add(self) -> None:
    p1 = Point(1, 2)
    p2 = Point(3, 4)
    result = p1 + p2
    assert result == Point(4, 6)

  def test_from_string_simple(self) -> None:
    p = Point.from_string("3,5")
    assert p == Point(3, 5)

  def test_from_string_with_parens(self) -> None:
    p = Point.from_string("(3,5)")
    assert p == Point(3, 5)

  def test_from_string_negative(self) -> None:
    p = Point.from_string("-3,-5")
    assert p == Point(-3, -5)

  def test_to_tuple(self) -> None:
    p = Point(3, 5)
    assert p.to_tuple() == (3, 5)


# =============================================================================
# RectBounds Tests
# =============================================================================


class TestRectBounds:
  def test_width_height(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(10, 5))
    assert bounds.width == 11
    assert bounds.height == 6

  def test_area(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(3, 2))
    assert bounds.area == 12  # 4 x 3

  def test_contains(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert bounds.contains(Point(0, 0))
    assert bounds.contains(Point(5, 5))
    assert bounds.contains(Point(3, 3))
    assert not bounds.contains(Point(-1, 0))
    assert not bounds.contains(Point(6, 0))
    assert not bounds.contains(Point(0, -1))
    assert not bounds.contains(Point(0, 6))

  def test_all_points(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(2, 1))
    points = bounds.all_points()
    expected = [
      Point(0, 0),
      Point(1, 0),
      Point(2, 0),
      Point(0, 1),
      Point(1, 1),
      Point(2, 1),
    ]
    assert points == expected


# =============================================================================
# 2x2 Tile Helper Tests
# =============================================================================


class TestGet2x2Quadrants:
  def test_basic(self) -> None:
    quadrants = get_2x2_quadrants(Point(0, 0))
    assert quadrants == [
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
    ]

  def test_offset(self) -> None:
    quadrants = get_2x2_quadrants(Point(5, 3))
    assert quadrants == [
      Point(5, 3),
      Point(6, 3),
      Point(5, 4),
      Point(6, 4),
    ]


class TestGet2x2Neighbors:
  def test_basic(self) -> None:
    neighbors = get_2x2_neighbors(Point(0, 0))
    # Top, Bottom, Left, Right
    expected = [
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 2),
      Point(1, 2),  # Bottom
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(2, 0),
      Point(2, 1),  # Right
    ]
    assert set(neighbors) == set(expected)
    assert len(neighbors) == 8


# =============================================================================
# 2x2 Placement Tests
# =============================================================================


class TestCanPlace2x2:
  def test_empty_grid(self) -> None:
    """2x2 can be placed in empty rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert can_place_2x2(Point(0, 0), bounds, set(), set())

  def test_out_of_bounds(self) -> None:
    """2x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Top-left at (5, 5) would extend to (6, 6)
    assert not can_place_2x2(Point(5, 5), bounds, set(), set())
    # Top-left at (5, 0) would extend to (6, 1)
    assert not can_place_2x2(Point(5, 0), bounds, set(), set())

  def test_neighbor_generated_top(self) -> None:
    """2x2 cannot be placed if top neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Top neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_bottom(self) -> None:
    """2x2 cannot be placed if bottom neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2)}  # Bottom neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_left(self) -> None:
    """2x2 cannot be placed if left neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0)}  # Left neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_right(self) -> None:
    """2x2 cannot be placed if right neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0)}  # Right neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_generated(self) -> None:
    """2x2 cannot be placed if any quadrant is already generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 0)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_scheduled(self) -> None:
    """2x2 cannot be placed if any quadrant is already scheduled."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    scheduled = {Point(1, 1)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, set(), scheduled)

  def test_valid_with_distant_generated(self) -> None:
    """2x2 can be placed if generated quadrants are not neighbors."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(3, 3)}  # Far from (0,0) 2x2
    assert can_place_2x2(Point(0, 0), bounds, generated, set())


# =============================================================================
# 2x1 Horizontal Placement Tests
# =============================================================================


class TestCanPlace2x1Horizontal:
  def test_valid_with_top_generated(self) -> None:
    """2x1 can be placed when top row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(1, -1)}  # Top neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_with_bottom_generated(self) -> None:
    """2x1 can be placed when bottom row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 1), Point(1, 1)}  # Bottom neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_left_generated(self) -> None:
    """2x1 cannot be placed when left neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_right_generated(self) -> None:
    """2x1 cannot be placed when right neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """2x1 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """2x1 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 1),
      Point(1, 1),  # Bottom
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_only_partial_long_side(self) -> None:
    """2x1 cannot be placed when only one of two top neighbors is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Only one top neighbor
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """2x1 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(5, -1), Point(6, -1)}
    # Left at x=5 would extend to x=6
    assert not can_place_2x1_horizontal(Point(5, 0), bounds, generated, set())


# =============================================================================
# 1x2 Vertical Placement Tests
# =============================================================================


class TestCanPlace1x2Vertical:
  def test_valid_with_left_generated(self) -> None:
    """1x2 can be placed when left column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(-1, 1)}  # Left neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_with_right_generated(self) -> None:
    """1x2 can be placed when right column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(1, 0), Point(1, 1)}  # Right neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_top_generated(self) -> None:
    """1x2 cannot be placed when top neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_bottom_generated(self) -> None:
    """1x2 cannot be placed when bottom neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """1x2 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """1x2 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(1, 0),
      Point(1, 1),  # Right
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """1x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 5), Point(-1, 6)}
    # Top at y=5 would extend to y=6
    assert not can_place_1x2_vertical(Point(0, 5), bounds, generated, set())


# =============================================================================
# Full Rectangle Plan Tests
# =============================================================================


class TestCreateRectanglePlan:
  def test_empty_rectangle_no_generated(self) -> None:
    """Empty rectangle with no pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_with_context(self) -> None:
    """Single quadrant rectangle requires 3 neighbors for context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 requires 3 of 4 quadrants in a 2x2 block to be generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_without_context(self) -> None:
    """Single quadrant without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_2x2_rectangle(self) -> None:
    """2x2 rectangle should be a single 2x2 tile."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    plan = create_rectangle_plan(bounds)

    # Should have exactly one 2x2 step
    assert len(plan.steps) == 1
    assert len(plan.steps[0].quadrants) == 4
    assert plan.steps[0].step_type == "2x2"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_3x3_rectangle(self) -> None:
    """3x3 rectangle - mix of tiles."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_4x4_rectangle(self) -> None:
    """4x4 rectangle - should fit multiple 2x2 tiles."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have multiple 2x2 tiles
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 1

  def test_wide_rectangle(self) -> None:
    """Wide rectangle (10x2)."""
    bounds = RectBounds(Point(0, 0), Point(9, 1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_tall_rectangle(self) -> None:
    """Tall rectangle (2x10)."""
    bounds = RectBounds(Point(0, 0), Point(1, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_corner(self) -> None:
    """Rectangle with one corner already generated."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should not include (0,0) in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants

  def test_with_pre_generated_edge(self) -> None:
    """Rectangle with one edge already generated (outside the bounds)."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generated row above the rectangle
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_interior(self) -> None:
    """Rectangle with some interior quadrants already generated."""
    bounds = RectBounds(Point(0, 0), Point(4, 4))
    # Some interior points generated - form a vertical 1x2 block
    # This provides context for adjacent tiles
    generated = {Point(2, 2), Point(2, 3)}
    plan = create_rectangle_plan(bounds, generated)

    # Should not include generated points
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(2, 2) not in all_quadrants
    assert Point(2, 3) not in all_quadrants

    # The plan should cover the remaining quadrants
    # Note: Some gaps may remain if there's no valid context
    covered = set(all_quadrants)
    expected_to_cover = set(bounds.all_points()) - generated

    # Verify no extra quadrants are covered
    extra = covered - expected_to_cover
    assert not extra, f"Extra quadrants covered: {extra}"

  def test_fully_generated(self) -> None:
    """Rectangle where all quadrants are already generated."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 0
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_negative_coordinates(self) -> None:
    """Rectangle in negative coordinate space."""
    bounds = RectBounds(Point(-5, -3), Point(-2, -1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_convenience(self) -> None:
    """Test the convenience function with tuples."""
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3))

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_with_generated(self) -> None:
    """Test convenience function with pre-generated set."""
    generated = {(0, 0), (1, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3), generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants


# =============================================================================
# 2x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x2RuleEnforcement:
  def test_2x2_not_touching_pre_generated(self) -> None:
    """2x2 tiles should not touch pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Pre-generated quadrant at (2, -1) - above the rectangle
    generated = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    # Find all 2x2 steps
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        # Subtract the tile itself
        neighbors -= set(step.quadrants)
        # No neighbor should be pre-generated
        for n in neighbors:
          assert n not in generated, (
            f"2x2 at {step.quadrants} has pre-generated neighbor {n}"
          )

  def test_2x2_not_touching_other_scheduled(self) -> None:
    """2x2 tiles should not touch other scheduled tiles (at placement time)."""
    # This is verified by the algorithm itself - 2x2 tiles can only be placed
    # where no neighbor is scheduled. We verify by checking no 2x2 tiles share edges.
    bounds = RectBounds(Point(0, 0), Point(7, 7))
    plan = create_rectangle_plan(bounds)

    # Collect all 2x2 tile quadrants
    all_2x2_quadrants: set[Point] = set()
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          all_2x2_quadrants.add(q)

    # Check that no 2x2 tiles share edges (they should have gaps)
    # Actually, 2x2 tiles CAN share edges with OTHER 2x2 tiles if they were
    # placed later. The rule is only about pre-existing generated content.
    # Let's just verify the plan is valid.
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# 2x1/1x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x1RuleEnforcement:
  def test_2x1_extends_from_generated_edge(self) -> None:
    """2x1 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Pre-generated row above
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x2_extends_from_generated_edge(self) -> None:
    """1x2 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Pre-generated column to the left
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Plan Summary Tests
# =============================================================================


class TestPlanSummary:
  def test_summary_basic(self) -> None:
    """Test plan summary generation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    summary = get_plan_summary(plan)

    assert summary["bounds"]["width"] == 4
    assert summary["bounds"]["height"] == 4
    assert summary["total_quadrants"] == 16
    assert summary["total_steps"] > 0

  def test_summary_with_pre_generated(self) -> None:
    """Test summary with pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0), Point(0, 1)}
    plan = create_rectangle_plan(bounds, generated)
    summary = get_plan_summary(plan)

    assert summary["pre_generated_count"] == 2
    assert summary["total_quadrants"] == 14  # 16 - 2


# =============================================================================
# Edge Case Tests
# =============================================================================


class TestEdgeCases:
  def test_1x1_rectangle_with_context(self) -> None:
    """Smallest possible rectangle with 3-neighbor context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 needs 3 of 4 quadrants in a 2x2 block generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid

  def test_1x1_rectangle_without_context(self) -> None:
    """1x1 rectangle without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_1x10_strip_with_context(self) -> None:
    """Very thin horizontal strip with bottom edge context."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    # Add context row below the strip
    generated = {Point(x, 1) for x in range(10)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x10_strip_without_context(self) -> None:
    """Thin strip without context cannot be fully generated."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed (can't place 2x2 in 1-row strip)
    assert len(plan.steps) == 0

  def test_10x1_strip_with_context(self) -> None:
    """Very thin vertical strip with right edge context."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    # Add context column to the right
    generated = {Point(1, y) for y in range(10)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_10x1_strip_without_context(self) -> None:
    """Thin strip without context cannot be fully generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed (can't place 2x2 in 1-col strip)
    assert len(plan.steps) == 0

  def test_large_rectangle(self) -> None:
    """Large rectangle (20x20)."""
    bounds = RectBounds(Point(0, 0), Point(19, 19))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have many 2x2 tiles (greedy algorithm may not be optimal)
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 40  # Should have a reasonable number of 2x2 tiles

  def test_checkerboard_pre_generated(self) -> None:
    """Checkerboard pattern of pre-generated quadrants.

    In a checkerboard pattern, each non-generated quadrant is surrounded
    by generated quadrants on all 4 sides, providing full 3-of-4 context
    for 1x1 generation.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Checkerboard: every other quadrant (including outside bounds for context)
    generated = {
      Point(x, y)
      for y in range(-1, 7)
      for x in range(-1, 7)
      if (x + y) % 2 == 0
    }
    plan = create_rectangle_plan(bounds, generated)

    # Get the non-generated quadrants within bounds
    to_generate = {p for p in bounds.all_points() if p not in generated}
    all_quadrants = [q for s in plan.steps for q in s.quadrants]

    # All generated should be 1x1
    for step in plan.steps:
      assert step.step_type == "1x1"

    # Should cover all non-generated quadrants
    assert set(all_quadrants) == to_generate

  def test_surrounded_by_generated(self) -> None:
    """Rectangle completely surrounded by generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    # Generate a border around the rectangle
    generated: set[Point] = set()
    for x in range(-1, 5):
      generated.add(Point(x, -1))  # Top
      generated.add(Point(x, 4))  # Bottom
    for y in range(0, 4):
      generated.add(Point(-1, y))  # Left
      generated.add(Point(4, y))  # Right

    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles CAN be placed in the interior (shielded by outer ring)
    # But edges should use smaller tiles
    # Check that all 2x2 tiles don't touch the generated border
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # 2x2 at edge positions would have generated neighbors
          # Interior 2x2 (at 1,1 or 1,2 etc.) is OK
          neighbors = [
            Point(q.x - 1, q.y),
            Point(q.x + 1, q.y),
            Point(q.x, q.y - 1),
            Point(q.x, q.y + 1),
          ]
          for n in neighbors:
            if n not in step.quadrants:  # Not part of the tile itself
              assert n not in generated, (
                f"2x2 at {step.quadrants} has neighbor {n} in generated"
              )


# =============================================================================
# Integration Tests - Complex Scenarios
# =============================================================================


class TestComplexScenarios:
  def test_partial_strip_extension(self) -> None:
    """Extending from a partially generated strip."""
    bounds = RectBounds(Point(0, 0), Point(7, 3))
    # Some quadrants above are generated
    generated = {Point(0, -1), Point(1, -1), Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_l_shaped_pre_generated(self) -> None:
    """L-shaped region of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # L-shape in top-left
    generated = {
      Point(-1, 0),
      Point(-1, 1),
      Point(-1, 2),
      Point(0, -1),
      Point(1, -1),
      Point(2, -1),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_island_of_generated(self) -> None:
    """Island of pre-generated quadrants in the middle."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # 2x2 island in the center
    generated = {Point(4, 4), Point(5, 4), Point(4, 5), Point(5, 5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Generated island should not be in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for g in generated:
      assert g not in all_quadrants

  def test_multiple_disjoint_pre_generated(self) -> None:
    """Multiple disjoint pre-generated regions."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # Two separate 2x2 regions
    generated = {
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
      Point(7, 7),
      Point(8, 7),
      Point(7, 8),
      Point(8, 8),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Serialization Tests
# =============================================================================


# =============================================================================
# Task 019 Strip Plan Pattern Tests
# =============================================================================


class TestStripPlanPattern:
  """
  Tests that verify the algorithm follows the 019 strip plan pattern:
  1. 2x2 tiles placed with gaps (every 3rd column)
  2. 1x2 bridges between 2x2 tiles
  3. 2x1 bridges connecting to generation edge
  4. 1x1 fills for remaining gaps
  """

  def test_depth_3_horizontal_pattern(self) -> None:
    """
    Test 6x3 rectangle with bottom edge generated.

    Expected pattern (following 019):
    Row 0-1: 2x2 at (0,0), (3,0) with 1x2 bridges at (2,0), (5,0)
    Row 2:   2x1 at (0,2), (3,2) with 1x1 at (2,2), (5,2)

    Visual:
    A A C B B D   <- row 0 (A=2x2, B=2x2, C=1x2, D=1x2)
    A A C B B D   <- row 1
    E E G F F H   <- row 2 (E=2x1, F=2x1, G=1x1, H=1x1)
    G G G G G G   <- generation edge (y=3, outside rectangle)
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generation edge at y=3 (below rectangle)
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 1x2, 2 2x1, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

    # Verify 2x2 positions
    two_by_two = [s for s in plan.steps if s.step_type == "2x2"]
    two_by_two_positions = [
      (min(q.x for q in s.quadrants), min(q.y for q in s.quadrants)) for s in two_by_two
    ]
    assert (0, 0) in two_by_two_positions
    assert (3, 0) in two_by_two_positions

    # Verify 1x2 positions (between 2x2 tiles)
    one_by_two = [s for s in plan.steps if s.step_type == "1x2"]
    one_by_two_positions = [s.quadrants[0] for s in one_by_two]
    assert Point(2, 0) in one_by_two_positions
    assert Point(5, 0) in one_by_two_positions

    # Verify 2x1 positions (connecting to edge)
    two_by_one = [s for s in plan.steps if s.step_type == "2x1"]
    two_by_one_positions = [
      (min(q.x for q in s.quadrants), s.quadrants[0].y) for s in two_by_one
    ]
    assert (0, 2) in two_by_one_positions
    assert (3, 2) in two_by_one_positions

  def test_depth_3_vertical_pattern(self) -> None:
    """
    Test 3x6 rectangle with left edge generated.

    Similar pattern but rotated 90 degrees.
    """
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Generation edge at x=-1 (left of rectangle)
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type - pattern should be similar
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 2x1, 2 1x2, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

  def test_1x2_bridges_between_2x2(self) -> None:
    """Test that 1x2 bridges correctly connect two 2x2 tiles."""
    # 5x3 rectangle (need 3 rows for 2x2 + bridge pattern)
    # With generation edge at y=3 (one row gap from 2x2 tiles)
    bounds = RectBounds(Point(0, 0), Point(4, 2))
    generated = {Point(x, 3) for x in range(5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Visual:
    # A A C B B   <- row 0 (A=2x2 at 0,0; B=2x2 at 3,0; C=1x2 at 2,0)
    # A A C B B   <- row 1
    # D D E F F   <- row 2 (D=2x1 at 0,2; E=1x1 at 2,2; F=2x1 at 3,2)
    # G G G G G   <- generation edge

    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # 2 2x2 tiles, 1 1x2 bridge, 2 2x1, 1 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 1, f"Expected 1 1x2 bridge, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 1, f"Expected 1 1x1 fill, got {types}"

  def test_order_matches_019_pattern(self) -> None:
    """
    Verify that generation order follows 019:
    1. 2x2 tiles first
    2. 1x2 bridges second
    3. 2x1 bridges third
    4. 1x1 fills last
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Check order
    current_phase = 0
    phase_order = {"2x2": 0, "1x2": 1, "2x1": 2, "1x1": 3}

    for step in plan.steps:
      phase = phase_order.get(step.step_type, 4)
      assert phase >= current_phase, (
        f"Step {step.step_type} appears after later phase. "
        f"Expected order: 2x2, 1x2, 2x1, 1x1"
      )
      current_phase = phase


class TestSerialization:
  def test_step_to_dict(self) -> None:
    """Test GenerationStep serialization."""
    step = GenerationStep(quadrants=[Point(0, 0), Point(1, 0)], step_type="2x1")
    d = step.to_dict()
    assert d["quadrants"] == [(0, 0), (1, 0)]
    assert d["type"] == "2x1"

  def test_plan_to_dict(self) -> None:
    """Test RectanglePlan serialization."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    d = plan.to_dict()

    assert d["bounds"]["top_left"] == (0, 0)
    assert d["bounds"]["bottom_right"] == (3, 3)
    assert len(d["steps"]) > 0


# =============================================================================
# Validation Tests
# =============================================================================


class TestValidation:
  def test_valid_plan(self) -> None:
    """Valid plan should pass validation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid
    assert len(errors) == 0

  def test_detect_duplicate_coverage(self) -> None:
    """Validation should detect duplicate coverage."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with duplicates
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0)]),
        GenerationStep(quadrants=[Point(0, 0), Point(0, 1)]),  # Duplicate!
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("multiple times" in e for e in errors)

  def test_detect_missing_quadrants(self) -> None:
    """Validation should detect missing quadrants."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with missing quadrant
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0), Point(0, 1)]),
        # Missing (1, 1)
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("Missing" in e for e in errors)


# =============================================================================
# Queued Quadrant Tests - Seam Detection with In-Progress/Queued Generations
# =============================================================================


class TestQueuedQuadrants:
  """
  Tests that verify the algorithm correctly considers in-progress and queued
  generations when determining if a seam will be formed.

  Queued quadrants are treated the same as generated quadrants for seam
  detection purposes - tiles cannot be placed adjacent to them.
  """

  def test_queued_quadrants_prevent_2x2_placement(self) -> None:
    """2x2 tiles cannot be placed adjacent to queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # No generated quadrants
    generated: set[Point] = set()
    # But there's a queued generation at (2, -1) - above the rectangle
    queued = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Find all 2x2 steps and verify none touch the queued quadrant
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        neighbors -= set(step.quadrants)
        for n in neighbors:
          assert n not in queued, f"2x2 at {step.quadrants} has queued neighbor {n}"

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_queued_quadrants_excluded_from_plan(self) -> None:
    """Queued quadrants within bounds should not be included in the plan.

    Queued quadrants act as context for other tiles but are not generated
    in this plan (they're already queued elsewhere).
    """
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queue a 2x2 block - this provides context for adjacent tiles
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Should not include queued points in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # The remaining quadrants should be covered
    remaining = set(bounds.all_points()) - queued
    covered = set(all_quadrants)

    # All covered should be from remaining
    assert covered.issubset(remaining), f"Covered {covered} not subset of remaining {remaining}"

  def test_queued_row_affects_2x1_placement(self) -> None:
    """2x1 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated: set[Point] = set()
    # Queued row below the rectangle acts like a generated edge
    queued = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 2x1 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at y=3, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"

  def test_queued_column_affects_1x2_placement(self) -> None:
    """1x2 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    generated: set[Point] = set()
    # Queued column to the left acts like a generated edge
    queued = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 1x2 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at x=-1, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"

  def test_mixed_generated_and_queued(self) -> None:
    """Plan should correctly handle both generated and queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Some quadrants are already generated
    generated = {Point(-1, 0), Point(-1, 1)}
    # Some quadrants are queued for generation
    queued = {Point(6, 0), Point(6, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles at left edge should not touch generated at (-1, 0) (-1, 1)
    # 2x2 tiles at right edge should not touch queued at (6, 0) (6, 1)
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # Check no neighbor is generated
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in generated, (
                f"2x2 at {step.quadrants} has generated neighbor {neighbor}"
              )
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_queued_quadrant_in_middle_prevents_2x2(self) -> None:
    """A queued quadrant in the middle should prevent 2x2 placement there."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queued 2x2 block in the center
    queued = {Point(1, 1), Point(2, 1), Point(1, 2), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # No step should include any queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # 2x2 tiles should not be placed adjacent to the queued block
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_from_coords_with_queued(self) -> None:
    """Test convenience function with queued set."""
    generated = {(0, 0), (1, 0)}
    queued = {(2, 0), (3, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (5, 3), generated, queued)

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    # Neither generated nor queued should be in plan
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants
    assert Point(2, 0) not in all_quadrants
    assert Point(3, 0) not in all_quadrants

  def test_fully_queued_rectangle(self) -> None:
    """Rectangle where all quadrants are queued should produce empty plan."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated: set[Point] = set()
    queued = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated, queued)

    assert len(plan.steps) == 0

  def test_queued_prevents_seam_with_future_generation(self) -> None:
    """
    Queued quadrants should be treated as if they will be generated,
    preventing seams with future generations.

    Scenario: User is generating a 2x2 at (0,0)-(1,1) and there's already
    a queued 2x2 at (2,0)-(3,1). The plan should not place tiles that
    would create a seam between them.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 3))
    generated: set[Point] = set()
    # First 2x2 is queued
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # The plan should not include the queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants

    # Verify the plan covers exactly the non-queued quadrants
    expected = set(bounds.all_points()) - queued
    covered = set(all_quadrants)
    assert covered == expected, f"Expected {expected}, got {covered}"

    # 2x2 tiles should not be placed at (2,0) because it would touch
    # the queued 2x2 at x=1
    for step in plan.steps:
      if step.step_type == "2x2":
        step_tl = min(q.x for q in step.quadrants), min(q.y for q in step.quadrants)
        # If there's a 2x2 at (2, 0), it would have neighbors at (1, 0) and (1, 1)
        # which are queued
        if step_tl == (2, 0):
          assert False, "2x2 at (2,0) would create seam with queued (0,0)-(1,1)"

```

The checkerboard pattern inherently cannot provide 3-of-4 context because every 2x2 block has exactly 2 generated (diagonal) quadrants. Let me fix the test:

```python
"""
Tests for make_rectangle_plan.py

These tests verify the rectangle generation planning algorithm handles
all cases correctly, including:
- Basic coverage of all quadrants
- 2x2 tile placement rules (no touching generated neighbors)
- 2x1/1x2 tile placement rules (extend from generated edges)
- 1x1 filling of remaining gaps
- Pre-existing generated quadrants
- Various rectangle sizes and configurations
"""

from isometric_nyc.e2e_generation.make_rectangle_plan import (
  GenerationStep,
  Point,
  RectanglePlan,
  RectBounds,
  can_place_1x2_vertical,
  can_place_2x1_horizontal,
  can_place_2x2,
  create_rectangle_plan,
  create_rectangle_plan_from_coords,
  get_2x2_neighbors,
  get_2x2_quadrants,
  get_plan_summary,
  validate_plan,
)

# =============================================================================
# Point Tests
# =============================================================================


class TestPoint:
  def test_str(self) -> None:
    p = Point(3, 5)
    assert str(p) == "(3,5)"

  def test_add(self) -> None:
    p1 = Point(1, 2)
    p2 = Point(3, 4)
    result = p1 + p2
    assert result == Point(4, 6)

  def test_from_string_simple(self) -> None:
    p = Point.from_string("3,5")
    assert p == Point(3, 5)

  def test_from_string_with_parens(self) -> None:
    p = Point.from_string("(3,5)")
    assert p == Point(3, 5)

  def test_from_string_negative(self) -> None:
    p = Point.from_string("-3,-5")
    assert p == Point(-3, -5)

  def test_to_tuple(self) -> None:
    p = Point(3, 5)
    assert p.to_tuple() == (3, 5)


# =============================================================================
# RectBounds Tests
# =============================================================================


class TestRectBounds:
  def test_width_height(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(10, 5))
    assert bounds.width == 11
    assert bounds.height == 6

  def test_area(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(3, 2))
    assert bounds.area == 12  # 4 x 3

  def test_contains(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert bounds.contains(Point(0, 0))
    assert bounds.contains(Point(5, 5))
    assert bounds.contains(Point(3, 3))
    assert not bounds.contains(Point(-1, 0))
    assert not bounds.contains(Point(6, 0))
    assert not bounds.contains(Point(0, -1))
    assert not bounds.contains(Point(0, 6))

  def test_all_points(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(2, 1))
    points = bounds.all_points()
    expected = [
      Point(0, 0),
      Point(1, 0),
      Point(2, 0),
      Point(0, 1),
      Point(1, 1),
      Point(2, 1),
    ]
    assert points == expected


# =============================================================================
# 2x2 Tile Helper Tests
# =============================================================================


class TestGet2x2Quadrants:
  def test_basic(self) -> None:
    quadrants = get_2x2_quadrants(Point(0, 0))
    assert quadrants == [
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
    ]

  def test_offset(self) -> None:
    quadrants = get_2x2_quadrants(Point(5, 3))
    assert quadrants == [
      Point(5, 3),
      Point(6, 3),
      Point(5, 4),
      Point(6, 4),
    ]


class TestGet2x2Neighbors:
  def test_basic(self) -> None:
    neighbors = get_2x2_neighbors(Point(0, 0))
    # Top, Bottom, Left, Right
    expected = [
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 2),
      Point(1, 2),  # Bottom
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(2, 0),
      Point(2, 1),  # Right
    ]
    assert set(neighbors) == set(expected)
    assert len(neighbors) == 8


# =============================================================================
# 2x2 Placement Tests
# =============================================================================


class TestCanPlace2x2:
  def test_empty_grid(self) -> None:
    """2x2 can be placed in empty rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert can_place_2x2(Point(0, 0), bounds, set(), set())

  def test_out_of_bounds(self) -> None:
    """2x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Top-left at (5, 5) would extend to (6, 6)
    assert not can_place_2x2(Point(5, 5), bounds, set(), set())
    # Top-left at (5, 0) would extend to (6, 1)
    assert not can_place_2x2(Point(5, 0), bounds, set(), set())

  def test_neighbor_generated_top(self) -> None:
    """2x2 cannot be placed if top neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Top neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_bottom(self) -> None:
    """2x2 cannot be placed if bottom neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2)}  # Bottom neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_left(self) -> None:
    """2x2 cannot be placed if left neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0)}  # Left neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_right(self) -> None:
    """2x2 cannot be placed if right neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0)}  # Right neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_generated(self) -> None:
    """2x2 cannot be placed if any quadrant is already generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 0)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_scheduled(self) -> None:
    """2x2 cannot be placed if any quadrant is already scheduled."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    scheduled = {Point(1, 1)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, set(), scheduled)

  def test_valid_with_distant_generated(self) -> None:
    """2x2 can be placed if generated quadrants are not neighbors."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(3, 3)}  # Far from (0,0) 2x2
    assert can_place_2x2(Point(0, 0), bounds, generated, set())


# =============================================================================
# 2x1 Horizontal Placement Tests
# =============================================================================


class TestCanPlace2x1Horizontal:
  def test_valid_with_top_generated(self) -> None:
    """2x1 can be placed when top row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(1, -1)}  # Top neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_with_bottom_generated(self) -> None:
    """2x1 can be placed when bottom row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 1), Point(1, 1)}  # Bottom neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_left_generated(self) -> None:
    """2x1 cannot be placed when left neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_right_generated(self) -> None:
    """2x1 cannot be placed when right neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """2x1 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """2x1 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 1),
      Point(1, 1),  # Bottom
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_only_partial_long_side(self) -> None:
    """2x1 cannot be placed when only one of two top neighbors is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Only one top neighbor
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """2x1 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(5, -1), Point(6, -1)}
    # Left at x=5 would extend to x=6
    assert not can_place_2x1_horizontal(Point(5, 0), bounds, generated, set())


# =============================================================================
# 1x2 Vertical Placement Tests
# =============================================================================


class TestCanPlace1x2Vertical:
  def test_valid_with_left_generated(self) -> None:
    """1x2 can be placed when left column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(-1, 1)}  # Left neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_with_right_generated(self) -> None:
    """1x2 can be placed when right column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(1, 0), Point(1, 1)}  # Right neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_top_generated(self) -> None:
    """1x2 cannot be placed when top neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_bottom_generated(self) -> None:
    """1x2 cannot be placed when bottom neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """1x2 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """1x2 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(1, 0),
      Point(1, 1),  # Right
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """1x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 5), Point(-1, 6)}
    # Top at y=5 would extend to y=6
    assert not can_place_1x2_vertical(Point(0, 5), bounds, generated, set())


# =============================================================================
# Full Rectangle Plan Tests
# =============================================================================


class TestCreateRectanglePlan:
  def test_empty_rectangle_no_generated(self) -> None:
    """Empty rectangle with no pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_with_context(self) -> None:
    """Single quadrant rectangle requires 3 neighbors for context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 requires 3 of 4 quadrants in a 2x2 block to be generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_without_context(self) -> None:
    """Single quadrant without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_2x2_rectangle(self) -> None:
    """2x2 rectangle should be a single 2x2 tile."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    plan = create_rectangle_plan(bounds)

    # Should have exactly one 2x2 step
    assert len(plan.steps) == 1
    assert len(plan.steps[0].quadrants) == 4
    assert plan.steps[0].step_type == "2x2"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_3x3_rectangle(self) -> None:
    """3x3 rectangle - mix of tiles."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_4x4_rectangle(self) -> None:
    """4x4 rectangle - should fit multiple 2x2 tiles."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have multiple 2x2 tiles
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 1

  def test_wide_rectangle(self) -> None:
    """Wide rectangle (10x2)."""
    bounds = RectBounds(Point(0, 0), Point(9, 1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_tall_rectangle(self) -> None:
    """Tall rectangle (2x10)."""
    bounds = RectBounds(Point(0, 0), Point(1, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_corner(self) -> None:
    """Rectangle with one corner already generated."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should not include (0,0) in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants

  def test_with_pre_generated_edge(self) -> None:
    """Rectangle with one edge already generated (outside the bounds)."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generated row above the rectangle
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_interior(self) -> None:
    """Rectangle with some interior quadrants already generated."""
    bounds = RectBounds(Point(0, 0), Point(4, 4))
    # Some interior points generated - form a vertical 1x2 block
    # This provides context for adjacent tiles
    generated = {Point(2, 2), Point(2, 3)}
    plan = create_rectangle_plan(bounds, generated)

    # Should not include generated points
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(2, 2) not in all_quadrants
    assert Point(2, 3) not in all_quadrants

    # The plan should cover the remaining quadrants
    # Note: Some gaps may remain if there's no valid context
    covered = set(all_quadrants)
    expected_to_cover = set(bounds.all_points()) - generated

    # Verify no extra quadrants are covered
    extra = covered - expected_to_cover
    assert not extra, f"Extra quadrants covered: {extra}"

  def test_fully_generated(self) -> None:
    """Rectangle where all quadrants are already generated."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 0
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_negative_coordinates(self) -> None:
    """Rectangle in negative coordinate space."""
    bounds = RectBounds(Point(-5, -3), Point(-2, -1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_convenience(self) -> None:
    """Test the convenience function with tuples."""
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3))

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_with_generated(self) -> None:
    """Test convenience function with pre-generated set."""
    generated = {(0, 0), (1, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3), generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants


# =============================================================================
# 2x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x2RuleEnforcement:
  def test_2x2_not_touching_pre_generated(self) -> None:
    """2x2 tiles should not touch pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Pre-generated quadrant at (2, -1) - above the rectangle
    generated = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    # Find all 2x2 steps
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        # Subtract the tile itself
        neighbors -= set(step.quadrants)
        # No neighbor should be pre-generated
        for n in neighbors:
          assert n not in generated, (
            f"2x2 at {step.quadrants} has pre-generated neighbor {n}"
          )

  def test_2x2_not_touching_other_scheduled(self) -> None:
    """2x2 tiles should not touch other scheduled tiles (at placement time)."""
    # This is verified by the algorithm itself - 2x2 tiles can only be placed
    # where no neighbor is scheduled. We verify by checking no 2x2 tiles share edges.
    bounds = RectBounds(Point(0, 0), Point(7, 7))
    plan = create_rectangle_plan(bounds)

    # Collect all 2x2 tile quadrants
    all_2x2_quadrants: set[Point] = set()
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          all_2x2_quadrants.add(q)

    # Check that no 2x2 tiles share edges (they should have gaps)
    # Actually, 2x2 tiles CAN share edges with OTHER 2x2 tiles if they were
    # placed later. The rule is only about pre-existing generated content.
    # Let's just verify the plan is valid.
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# 2x1/1x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x1RuleEnforcement:
  def test_2x1_extends_from_generated_edge(self) -> None:
    """2x1 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Pre-generated row above
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x2_extends_from_generated_edge(self) -> None:
    """1x2 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Pre-generated column to the left
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Plan Summary Tests
# =============================================================================


class TestPlanSummary:
  def test_summary_basic(self) -> None:
    """Test plan summary generation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    summary = get_plan_summary(plan)

    assert summary["bounds"]["width"] == 4
    assert summary["bounds"]["height"] == 4
    assert summary["total_quadrants"] == 16
    assert summary["total_steps"] > 0

  def test_summary_with_pre_generated(self) -> None:
    """Test summary with pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0), Point(0, 1)}
    plan = create_rectangle_plan(bounds, generated)
    summary = get_plan_summary(plan)

    assert summary["pre_generated_count"] == 2
    assert summary["total_quadrants"] == 14  # 16 - 2


# =============================================================================
# Edge Case Tests
# =============================================================================


class TestEdgeCases:
  def test_1x1_rectangle_with_context(self) -> None:
    """Smallest possible rectangle with 3-neighbor context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 needs 3 of 4 quadrants in a 2x2 block generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid

  def test_1x1_rectangle_without_context(self) -> None:
    """1x1 rectangle without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_1x10_strip_with_context(self) -> None:
    """Very thin horizontal strip with bottom edge context."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    # Add context row below the strip
    generated = {Point(x, 1) for x in range(10)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x10_strip_without_context(self) -> None:
    """Thin strip without context cannot be fully generated."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed (can't place 2x2 in 1-row strip)
    assert len(plan.steps) == 0

  def test_10x1_strip_with_context(self) -> None:
    """Very thin vertical strip with right edge context."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    # Add context column to the right
    generated = {Point(1, y) for y in range(10)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_10x1_strip_without_context(self) -> None:
    """Thin strip without context cannot be fully generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed (can't place 2x2 in 1-col strip)
    assert len(plan.steps) == 0

  def test_large_rectangle(self) -> None:
    """Large rectangle (20x20)."""
    bounds = RectBounds(Point(0, 0), Point(19, 19))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have many 2x2 tiles (greedy algorithm may not be optimal)
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 40  # Should have a reasonable number of 2x2 tiles

  def test_checkerboard_pre_generated(self) -> None:
    """Checkerboard pattern of pre-generated quadrants.

    In a checkerboard pattern, every 2x2 block has exactly 2 generated
    quadrants (diagonal corners). This means no point has 3-of-4 context
    in any 2x2 block, so 1x1 tiles cannot be placed.

    This is expected behavior - checkerboard patterns cannot be extended
    with valid context.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Checkerboard: every other quadrant
    generated = {Point(x, y) for y in range(6) for x in range(6) if (x + y) % 2 == 0}
    plan = create_rectangle_plan(bounds, generated)

    # No tiles can be placed because no point has 3-of-4 context
    # in any 2x2 block (checkerboard has only 2-of-4 diagonal)
    assert len(plan.steps) == 0

  def test_row_pattern_provides_context(self) -> None:
    """Row pattern provides valid 3-of-4 context for 1x1 generation.

    Unlike checkerboard, alternating rows allow 3-of-4 context.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Alternating rows: y=0,2,4 are generated
    generated = {Point(x, y) for y in [0, 2, 4] for x in range(6)}
    # Add edge context
    generated |= {Point(x, -1) for x in range(6)}
    generated |= {Point(x, 6) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Get the non-generated quadrants within bounds (rows 1, 3, 5)
    to_generate = {p for p in bounds.all_points() if p not in generated}
    all_quadrants = [q for s in plan.steps for q in s.quadrants]

    # Should cover all non-generated quadrants
    assert set(all_quadrants) == to_generate

    # All should be 2x1 (horizontal) since they have context above and below
    for step in plan.steps:
      assert step.step_type == "2x1"

  def test_surrounded_by_generated(self) -> None:
    """Rectangle completely surrounded by generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    # Generate a border around the rectangle
    generated: set[Point] = set()
    for x in range(-1, 5):
      generated.add(Point(x, -1))  # Top
      generated.add(Point(x, 4))  # Bottom
    for y in range(0, 4):
      generated.add(Point(-1, y))  # Left
      generated.add(Point(4, y))  # Right

    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles CAN be placed in the interior (shielded by outer ring)
    # But edges should use smaller tiles
    # Check that all 2x2 tiles don't touch the generated border
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # 2x2 at edge positions would have generated neighbors
          # Interior 2x2 (at 1,1 or 1,2 etc.) is OK
          neighbors = [
            Point(q.x - 1, q.y),
            Point(q.x + 1, q.y),
            Point(q.x, q.y - 1),
            Point(q.x, q.y + 1),
          ]
          for n in neighbors:
            if n not in step.quadrants:  # Not part of the tile itself
              assert n not in generated, (
                f"2x2 at {step.quadrants} has neighbor {n} in generated"
              )


# =============================================================================
# Integration Tests - Complex Scenarios
# =============================================================================


class TestComplexScenarios:
  def test_partial_strip_extension(self) -> None:
    """Extending from a partially generated strip."""
    bounds = RectBounds(Point(0, 0), Point(7, 3))
    # Some quadrants above are generated
    generated = {Point(0, -1), Point(1, -1), Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_l_shaped_pre_generated(self) -> None:
    """L-shaped region of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # L-shape in top-left
    generated = {
      Point(-1, 0),
      Point(-1, 1),
      Point(-1, 2),
      Point(0, -1),
      Point(1, -1),
      Point(2, -1),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_island_of_generated(self) -> None:
    """Island of pre-generated quadrants in the middle."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # 2x2 island in the center
    generated = {Point(4, 4), Point(5, 4), Point(4, 5), Point(5, 5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Generated island should not be in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for g in generated:
      assert g not in all_quadrants

  def test_multiple_disjoint_pre_generated(self) -> None:
    """Multiple disjoint pre-generated regions."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # Two separate 2x2 regions
    generated = {
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
      Point(7, 7),
      Point(8, 7),
      Point(7, 8),
      Point(8, 8),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Serialization Tests
# =============================================================================


# =============================================================================
# Task 019 Strip Plan Pattern Tests
# =============================================================================


class TestStripPlanPattern:
  """
  Tests that verify the algorithm follows the 019 strip plan pattern:
  1. 2x2 tiles placed with gaps (every 3rd column)
  2. 1x2 bridges between 2x2 tiles
  3. 2x1 bridges connecting to generation edge
  4. 1x1 fills for remaining gaps
  """

  def test_depth_3_horizontal_pattern(self) -> None:
    """
    Test 6x3 rectangle with bottom edge generated.

    Expected pattern (following 019):
    Row 0-1: 2x2 at (0,0), (3,0) with 1x2 bridges at (2,0), (5,0)
    Row 2:   2x1 at (0,2), (3,2) with 1x1 at (2,2), (5,2)

    Visual:
    A A C B B D   <- row 0 (A=2x2, B=2x2, C=1x2, D=1x2)
    A A C B B D   <- row 1
    E E G F F H   <- row 2 (E=2x1, F=2x1, G=1x1, H=1x1)
    G G G G G G   <- generation edge (y=3, outside rectangle)
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generation edge at y=3 (below rectangle)
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 1x2, 2 2x1, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

    # Verify 2x2 positions
    two_by_two = [s for s in plan.steps if s.step_type == "2x2"]
    two_by_two_positions = [
      (min(q.x for q in s.quadrants), min(q.y for q in s.quadrants)) for s in two_by_two
    ]
    assert (0, 0) in two_by_two_positions
    assert (3, 0) in two_by_two_positions

    # Verify 1x2 positions (between 2x2 tiles)
    one_by_two = [s for s in plan.steps if s.step_type == "1x2"]
    one_by_two_positions = [s.quadrants[0] for s in one_by_two]
    assert Point(2, 0) in one_by_two_positions
    assert Point(5, 0) in one_by_two_positions

    # Verify 2x1 positions (connecting to edge)
    two_by_one = [s for s in plan.steps if s.step_type == "2x1"]
    two_by_one_positions = [
      (min(q.x for q in s.quadrants), s.quadrants[0].y) for s in two_by_one
    ]
    assert (0, 2) in two_by_one_positions
    assert (3, 2) in two_by_one_positions

  def test_depth_3_vertical_pattern(self) -> None:
    """
    Test 3x6 rectangle with left edge generated.

    Similar pattern but rotated 90 degrees.
    """
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Generation edge at x=-1 (left of rectangle)
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type - pattern should be similar
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 2x1, 2 1x2, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

  def test_1x2_bridges_between_2x2(self) -> None:
    """Test that 1x2 bridges correctly connect two 2x2 tiles."""
    # 5x3 rectangle (need 3 rows for 2x2 + bridge pattern)
    # With generation edge at y=3 (one row gap from 2x2 tiles)
    bounds = RectBounds(Point(0, 0), Point(4, 2))
    generated = {Point(x, 3) for x in range(5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Visual:
    # A A C B B   <- row 0 (A=2x2 at 0,0; B=2x2 at 3,0; C=1x2 at 2,0)
    # A A C B B   <- row 1
    # D D E F F   <- row 2 (D=2x1 at 0,2; E=1x1 at 2,2; F=2x1 at 3,2)
    # G G G G G   <- generation edge

    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # 2 2x2 tiles, 1 1x2 bridge, 2 2x1, 1 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 1, f"Expected 1 1x2 bridge, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 1, f"Expected 1 1x1 fill, got {types}"

  def test_order_matches_019_pattern(self) -> None:
    """
    Verify that generation order follows 019:
    1. 2x2 tiles first
    2. 1x2 bridges second
    3. 2x1 bridges third
    4. 1x1 fills last
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Check order
    current_phase = 0
    phase_order = {"2x2": 0, "1x2": 1, "2x1": 2, "1x1": 3}

    for step in plan.steps:
      phase = phase_order.get(step.step_type, 4)
      assert phase >= current_phase, (
        f"Step {step.step_type} appears after later phase. "
        f"Expected order: 2x2, 1x2, 2x1, 1x1"
      )
      current_phase = phase


class TestSerialization:
  def test_step_to_dict(self) -> None:
    """Test GenerationStep serialization."""
    step = GenerationStep(quadrants=[Point(0, 0), Point(1, 0)], step_type="2x1")
    d = step.to_dict()
    assert d["quadrants"] == [(0, 0), (1, 0)]
    assert d["type"] == "2x1"

  def test_plan_to_dict(self) -> None:
    """Test RectanglePlan serialization."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    d = plan.to_dict()

    assert d["bounds"]["top_left"] == (0, 0)
    assert d["bounds"]["bottom_right"] == (3, 3)
    assert len(d["steps"]) > 0


# =============================================================================
# Validation Tests
# =============================================================================


class TestValidation:
  def test_valid_plan(self) -> None:
    """Valid plan should pass validation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid
    assert len(errors) == 0

  def test_detect_duplicate_coverage(self) -> None:
    """Validation should detect duplicate coverage."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with duplicates
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0)]),
        GenerationStep(quadrants=[Point(0, 0), Point(0, 1)]),  # Duplicate!
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("multiple times" in e for e in errors)

  def test_detect_missing_quadrants(self) -> None:
    """Validation should detect missing quadrants."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with missing quadrant
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0), Point(0, 1)]),
        # Missing (1, 1)
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("Missing" in e for e in errors)


# =============================================================================
# Queued Quadrant Tests - Seam Detection with In-Progress/Queued Generations
# =============================================================================


class TestQueuedQuadrants:
  """
  Tests that verify the algorithm correctly considers in-progress and queued
  generations when determining if a seam will be formed.

  Queued quadrants are treated the same as generated quadrants for seam
  detection purposes - tiles cannot be placed adjacent to them.
  """

  def test_queued_quadrants_prevent_2x2_placement(self) -> None:
    """2x2 tiles cannot be placed adjacent to queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # No generated quadrants
    generated: set[Point] = set()
    # But there's a queued generation at (2, -1) - above the rectangle
    queued = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Find all 2x2 steps and verify none touch the queued quadrant
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        neighbors -= set(step.quadrants)
        for n in neighbors:
          assert n not in queued, f"2x2 at {step.quadrants} has queued neighbor {n}"

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_queued_quadrants_excluded_from_plan(self) -> None:
    """Queued quadrants within bounds should not be included in the plan.

    Queued quadrants act as context for other tiles but are not generated
    in this plan (they're already queued elsewhere).
    """
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queue a 2x2 block - this provides context for adjacent tiles
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Should not include queued points in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # The remaining quadrants should be covered
    remaining = set(bounds.all_points()) - queued
    covered = set(all_quadrants)

    # All covered should be from remaining
    assert covered.issubset(remaining), f"Covered {covered} not subset of remaining {remaining}"

  def test_queued_row_affects_2x1_placement(self) -> None:
    """2x1 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated: set[Point] = set()
    # Queued row below the rectangle acts like a generated edge
    queued = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 2x1 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at y=3, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"

  def test_queued_column_affects_1x2_placement(self) -> None:
    """1x2 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    generated: set[Point] = set()
    # Queued column to the left acts like a generated edge
    queued = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 1x2 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at x=-1, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"

  def test_mixed_generated_and_queued(self) -> None:
    """Plan should correctly handle both generated and queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Some quadrants are already generated
    generated = {Point(-1, 0), Point(-1, 1)}
    # Some quadrants are queued for generation
    queued = {Point(6, 0), Point(6, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles at left edge should not touch generated at (-1, 0) (-1, 1)
    # 2x2 tiles at right edge should not touch queued at (6, 0) (6, 1)
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # Check no neighbor is generated
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in generated, (
                f"2x2 at {step.quadrants} has generated neighbor {neighbor}"
              )
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_queued_quadrant_in_middle_prevents_2x2(self) -> None:
    """A queued quadrant in the middle should prevent 2x2 placement there."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queued 2x2 block in the center
    queued = {Point(1, 1), Point(2, 1), Point(1, 2), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # No step should include any queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # 2x2 tiles should not be placed adjacent to the queued block
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_from_coords_with_queued(self) -> None:
    """Test convenience function with queued set."""
    generated = {(0, 0), (1, 0)}
    queued = {(2, 0), (3, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (5, 3), generated, queued)

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    # Neither generated nor queued should be in plan
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants
    assert Point(2, 0) not in all_quadrants
    assert Point(3, 0) not in all_quadrants

  def test_fully_queued_rectangle(self) -> None:
    """Rectangle where all quadrants are queued should produce empty plan."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated: set[Point] = set()
    queued = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated, queued)

    assert len(plan.steps) == 0

  def test_queued_prevents_seam_with_future_generation(self) -> None:
    """
    Queued quadrants should be treated as if they will be generated,
    preventing seams with future generations.

    Scenario: User is generating a 2x2 at (0,0)-(1,1) and there's already
    a queued 2x2 at (2,0)-(3,1). The plan should not place tiles that
    would create a seam between them.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 3))
    generated: set[Point] = set()
    # First 2x2 is queued
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # The plan should not include the queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants

    # Verify the plan covers exactly the non-queued quadrants
    expected = set(bounds.all_points()) - queued
    covered = set(all_quadrants)
    assert covered == expected, f"Expected {expected}, got {covered}"

    # 2x2 tiles should not be placed at (2,0) because it would touch
    # the queued 2x2 at x=1
    for step in plan.steps:
      if step.step_type == "2x2":
        step_tl = min(q.x for q in step.quadrants), min(q.y for q in step.quadrants)
        # If there's a 2x2 at (2, 0), it would have neighbors at (1, 0) and (1, 1)
        # which are queued
        if step_tl == (2, 0):
          assert False, "2x2 at (2,0) would create seam with queued (0,0)-(1,1)"

```

---

**User**

keep going

---

**Cursor**

```python
"""
Tests for make_rectangle_plan.py

These tests verify the rectangle generation planning algorithm handles
all cases correctly, including:
- Basic coverage of all quadrants
- 2x2 tile placement rules (no touching generated neighbors)
- 2x1/1x2 tile placement rules (extend from generated edges)
- 1x1 filling of remaining gaps
- Pre-existing generated quadrants
- Various rectangle sizes and configurations
"""

from isometric_nyc.e2e_generation.make_rectangle_plan import (
  GenerationStep,
  Point,
  RectanglePlan,
  RectBounds,
  can_place_1x2_vertical,
  can_place_2x1_horizontal,
  can_place_2x2,
  create_rectangle_plan,
  create_rectangle_plan_from_coords,
  get_2x2_neighbors,
  get_2x2_quadrants,
  get_plan_summary,
  validate_plan,
)

# =============================================================================
# Point Tests
# =============================================================================


class TestPoint:
  def test_str(self) -> None:
    p = Point(3, 5)
    assert str(p) == "(3,5)"

  def test_add(self) -> None:
    p1 = Point(1, 2)
    p2 = Point(3, 4)
    result = p1 + p2
    assert result == Point(4, 6)

  def test_from_string_simple(self) -> None:
    p = Point.from_string("3,5")
    assert p == Point(3, 5)

  def test_from_string_with_parens(self) -> None:
    p = Point.from_string("(3,5)")
    assert p == Point(3, 5)

  def test_from_string_negative(self) -> None:
    p = Point.from_string("-3,-5")
    assert p == Point(-3, -5)

  def test_to_tuple(self) -> None:
    p = Point(3, 5)
    assert p.to_tuple() == (3, 5)


# =============================================================================
# RectBounds Tests
# =============================================================================


class TestRectBounds:
  def test_width_height(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(10, 5))
    assert bounds.width == 11
    assert bounds.height == 6

  def test_area(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(3, 2))
    assert bounds.area == 12  # 4 x 3

  def test_contains(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert bounds.contains(Point(0, 0))
    assert bounds.contains(Point(5, 5))
    assert bounds.contains(Point(3, 3))
    assert not bounds.contains(Point(-1, 0))
    assert not bounds.contains(Point(6, 0))
    assert not bounds.contains(Point(0, -1))
    assert not bounds.contains(Point(0, 6))

  def test_all_points(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(2, 1))
    points = bounds.all_points()
    expected = [
      Point(0, 0),
      Point(1, 0),
      Point(2, 0),
      Point(0, 1),
      Point(1, 1),
      Point(2, 1),
    ]
    assert points == expected


# =============================================================================
# 2x2 Tile Helper Tests
# =============================================================================


class TestGet2x2Quadrants:
  def test_basic(self) -> None:
    quadrants = get_2x2_quadrants(Point(0, 0))
    assert quadrants == [
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
    ]

  def test_offset(self) -> None:
    quadrants = get_2x2_quadrants(Point(5, 3))
    assert quadrants == [
      Point(5, 3),
      Point(6, 3),
      Point(5, 4),
      Point(6, 4),
    ]


class TestGet2x2Neighbors:
  def test_basic(self) -> None:
    neighbors = get_2x2_neighbors(Point(0, 0))
    # Top, Bottom, Left, Right
    expected = [
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 2),
      Point(1, 2),  # Bottom
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(2, 0),
      Point(2, 1),  # Right
    ]
    assert set(neighbors) == set(expected)
    assert len(neighbors) == 8


# =============================================================================
# 2x2 Placement Tests
# =============================================================================


class TestCanPlace2x2:
  def test_empty_grid(self) -> None:
    """2x2 can be placed in empty rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert can_place_2x2(Point(0, 0), bounds, set(), set())

  def test_out_of_bounds(self) -> None:
    """2x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Top-left at (5, 5) would extend to (6, 6)
    assert not can_place_2x2(Point(5, 5), bounds, set(), set())
    # Top-left at (5, 0) would extend to (6, 1)
    assert not can_place_2x2(Point(5, 0), bounds, set(), set())

  def test_neighbor_generated_top(self) -> None:
    """2x2 cannot be placed if top neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Top neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_bottom(self) -> None:
    """2x2 cannot be placed if bottom neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2)}  # Bottom neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_left(self) -> None:
    """2x2 cannot be placed if left neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0)}  # Left neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_right(self) -> None:
    """2x2 cannot be placed if right neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0)}  # Right neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_generated(self) -> None:
    """2x2 cannot be placed if any quadrant is already generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 0)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_scheduled(self) -> None:
    """2x2 cannot be placed if any quadrant is already scheduled."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    scheduled = {Point(1, 1)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, set(), scheduled)

  def test_valid_with_distant_generated(self) -> None:
    """2x2 can be placed if generated quadrants are not neighbors."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(3, 3)}  # Far from (0,0) 2x2
    assert can_place_2x2(Point(0, 0), bounds, generated, set())


# =============================================================================
# 2x1 Horizontal Placement Tests
# =============================================================================


class TestCanPlace2x1Horizontal:
  def test_valid_with_top_generated(self) -> None:
    """2x1 can be placed when top row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(1, -1)}  # Top neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_with_bottom_generated(self) -> None:
    """2x1 can be placed when bottom row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 1), Point(1, 1)}  # Bottom neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_left_generated(self) -> None:
    """2x1 cannot be placed when left neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_right_generated(self) -> None:
    """2x1 cannot be placed when right neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """2x1 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """2x1 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 1),
      Point(1, 1),  # Bottom
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_only_partial_long_side(self) -> None:
    """2x1 cannot be placed when only one of two top neighbors is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Only one top neighbor
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """2x1 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(5, -1), Point(6, -1)}
    # Left at x=5 would extend to x=6
    assert not can_place_2x1_horizontal(Point(5, 0), bounds, generated, set())


# =============================================================================
# 1x2 Vertical Placement Tests
# =============================================================================


class TestCanPlace1x2Vertical:
  def test_valid_with_left_generated(self) -> None:
    """1x2 can be placed when left column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(-1, 1)}  # Left neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_with_right_generated(self) -> None:
    """1x2 can be placed when right column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(1, 0), Point(1, 1)}  # Right neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_top_generated(self) -> None:
    """1x2 cannot be placed when top neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_bottom_generated(self) -> None:
    """1x2 cannot be placed when bottom neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """1x2 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """1x2 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(1, 0),
      Point(1, 1),  # Right
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """1x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 5), Point(-1, 6)}
    # Top at y=5 would extend to y=6
    assert not can_place_1x2_vertical(Point(0, 5), bounds, generated, set())


# =============================================================================
# Full Rectangle Plan Tests
# =============================================================================


class TestCreateRectanglePlan:
  def test_empty_rectangle_no_generated(self) -> None:
    """Empty rectangle with no pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_with_context(self) -> None:
    """Single quadrant rectangle requires 3 neighbors for context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 requires 3 of 4 quadrants in a 2x2 block to be generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_without_context(self) -> None:
    """Single quadrant without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_2x2_rectangle(self) -> None:
    """2x2 rectangle should be a single 2x2 tile."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    plan = create_rectangle_plan(bounds)

    # Should have exactly one 2x2 step
    assert len(plan.steps) == 1
    assert len(plan.steps[0].quadrants) == 4
    assert plan.steps[0].step_type == "2x2"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_3x3_rectangle(self) -> None:
    """3x3 rectangle - mix of tiles."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_4x4_rectangle(self) -> None:
    """4x4 rectangle - should fit multiple 2x2 tiles."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have multiple 2x2 tiles
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 1

  def test_wide_rectangle(self) -> None:
    """Wide rectangle (10x2)."""
    bounds = RectBounds(Point(0, 0), Point(9, 1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_tall_rectangle(self) -> None:
    """Tall rectangle (2x10)."""
    bounds = RectBounds(Point(0, 0), Point(1, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_corner(self) -> None:
    """Rectangle with one corner already generated."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should not include (0,0) in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants

  def test_with_pre_generated_edge(self) -> None:
    """Rectangle with one edge already generated (outside the bounds)."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generated row above the rectangle
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_interior(self) -> None:
    """Rectangle with some interior quadrants already generated."""
    bounds = RectBounds(Point(0, 0), Point(4, 4))
    # Some interior points generated - form a vertical 1x2 block
    # This provides context for adjacent tiles
    generated = {Point(2, 2), Point(2, 3)}
    plan = create_rectangle_plan(bounds, generated)

    # Should not include generated points
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(2, 2) not in all_quadrants
    assert Point(2, 3) not in all_quadrants

    # The plan should cover the remaining quadrants
    # Note: Some gaps may remain if there's no valid context
    covered = set(all_quadrants)
    expected_to_cover = set(bounds.all_points()) - generated

    # Verify no extra quadrants are covered
    extra = covered - expected_to_cover
    assert not extra, f"Extra quadrants covered: {extra}"

  def test_fully_generated(self) -> None:
    """Rectangle where all quadrants are already generated."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 0
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_negative_coordinates(self) -> None:
    """Rectangle in negative coordinate space."""
    bounds = RectBounds(Point(-5, -3), Point(-2, -1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_convenience(self) -> None:
    """Test the convenience function with tuples."""
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3))

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_with_generated(self) -> None:
    """Test convenience function with pre-generated set."""
    generated = {(0, 0), (1, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3), generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants


# =============================================================================
# 2x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x2RuleEnforcement:
  def test_2x2_not_touching_pre_generated(self) -> None:
    """2x2 tiles should not touch pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Pre-generated quadrant at (2, -1) - above the rectangle
    generated = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    # Find all 2x2 steps
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        # Subtract the tile itself
        neighbors -= set(step.quadrants)
        # No neighbor should be pre-generated
        for n in neighbors:
          assert n not in generated, (
            f"2x2 at {step.quadrants} has pre-generated neighbor {n}"
          )

  def test_2x2_not_touching_other_scheduled(self) -> None:
    """2x2 tiles should not touch other scheduled tiles (at placement time)."""
    # This is verified by the algorithm itself - 2x2 tiles can only be placed
    # where no neighbor is scheduled. We verify by checking no 2x2 tiles share edges.
    bounds = RectBounds(Point(0, 0), Point(7, 7))
    plan = create_rectangle_plan(bounds)

    # Collect all 2x2 tile quadrants
    all_2x2_quadrants: set[Point] = set()
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          all_2x2_quadrants.add(q)

    # Check that no 2x2 tiles share edges (they should have gaps)
    # Actually, 2x2 tiles CAN share edges with OTHER 2x2 tiles if they were
    # placed later. The rule is only about pre-existing generated content.
    # Let's just verify the plan is valid.
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# 2x1/1x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x1RuleEnforcement:
  def test_2x1_extends_from_generated_edge(self) -> None:
    """2x1 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Pre-generated row above
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x2_extends_from_generated_edge(self) -> None:
    """1x2 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Pre-generated column to the left
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Plan Summary Tests
# =============================================================================


class TestPlanSummary:
  def test_summary_basic(self) -> None:
    """Test plan summary generation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    summary = get_plan_summary(plan)

    assert summary["bounds"]["width"] == 4
    assert summary["bounds"]["height"] == 4
    assert summary["total_quadrants"] == 16
    assert summary["total_steps"] > 0

  def test_summary_with_pre_generated(self) -> None:
    """Test summary with pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0), Point(0, 1)}
    plan = create_rectangle_plan(bounds, generated)
    summary = get_plan_summary(plan)

    assert summary["pre_generated_count"] == 2
    assert summary["total_quadrants"] == 14  # 16 - 2


# =============================================================================
# Edge Case Tests
# =============================================================================


class TestEdgeCases:
  def test_1x1_rectangle_with_context(self) -> None:
    """Smallest possible rectangle with 3-neighbor context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 needs 3 of 4 quadrants in a 2x2 block generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid

  def test_1x1_rectangle_without_context(self) -> None:
    """1x1 rectangle without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_1x10_strip_with_context(self) -> None:
    """Very thin horizontal strip with bottom edge context."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    # Add context row below the strip
    generated = {Point(x, 1) for x in range(10)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x10_strip_without_context(self) -> None:
    """Thin strip without context cannot be fully generated."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed (can't place 2x2 in 1-row strip)
    assert len(plan.steps) == 0

  def test_10x1_strip_with_context(self) -> None:
    """Very thin vertical strip with right edge context."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    # Add context column to the right
    generated = {Point(1, y) for y in range(10)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_10x1_strip_without_context(self) -> None:
    """Thin strip without context cannot be fully generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed (can't place 2x2 in 1-col strip)
    assert len(plan.steps) == 0

  def test_large_rectangle(self) -> None:
    """Large rectangle (20x20)."""
    bounds = RectBounds(Point(0, 0), Point(19, 19))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have many 2x2 tiles (greedy algorithm may not be optimal)
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 40  # Should have a reasonable number of 2x2 tiles

  def test_checkerboard_pre_generated(self) -> None:
    """Checkerboard pattern of pre-generated quadrants.

    In a checkerboard pattern, every 2x2 block has exactly 2 generated
    quadrants (diagonal corners). This means no point has 3-of-4 context
    in any 2x2 block, so 1x1 tiles cannot be placed.

    This is expected behavior - checkerboard patterns cannot be extended
    with valid context.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Checkerboard: every other quadrant
    generated = {Point(x, y) for y in range(6) for x in range(6) if (x + y) % 2 == 0}
    plan = create_rectangle_plan(bounds, generated)

    # No tiles can be placed because no point has 3-of-4 context
    # in any 2x2 block (checkerboard has only 2-of-4 diagonal)
    assert len(plan.steps) == 0

  def test_row_pattern_provides_context(self) -> None:
    """Row pattern provides valid context for generation.

    Unlike checkerboard, alternating rows allow valid context because
    each non-generated quadrant has 3 neighbors in some 2x2 block.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Alternating rows: y=0,2,4 are generated
    generated = {Point(x, y) for y in [0, 2, 4] for x in range(6)}
    # Add edge context
    generated |= {Point(x, -1) for x in range(6)}
    generated |= {Point(x, 6) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Get the non-generated quadrants within bounds (rows 1, 3, 5)
    to_generate = {p for p in bounds.all_points() if p not in generated}
    all_quadrants = [q for s in plan.steps for q in s.quadrants]

    # Should cover all non-generated quadrants
    assert set(all_quadrants) == to_generate

    # All tiles should be 2x1 or 1x1 (both valid with row context)
    for step in plan.steps:
      assert step.step_type in ("2x1", "1x1")

  def test_surrounded_by_generated(self) -> None:
    """Rectangle completely surrounded by generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    # Generate a border around the rectangle
    generated: set[Point] = set()
    for x in range(-1, 5):
      generated.add(Point(x, -1))  # Top
      generated.add(Point(x, 4))  # Bottom
    for y in range(0, 4):
      generated.add(Point(-1, y))  # Left
      generated.add(Point(4, y))  # Right

    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles CAN be placed in the interior (shielded by outer ring)
    # But edges should use smaller tiles
    # Check that all 2x2 tiles don't touch the generated border
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # 2x2 at edge positions would have generated neighbors
          # Interior 2x2 (at 1,1 or 1,2 etc.) is OK
          neighbors = [
            Point(q.x - 1, q.y),
            Point(q.x + 1, q.y),
            Point(q.x, q.y - 1),
            Point(q.x, q.y + 1),
          ]
          for n in neighbors:
            if n not in step.quadrants:  # Not part of the tile itself
              assert n not in generated, (
                f"2x2 at {step.quadrants} has neighbor {n} in generated"
              )


# =============================================================================
# Integration Tests - Complex Scenarios
# =============================================================================


class TestComplexScenarios:
  def test_partial_strip_extension(self) -> None:
    """Extending from a partially generated strip."""
    bounds = RectBounds(Point(0, 0), Point(7, 3))
    # Some quadrants above are generated
    generated = {Point(0, -1), Point(1, -1), Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_l_shaped_pre_generated(self) -> None:
    """L-shaped region of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # L-shape in top-left
    generated = {
      Point(-1, 0),
      Point(-1, 1),
      Point(-1, 2),
      Point(0, -1),
      Point(1, -1),
      Point(2, -1),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_island_of_generated(self) -> None:
    """Island of pre-generated quadrants in the middle."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # 2x2 island in the center
    generated = {Point(4, 4), Point(5, 4), Point(4, 5), Point(5, 5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Generated island should not be in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for g in generated:
      assert g not in all_quadrants

  def test_multiple_disjoint_pre_generated(self) -> None:
    """Multiple disjoint pre-generated regions."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # Two separate 2x2 regions
    generated = {
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
      Point(7, 7),
      Point(8, 7),
      Point(7, 8),
      Point(8, 8),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Serialization Tests
# =============================================================================


# =============================================================================
# Task 019 Strip Plan Pattern Tests
# =============================================================================


class TestStripPlanPattern:
  """
  Tests that verify the algorithm follows the 019 strip plan pattern:
  1. 2x2 tiles placed with gaps (every 3rd column)
  2. 1x2 bridges between 2x2 tiles
  3. 2x1 bridges connecting to generation edge
  4. 1x1 fills for remaining gaps
  """

  def test_depth_3_horizontal_pattern(self) -> None:
    """
    Test 6x3 rectangle with bottom edge generated.

    Expected pattern (following 019):
    Row 0-1: 2x2 at (0,0), (3,0) with 1x2 bridges at (2,0), (5,0)
    Row 2:   2x1 at (0,2), (3,2) with 1x1 at (2,2), (5,2)

    Visual:
    A A C B B D   <- row 0 (A=2x2, B=2x2, C=1x2, D=1x2)
    A A C B B D   <- row 1
    E E G F F H   <- row 2 (E=2x1, F=2x1, G=1x1, H=1x1)
    G G G G G G   <- generation edge (y=3, outside rectangle)
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generation edge at y=3 (below rectangle)
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 1x2, 2 2x1, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

    # Verify 2x2 positions
    two_by_two = [s for s in plan.steps if s.step_type == "2x2"]
    two_by_two_positions = [
      (min(q.x for q in s.quadrants), min(q.y for q in s.quadrants)) for s in two_by_two
    ]
    assert (0, 0) in two_by_two_positions
    assert (3, 0) in two_by_two_positions

    # Verify 1x2 positions (between 2x2 tiles)
    one_by_two = [s for s in plan.steps if s.step_type == "1x2"]
    one_by_two_positions = [s.quadrants[0] for s in one_by_two]
    assert Point(2, 0) in one_by_two_positions
    assert Point(5, 0) in one_by_two_positions

    # Verify 2x1 positions (connecting to edge)
    two_by_one = [s for s in plan.steps if s.step_type == "2x1"]
    two_by_one_positions = [
      (min(q.x for q in s.quadrants), s.quadrants[0].y) for s in two_by_one
    ]
    assert (0, 2) in two_by_one_positions
    assert (3, 2) in two_by_one_positions

  def test_depth_3_vertical_pattern(self) -> None:
    """
    Test 3x6 rectangle with left edge generated.

    Similar pattern but rotated 90 degrees.
    """
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Generation edge at x=-1 (left of rectangle)
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type - pattern should be similar
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 2x1, 2 1x2, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

  def test_1x2_bridges_between_2x2(self) -> None:
    """Test that 1x2 bridges correctly connect two 2x2 tiles."""
    # 5x3 rectangle (need 3 rows for 2x2 + bridge pattern)
    # With generation edge at y=3 (one row gap from 2x2 tiles)
    bounds = RectBounds(Point(0, 0), Point(4, 2))
    generated = {Point(x, 3) for x in range(5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Visual:
    # A A C B B   <- row 0 (A=2x2 at 0,0; B=2x2 at 3,0; C=1x2 at 2,0)
    # A A C B B   <- row 1
    # D D E F F   <- row 2 (D=2x1 at 0,2; E=1x1 at 2,2; F=2x1 at 3,2)
    # G G G G G   <- generation edge

    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # 2 2x2 tiles, 1 1x2 bridge, 2 2x1, 1 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 1, f"Expected 1 1x2 bridge, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 1, f"Expected 1 1x1 fill, got {types}"

  def test_order_matches_019_pattern(self) -> None:
    """
    Verify that generation order follows 019:
    1. 2x2 tiles first
    2. 1x2 bridges second
    3. 2x1 bridges third
    4. 1x1 fills last
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Check order
    current_phase = 0
    phase_order = {"2x2": 0, "1x2": 1, "2x1": 2, "1x1": 3}

    for step in plan.steps:
      phase = phase_order.get(step.step_type, 4)
      assert phase >= current_phase, (
        f"Step {step.step_type} appears after later phase. "
        f"Expected order: 2x2, 1x2, 2x1, 1x1"
      )
      current_phase = phase


class TestSerialization:
  def test_step_to_dict(self) -> None:
    """Test GenerationStep serialization."""
    step = GenerationStep(quadrants=[Point(0, 0), Point(1, 0)], step_type="2x1")
    d = step.to_dict()
    assert d["quadrants"] == [(0, 0), (1, 0)]
    assert d["type"] == "2x1"

  def test_plan_to_dict(self) -> None:
    """Test RectanglePlan serialization."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    d = plan.to_dict()

    assert d["bounds"]["top_left"] == (0, 0)
    assert d["bounds"]["bottom_right"] == (3, 3)
    assert len(d["steps"]) > 0


# =============================================================================
# Validation Tests
# =============================================================================


class TestValidation:
  def test_valid_plan(self) -> None:
    """Valid plan should pass validation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid
    assert len(errors) == 0

  def test_detect_duplicate_coverage(self) -> None:
    """Validation should detect duplicate coverage."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with duplicates
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0)]),
        GenerationStep(quadrants=[Point(0, 0), Point(0, 1)]),  # Duplicate!
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("multiple times" in e for e in errors)

  def test_detect_missing_quadrants(self) -> None:
    """Validation should detect missing quadrants."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with missing quadrant
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0), Point(0, 1)]),
        # Missing (1, 1)
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("Missing" in e for e in errors)


# =============================================================================
# Queued Quadrant Tests - Seam Detection with In-Progress/Queued Generations
# =============================================================================


class TestQueuedQuadrants:
  """
  Tests that verify the algorithm correctly considers in-progress and queued
  generations when determining if a seam will be formed.

  Queued quadrants are treated the same as generated quadrants for seam
  detection purposes - tiles cannot be placed adjacent to them.
  """

  def test_queued_quadrants_prevent_2x2_placement(self) -> None:
    """2x2 tiles cannot be placed adjacent to queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # No generated quadrants
    generated: set[Point] = set()
    # But there's a queued generation at (2, -1) - above the rectangle
    queued = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Find all 2x2 steps and verify none touch the queued quadrant
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        neighbors -= set(step.quadrants)
        for n in neighbors:
          assert n not in queued, f"2x2 at {step.quadrants} has queued neighbor {n}"

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_queued_quadrants_excluded_from_plan(self) -> None:
    """Queued quadrants within bounds should not be included in the plan.

    Queued quadrants act as context for other tiles but are not generated
    in this plan (they're already queued elsewhere).
    """
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queue a 2x2 block - this provides context for adjacent tiles
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Should not include queued points in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # The remaining quadrants should be covered
    remaining = set(bounds.all_points()) - queued
    covered = set(all_quadrants)

    # All covered should be from remaining
    assert covered.issubset(remaining), (
      f"Covered {covered} not subset of remaining {remaining}"
    )

  def test_queued_row_affects_2x1_placement(self) -> None:
    """2x1 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated: set[Point] = set()
    # Queued row below the rectangle acts like a generated edge
    queued = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 2x1 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at y=3, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"

  def test_queued_column_affects_1x2_placement(self) -> None:
    """1x2 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    generated: set[Point] = set()
    # Queued column to the left acts like a generated edge
    queued = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 1x2 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at x=-1, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"

  def test_mixed_generated_and_queued(self) -> None:
    """Plan should correctly handle both generated and queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Some quadrants are already generated
    generated = {Point(-1, 0), Point(-1, 1)}
    # Some quadrants are queued for generation
    queued = {Point(6, 0), Point(6, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles at left edge should not touch generated at (-1, 0) (-1, 1)
    # 2x2 tiles at right edge should not touch queued at (6, 0) (6, 1)
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # Check no neighbor is generated
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in generated, (
                f"2x2 at {step.quadrants} has generated neighbor {neighbor}"
              )
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_queued_quadrant_in_middle_prevents_2x2(self) -> None:
    """A queued quadrant in the middle should prevent 2x2 placement there."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queued 2x2 block in the center
    queued = {Point(1, 1), Point(2, 1), Point(1, 2), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # No step should include any queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # 2x2 tiles should not be placed adjacent to the queued block
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_from_coords_with_queued(self) -> None:
    """Test convenience function with queued set."""
    generated = {(0, 0), (1, 0)}
    queued = {(2, 0), (3, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (5, 3), generated, queued)

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    # Neither generated nor queued should be in plan
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants
    assert Point(2, 0) not in all_quadrants
    assert Point(3, 0) not in all_quadrants

  def test_fully_queued_rectangle(self) -> None:
    """Rectangle where all quadrants are queued should produce empty plan."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated: set[Point] = set()
    queued = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated, queued)

    assert len(plan.steps) == 0

  def test_queued_prevents_seam_with_future_generation(self) -> None:
    """
    Queued quadrants should be treated as if they will be generated,
    preventing seams with future generations.

    Scenario: User is generating a 2x2 at (0,0)-(1,1) and there's already
    a queued 2x2 at (2,0)-(3,1). The plan should not place tiles that
    would create a seam between them.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 3))
    generated: set[Point] = set()
    # First 2x2 is queued
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # The plan should not include the queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants

    # Verify the plan covers exactly the non-queued quadrants
    expected = set(bounds.all_points()) - queued
    covered = set(all_quadrants)
    assert covered == expected, f"Expected {expected}, got {covered}"

    # 2x2 tiles should not be placed at (2,0) because it would touch
    # the queued 2x2 at x=1
    for step in plan.steps:
      if step.step_type == "2x2":
        step_tl = min(q.x for q in step.quadrants), min(q.y for q in step.quadrants)
        # If there's a 2x2 at (2, 0), it would have neighbors at (1, 0) and (1, 1)
        # which are queued
        if step_tl == (2, 0):
          assert False, "2x2 at (2,0) would create seam with queued (0,0)-(1,1)"

```

All tests pass. Let me run the full test suite to make sure nothing else is broken:

All 148 tests pass. Let me add tests for the new `validate_plan_context` function:

```python
"""
Tests for make_rectangle_plan.py

These tests verify the rectangle generation planning algorithm handles
all cases correctly, including:
- Basic coverage of all quadrants
- 2x2 tile placement rules (no touching generated neighbors)
- 2x1/1x2 tile placement rules (extend from generated edges)
- 1x1 filling of remaining gaps
- Pre-existing generated quadrants
- Various rectangle sizes and configurations
"""

from isometric_nyc.e2e_generation.make_rectangle_plan import (
  GenerationStep,
  Point,
  RectanglePlan,
  RectBounds,
  can_place_1x1,
  can_place_1x2_vertical,
  can_place_2x1_horizontal,
  can_place_2x2,
  create_rectangle_plan,
  create_rectangle_plan_from_coords,
  get_2x2_neighbors,
  get_2x2_quadrants,
  get_plan_summary,
  has_valid_2x2_context,
  validate_plan,
  validate_plan_context,
)

# =============================================================================
# Point Tests
# =============================================================================


class TestPoint:
  def test_str(self) -> None:
    p = Point(3, 5)
    assert str(p) == "(3,5)"

  def test_add(self) -> None:
    p1 = Point(1, 2)
    p2 = Point(3, 4)
    result = p1 + p2
    assert result == Point(4, 6)

  def test_from_string_simple(self) -> None:
    p = Point.from_string("3,5")
    assert p == Point(3, 5)

  def test_from_string_with_parens(self) -> None:
    p = Point.from_string("(3,5)")
    assert p == Point(3, 5)

  def test_from_string_negative(self) -> None:
    p = Point.from_string("-3,-5")
    assert p == Point(-3, -5)

  def test_to_tuple(self) -> None:
    p = Point(3, 5)
    assert p.to_tuple() == (3, 5)


# =============================================================================
# RectBounds Tests
# =============================================================================


class TestRectBounds:
  def test_width_height(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(10, 5))
    assert bounds.width == 11
    assert bounds.height == 6

  def test_area(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(3, 2))
    assert bounds.area == 12  # 4 x 3

  def test_contains(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert bounds.contains(Point(0, 0))
    assert bounds.contains(Point(5, 5))
    assert bounds.contains(Point(3, 3))
    assert not bounds.contains(Point(-1, 0))
    assert not bounds.contains(Point(6, 0))
    assert not bounds.contains(Point(0, -1))
    assert not bounds.contains(Point(0, 6))

  def test_all_points(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(2, 1))
    points = bounds.all_points()
    expected = [
      Point(0, 0),
      Point(1, 0),
      Point(2, 0),
      Point(0, 1),
      Point(1, 1),
      Point(2, 1),
    ]
    assert points == expected


# =============================================================================
# 2x2 Tile Helper Tests
# =============================================================================


class TestGet2x2Quadrants:
  def test_basic(self) -> None:
    quadrants = get_2x2_quadrants(Point(0, 0))
    assert quadrants == [
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
    ]

  def test_offset(self) -> None:
    quadrants = get_2x2_quadrants(Point(5, 3))
    assert quadrants == [
      Point(5, 3),
      Point(6, 3),
      Point(5, 4),
      Point(6, 4),
    ]


class TestGet2x2Neighbors:
  def test_basic(self) -> None:
    neighbors = get_2x2_neighbors(Point(0, 0))
    # Top, Bottom, Left, Right
    expected = [
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 2),
      Point(1, 2),  # Bottom
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(2, 0),
      Point(2, 1),  # Right
    ]
    assert set(neighbors) == set(expected)
    assert len(neighbors) == 8


# =============================================================================
# 2x2 Placement Tests
# =============================================================================


class TestCanPlace2x2:
  def test_empty_grid(self) -> None:
    """2x2 can be placed in empty rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert can_place_2x2(Point(0, 0), bounds, set(), set())

  def test_out_of_bounds(self) -> None:
    """2x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Top-left at (5, 5) would extend to (6, 6)
    assert not can_place_2x2(Point(5, 5), bounds, set(), set())
    # Top-left at (5, 0) would extend to (6, 1)
    assert not can_place_2x2(Point(5, 0), bounds, set(), set())

  def test_neighbor_generated_top(self) -> None:
    """2x2 cannot be placed if top neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Top neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_bottom(self) -> None:
    """2x2 cannot be placed if bottom neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2)}  # Bottom neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_left(self) -> None:
    """2x2 cannot be placed if left neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0)}  # Left neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_right(self) -> None:
    """2x2 cannot be placed if right neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0)}  # Right neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_generated(self) -> None:
    """2x2 cannot be placed if any quadrant is already generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 0)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_scheduled(self) -> None:
    """2x2 cannot be placed if any quadrant is already scheduled."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    scheduled = {Point(1, 1)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, set(), scheduled)

  def test_valid_with_distant_generated(self) -> None:
    """2x2 can be placed if generated quadrants are not neighbors."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(3, 3)}  # Far from (0,0) 2x2
    assert can_place_2x2(Point(0, 0), bounds, generated, set())


# =============================================================================
# 2x1 Horizontal Placement Tests
# =============================================================================


class TestCanPlace2x1Horizontal:
  def test_valid_with_top_generated(self) -> None:
    """2x1 can be placed when top row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(1, -1)}  # Top neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_with_bottom_generated(self) -> None:
    """2x1 can be placed when bottom row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 1), Point(1, 1)}  # Bottom neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_left_generated(self) -> None:
    """2x1 cannot be placed when left neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_right_generated(self) -> None:
    """2x1 cannot be placed when right neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """2x1 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """2x1 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 1),
      Point(1, 1),  # Bottom
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_only_partial_long_side(self) -> None:
    """2x1 cannot be placed when only one of two top neighbors is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Only one top neighbor
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """2x1 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(5, -1), Point(6, -1)}
    # Left at x=5 would extend to x=6
    assert not can_place_2x1_horizontal(Point(5, 0), bounds, generated, set())


# =============================================================================
# 1x2 Vertical Placement Tests
# =============================================================================


class TestCanPlace1x2Vertical:
  def test_valid_with_left_generated(self) -> None:
    """1x2 can be placed when left column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(-1, 1)}  # Left neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_with_right_generated(self) -> None:
    """1x2 can be placed when right column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(1, 0), Point(1, 1)}  # Right neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_top_generated(self) -> None:
    """1x2 cannot be placed when top neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_bottom_generated(self) -> None:
    """1x2 cannot be placed when bottom neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """1x2 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """1x2 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(1, 0),
      Point(1, 1),  # Right
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """1x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 5), Point(-1, 6)}
    # Top at y=5 would extend to y=6
    assert not can_place_1x2_vertical(Point(0, 5), bounds, generated, set())


# =============================================================================
# Full Rectangle Plan Tests
# =============================================================================


class TestCreateRectanglePlan:
  def test_empty_rectangle_no_generated(self) -> None:
    """Empty rectangle with no pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_with_context(self) -> None:
    """Single quadrant rectangle requires 3 neighbors for context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 requires 3 of 4 quadrants in a 2x2 block to be generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_without_context(self) -> None:
    """Single quadrant without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_2x2_rectangle(self) -> None:
    """2x2 rectangle should be a single 2x2 tile."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    plan = create_rectangle_plan(bounds)

    # Should have exactly one 2x2 step
    assert len(plan.steps) == 1
    assert len(plan.steps[0].quadrants) == 4
    assert plan.steps[0].step_type == "2x2"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_3x3_rectangle(self) -> None:
    """3x3 rectangle - mix of tiles."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_4x4_rectangle(self) -> None:
    """4x4 rectangle - should fit multiple 2x2 tiles."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have multiple 2x2 tiles
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 1

  def test_wide_rectangle(self) -> None:
    """Wide rectangle (10x2)."""
    bounds = RectBounds(Point(0, 0), Point(9, 1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_tall_rectangle(self) -> None:
    """Tall rectangle (2x10)."""
    bounds = RectBounds(Point(0, 0), Point(1, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_corner(self) -> None:
    """Rectangle with one corner already generated."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should not include (0,0) in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants

  def test_with_pre_generated_edge(self) -> None:
    """Rectangle with one edge already generated (outside the bounds)."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generated row above the rectangle
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_interior(self) -> None:
    """Rectangle with some interior quadrants already generated."""
    bounds = RectBounds(Point(0, 0), Point(4, 4))
    # Some interior points generated - form a vertical 1x2 block
    # This provides context for adjacent tiles
    generated = {Point(2, 2), Point(2, 3)}
    plan = create_rectangle_plan(bounds, generated)

    # Should not include generated points
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(2, 2) not in all_quadrants
    assert Point(2, 3) not in all_quadrants

    # The plan should cover the remaining quadrants
    # Note: Some gaps may remain if there's no valid context
    covered = set(all_quadrants)
    expected_to_cover = set(bounds.all_points()) - generated

    # Verify no extra quadrants are covered
    extra = covered - expected_to_cover
    assert not extra, f"Extra quadrants covered: {extra}"

  def test_fully_generated(self) -> None:
    """Rectangle where all quadrants are already generated."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 0
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_negative_coordinates(self) -> None:
    """Rectangle in negative coordinate space."""
    bounds = RectBounds(Point(-5, -3), Point(-2, -1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_convenience(self) -> None:
    """Test the convenience function with tuples."""
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3))

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_with_generated(self) -> None:
    """Test convenience function with pre-generated set."""
    generated = {(0, 0), (1, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3), generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants


# =============================================================================
# 2x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x2RuleEnforcement:
  def test_2x2_not_touching_pre_generated(self) -> None:
    """2x2 tiles should not touch pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Pre-generated quadrant at (2, -1) - above the rectangle
    generated = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    # Find all 2x2 steps
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        # Subtract the tile itself
        neighbors -= set(step.quadrants)
        # No neighbor should be pre-generated
        for n in neighbors:
          assert n not in generated, (
            f"2x2 at {step.quadrants} has pre-generated neighbor {n}"
          )

  def test_2x2_not_touching_other_scheduled(self) -> None:
    """2x2 tiles should not touch other scheduled tiles (at placement time)."""
    # This is verified by the algorithm itself - 2x2 tiles can only be placed
    # where no neighbor is scheduled. We verify by checking no 2x2 tiles share edges.
    bounds = RectBounds(Point(0, 0), Point(7, 7))
    plan = create_rectangle_plan(bounds)

    # Collect all 2x2 tile quadrants
    all_2x2_quadrants: set[Point] = set()
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          all_2x2_quadrants.add(q)

    # Check that no 2x2 tiles share edges (they should have gaps)
    # Actually, 2x2 tiles CAN share edges with OTHER 2x2 tiles if they were
    # placed later. The rule is only about pre-existing generated content.
    # Let's just verify the plan is valid.
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# 2x1/1x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x1RuleEnforcement:
  def test_2x1_extends_from_generated_edge(self) -> None:
    """2x1 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Pre-generated row above
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x2_extends_from_generated_edge(self) -> None:
    """1x2 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Pre-generated column to the left
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Plan Summary Tests
# =============================================================================


class TestPlanSummary:
  def test_summary_basic(self) -> None:
    """Test plan summary generation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    summary = get_plan_summary(plan)

    assert summary["bounds"]["width"] == 4
    assert summary["bounds"]["height"] == 4
    assert summary["total_quadrants"] == 16
    assert summary["total_steps"] > 0

  def test_summary_with_pre_generated(self) -> None:
    """Test summary with pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0), Point(0, 1)}
    plan = create_rectangle_plan(bounds, generated)
    summary = get_plan_summary(plan)

    assert summary["pre_generated_count"] == 2
    assert summary["total_quadrants"] == 14  # 16 - 2


# =============================================================================
# Edge Case Tests
# =============================================================================


class TestEdgeCases:
  def test_1x1_rectangle_with_context(self) -> None:
    """Smallest possible rectangle with 3-neighbor context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 needs 3 of 4 quadrants in a 2x2 block generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid

  def test_1x1_rectangle_without_context(self) -> None:
    """1x1 rectangle without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_1x10_strip_with_context(self) -> None:
    """Very thin horizontal strip with bottom edge context."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    # Add context row below the strip
    generated = {Point(x, 1) for x in range(10)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x10_strip_without_context(self) -> None:
    """Thin strip without context cannot be fully generated."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed (can't place 2x2 in 1-row strip)
    assert len(plan.steps) == 0

  def test_10x1_strip_with_context(self) -> None:
    """Very thin vertical strip with right edge context."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    # Add context column to the right
    generated = {Point(1, y) for y in range(10)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_10x1_strip_without_context(self) -> None:
    """Thin strip without context cannot be fully generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed (can't place 2x2 in 1-col strip)
    assert len(plan.steps) == 0

  def test_large_rectangle(self) -> None:
    """Large rectangle (20x20)."""
    bounds = RectBounds(Point(0, 0), Point(19, 19))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have many 2x2 tiles (greedy algorithm may not be optimal)
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 40  # Should have a reasonable number of 2x2 tiles

  def test_checkerboard_pre_generated(self) -> None:
    """Checkerboard pattern of pre-generated quadrants.

    In a checkerboard pattern, every 2x2 block has exactly 2 generated
    quadrants (diagonal corners). This means no point has 3-of-4 context
    in any 2x2 block, so 1x1 tiles cannot be placed.

    This is expected behavior - checkerboard patterns cannot be extended
    with valid context.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Checkerboard: every other quadrant
    generated = {Point(x, y) for y in range(6) for x in range(6) if (x + y) % 2 == 0}
    plan = create_rectangle_plan(bounds, generated)

    # No tiles can be placed because no point has 3-of-4 context
    # in any 2x2 block (checkerboard has only 2-of-4 diagonal)
    assert len(plan.steps) == 0

  def test_row_pattern_provides_context(self) -> None:
    """Row pattern provides valid context for generation.

    Unlike checkerboard, alternating rows allow valid context because
    each non-generated quadrant has 3 neighbors in some 2x2 block.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Alternating rows: y=0,2,4 are generated
    generated = {Point(x, y) for y in [0, 2, 4] for x in range(6)}
    # Add edge context
    generated |= {Point(x, -1) for x in range(6)}
    generated |= {Point(x, 6) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Get the non-generated quadrants within bounds (rows 1, 3, 5)
    to_generate = {p for p in bounds.all_points() if p not in generated}
    all_quadrants = [q for s in plan.steps for q in s.quadrants]

    # Should cover all non-generated quadrants
    assert set(all_quadrants) == to_generate

    # All tiles should be 2x1 or 1x1 (both valid with row context)
    for step in plan.steps:
      assert step.step_type in ("2x1", "1x1")

  def test_surrounded_by_generated(self) -> None:
    """Rectangle completely surrounded by generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    # Generate a border around the rectangle
    generated: set[Point] = set()
    for x in range(-1, 5):
      generated.add(Point(x, -1))  # Top
      generated.add(Point(x, 4))  # Bottom
    for y in range(0, 4):
      generated.add(Point(-1, y))  # Left
      generated.add(Point(4, y))  # Right

    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles CAN be placed in the interior (shielded by outer ring)
    # But edges should use smaller tiles
    # Check that all 2x2 tiles don't touch the generated border
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # 2x2 at edge positions would have generated neighbors
          # Interior 2x2 (at 1,1 or 1,2 etc.) is OK
          neighbors = [
            Point(q.x - 1, q.y),
            Point(q.x + 1, q.y),
            Point(q.x, q.y - 1),
            Point(q.x, q.y + 1),
          ]
          for n in neighbors:
            if n not in step.quadrants:  # Not part of the tile itself
              assert n not in generated, (
                f"2x2 at {step.quadrants} has neighbor {n} in generated"
              )


# =============================================================================
# Integration Tests - Complex Scenarios
# =============================================================================


class TestComplexScenarios:
  def test_partial_strip_extension(self) -> None:
    """Extending from a partially generated strip."""
    bounds = RectBounds(Point(0, 0), Point(7, 3))
    # Some quadrants above are generated
    generated = {Point(0, -1), Point(1, -1), Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_l_shaped_pre_generated(self) -> None:
    """L-shaped region of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # L-shape in top-left
    generated = {
      Point(-1, 0),
      Point(-1, 1),
      Point(-1, 2),
      Point(0, -1),
      Point(1, -1),
      Point(2, -1),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_island_of_generated(self) -> None:
    """Island of pre-generated quadrants in the middle."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # 2x2 island in the center
    generated = {Point(4, 4), Point(5, 4), Point(4, 5), Point(5, 5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Generated island should not be in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for g in generated:
      assert g not in all_quadrants

  def test_multiple_disjoint_pre_generated(self) -> None:
    """Multiple disjoint pre-generated regions."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # Two separate 2x2 regions
    generated = {
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
      Point(7, 7),
      Point(8, 7),
      Point(7, 8),
      Point(8, 8),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Serialization Tests
# =============================================================================


# =============================================================================
# Task 019 Strip Plan Pattern Tests
# =============================================================================


class TestStripPlanPattern:
  """
  Tests that verify the algorithm follows the 019 strip plan pattern:
  1. 2x2 tiles placed with gaps (every 3rd column)
  2. 1x2 bridges between 2x2 tiles
  3. 2x1 bridges connecting to generation edge
  4. 1x1 fills for remaining gaps
  """

  def test_depth_3_horizontal_pattern(self) -> None:
    """
    Test 6x3 rectangle with bottom edge generated.

    Expected pattern (following 019):
    Row 0-1: 2x2 at (0,0), (3,0) with 1x2 bridges at (2,0), (5,0)
    Row 2:   2x1 at (0,2), (3,2) with 1x1 at (2,2), (5,2)

    Visual:
    A A C B B D   <- row 0 (A=2x2, B=2x2, C=1x2, D=1x2)
    A A C B B D   <- row 1
    E E G F F H   <- row 2 (E=2x1, F=2x1, G=1x1, H=1x1)
    G G G G G G   <- generation edge (y=3, outside rectangle)
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generation edge at y=3 (below rectangle)
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 1x2, 2 2x1, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

    # Verify 2x2 positions
    two_by_two = [s for s in plan.steps if s.step_type == "2x2"]
    two_by_two_positions = [
      (min(q.x for q in s.quadrants), min(q.y for q in s.quadrants)) for s in two_by_two
    ]
    assert (0, 0) in two_by_two_positions
    assert (3, 0) in two_by_two_positions

    # Verify 1x2 positions (between 2x2 tiles)
    one_by_two = [s for s in plan.steps if s.step_type == "1x2"]
    one_by_two_positions = [s.quadrants[0] for s in one_by_two]
    assert Point(2, 0) in one_by_two_positions
    assert Point(5, 0) in one_by_two_positions

    # Verify 2x1 positions (connecting to edge)
    two_by_one = [s for s in plan.steps if s.step_type == "2x1"]
    two_by_one_positions = [
      (min(q.x for q in s.quadrants), s.quadrants[0].y) for s in two_by_one
    ]
    assert (0, 2) in two_by_one_positions
    assert (3, 2) in two_by_one_positions

  def test_depth_3_vertical_pattern(self) -> None:
    """
    Test 3x6 rectangle with left edge generated.

    Similar pattern but rotated 90 degrees.
    """
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Generation edge at x=-1 (left of rectangle)
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type - pattern should be similar
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 2x1, 2 1x2, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

  def test_1x2_bridges_between_2x2(self) -> None:
    """Test that 1x2 bridges correctly connect two 2x2 tiles."""
    # 5x3 rectangle (need 3 rows for 2x2 + bridge pattern)
    # With generation edge at y=3 (one row gap from 2x2 tiles)
    bounds = RectBounds(Point(0, 0), Point(4, 2))
    generated = {Point(x, 3) for x in range(5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Visual:
    # A A C B B   <- row 0 (A=2x2 at 0,0; B=2x2 at 3,0; C=1x2 at 2,0)
    # A A C B B   <- row 1
    # D D E F F   <- row 2 (D=2x1 at 0,2; E=1x1 at 2,2; F=2x1 at 3,2)
    # G G G G G   <- generation edge

    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # 2 2x2 tiles, 1 1x2 bridge, 2 2x1, 1 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 1, f"Expected 1 1x2 bridge, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 1, f"Expected 1 1x1 fill, got {types}"

  def test_order_matches_019_pattern(self) -> None:
    """
    Verify that generation order follows 019:
    1. 2x2 tiles first
    2. 1x2 bridges second
    3. 2x1 bridges third
    4. 1x1 fills last
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Check order
    current_phase = 0
    phase_order = {"2x2": 0, "1x2": 1, "2x1": 2, "1x1": 3}

    for step in plan.steps:
      phase = phase_order.get(step.step_type, 4)
      assert phase >= current_phase, (
        f"Step {step.step_type} appears after later phase. "
        f"Expected order: 2x2, 1x2, 2x1, 1x1"
      )
      current_phase = phase


class TestSerialization:
  def test_step_to_dict(self) -> None:
    """Test GenerationStep serialization."""
    step = GenerationStep(quadrants=[Point(0, 0), Point(1, 0)], step_type="2x1")
    d = step.to_dict()
    assert d["quadrants"] == [(0, 0), (1, 0)]
    assert d["type"] == "2x1"

  def test_plan_to_dict(self) -> None:
    """Test RectanglePlan serialization."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    d = plan.to_dict()

    assert d["bounds"]["top_left"] == (0, 0)
    assert d["bounds"]["bottom_right"] == (3, 3)
    assert len(d["steps"]) > 0


# =============================================================================
# Validation Tests
# =============================================================================


class TestValidation:
  def test_valid_plan(self) -> None:
    """Valid plan should pass validation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid
    assert len(errors) == 0

  def test_detect_duplicate_coverage(self) -> None:
    """Validation should detect duplicate coverage."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with duplicates
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0)]),
        GenerationStep(quadrants=[Point(0, 0), Point(0, 1)]),  # Duplicate!
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("multiple times" in e for e in errors)

  def test_detect_missing_quadrants(self) -> None:
    """Validation should detect missing quadrants."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with missing quadrant
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0), Point(0, 1)]),
        # Missing (1, 1)
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("Missing" in e for e in errors)


# =============================================================================
# Queued Quadrant Tests - Seam Detection with In-Progress/Queued Generations
# =============================================================================


class TestQueuedQuadrants:
  """
  Tests that verify the algorithm correctly considers in-progress and queued
  generations when determining if a seam will be formed.

  Queued quadrants are treated the same as generated quadrants for seam
  detection purposes - tiles cannot be placed adjacent to them.
  """

  def test_queued_quadrants_prevent_2x2_placement(self) -> None:
    """2x2 tiles cannot be placed adjacent to queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # No generated quadrants
    generated: set[Point] = set()
    # But there's a queued generation at (2, -1) - above the rectangle
    queued = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Find all 2x2 steps and verify none touch the queued quadrant
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        neighbors -= set(step.quadrants)
        for n in neighbors:
          assert n not in queued, f"2x2 at {step.quadrants} has queued neighbor {n}"

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_queued_quadrants_excluded_from_plan(self) -> None:
    """Queued quadrants within bounds should not be included in the plan.

    Queued quadrants act as context for other tiles but are not generated
    in this plan (they're already queued elsewhere).
    """
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queue a 2x2 block - this provides context for adjacent tiles
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Should not include queued points in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # The remaining quadrants should be covered
    remaining = set(bounds.all_points()) - queued
    covered = set(all_quadrants)

    # All covered should be from remaining
    assert covered.issubset(remaining), (
      f"Covered {covered} not subset of remaining {remaining}"
    )

  def test_queued_row_affects_2x1_placement(self) -> None:
    """2x1 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated: set[Point] = set()
    # Queued row below the rectangle acts like a generated edge
    queued = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 2x1 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at y=3, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"

  def test_queued_column_affects_1x2_placement(self) -> None:
    """1x2 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    generated: set[Point] = set()
    # Queued column to the left acts like a generated edge
    queued = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 1x2 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at x=-1, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"

  def test_mixed_generated_and_queued(self) -> None:
    """Plan should correctly handle both generated and queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Some quadrants are already generated
    generated = {Point(-1, 0), Point(-1, 1)}
    # Some quadrants are queued for generation
    queued = {Point(6, 0), Point(6, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles at left edge should not touch generated at (-1, 0) (-1, 1)
    # 2x2 tiles at right edge should not touch queued at (6, 0) (6, 1)
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # Check no neighbor is generated
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in generated, (
                f"2x2 at {step.quadrants} has generated neighbor {neighbor}"
              )
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_queued_quadrant_in_middle_prevents_2x2(self) -> None:
    """A queued quadrant in the middle should prevent 2x2 placement there."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queued 2x2 block in the center
    queued = {Point(1, 1), Point(2, 1), Point(1, 2), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # No step should include any queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # 2x2 tiles should not be placed adjacent to the queued block
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_from_coords_with_queued(self) -> None:
    """Test convenience function with queued set."""
    generated = {(0, 0), (1, 0)}
    queued = {(2, 0), (3, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (5, 3), generated, queued)

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    # Neither generated nor queued should be in plan
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants
    assert Point(2, 0) not in all_quadrants
    assert Point(3, 0) not in all_quadrants

  def test_fully_queued_rectangle(self) -> None:
    """Rectangle where all quadrants are queued should produce empty plan."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated: set[Point] = set()
    queued = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated, queued)

    assert len(plan.steps) == 0

  def test_queued_prevents_seam_with_future_generation(self) -> None:
    """
    Queued quadrants should be treated as if they will be generated,
    preventing seams with future generations.

    Scenario: User is generating a 2x2 at (0,0)-(1,1) and there's already
    a queued 2x2 at (2,0)-(3,1). The plan should not place tiles that
    would create a seam between them.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 3))
    generated: set[Point] = set()
    # First 2x2 is queued
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # The plan should not include the queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants

    # Verify the plan covers exactly the non-queued quadrants
    expected = set(bounds.all_points()) - queued
    covered = set(all_quadrants)
    assert covered == expected, f"Expected {expected}, got {covered}"

    # 2x2 tiles should not be placed at (2,0) because it would touch
    # the queued 2x2 at x=1
    for step in plan.steps:
      if step.step_type == "2x2":
        step_tl = min(q.x for q in step.quadrants), min(q.y for q in step.quadrants)
        # If there's a 2x2 at (2, 0), it would have neighbors at (1, 0) and (1, 1)
        # which are queued
        if step_tl == (2, 0):
          assert False, "2x2 at (2,0) would create seam with queued (0,0)-(1,1)"

```

```python
"""
Tests for make_rectangle_plan.py

These tests verify the rectangle generation planning algorithm handles
all cases correctly, including:
- Basic coverage of all quadrants
- 2x2 tile placement rules (no touching generated neighbors)
- 2x1/1x2 tile placement rules (extend from generated edges)
- 1x1 filling of remaining gaps
- Pre-existing generated quadrants
- Various rectangle sizes and configurations
"""

from isometric_nyc.e2e_generation.make_rectangle_plan import (
  GenerationStep,
  Point,
  RectanglePlan,
  RectBounds,
  can_place_1x1,
  can_place_1x2_vertical,
  can_place_2x1_horizontal,
  can_place_2x2,
  create_rectangle_plan,
  create_rectangle_plan_from_coords,
  get_2x2_neighbors,
  get_2x2_quadrants,
  get_plan_summary,
  has_valid_2x2_context,
  validate_plan,
  validate_plan_context,
)

# =============================================================================
# Point Tests
# =============================================================================


class TestPoint:
  def test_str(self) -> None:
    p = Point(3, 5)
    assert str(p) == "(3,5)"

  def test_add(self) -> None:
    p1 = Point(1, 2)
    p2 = Point(3, 4)
    result = p1 + p2
    assert result == Point(4, 6)

  def test_from_string_simple(self) -> None:
    p = Point.from_string("3,5")
    assert p == Point(3, 5)

  def test_from_string_with_parens(self) -> None:
    p = Point.from_string("(3,5)")
    assert p == Point(3, 5)

  def test_from_string_negative(self) -> None:
    p = Point.from_string("-3,-5")
    assert p == Point(-3, -5)

  def test_to_tuple(self) -> None:
    p = Point(3, 5)
    assert p.to_tuple() == (3, 5)


# =============================================================================
# RectBounds Tests
# =============================================================================


class TestRectBounds:
  def test_width_height(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(10, 5))
    assert bounds.width == 11
    assert bounds.height == 6

  def test_area(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(3, 2))
    assert bounds.area == 12  # 4 x 3

  def test_contains(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert bounds.contains(Point(0, 0))
    assert bounds.contains(Point(5, 5))
    assert bounds.contains(Point(3, 3))
    assert not bounds.contains(Point(-1, 0))
    assert not bounds.contains(Point(6, 0))
    assert not bounds.contains(Point(0, -1))
    assert not bounds.contains(Point(0, 6))

  def test_all_points(self) -> None:
    bounds = RectBounds(Point(0, 0), Point(2, 1))
    points = bounds.all_points()
    expected = [
      Point(0, 0),
      Point(1, 0),
      Point(2, 0),
      Point(0, 1),
      Point(1, 1),
      Point(2, 1),
    ]
    assert points == expected


# =============================================================================
# 2x2 Tile Helper Tests
# =============================================================================


class TestGet2x2Quadrants:
  def test_basic(self) -> None:
    quadrants = get_2x2_quadrants(Point(0, 0))
    assert quadrants == [
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
    ]

  def test_offset(self) -> None:
    quadrants = get_2x2_quadrants(Point(5, 3))
    assert quadrants == [
      Point(5, 3),
      Point(6, 3),
      Point(5, 4),
      Point(6, 4),
    ]


class TestGet2x2Neighbors:
  def test_basic(self) -> None:
    neighbors = get_2x2_neighbors(Point(0, 0))
    # Top, Bottom, Left, Right
    expected = [
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 2),
      Point(1, 2),  # Bottom
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(2, 0),
      Point(2, 1),  # Right
    ]
    assert set(neighbors) == set(expected)
    assert len(neighbors) == 8


# =============================================================================
# 2x2 Placement Tests
# =============================================================================


class TestCanPlace2x2:
  def test_empty_grid(self) -> None:
    """2x2 can be placed in empty rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    assert can_place_2x2(Point(0, 0), bounds, set(), set())

  def test_out_of_bounds(self) -> None:
    """2x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Top-left at (5, 5) would extend to (6, 6)
    assert not can_place_2x2(Point(5, 5), bounds, set(), set())
    # Top-left at (5, 0) would extend to (6, 1)
    assert not can_place_2x2(Point(5, 0), bounds, set(), set())

  def test_neighbor_generated_top(self) -> None:
    """2x2 cannot be placed if top neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Top neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_bottom(self) -> None:
    """2x2 cannot be placed if bottom neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2)}  # Bottom neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_left(self) -> None:
    """2x2 cannot be placed if left neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0)}  # Left neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_neighbor_generated_right(self) -> None:
    """2x2 cannot be placed if right neighbors are generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0)}  # Right neighbor
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_generated(self) -> None:
    """2x2 cannot be placed if any quadrant is already generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 0)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, generated, set())

  def test_quadrant_already_scheduled(self) -> None:
    """2x2 cannot be placed if any quadrant is already scheduled."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    scheduled = {Point(1, 1)}  # One of the quadrants
    assert not can_place_2x2(Point(0, 0), bounds, set(), scheduled)

  def test_valid_with_distant_generated(self) -> None:
    """2x2 can be placed if generated quadrants are not neighbors."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(3, 3)}  # Far from (0,0) 2x2
    assert can_place_2x2(Point(0, 0), bounds, generated, set())


# =============================================================================
# 2x1 Horizontal Placement Tests
# =============================================================================


class TestCanPlace2x1Horizontal:
  def test_valid_with_top_generated(self) -> None:
    """2x1 can be placed when top row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(1, -1)}  # Top neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_with_bottom_generated(self) -> None:
    """2x1 can be placed when bottom row is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 1), Point(1, 1)}  # Bottom neighbors
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_left_generated(self) -> None:
    """2x1 cannot be placed when left neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_right_generated(self) -> None:
    """2x1 cannot be placed when right neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(2, 0), Point(0, -1), Point(1, -1)}
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """2x1 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """2x1 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(0, -1),
      Point(1, -1),  # Top
      Point(0, 1),
      Point(1, 1),  # Bottom
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_invalid_when_only_partial_long_side(self) -> None:
    """2x1 cannot be placed when only one of two top neighbors is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1)}  # Only one top neighbor
    assert not can_place_2x1_horizontal(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """2x1 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(5, -1), Point(6, -1)}
    # Left at x=5 would extend to x=6
    assert not can_place_2x1_horizontal(Point(5, 0), bounds, generated, set())


# =============================================================================
# 1x2 Vertical Placement Tests
# =============================================================================


class TestCanPlace1x2Vertical:
  def test_valid_with_left_generated(self) -> None:
    """1x2 can be placed when left column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 0), Point(-1, 1)}  # Left neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_with_right_generated(self) -> None:
    """1x2 can be placed when right column is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(1, 0), Point(1, 1)}  # Right neighbors
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_top_generated(self) -> None:
    """1x2 cannot be placed when top neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, -1), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_bottom_generated(self) -> None:
    """1x2 cannot be placed when bottom neighbor is generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(0, 2), Point(-1, 0), Point(-1, 1)}
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_invalid_when_neither_long_side_generated(self) -> None:
    """1x2 cannot be placed when neither long side is fully generated."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated: set[Point] = set()
    assert not can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_valid_when_both_long_sides_generated(self) -> None:
    """1x2 CAN be placed when both long sides are generated (bridges between 2x2s)."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {
      Point(-1, 0),
      Point(-1, 1),  # Left
      Point(1, 0),
      Point(1, 1),  # Right
    }
    # This is now valid - bridges between two 2x2 tiles have both sides generated
    assert can_place_1x2_vertical(Point(0, 0), bounds, generated, set())

  def test_out_of_bounds(self) -> None:
    """1x2 cannot extend beyond rectangle."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    generated = {Point(-1, 5), Point(-1, 6)}
    # Top at y=5 would extend to y=6
    assert not can_place_1x2_vertical(Point(0, 5), bounds, generated, set())


# =============================================================================
# Full Rectangle Plan Tests
# =============================================================================


class TestCreateRectanglePlan:
  def test_empty_rectangle_no_generated(self) -> None:
    """Empty rectangle with no pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_with_context(self) -> None:
    """Single quadrant rectangle requires 3 neighbors for context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 requires 3 of 4 quadrants in a 2x2 block to be generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_single_quadrant_without_context(self) -> None:
    """Single quadrant without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_2x2_rectangle(self) -> None:
    """2x2 rectangle should be a single 2x2 tile."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    plan = create_rectangle_plan(bounds)

    # Should have exactly one 2x2 step
    assert len(plan.steps) == 1
    assert len(plan.steps[0].quadrants) == 4
    assert plan.steps[0].step_type == "2x2"
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_3x3_rectangle(self) -> None:
    """3x3 rectangle - mix of tiles."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_4x4_rectangle(self) -> None:
    """4x4 rectangle - should fit multiple 2x2 tiles."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have multiple 2x2 tiles
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 1

  def test_wide_rectangle(self) -> None:
    """Wide rectangle (10x2)."""
    bounds = RectBounds(Point(0, 0), Point(9, 1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_tall_rectangle(self) -> None:
    """Tall rectangle (2x10)."""
    bounds = RectBounds(Point(0, 0), Point(1, 9))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_corner(self) -> None:
    """Rectangle with one corner already generated."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should not include (0,0) in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants

  def test_with_pre_generated_edge(self) -> None:
    """Rectangle with one edge already generated (outside the bounds)."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generated row above the rectangle
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_with_pre_generated_interior(self) -> None:
    """Rectangle with some interior quadrants already generated."""
    bounds = RectBounds(Point(0, 0), Point(4, 4))
    # Some interior points generated - form a vertical 1x2 block
    # This provides context for adjacent tiles
    generated = {Point(2, 2), Point(2, 3)}
    plan = create_rectangle_plan(bounds, generated)

    # Should not include generated points
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(2, 2) not in all_quadrants
    assert Point(2, 3) not in all_quadrants

    # The plan should cover the remaining quadrants
    # Note: Some gaps may remain if there's no valid context
    covered = set(all_quadrants)
    expected_to_cover = set(bounds.all_points()) - generated

    # Verify no extra quadrants are covered
    extra = covered - expected_to_cover
    assert not extra, f"Extra quadrants covered: {extra}"

  def test_fully_generated(self) -> None:
    """Rectangle where all quadrants are already generated."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 0
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_negative_coordinates(self) -> None:
    """Rectangle in negative coordinate space."""
    bounds = RectBounds(Point(-5, -3), Point(-2, -1))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_convenience(self) -> None:
    """Test the convenience function with tuples."""
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3))

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_from_coords_with_generated(self) -> None:
    """Test convenience function with pre-generated set."""
    generated = {(0, 0), (1, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (3, 3), generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants


# =============================================================================
# 2x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x2RuleEnforcement:
  def test_2x2_not_touching_pre_generated(self) -> None:
    """2x2 tiles should not touch pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Pre-generated quadrant at (2, -1) - above the rectangle
    generated = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    # Find all 2x2 steps
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        # Subtract the tile itself
        neighbors -= set(step.quadrants)
        # No neighbor should be pre-generated
        for n in neighbors:
          assert n not in generated, (
            f"2x2 at {step.quadrants} has pre-generated neighbor {n}"
          )

  def test_2x2_not_touching_other_scheduled(self) -> None:
    """2x2 tiles should not touch other scheduled tiles (at placement time)."""
    # This is verified by the algorithm itself - 2x2 tiles can only be placed
    # where no neighbor is scheduled. We verify by checking no 2x2 tiles share edges.
    bounds = RectBounds(Point(0, 0), Point(7, 7))
    plan = create_rectangle_plan(bounds)

    # Collect all 2x2 tile quadrants
    all_2x2_quadrants: set[Point] = set()
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          all_2x2_quadrants.add(q)

    # Check that no 2x2 tiles share edges (they should have gaps)
    # Actually, 2x2 tiles CAN share edges with OTHER 2x2 tiles if they were
    # placed later. The rule is only about pre-existing generated content.
    # Let's just verify the plan is valid.
    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# 2x1/1x2 Tile Rule Enforcement Tests
# =============================================================================


class Test2x1RuleEnforcement:
  def test_2x1_extends_from_generated_edge(self) -> None:
    """2x1 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Pre-generated row above
    generated = {Point(x, -1) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x2_extends_from_generated_edge(self) -> None:
    """1x2 tiles should extend from a fully generated edge."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Pre-generated column to the left
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Plan Summary Tests
# =============================================================================


class TestPlanSummary:
  def test_summary_basic(self) -> None:
    """Test plan summary generation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    summary = get_plan_summary(plan)

    assert summary["bounds"]["width"] == 4
    assert summary["bounds"]["height"] == 4
    assert summary["total_quadrants"] == 16
    assert summary["total_steps"] > 0

  def test_summary_with_pre_generated(self) -> None:
    """Test summary with pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated = {Point(0, 0), Point(0, 1)}
    plan = create_rectangle_plan(bounds, generated)
    summary = get_plan_summary(plan)

    assert summary["pre_generated_count"] == 2
    assert summary["total_quadrants"] == 14  # 16 - 2


# =============================================================================
# Edge Case Tests
# =============================================================================


class TestEdgeCases:
  def test_1x1_rectangle_with_context(self) -> None:
    """Smallest possible rectangle with 3-neighbor context."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # 1x1 needs 3 of 4 quadrants in a 2x2 block generated
    generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated)

    assert len(plan.steps) == 1
    assert plan.steps[0].step_type == "1x1"
    is_valid, errors = validate_plan(plan)
    assert is_valid

  def test_1x1_rectangle_without_context(self) -> None:
    """1x1 rectangle without context cannot be generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed
    assert len(plan.steps) == 0

  def test_1x10_strip_with_context(self) -> None:
    """Very thin horizontal strip with bottom edge context."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    # Add context row below the strip
    generated = {Point(x, 1) for x in range(10)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_1x10_strip_without_context(self) -> None:
    """Thin strip without context cannot be fully generated."""
    bounds = RectBounds(Point(0, 0), Point(9, 0))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed (can't place 2x2 in 1-row strip)
    assert len(plan.steps) == 0

  def test_10x1_strip_with_context(self) -> None:
    """Very thin vertical strip with right edge context."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    # Add context column to the right
    generated = {Point(1, y) for y in range(10)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_10x1_strip_without_context(self) -> None:
    """Thin strip without context cannot be fully generated."""
    bounds = RectBounds(Point(0, 0), Point(0, 9))
    plan = create_rectangle_plan(bounds)

    # Without context, no tiles can be placed (can't place 2x2 in 1-col strip)
    assert len(plan.steps) == 0

  def test_large_rectangle(self) -> None:
    """Large rectangle (20x20)."""
    bounds = RectBounds(Point(0, 0), Point(19, 19))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have many 2x2 tiles (greedy algorithm may not be optimal)
    count_2x2 = sum(1 for s in plan.steps if s.step_type == "2x2")
    assert count_2x2 >= 40  # Should have a reasonable number of 2x2 tiles

  def test_checkerboard_pre_generated(self) -> None:
    """Checkerboard pattern of pre-generated quadrants.

    In a checkerboard pattern, every 2x2 block has exactly 2 generated
    quadrants (diagonal corners). This means no point has 3-of-4 context
    in any 2x2 block, so 1x1 tiles cannot be placed.

    This is expected behavior - checkerboard patterns cannot be extended
    with valid context.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Checkerboard: every other quadrant
    generated = {Point(x, y) for y in range(6) for x in range(6) if (x + y) % 2 == 0}
    plan = create_rectangle_plan(bounds, generated)

    # No tiles can be placed because no point has 3-of-4 context
    # in any 2x2 block (checkerboard has only 2-of-4 diagonal)
    assert len(plan.steps) == 0

  def test_row_pattern_provides_context(self) -> None:
    """Row pattern provides valid context for generation.

    Unlike checkerboard, alternating rows allow valid context because
    each non-generated quadrant has 3 neighbors in some 2x2 block.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Alternating rows: y=0,2,4 are generated
    generated = {Point(x, y) for y in [0, 2, 4] for x in range(6)}
    # Add edge context
    generated |= {Point(x, -1) for x in range(6)}
    generated |= {Point(x, 6) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Get the non-generated quadrants within bounds (rows 1, 3, 5)
    to_generate = {p for p in bounds.all_points() if p not in generated}
    all_quadrants = [q for s in plan.steps for q in s.quadrants]

    # Should cover all non-generated quadrants
    assert set(all_quadrants) == to_generate

    # All tiles should be 2x1 or 1x1 (both valid with row context)
    for step in plan.steps:
      assert step.step_type in ("2x1", "1x1")

  def test_surrounded_by_generated(self) -> None:
    """Rectangle completely surrounded by generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    # Generate a border around the rectangle
    generated: set[Point] = set()
    for x in range(-1, 5):
      generated.add(Point(x, -1))  # Top
      generated.add(Point(x, 4))  # Bottom
    for y in range(0, 4):
      generated.add(Point(-1, y))  # Left
      generated.add(Point(4, y))  # Right

    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles CAN be placed in the interior (shielded by outer ring)
    # But edges should use smaller tiles
    # Check that all 2x2 tiles don't touch the generated border
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # 2x2 at edge positions would have generated neighbors
          # Interior 2x2 (at 1,1 or 1,2 etc.) is OK
          neighbors = [
            Point(q.x - 1, q.y),
            Point(q.x + 1, q.y),
            Point(q.x, q.y - 1),
            Point(q.x, q.y + 1),
          ]
          for n in neighbors:
            if n not in step.quadrants:  # Not part of the tile itself
              assert n not in generated, (
                f"2x2 at {step.quadrants} has neighbor {n} in generated"
              )


# =============================================================================
# Integration Tests - Complex Scenarios
# =============================================================================


class TestComplexScenarios:
  def test_partial_strip_extension(self) -> None:
    """Extending from a partially generated strip."""
    bounds = RectBounds(Point(0, 0), Point(7, 3))
    # Some quadrants above are generated
    generated = {Point(0, -1), Point(1, -1), Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_l_shaped_pre_generated(self) -> None:
    """L-shaped region of pre-generated quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # L-shape in top-left
    generated = {
      Point(-1, 0),
      Point(-1, 1),
      Point(-1, 2),
      Point(0, -1),
      Point(1, -1),
      Point(2, -1),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_island_of_generated(self) -> None:
    """Island of pre-generated quadrants in the middle."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # 2x2 island in the center
    generated = {Point(4, 4), Point(5, 4), Point(4, 5), Point(5, 5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Generated island should not be in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for g in generated:
      assert g not in all_quadrants

  def test_multiple_disjoint_pre_generated(self) -> None:
    """Multiple disjoint pre-generated regions."""
    bounds = RectBounds(Point(0, 0), Point(9, 9))
    # Two separate 2x2 regions
    generated = {
      Point(0, 0),
      Point(1, 0),
      Point(0, 1),
      Point(1, 1),
      Point(7, 7),
      Point(8, 7),
      Point(7, 8),
      Point(8, 8),
    }
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"


# =============================================================================
# Serialization Tests
# =============================================================================


# =============================================================================
# Task 019 Strip Plan Pattern Tests
# =============================================================================


class TestStripPlanPattern:
  """
  Tests that verify the algorithm follows the 019 strip plan pattern:
  1. 2x2 tiles placed with gaps (every 3rd column)
  2. 1x2 bridges between 2x2 tiles
  3. 2x1 bridges connecting to generation edge
  4. 1x1 fills for remaining gaps
  """

  def test_depth_3_horizontal_pattern(self) -> None:
    """
    Test 6x3 rectangle with bottom edge generated.

    Expected pattern (following 019):
    Row 0-1: 2x2 at (0,0), (3,0) with 1x2 bridges at (2,0), (5,0)
    Row 2:   2x1 at (0,2), (3,2) with 1x1 at (2,2), (5,2)

    Visual:
    A A C B B D   <- row 0 (A=2x2, B=2x2, C=1x2, D=1x2)
    A A C B B D   <- row 1
    E E G F F H   <- row 2 (E=2x1, F=2x1, G=1x1, H=1x1)
    G G G G G G   <- generation edge (y=3, outside rectangle)
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    # Generation edge at y=3 (below rectangle)
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 1x2, 2 2x1, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

    # Verify 2x2 positions
    two_by_two = [s for s in plan.steps if s.step_type == "2x2"]
    two_by_two_positions = [
      (min(q.x for q in s.quadrants), min(q.y for q in s.quadrants)) for s in two_by_two
    ]
    assert (0, 0) in two_by_two_positions
    assert (3, 0) in two_by_two_positions

    # Verify 1x2 positions (between 2x2 tiles)
    one_by_two = [s for s in plan.steps if s.step_type == "1x2"]
    one_by_two_positions = [s.quadrants[0] for s in one_by_two]
    assert Point(2, 0) in one_by_two_positions
    assert Point(5, 0) in one_by_two_positions

    # Verify 2x1 positions (connecting to edge)
    two_by_one = [s for s in plan.steps if s.step_type == "2x1"]
    two_by_one_positions = [
      (min(q.x for q in s.quadrants), s.quadrants[0].y) for s in two_by_one
    ]
    assert (0, 2) in two_by_one_positions
    assert (3, 2) in two_by_one_positions

  def test_depth_3_vertical_pattern(self) -> None:
    """
    Test 3x6 rectangle with left edge generated.

    Similar pattern but rotated 90 degrees.
    """
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    # Generation edge at x=-1 (left of rectangle)
    generated = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Count by type - pattern should be similar
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # Should have: 2 2x2, 2 2x1, 2 1x2, 2 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"
    assert types.get("1x1", 0) == 2, f"Expected 2 1x1 tiles, got {types}"

  def test_1x2_bridges_between_2x2(self) -> None:
    """Test that 1x2 bridges correctly connect two 2x2 tiles."""
    # 5x3 rectangle (need 3 rows for 2x2 + bridge pattern)
    # With generation edge at y=3 (one row gap from 2x2 tiles)
    bounds = RectBounds(Point(0, 0), Point(4, 2))
    generated = {Point(x, 3) for x in range(5)}
    plan = create_rectangle_plan(bounds, generated)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Visual:
    # A A C B B   <- row 0 (A=2x2 at 0,0; B=2x2 at 3,0; C=1x2 at 2,0)
    # A A C B B   <- row 1
    # D D E F F   <- row 2 (D=2x1 at 0,2; E=1x1 at 2,2; F=2x1 at 3,2)
    # G G G G G   <- generation edge

    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # 2 2x2 tiles, 1 1x2 bridge, 2 2x1, 1 1x1
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 1, f"Expected 1 1x2 bridge, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"
    assert types.get("1x1", 0) == 1, f"Expected 1 1x1 fill, got {types}"

  def test_order_matches_019_pattern(self) -> None:
    """
    Verify that generation order follows 019:
    1. 2x2 tiles first
    2. 1x2 bridges second
    3. 2x1 bridges third
    4. 1x1 fills last
    """
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated)

    # Check order
    current_phase = 0
    phase_order = {"2x2": 0, "1x2": 1, "2x1": 2, "1x1": 3}

    for step in plan.steps:
      phase = phase_order.get(step.step_type, 4)
      assert phase >= current_phase, (
        f"Step {step.step_type} appears after later phase. "
        f"Expected order: 2x2, 1x2, 2x1, 1x1"
      )
      current_phase = phase


class TestSerialization:
  def test_step_to_dict(self) -> None:
    """Test GenerationStep serialization."""
    step = GenerationStep(quadrants=[Point(0, 0), Point(1, 0)], step_type="2x1")
    d = step.to_dict()
    assert d["quadrants"] == [(0, 0), (1, 0)]
    assert d["type"] == "2x1"

  def test_plan_to_dict(self) -> None:
    """Test RectanglePlan serialization."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)
    d = plan.to_dict()

    assert d["bounds"]["top_left"] == (0, 0)
    assert d["bounds"]["bottom_right"] == (3, 3)
    assert len(d["steps"]) > 0


# =============================================================================
# Validation Tests
# =============================================================================


class TestValidation:
  def test_valid_plan(self) -> None:
    """Valid plan should pass validation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan(plan)
    assert is_valid
    assert len(errors) == 0

  def test_detect_duplicate_coverage(self) -> None:
    """Validation should detect duplicate coverage."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with duplicates
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0)]),
        GenerationStep(quadrants=[Point(0, 0), Point(0, 1)]),  # Duplicate!
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("multiple times" in e for e in errors)

  def test_detect_missing_quadrants(self) -> None:
    """Validation should detect missing quadrants."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create invalid plan with missing quadrant
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0), Point(1, 0), Point(0, 1)]),
        # Missing (1, 1)
      ],
    )

    is_valid, errors = validate_plan(plan)
    assert not is_valid
    assert any("Missing" in e for e in errors)


# =============================================================================
# Context Validation Tests
# =============================================================================


class TestContextValidation:
  """Tests for 2x2 context requirement validation."""

  def test_has_valid_2x2_context_single_quadrant_with_3_neighbors(self) -> None:
    """Single quadrant with 3 neighbors has valid context."""
    quadrants = [Point(0, 0)]
    combined = {Point(1, 0), Point(0, 1), Point(1, 1)}
    assert has_valid_2x2_context(quadrants, combined)

  def test_has_valid_2x2_context_single_quadrant_with_2_neighbors(self) -> None:
    """Single quadrant with only 2 neighbors lacks valid context."""
    quadrants = [Point(0, 0)]
    combined = {Point(1, 0), Point(0, 1)}  # Only 2 neighbors
    assert not has_valid_2x2_context(quadrants, combined)

  def test_has_valid_2x2_context_2x2_is_self_contained(self) -> None:
    """2x2 tile is always self-contained (has valid context)."""
    quadrants = [Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)]
    combined: set[Point] = set()  # No external context
    assert has_valid_2x2_context(quadrants, combined)

  def test_has_valid_2x2_context_2x1_with_top_neighbors(self) -> None:
    """2x1 with both top neighbors has valid context."""
    quadrants = [Point(0, 1), Point(1, 1)]  # Bottom row of 2x2
    combined = {Point(0, 0), Point(1, 0)}  # Top row
    assert has_valid_2x2_context(quadrants, combined)

  def test_has_valid_2x2_context_2x1_with_only_one_neighbor(self) -> None:
    """2x1 with only one neighbor lacks valid context."""
    quadrants = [Point(0, 1), Point(1, 1)]
    combined = {Point(0, 0)}  # Only one top neighbor
    assert not has_valid_2x2_context(quadrants, combined)

  def test_can_place_1x1_with_3_neighbors(self) -> None:
    """1x1 can be placed when 3 of 4 quadrants in a 2x2 block are generated."""
    combined = {Point(1, 0), Point(0, 1), Point(1, 1)}
    assert can_place_1x1(Point(0, 0), combined)

  def test_can_place_1x1_with_2_neighbors(self) -> None:
    """1x1 cannot be placed with only 2 neighbors."""
    combined = {Point(1, 0), Point(0, 1)}  # Only 2 neighbors
    assert not can_place_1x1(Point(0, 0), combined)

  def test_validate_plan_context_valid_plan(self) -> None:
    """Plan with valid context passes validation."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    plan = create_rectangle_plan(bounds)

    is_valid, errors = validate_plan_context(plan)
    assert is_valid, f"Context validation failed: {errors}"

  def test_validate_plan_context_invalid_plan(self) -> None:
    """Plan with invalid context fails validation."""
    bounds = RectBounds(Point(0, 0), Point(1, 1))
    # Manually create a plan with a 1x1 that lacks context
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0)], step_type="1x1"),
      ],
      pre_generated=set(),
    )

    is_valid, errors = validate_plan_context(plan)
    assert not is_valid
    assert any("lacks valid 2x2 context" in e for e in errors)

  def test_validate_plan_context_with_pre_generated(self) -> None:
    """Plan with pre-generated context passes validation."""
    bounds = RectBounds(Point(0, 0), Point(0, 0))
    # Pre-generated provides 3-of-4 context
    pre_generated = {Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = RectanglePlan(
      bounds=bounds,
      steps=[
        GenerationStep(quadrants=[Point(0, 0)], step_type="1x1"),
      ],
      pre_generated=pre_generated,
    )

    is_valid, errors = validate_plan_context(plan)
    assert is_valid, f"Context validation failed: {errors}"


# =============================================================================
# Queued Quadrant Tests - Seam Detection with In-Progress/Queued Generations
# =============================================================================


class TestQueuedQuadrants:
  """
  Tests that verify the algorithm correctly considers in-progress and queued
  generations when determining if a seam will be formed.

  Queued quadrants are treated the same as generated quadrants for seam
  detection purposes - tiles cannot be placed adjacent to them.
  """

  def test_queued_quadrants_prevent_2x2_placement(self) -> None:
    """2x2 tiles cannot be placed adjacent to queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # No generated quadrants
    generated: set[Point] = set()
    # But there's a queued generation at (2, -1) - above the rectangle
    queued = {Point(2, -1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Find all 2x2 steps and verify none touch the queued quadrant
    for step in plan.steps:
      if step.step_type == "2x2":
        neighbors = set()
        for q in step.quadrants:
          neighbors.add(Point(q.x - 1, q.y))
          neighbors.add(Point(q.x + 1, q.y))
          neighbors.add(Point(q.x, q.y - 1))
          neighbors.add(Point(q.x, q.y + 1))
        neighbors -= set(step.quadrants)
        for n in neighbors:
          assert n not in queued, f"2x2 at {step.quadrants} has queued neighbor {n}"

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

  def test_queued_quadrants_excluded_from_plan(self) -> None:
    """Queued quadrants within bounds should not be included in the plan.

    Queued quadrants act as context for other tiles but are not generated
    in this plan (they're already queued elsewhere).
    """
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queue a 2x2 block - this provides context for adjacent tiles
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # Should not include queued points in any step
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # The remaining quadrants should be covered
    remaining = set(bounds.all_points()) - queued
    covered = set(all_quadrants)

    # All covered should be from remaining
    assert covered.issubset(remaining), (
      f"Covered {covered} not subset of remaining {remaining}"
    )

  def test_queued_row_affects_2x1_placement(self) -> None:
    """2x1 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(5, 2))
    generated: set[Point] = set()
    # Queued row below the rectangle acts like a generated edge
    queued = {Point(x, 3) for x in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 2x1 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at y=3, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("2x1", 0) == 2, f"Expected 2 2x1 tiles, got {types}"

  def test_queued_column_affects_1x2_placement(self) -> None:
    """1x2 tiles should consider queued quadrants as generated for edge detection."""
    bounds = RectBounds(Point(0, 0), Point(2, 5))
    generated: set[Point] = set()
    # Queued column to the left acts like a generated edge
    queued = {Point(-1, y) for y in range(6)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # Should have 1x2 tiles connecting to the queued edge
    types = {}
    for step in plan.steps:
      t = step.step_type
      types[t] = types.get(t, 0) + 1

    # With edge at x=-1, we should get 2x2 + bridge pattern
    assert types.get("2x2", 0) == 2, f"Expected 2 2x2 tiles, got {types}"
    assert types.get("1x2", 0) == 2, f"Expected 2 1x2 tiles, got {types}"

  def test_mixed_generated_and_queued(self) -> None:
    """Plan should correctly handle both generated and queued quadrants."""
    bounds = RectBounds(Point(0, 0), Point(5, 5))
    # Some quadrants are already generated
    generated = {Point(-1, 0), Point(-1, 1)}
    # Some quadrants are queued for generation
    queued = {Point(6, 0), Point(6, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    is_valid, errors = validate_plan(plan)
    assert is_valid, f"Plan invalid: {errors}"

    # 2x2 tiles at left edge should not touch generated at (-1, 0) (-1, 1)
    # 2x2 tiles at right edge should not touch queued at (6, 0) (6, 1)
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          # Check no neighbor is generated
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in generated, (
                f"2x2 at {step.quadrants} has generated neighbor {neighbor}"
              )
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_queued_quadrant_in_middle_prevents_2x2(self) -> None:
    """A queued quadrant in the middle should prevent 2x2 placement there."""
    bounds = RectBounds(Point(0, 0), Point(3, 3))
    generated: set[Point] = set()
    # Queued 2x2 block in the center
    queued = {Point(1, 1), Point(2, 1), Point(1, 2), Point(2, 2)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # No step should include any queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants, f"Queued quadrant {q} should not be in plan"

    # 2x2 tiles should not be placed adjacent to the queued block
    for step in plan.steps:
      if step.step_type == "2x2":
        for q in step.quadrants:
          for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            neighbor = Point(q.x + dx, q.y + dy)
            if neighbor not in step.quadrants:
              assert neighbor not in queued, (
                f"2x2 at {step.quadrants} has queued neighbor {neighbor}"
              )

  def test_from_coords_with_queued(self) -> None:
    """Test convenience function with queued set."""
    generated = {(0, 0), (1, 0)}
    queued = {(2, 0), (3, 0)}
    plan = create_rectangle_plan_from_coords((0, 0), (5, 3), generated, queued)

    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    # Neither generated nor queued should be in plan
    assert Point(0, 0) not in all_quadrants
    assert Point(1, 0) not in all_quadrants
    assert Point(2, 0) not in all_quadrants
    assert Point(3, 0) not in all_quadrants

  def test_fully_queued_rectangle(self) -> None:
    """Rectangle where all quadrants are queued should produce empty plan."""
    bounds = RectBounds(Point(0, 0), Point(2, 2))
    generated: set[Point] = set()
    queued = set(bounds.all_points())
    plan = create_rectangle_plan(bounds, generated, queued)

    assert len(plan.steps) == 0

  def test_queued_prevents_seam_with_future_generation(self) -> None:
    """
    Queued quadrants should be treated as if they will be generated,
    preventing seams with future generations.

    Scenario: User is generating a 2x2 at (0,0)-(1,1) and there's already
    a queued 2x2 at (2,0)-(3,1). The plan should not place tiles that
    would create a seam between them.
    """
    bounds = RectBounds(Point(0, 0), Point(5, 3))
    generated: set[Point] = set()
    # First 2x2 is queued
    queued = {Point(0, 0), Point(1, 0), Point(0, 1), Point(1, 1)}
    plan = create_rectangle_plan(bounds, generated, queued)

    # The plan should not include the queued quadrants
    all_quadrants = [q for s in plan.steps for q in s.quadrants]
    for q in queued:
      assert q not in all_quadrants

    # Verify the plan covers exactly the non-queued quadrants
    expected = set(bounds.all_points()) - queued
    covered = set(all_quadrants)
    assert covered == expected, f"Expected {expected}, got {covered}"

    # 2x2 tiles should not be placed at (2,0) because it would touch
    # the queued 2x2 at x=1
    for step in plan.steps:
      if step.step_type == "2x2":
        step_tl = min(q.x for q in step.quadrants), min(q.y for q in step.quadrants)
        # If there's a 2x2 at (2, 0), it would have neighbors at (1, 0) and (1, 1)
        # which are queued
        if step_tl == (2, 0):
          assert False, "2x2 at (2,0) would create seam with queued (0,0)-(1,1)"

```

All 158 tests pass. Here's a summary of the changes made to enforce 2x2 context requirements:

**Changes to `make_rectangle_plan.py`:**

1. **`has_valid_2x2_context()`** - New helper function that checks if a set of quadrants has valid 2x2 context (all 4 quadrants of at least one 2x2 block are covered by the quadrants being generated + already generated content)

2. **`can_place_1x1()`** - New function that checks if a 1x1 tile can be placed with valid context (requires 3 of 4 quadrants in a 2x2 block to already be generated/scheduled)

3. **`place_1x1_tiles()`** - Updated to **require** 3-of-4 context (not just prefer it). Uses iterative placement that re-evaluates after each placement to enable cascading fills.

4. **`can_place_2x2()`** - Added `allow_adjacent_scheduled` parameter to enable dense 2x2 packing for empty rectangles

5. **`place_2x2_tiles()`** - Now uses a two-pass strategy:
   - First pass: Place 2x2s with gaps (avoid both generated AND scheduled neighbors)
   - Second pass: Fill remaining 2x2-sized gaps (allow adjacent to scheduled)

6. **`validate_plan_context()`** - New validation function that verifies all steps have valid 2x2 context

**Updated tests:**
- Tests for scenarios without context now expect empty plans (cannot generate without context)
- Added tests for scenarios WITH context to verify correct behavior
- Added `TestContextValidation` class with 10 new tests for context validation functions
- Checkerboard pattern test updated to show it cannot provide valid context (every 2x2 block has only 2 generated quadrants)

**Key insight:** A generation MUST have a 2x2 block where all 4 quadrants are either:
- Part of the current generation
- Already generated/scheduled

This ensures the infill template builder always has valid pixel context for generation.

---

**User**

OK - now I'm noticing some weird bugs- there seem to be some issues with context for enqueued generations. If no context is explicitly provided, we want to calculate it lazily - that is, immediately before the enqueued generation is about to run. I'm noticing that a lot of generations are failing because the context is incorrect, even though after the previous generation sufficient quadrant context should be there

---

**Cursor**

I understand - the context should be calculated lazily at execution time, not at queue time. Let me look at how the queue and generation currently work:

I see the issue. When `context_quadrants` is `None` (not explicitly provided at queue time), we should calculate the context lazily at execution time based on what's actually generated. Let me add this functionality:

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  cancel_queue_item_by_id,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def calculate_context_quadrants(
  conn: sqlite3.Connection,
  selected_quadrants: list[tuple[int, int]],
) -> list[tuple[int, int]]:
  """
  Calculate context quadrants lazily at execution time.

  This determines which adjacent quadrants have existing generations
  that can provide context for the current generation.

  For a valid generation, we need at least a 2x2 block where all 4 quadrants
  are either being generated or already generated.

  Args:
    conn: Database connection
    selected_quadrants: The quadrants being generated

  Returns:
    List of quadrant coordinates that have existing generations and can
    provide context for the current generation.
  """
  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation as shared_get_quadrant_generation,
  )

  selected_set = set(selected_quadrants)
  context = []

  # Find all quadrants adjacent to the selection that have generations
  # Check all potential 2x2 blocks that include any selected quadrant
  checked = set()

  for qx, qy in selected_quadrants:
    # Check all neighbors that could form a 2x2 block with this quadrant
    # A quadrant can be in 4 different 2x2 blocks (as TL, TR, BL, BR corner)
    potential_context = [
      # Neighbors for 2x2 where (qx, qy) is top-left
      (qx + 1, qy), (qx, qy + 1), (qx + 1, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is top-right
      (qx - 1, qy), (qx - 1, qy + 1), (qx, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is bottom-left
      (qx, qy - 1), (qx + 1, qy - 1), (qx + 1, qy),
      # Neighbors for 2x2 where (qx, qy) is bottom-right
      (qx - 1, qy - 1), (qx, qy - 1), (qx - 1, qy),
    ]

    for nx, ny in potential_context:
      coord = (nx, ny)
      if coord in checked or coord in selected_set:
        continue
      checked.add(coord)

      # Check if this quadrant has an existing generation
      gen = shared_get_quadrant_generation(conn, nx, ny)
      if gen is not None:
        context.append(coord)

  return context


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.
    prompt: Optional additional prompt text for generation

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants, prompt
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None
    prompt = row[4]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]
    context_quadrants = (
      [(q[0], q[1]) for q in context_quadrants_raw] if context_quadrants_raw else None
    )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    if prompt:
      print(f"   Prompt: {prompt}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants, prompt
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_models": model_status["processing_models"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
      # All quadrants being processed across all models
      "all_processing_quadrants": model_status["all_processing_quadrants"],
    }

    # Set is_generating based on whether any models are active
    response["is_generating"] = len(active_models) > 0

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/queue/cancel/<int:item_id>", methods=["POST"])
def api_cancel_queue_item(item_id: int):
  """
  API endpoint to cancel a specific queue item by its ID.

  Returns:
    {
      "success": true,
      "cancelled": true,
      "item_id": N,
      "message": "Cancelled queue item N"
    }
  """
  global generation_cancelled

  print(f"\n{'=' * 60}")
  print(f"üóëÔ∏è  Cancel queue item request received: item_id={item_id}")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    cancelled = cancel_queue_item_by_id(conn, item_id)

    if cancelled:
      # Set the cancellation flag so the worker knows to stop
      # (in case this was a processing item)
      generation_cancelled = True
      print(f"‚úÖ Cancelled queue item {item_id}")

      return jsonify(
        {
          "success": True,
          "cancelled": True,
          "item_id": item_id,
          "message": f"Cancelled queue item {item_id}",
        }
      )
    else:
      print(f"‚ÑπÔ∏è  Queue item {item_id} not found or already completed")
      return jsonify(
        {
          "success": True,
          "cancelled": False,
          "item_id": item_id,
          "message": f"Queue item {item_id} not found or already completed",
        }
      )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  # Parse optional prompt
  prompt = data.get("prompt")
  if prompt and not isinstance(prompt, str):
    return jsonify(
      {
        "success": False,
        "error": "prompt must be a string",
      }
    ), 400

  # Clean up prompt (strip whitespace, None if empty)
  if prompt:
    prompt = prompt.strip()
    if not prompt:
      prompt = None

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  if prompt:
    print(f"   Prompt: {prompt}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(
    selected_quadrants, "generate", model_id, context_quadrants, prompt
  )
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  cancel_queue_item_by_id,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data (generation or render based on mode)
  tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      data = get_quadrant_data(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = data is not None

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def calculate_context_quadrants(
  conn: sqlite3.Connection,
  selected_quadrants: list[tuple[int, int]],
) -> list[tuple[int, int]]:
  """
  Calculate context quadrants lazily at execution time.

  This determines which adjacent quadrants have existing generations
  that can provide context for the current generation.

  For a valid generation, we need at least a 2x2 block where all 4 quadrants
  are either being generated or already generated.

  Args:
    conn: Database connection
    selected_quadrants: The quadrants being generated

  Returns:
    List of quadrant coordinates that have existing generations and can
    provide context for the current generation.
  """
  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation as shared_get_quadrant_generation,
  )

  selected_set = set(selected_quadrants)
  context = []

  # Find all quadrants adjacent to the selection that have generations
  # Check all potential 2x2 blocks that include any selected quadrant
  checked = set()

  for qx, qy in selected_quadrants:
    # Check all neighbors that could form a 2x2 block with this quadrant
    # A quadrant can be in 4 different 2x2 blocks (as TL, TR, BL, BR corner)
    potential_context = [
      # Neighbors for 2x2 where (qx, qy) is top-left
      (qx + 1, qy), (qx, qy + 1), (qx + 1, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is top-right
      (qx - 1, qy), (qx - 1, qy + 1), (qx, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is bottom-left
      (qx, qy - 1), (qx + 1, qy - 1), (qx + 1, qy),
      # Neighbors for 2x2 where (qx, qy) is bottom-right
      (qx - 1, qy - 1), (qx, qy - 1), (qx - 1, qy),
    ]

    for nx, ny in potential_context:
      coord = (nx, ny)
      if coord in checked or coord in selected_set:
        continue
      checked.add(coord)

      # Check if this quadrant has an existing generation
      gen = shared_get_quadrant_generation(conn, nx, ny)
      if gen is not None:
        context.append(coord)

  return context


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.
    prompt: Optional additional prompt text for generation

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants, prompt
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None
    prompt = row[4]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]

    # Calculate context lazily if not explicitly provided
    # This ensures we use the most up-to-date context based on what's
    # actually generated at execution time (not queue time)
    if context_quadrants_raw:
      context_quadrants = [(q[0], q[1]) for q in context_quadrants_raw]
      print(f"   üìã Using explicit context from queue: {len(context_quadrants)} quadrant(s)")
    else:
      # Calculate context lazily based on current generation state
      context_quadrants = calculate_context_quadrants(conn, selected_quadrants)
      if context_quadrants:
        print(f"   üìã Calculated lazy context: {len(context_quadrants)} quadrant(s)")
      else:
        print("   üìã No context quadrants (2x2 self-contained or no adjacent generations)")

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    if prompt:
      print(f"   Prompt: {prompt}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants, prompt
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_models": model_status["processing_models"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
      # All quadrants being processed across all models
      "all_processing_quadrants": model_status["all_processing_quadrants"],
    }

    # Set is_generating based on whether any models are active
    response["is_generating"] = len(active_models) > 0

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/queue/cancel/<int:item_id>", methods=["POST"])
def api_cancel_queue_item(item_id: int):
  """
  API endpoint to cancel a specific queue item by its ID.

  Returns:
    {
      "success": true,
      "cancelled": true,
      "item_id": N,
      "message": "Cancelled queue item N"
    }
  """
  global generation_cancelled

  print(f"\n{'=' * 60}")
  print(f"üóëÔ∏è  Cancel queue item request received: item_id={item_id}")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    cancelled = cancel_queue_item_by_id(conn, item_id)

    if cancelled:
      # Set the cancellation flag so the worker knows to stop
      # (in case this was a processing item)
      generation_cancelled = True
      print(f"‚úÖ Cancelled queue item {item_id}")

      return jsonify(
        {
          "success": True,
          "cancelled": True,
          "item_id": item_id,
          "message": f"Cancelled queue item {item_id}",
        }
      )
    else:
      print(f"‚ÑπÔ∏è  Queue item {item_id} not found or already completed")
      return jsonify(
        {
          "success": True,
          "cancelled": False,
          "item_id": item_id,
          "message": f"Queue item {item_id} not found or already completed",
        }
      )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  # Parse optional prompt
  prompt = data.get("prompt")
  if prompt and not isinstance(prompt, str):
    return jsonify(
      {
        "success": False,
        "error": "prompt must be a string",
      }
    ), 400

  # Clean up prompt (strip whitespace, None if empty)
  if prompt:
    prompt = prompt.strip()
    if not prompt:
      prompt = None

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  if prompt:
    print(f"   Prompt: {prompt}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(
    selected_quadrants, "generate", model_id, context_quadrants, prompt
  )
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

All tests pass. Here's a summary of the lazy context calculation fix:

**Changes to `app.py`:**

1. **Added `calculate_context_quadrants()`** - New function that calculates context quadrants lazily at execution time:
   - Looks at all quadrants adjacent to the selection
   - Checks which have existing generations in the database
   - Returns those as context quadrants

2. **Updated `process_queue_item_from_db()`** - Now calculates context lazily:
   - If `context_quadrants` was explicitly provided at queue time ‚Üí use it as before
   - If NOT explicitly provided (`None`) ‚Üí calculate context lazily by checking what's actually generated at execution time

**How it works:**

```
Queue time:
  - User queues generation for quadrants (0,0), (1,0)
  - No context explicitly provided, so context_quadrants = None is stored

Execution time (later, after previous generations complete):
  - System retrieves the queued item
  - context_quadrants is None, so calculate_context_quadrants() is called
  - Function checks what's adjacent to (0,0), (1,0) and has generations
  - If quadrant (0,1) now has a generation, it's included as context
  - The generation runs with the freshly calculated context
```

This ensures that:
- When a generation runs, it uses the **current** state of the database
- Previous generations that completed while this item was queued are now available as context
- Explicitly provided context (for user-directed generation) still works as before

```plaintext
Queue time:
  - User queues generation for quadrants (0,0), (1,0)
  - No context explicitly provided, so context_quadrants = None is stored

Execution time (later, after previous generations complete):
  - System retrieves the queued item
  - context_quadrants is None, so calculate_context_quadrants() is called
  - Function checks what's adjacent to (0,0), (1,0) and has generations
  - If quadrant (0,1) now has a generation, it's included as context
  - The generation runs with the freshly calculated context
```

---

**User**

OK - i'm running into some weird issues with deleting an eunqueued generation - it seems like deleting an enqueued generation changes other items in the queue and moves generation to another

---

**Cursor**

Let me look at the queue cancellation logic to understand what might be going wrong:

```javascript
cancelBtn.onclick = (e) => {
  e.stopPropagation();
  cancelQueueItem(item.id);
};
```

```javascript
function createOverlay(item, options = {}) {
  ...
  const overlay = document.createElement("div");
  overlay.className = isProcessing
    ? "queue-overlay processing"
    : "queue-overlay";
  overlay.dataset.itemId = item.id;
  ...
  cancelBtn.onclick = (e) => {
    e.stopPropagation();
    cancelQueueItem(item.id);
  };
  ...
}
```

I found the bug! When cancelling a single queue item, the code always sets `generation_cancelled = True`, which causes the queue worker to reset ALL generations - even ones that weren't cancelled. This is why cancelling one item seems to affect others.

Let me fix this:

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  cancel_queue_item_by_id,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def ensure_flagged_column_exists(conn: sqlite3.Connection) -> None:
  """Ensure the flagged column exists in the quadrants table (migration)."""
  cursor = conn.cursor()
  # Check if column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "flagged" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN flagged INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'flagged' column to quadrants table")


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


def get_quadrant_info(x: int, y: int, use_render: bool = False) -> dict:
  """Get info about a quadrant including whether it has data and is flagged."""
  conn = get_db_connection()
  try:
    # Ensure flagged column exists
    ensure_flagged_column_exists(conn)

    cursor = conn.cursor()
    column = "render" if use_render else "generation"
    cursor.execute(
      f"""
      SELECT {column} IS NOT NULL, COALESCE(flagged, 0)
      FROM quadrants
      WHERE quadrant_x = ? AND quadrant_y = ?
      """,
      (x, y),
    )
    row = cursor.fetchone()
    if row:
      return {"has_data": bool(row[0]), "flagged": bool(row[1])}
    return {"has_data": False, "flagged": False}
  finally:
    conn.close()


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data and flagged status
  tiles = {}
  flagged_tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      info = get_quadrant_info(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = info["has_data"]
      flagged_tiles[(dx, dy)] = info["flagged"]

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    flagged_tiles=flagged_tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def calculate_context_quadrants(
  conn: sqlite3.Connection,
  selected_quadrants: list[tuple[int, int]],
) -> list[tuple[int, int]]:
  """
  Calculate context quadrants lazily at execution time.

  This determines which adjacent quadrants have existing generations
  that can provide context for the current generation.

  For a valid generation, we need at least a 2x2 block where all 4 quadrants
  are either being generated or already generated.

  Args:
    conn: Database connection
    selected_quadrants: The quadrants being generated

  Returns:
    List of quadrant coordinates that have existing generations and can
    provide context for the current generation.
  """
  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation as shared_get_quadrant_generation,
  )

  selected_set = set(selected_quadrants)
  context = []

  # Find all quadrants adjacent to the selection that have generations
  # Check all potential 2x2 blocks that include any selected quadrant
  checked = set()

  for qx, qy in selected_quadrants:
    # Check all neighbors that could form a 2x2 block with this quadrant
    # A quadrant can be in 4 different 2x2 blocks (as TL, TR, BL, BR corner)
    potential_context = [
      # Neighbors for 2x2 where (qx, qy) is top-left
      (qx + 1, qy),
      (qx, qy + 1),
      (qx + 1, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is top-right
      (qx - 1, qy),
      (qx - 1, qy + 1),
      (qx, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is bottom-left
      (qx, qy - 1),
      (qx + 1, qy - 1),
      (qx + 1, qy),
      # Neighbors for 2x2 where (qx, qy) is bottom-right
      (qx - 1, qy - 1),
      (qx, qy - 1),
      (qx - 1, qy),
    ]

    for nx, ny in potential_context:
      coord = (nx, ny)
      if coord in checked or coord in selected_set:
        continue
      checked.add(coord)

      # Check if this quadrant has an existing generation
      gen = shared_get_quadrant_generation(conn, nx, ny)
      if gen is not None:
        context.append(coord)

  return context


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.
    prompt: Optional additional prompt text for generation

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants, prompt
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None
    prompt = row[4]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]

    # Calculate context lazily if not explicitly provided
    # This ensures we use the most up-to-date context based on what's
    # actually generated at execution time (not queue time)
    if context_quadrants_raw:
      context_quadrants = [(q[0], q[1]) for q in context_quadrants_raw]
      print(
        f"   üìã Using explicit context from queue: {len(context_quadrants)} quadrant(s)"
      )
    else:
      # Calculate context lazily based on current generation state
      context_quadrants = calculate_context_quadrants(conn, selected_quadrants)
      if context_quadrants:
        print(f"   üìã Calculated lazy context: {len(context_quadrants)} quadrant(s)")
      else:
        print(
          "   üìã No context quadrants (2x2 self-contained or no adjacent generations)"
        )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    if prompt:
      print(f"   Prompt: {prompt}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants, prompt
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_models": model_status["processing_models"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
      # All quadrants being processed across all models
      "all_processing_quadrants": model_status["all_processing_quadrants"],
    }

    # Set is_generating based on whether any models are active
    response["is_generating"] = len(active_models) > 0

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/queue/cancel/<int:item_id>", methods=["POST"])
def api_cancel_queue_item(item_id: int):
  """
  API endpoint to cancel a specific queue item by its ID.

  Returns:
    {
      "success": true,
      "cancelled": true,
      "item_id": N,
      "message": "Cancelled queue item N"
    }
  """
  global generation_cancelled

  print(f"\n{'=' * 60}")
  print(f"üóëÔ∏è  Cancel queue item request received: item_id={item_id}")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # First check if this item was processing (not just pending)
    cursor = conn.cursor()
    cursor.execute(
      "SELECT status, model_id FROM generation_queue WHERE id = ?",
      (item_id,),
    )
    row = cursor.fetchone()
    was_processing = row and row[0] == "processing"
    cancelled_model_id = row[1] if row else None

    cancelled = cancel_queue_item_by_id(conn, item_id)

    if cancelled:
      print(f"‚úÖ Cancelled queue item {item_id}")

      # Only set the global cancellation flag if this was a PROCESSING item
      # Pending items just get marked as cancelled in the database
      if was_processing:
        generation_cancelled = True
        print(f"   ‚ö†Ô∏è  Item was processing, signaling cancellation")

        # Also remove this model from busy set so it can pick up new work
        if cancelled_model_id:
          with busy_models_lock:
            busy_models.discard(cancelled_model_id)

      return jsonify(
        {
          "success": True,
          "cancelled": True,
          "item_id": item_id,
          "message": f"Cancelled queue item {item_id}",
        }
      )
    else:
      print(f"‚ÑπÔ∏è  Queue item {item_id} not found or already completed")
      return jsonify(
        {
          "success": True,
          "cancelled": False,
          "item_id": item_id,
          "message": f"Queue item {item_id} not found or already completed",
        }
      )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


@app.route("/api/flag", methods=["POST"])
def api_flag():
  """API endpoint to flag/unflag selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Get flag value (default to True/1 for flagging, False/0 for unflagging)
  flag_value = 1 if data.get("flag", True) else 0

  conn = get_db_connection()

  try:
    # Ensure the flagged column exists
    ensure_flagged_column_exists(conn)

    flagged_count = 0
    for qx, qy in quadrants:
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET flagged = ?
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (flag_value, qx, qy),
      )
      if cursor.rowcount > 0:
        flagged_count += 1

    conn.commit()

    action = "Flagged" if flag_value else "Unflagged"
    return jsonify(
      {
        "success": True,
        "message": f"{action} {flagged_count} quadrant{'s' if flagged_count != 1 else ''}",
        "count": flagged_count,
        "flagged": bool(flag_value),
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  # Parse optional prompt
  prompt = data.get("prompt")
  if prompt and not isinstance(prompt, str):
    return jsonify(
      {
        "success": False,
        "error": "prompt must be a string",
      }
    ), 400

  # Clean up prompt (strip whitespace, None if empty)
  if prompt:
    prompt = prompt.strip()
    if not prompt:
      prompt = None

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  if prompt:
    print(f"   Prompt: {prompt}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(
    selected_quadrants, "generate", model_id, context_quadrants, prompt
  )
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

```python
"""
Simple web app to view generated tiles in an nx√óny grid.

Usage:
  uv run python src/isometric_nyc/e2e_generation/view_generations.py <generation_dir>

Then open http://localhost:8080/?x=0&y=0 in your browser.

URL Parameters:
  x, y   - Starting coordinates (default: 0, 0)
  nx, ny - Grid size nx√óny (default: 2, max: 20)
  lines  - Show grid lines: 1=on, 0=off (default: 1)
  coords - Show coordinates: 1=on, 0=off (default: 1)
  render - Show renders instead of generations: 1=renders, 0=generations (default: 0)

Keyboard shortcuts:
  Arrow keys - Navigate the grid
  L          - Toggle lines
  C          - Toggle coords
  R          - Toggle render/generation mode
  G          - Generate selected quadrants
  S          - Toggle select tool
"""

import argparse
import hashlib
import json
import logging
import sqlite3
import threading
import time
import traceback
from pathlib import Path

from dotenv import load_dotenv
from flask import Flask, Response, jsonify, render_template, request

from isometric_nyc.e2e_generation.generate_omni import run_generation_for_quadrants
from isometric_nyc.e2e_generation.make_rectangle_plan import (
  Point,
  RectBounds,
  create_rectangle_plan,
  get_plan_summary,
  validate_plan,
)
from isometric_nyc.e2e_generation.model_config import AppConfig, load_app_config
from isometric_nyc.e2e_generation.queue_db import (
  QueueItemType,
  add_to_queue,
  cancel_processing_items,
  cancel_queue_item_by_id,
  clear_completed_items,
  clear_pending_queue,
  get_next_pending_item_for_available_model,
  get_pending_queue,
  get_queue_position_for_model,
  get_queue_status,
  get_queue_status_by_model,
  init_queue_table,
  mark_item_complete,
  mark_item_error,
  mark_item_processing,
  reset_all_processing_items,
)
from isometric_nyc.e2e_generation.replace_color import hex_to_rgb
from isometric_nyc.e2e_generation.replace_color import (
  process_quadrant as process_color_replacement,
)
from isometric_nyc.e2e_generation.shared import DEFAULT_WEB_PORT, get_generation_config
from isometric_nyc.e2e_generation.web_renderer import (
  start_global_renderer,
  stop_global_renderer,
)

# Load environment variables
load_dotenv()

# Setup Flask with template and static folders relative to this file
VIEWER_DIR = Path(__file__).parent
app = Flask(
  __name__,
  template_folder=str(VIEWER_DIR / "templates"),
  static_folder=str(VIEWER_DIR / "static"),
)


# =============================================================================
# Logging Configuration - Suppress noisy tile request logs
# =============================================================================
class TileRequestFilter(logging.Filter):
  """Filter out noisy tile and static file requests from logs."""

  def filter(self, record: logging.LogRecord) -> bool:
    message = record.getMessage()
    # Filter out tile requests, static files, and api/status polling
    if "/tile/" in message:
      return False
    if "/static/" in message:
      return False
    if "/api/status" in message:
      return False
    return True


# Apply filter to werkzeug logger (Flask's HTTP request logger)
werkzeug_logger = logging.getLogger("werkzeug")
werkzeug_logger.addFilter(TileRequestFilter())

# Generation lock - protects generation_state updates
generation_lock = threading.Lock()

# Per-model generation states
# Key is model_id (None for default), value is state dict
model_generation_states: dict[str | None, dict] = {}

# Legacy global generation_state for backwards compatibility with API
generation_state = {
  "is_generating": False,
  "quadrants": [],  # List of quadrant coords being generated
  "status": "idle",  # idle, validating, rendering, uploading, generating, saving, complete, error
  "message": "",
  "error": None,
  "started_at": None,
  "current_item_id": None,
  "model_id": None,
}

# Track which models are currently processing
busy_models: set[str | None] = set()
busy_models_lock = threading.Lock()

# Queue worker thread
queue_worker_thread: threading.Thread | None = None
queue_worker_running = False

# Cancellation flag - set to True to cancel all generations
generation_cancelled = False

# Will be set by main()
GENERATION_DIR: Path | None = None
WEB_SERVER_PORT: int = DEFAULT_WEB_PORT
APP_CONFIG: AppConfig | None = None


def get_db_connection() -> sqlite3.Connection:
  """Get a connection to the quadrants database."""
  if GENERATION_DIR is None:
    raise RuntimeError("GENERATION_DIR not set")
  db_path = GENERATION_DIR / "quadrants.db"
  return sqlite3.connect(db_path)


def ensure_flagged_column_exists(conn: sqlite3.Connection) -> None:
  """Ensure the flagged column exists in the quadrants table (migration)."""
  cursor = conn.cursor()
  # Check if column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  if "flagged" not in columns:
    cursor.execute("ALTER TABLE quadrants ADD COLUMN flagged INTEGER DEFAULT 0")
    conn.commit()
    print("üìù Added 'flagged' column to quadrants table")


def get_quadrant_generation(x: int, y: int) -> bytes | None:
  """Get the generation bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT generation FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_render(x: int, y: int) -> bytes | None:
  """Get the render bytes for a quadrant."""
  conn = get_db_connection()
  try:
    cursor = conn.cursor()
    cursor.execute(
      "SELECT render FROM quadrants WHERE quadrant_x = ? AND quadrant_y = ?",
      (x, y),
    )
    row = cursor.fetchone()
    return row[0] if row and row[0] else None
  finally:
    conn.close()


def get_quadrant_data(x: int, y: int, use_render: bool = False) -> bytes | None:
  """Get either render or generation bytes for a quadrant."""
  if use_render:
    return get_quadrant_render(x, y)
  return get_quadrant_generation(x, y)


def get_quadrant_info(x: int, y: int, use_render: bool = False) -> dict:
  """Get info about a quadrant including whether it has data and is flagged."""
  conn = get_db_connection()
  try:
    # Ensure flagged column exists
    ensure_flagged_column_exists(conn)

    cursor = conn.cursor()
    column = "render" if use_render else "generation"
    cursor.execute(
      f"""
      SELECT {column} IS NOT NULL, COALESCE(flagged, 0)
      FROM quadrants
      WHERE quadrant_x = ? AND quadrant_y = ?
      """,
      (x, y),
    )
    row = cursor.fetchone()
    if row:
      return {"has_data": bool(row[0]), "flagged": bool(row[1])}
    return {"has_data": False, "flagged": False}
  finally:
    conn.close()


@app.route("/")
def index():
  """Main page showing nx√óny grid of tiles."""
  x = request.args.get("x", 0, type=int)
  y = request.args.get("y", 0, type=int)
  # Default fallback if nx/ny not present
  n_default = request.args.get("n", 2, type=int)
  nx = request.args.get("nx", n_default, type=int)
  ny = request.args.get("ny", n_default, type=int)
  size_px = request.args.get("size", 256, type=int)
  show_lines = request.args.get("lines", "1") == "1"
  show_coords = request.args.get("coords", "1") == "1"
  show_render = request.args.get("render", "0") == "1"

  # Clamp nx/ny to reasonable bounds
  nx = max(1, min(nx, 20))
  ny = max(1, min(ny, 20))

  # Check which tiles have data and flagged status
  tiles = {}
  flagged_tiles = {}
  for dx in range(nx):
    for dy in range(ny):
      qx, qy = x + dx, y + dy
      info = get_quadrant_info(qx, qy, use_render=show_render)
      tiles[(dx, dy)] = info["has_data"]
      flagged_tiles[(dx, dy)] = info["flagged"]

  # Get model configuration for the frontend
  models_config = []
  default_model_id = None
  if APP_CONFIG:
    models_config = [m.to_dict() for m in APP_CONFIG.models]
    default_model_id = APP_CONFIG.default_model_id

  return render_template(
    "viewer.html",
    x=x,
    y=y,
    nx=nx,
    ny=ny,
    size_px=size_px,
    show_lines=show_lines,
    show_coords=show_coords,
    show_render=show_render,
    tiles=tiles,
    flagged_tiles=flagged_tiles,
    generation_dir=str(GENERATION_DIR),
    models_config=json.dumps(models_config),
    default_model_id=default_model_id,
  )


@app.route("/tile/<x>/<y>")
def tile(x: str, y: str):
  """Serve a tile image (generation or render based on query param)."""
  try:
    qx, qy = int(x), int(y)
  except ValueError:
    return Response("Invalid coordinates", status=400)

  use_render = request.args.get("render", "0") == "1"
  data = get_quadrant_data(qx, qy, use_render=use_render)

  if data is None:
    return Response("Not found", status=404)

  # Generate ETag from content hash for caching
  etag = hashlib.md5(data).hexdigest()

  # Check if client has cached version
  if_none_match = request.headers.get("If-None-Match")
  if if_none_match and if_none_match == etag:
    return Response(status=304)  # Not Modified

  response = Response(data, mimetype="image/png")
  response.headers["ETag"] = etag
  response.headers["Cache-Control"] = "public, max-age=3600"  # Cache for 1 hour
  return response


# =============================================================================
# Generation API
# =============================================================================


def update_generation_state(
  status: str, message: str = "", error: str | None = None
) -> None:
  """Update the global generation state."""
  global generation_state
  generation_state["status"] = status
  generation_state["message"] = message
  if error:
    generation_state["error"] = error


def calculate_context_quadrants(
  conn: sqlite3.Connection,
  selected_quadrants: list[tuple[int, int]],
) -> list[tuple[int, int]]:
  """
  Calculate context quadrants lazily at execution time.

  This determines which adjacent quadrants have existing generations
  that can provide context for the current generation.

  For a valid generation, we need at least a 2x2 block where all 4 quadrants
  are either being generated or already generated.

  Args:
    conn: Database connection
    selected_quadrants: The quadrants being generated

  Returns:
    List of quadrant coordinates that have existing generations and can
    provide context for the current generation.
  """
  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation as shared_get_quadrant_generation,
  )

  selected_set = set(selected_quadrants)
  context = []

  # Find all quadrants adjacent to the selection that have generations
  # Check all potential 2x2 blocks that include any selected quadrant
  checked = set()

  for qx, qy in selected_quadrants:
    # Check all neighbors that could form a 2x2 block with this quadrant
    # A quadrant can be in 4 different 2x2 blocks (as TL, TR, BL, BR corner)
    potential_context = [
      # Neighbors for 2x2 where (qx, qy) is top-left
      (qx + 1, qy),
      (qx, qy + 1),
      (qx + 1, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is top-right
      (qx - 1, qy),
      (qx - 1, qy + 1),
      (qx, qy + 1),
      # Neighbors for 2x2 where (qx, qy) is bottom-left
      (qx, qy - 1),
      (qx + 1, qy - 1),
      (qx + 1, qy),
      # Neighbors for 2x2 where (qx, qy) is bottom-right
      (qx - 1, qy - 1),
      (qx, qy - 1),
      (qx - 1, qy),
    ]

    for nx, ny in potential_context:
      coord = (nx, ny)
      if coord in checked or coord in selected_set:
        continue
      checked.add(coord)

      # Check if this quadrant has an existing generation
      gen = shared_get_quadrant_generation(conn, nx, ny)
      if gen is not None:
        context.append(coord)

  return context


def run_generation(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is a wrapper around run_generation_for_quadrants that ensures
  the web server is running and updates the global generation state.

  Args:
    conn: Database connection
    config: Generation config dict
    selected_quadrants: List of (x, y) quadrant coordinates to generate
    model_id: Optional model ID for generation
    context_quadrants: Optional list of (x, y) quadrant coordinates to use as
      context. These quadrants provide surrounding pixel art context for the
      generation.
    prompt: Optional additional prompt text for generation

  Returns dict with success status and message/error.
  """
  # Get model configuration if specified
  model_config = None
  if model_id and APP_CONFIG:
    model_config = APP_CONFIG.get_model(model_id)
  elif APP_CONFIG:
    model_config = APP_CONFIG.get_default_model()

  # Create status callback that updates global state
  def status_callback(status: str, message: str) -> None:
    update_generation_state(status, message)

  # Use the shared library function
  return run_generation_for_quadrants(
    conn=conn,
    config=config,
    selected_quadrants=selected_quadrants,
    port=WEB_SERVER_PORT,
    status_callback=status_callback,
    model_config=model_config,
    context_quadrants=context_quadrants,
    prompt=prompt,
  )


def render_quadrant_with_renderer(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
) -> bytes | None:
  """
  Render a quadrant using the global web renderer.

  Returns the PNG bytes of the rendered quadrant.
  """
  from isometric_nyc.e2e_generation.shared import (
    ensure_quadrant_exists,
    save_quadrant_render,
  )
  from isometric_nyc.e2e_generation.web_renderer import get_web_renderer

  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  renderer = get_web_renderer(port=WEB_SERVER_PORT)

  # Render the tile
  quadrant_images = renderer.render_quadrant(
    quadrant_x=x,
    quadrant_y=y,
    lat=quadrant["lat"],
    lng=quadrant["lng"],
    width_px=config["width_px"],
    height_px=config["height_px"],
    camera_azimuth_degrees=config["camera_azimuth_degrees"],
    camera_elevation_degrees=config["camera_elevation_degrees"],
    view_height_meters=config.get("view_height_meters", 200),
  )

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), png_bytes in quadrant_images.items():
    qx, qy = x + dx, y + dy
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


def process_queue_item_from_db(item_id: int) -> dict:
  """Process a single queue item from the database."""
  global generation_state

  conn = get_db_connection()
  try:
    # Get item details
    cursor = conn.cursor()
    cursor.execute(
      """
      SELECT item_type, quadrants, model_id, context_quadrants, prompt
      FROM generation_queue
      WHERE id = ?
      """,
      (item_id,),
    )
    row = cursor.fetchone()
    if not row:
      return {"success": False, "error": "Item not found"}

    item_type = QueueItemType(row[0])
    quadrants = json.loads(row[1])
    model_id = row[2]
    context_quadrants_raw = json.loads(row[3]) if row[3] else None
    prompt = row[4]

    # Convert to list of tuples
    selected_quadrants = [(q[0], q[1]) for q in quadrants]

    # Calculate context lazily if not explicitly provided
    # This ensures we use the most up-to-date context based on what's
    # actually generated at execution time (not queue time)
    if context_quadrants_raw:
      context_quadrants = [(q[0], q[1]) for q in context_quadrants_raw]
      print(
        f"   üìã Using explicit context from queue: {len(context_quadrants)} quadrant(s)"
      )
    else:
      # Calculate context lazily based on current generation state
      context_quadrants = calculate_context_quadrants(conn, selected_quadrants)
      if context_quadrants:
        print(f"   üìã Calculated lazy context: {len(context_quadrants)} quadrant(s)")
      else:
        print(
          "   üìã No context quadrants (2x2 self-contained or no adjacent generations)"
        )

    # Mark item as processing
    mark_item_processing(conn, item_id)

    # Initialize generation state
    generation_state["is_generating"] = True
    generation_state["quadrants"] = selected_quadrants
    generation_state["status"] = (
      "starting" if item_type == QueueItemType.GENERATE else "rendering"
    )
    generation_state["message"] = f"Starting {item_type.value}..."
    generation_state["error"] = None
    generation_state["started_at"] = time.time()
    generation_state["current_item_id"] = item_id
    generation_state["model_id"] = model_id

    print(f"\n{'=' * 60}")
    emoji = "üéØ" if item_type == QueueItemType.GENERATE else "üé®"
    print(
      f"{emoji} {item_type.value.title()} request (item {item_id}): {selected_quadrants}"
    )
    if model_id:
      print(f"   Model: {model_id}")
    if context_quadrants:
      print(f"   Context: {context_quadrants}")
    if prompt:
      print(f"   Prompt: {prompt}")
    print(f"{'=' * 60}")

    config = get_generation_config(conn)

    if item_type == QueueItemType.GENERATE:
      result = run_generation(
        conn, config, selected_quadrants, model_id, context_quadrants, prompt
      )
      if result["success"]:
        print(f"‚úÖ Generation complete: {result['message']}")
        generation_state["status"] = "complete"
        generation_state["message"] = result["message"]
        mark_item_complete(conn, item_id, result["message"])
      else:
        print(f"‚ùå Generation failed: {result['error']}")
        generation_state["status"] = "error"
        generation_state["error"] = result["error"]
        mark_item_error(conn, item_id, result["error"])
      return result

    else:  # render
      update_generation_state("rendering", "Starting render...")

      rendered_count = 0
      total = len(selected_quadrants)

      for i, (qx, qy) in enumerate(selected_quadrants):
        update_generation_state(
          "rendering", f"Rendering quadrant ({qx}, {qy})... ({i + 1}/{total})"
        )
        print(f"   üé® Rendering quadrant ({qx}, {qy})...")

        try:
          render_bytes = render_quadrant_with_renderer(conn, config, qx, qy)
          if render_bytes:
            rendered_count += 1
            print(f"      ‚úì Rendered quadrant ({qx}, {qy})")
          else:
            print(f"      ‚ö†Ô∏è No render output for ({qx}, {qy})")
        except Exception as e:
          print(f"      ‚ùå Failed to render ({qx}, {qy}): {e}")
          traceback.print_exc()

      result_message = f"Rendered {rendered_count} quadrant(s)"
      update_generation_state("complete", result_message)
      print(f"‚úÖ Render complete: {rendered_count}/{total} quadrants")
      mark_item_complete(conn, item_id, result_message)

      return {
        "success": True,
        "message": f"Rendered {rendered_count} quadrant{'s' if rendered_count != 1 else ''}",
        "quadrants": selected_quadrants,
      }

  except Exception as e:
    traceback.print_exc()
    generation_state["status"] = "error"
    generation_state["error"] = str(e)
    mark_item_error(conn, item_id, str(e))
    return {"success": False, "error": str(e)}
  finally:
    conn.close()


def process_model_item(item_id: int, model_id: str | None):
  """Process a single queue item for a specific model in its own thread."""
  global generation_state, generation_cancelled

  try:
    # Check cancellation before starting
    if generation_cancelled:
      print(f"‚ö†Ô∏è  Item {item_id} cancelled before processing")
      return

    process_queue_item_from_db(item_id)

  except Exception as e:
    print(f"‚ùå Model worker error for {model_id}: {e}")
    traceback.print_exc()
  finally:
    # Remove model from busy set
    with busy_models_lock:
      busy_models.discard(model_id)

    # Update global state if this was the active model
    with generation_lock:
      if generation_state.get("model_id") == model_id:
        generation_state["is_generating"] = False
        generation_state["current_item_id"] = None

    # Remove from per-model states
    if model_id in model_generation_states:
      del model_generation_states[model_id]


def queue_worker():
  """Background worker that processes the generation queue from the database.

  This worker supports parallel processing of different models - each model
  can have one active generation at a time, but different models can run
  concurrently.
  """
  global generation_state, queue_worker_running, generation_cancelled

  print("üîÑ Queue worker started (parallel model support)")

  while queue_worker_running:
    conn = None
    try:
      # Check if we were cancelled
      if generation_cancelled:
        print("‚ö†Ô∏è  Generation cancelled, resetting flags...")
        generation_cancelled = False
        with generation_lock:
          generation_state["is_generating"] = False
          generation_state["current_item_id"] = None
        with busy_models_lock:
          busy_models.clear()
        model_generation_states.clear()
        time.sleep(0.5)
        continue

      conn = get_db_connection()

      # Get current busy models
      with busy_models_lock:
        current_busy = busy_models.copy()

      # Get next pending item for an available model
      item = get_next_pending_item_for_available_model(conn, current_busy)

      if item is None:
        # No items available (either queue empty or all models busy)
        conn.close()
        time.sleep(0.5)
        continue

      item_id = item.id
      model_id = item.model_id
      conn.close()
      conn = None

      # Mark this model as busy
      with busy_models_lock:
        if model_id in busy_models:
          # Another thread grabbed this model, skip
          continue
        busy_models.add(model_id)

      # Update global state for display (use most recent)
      with generation_lock:
        generation_state["is_generating"] = True
        generation_state["model_id"] = model_id

      # Initialize per-model state
      model_generation_states[model_id] = {
        "is_generating": True,
        "item_id": item_id,
        "started_at": time.time(),
      }

      # Spawn a thread to process this model's item
      model_name = model_id or "default"
      worker_thread = threading.Thread(
        target=process_model_item,
        args=(item_id, model_id),
        name=f"model-worker-{model_name}",
        daemon=True,
      )
      worker_thread.start()

      print(f"üöÄ Started worker for model '{model_name}' (item {item_id})")

      # Small delay before checking for more work
      time.sleep(0.2)

    except Exception as e:
      print(f"‚ùå Queue worker error: {e}")
      traceback.print_exc()
      time.sleep(1.0)
    finally:
      if conn:
        conn.close()

  print("üõë Queue worker stopped")


def start_queue_worker():
  """Start the queue worker thread if not already running."""
  global queue_worker_thread, queue_worker_running

  if queue_worker_thread is not None and queue_worker_thread.is_alive():
    return  # Already running

  queue_worker_running = True
  queue_worker_thread = threading.Thread(target=queue_worker, daemon=True)
  queue_worker_thread.start()


def stop_queue_worker():
  """Stop the queue worker thread."""
  global queue_worker_running
  queue_worker_running = False


def add_to_queue_db(
  quadrants: list[tuple[int, int]],
  item_type: str,
  model_id: str | None = None,
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """Add a generation/render request to the database queue."""
  conn = get_db_connection()
  try:
    queue_item = add_to_queue(
      conn,
      QueueItemType(item_type),
      quadrants,
      model_id,
      context_quadrants,
      prompt,
    )

    # Get model-specific queue position
    model_position = get_queue_position_for_model(conn, queue_item.id, model_id)

    # Get total queue length for backwards compatibility
    pending = get_pending_queue(conn)
    total_position = len(pending)

    # Ensure the queue worker is running
    start_queue_worker()

    return {
      "success": True,
      "queued": True,
      "position": model_position,  # Position within this model's queue
      "total_position": total_position,  # Overall queue position
      "model_id": model_id,
      "item_id": queue_item.id,
      "message": f"Added to queue at position {model_position}",
    }
  finally:
    conn.close()


@app.route("/api/status")
def api_status():
  """API endpoint to check generation status including queue info."""
  conn = get_db_connection()
  try:
    queue_status = get_queue_status(conn)
    model_status = get_queue_status_by_model(conn)

    # Get list of currently busy models
    with busy_models_lock:
      active_models = list(busy_models)

    # Build the response
    response = {
      **generation_state,
      "queue": queue_status["pending_items"],
      "queue_length": queue_status["pending_count"],
      # Per-model queue info
      "queue_by_model": model_status["by_model"],
      "processing_models": model_status["processing_models"],
      # All currently processing models (for parallel processing)
      "active_models": active_models,
      "active_model_count": len(active_models),
      # All quadrants being processed across all models
      "all_processing_quadrants": model_status["all_processing_quadrants"],
    }

    # Set is_generating based on whether any models are active
    response["is_generating"] = len(active_models) > 0

    # Include current processing item info if available
    if queue_status["current_item"]:
      response["current_item"] = queue_status["current_item"]

    return jsonify(response)
  finally:
    conn.close()


@app.route("/api/queue/clear", methods=["POST"])
def api_clear_queue():
  """
  API endpoint to clear all items from the generation queue,
  including cancelling any currently running generation.

  Returns:
    {
      "success": true,
      "cleared_count": N,
      "cancelled_count": M,
      "message": "Cleared N pending item(s), cancelled M in-progress item(s)"
    }
  """
  global generation_state, generation_cancelled

  print(f"\n{'=' * 60}")
  print("üóëÔ∏è  Clear queue request received")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # Clear pending items
    cleared_count = clear_pending_queue(conn)

    # Cancel any in-progress items
    cancelled_count = cancel_processing_items(conn)

    # Set the cancellation flag so the worker knows to stop
    if cancelled_count > 0:
      generation_cancelled = True

    # Clear busy models
    with busy_models_lock:
      busy_models.clear()

    # Clear per-model states
    model_generation_states.clear()

    # Reset the generation state
    generation_state["is_generating"] = False
    generation_state["quadrants"] = []
    generation_state["status"] = "idle"
    generation_state["message"] = "Queue cleared"
    generation_state["error"] = None
    generation_state["current_item_id"] = None

    if cleared_count > 0 or cancelled_count > 0:
      print(
        f"‚úÖ Cleared {cleared_count} pending, cancelled {cancelled_count} in-progress"
      )
    else:
      print("‚ÑπÔ∏è  Queue was already empty")

    message_parts = []
    if cleared_count > 0:
      message_parts.append(f"Cleared {cleared_count} pending item(s)")
    if cancelled_count > 0:
      message_parts.append(f"cancelled {cancelled_count} in-progress item(s)")
    message = ", ".join(message_parts) if message_parts else "Queue was already empty"

    return jsonify(
      {
        "success": True,
        "cleared_count": cleared_count,
        "cancelled_count": cancelled_count,
        "message": message,
      }
    )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/queue/cancel/<int:item_id>", methods=["POST"])
def api_cancel_queue_item(item_id: int):
  """
  API endpoint to cancel a specific queue item by its ID.

  Returns:
    {
      "success": true,
      "cancelled": true,
      "item_id": N,
      "message": "Cancelled queue item N"
    }
  """
  global generation_cancelled

  print(f"\n{'=' * 60}")
  print(f"üóëÔ∏è  Cancel queue item request received: item_id={item_id}")
  print(f"{'=' * 60}")

  conn = get_db_connection()
  try:
    # First check if this item was processing (not just pending)
    cursor = conn.cursor()
    cursor.execute(
      "SELECT status, model_id FROM generation_queue WHERE id = ?",
      (item_id,),
    )
    row = cursor.fetchone()
    was_processing = row and row[0] == "processing"
    cancelled_model_id = row[1] if row else None

    cancelled = cancel_queue_item_by_id(conn, item_id)

    if cancelled:
      print(f"‚úÖ Cancelled queue item {item_id}")

      # Only set the global cancellation flag if this was a PROCESSING item
      # Pending items just get marked as cancelled in the database
      if was_processing:
        generation_cancelled = True
        print("   ‚ö†Ô∏è  Item was processing, signaling cancellation")

        # Also remove this model from busy set so it can pick up new work
        if cancelled_model_id:
          with busy_models_lock:
            busy_models.discard(cancelled_model_id)

      return jsonify(
        {
          "success": True,
          "cancelled": True,
          "item_id": item_id,
          "message": f"Cancelled queue item {item_id}",
        }
      )
    else:
      print(f"‚ÑπÔ∏è  Queue item {item_id} not found or already completed")
      return jsonify(
        {
          "success": True,
          "cancelled": False,
          "item_id": item_id,
          "message": f"Queue item {item_id} not found or already completed",
        }
      )
  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/models")
def api_models():
  """API endpoint to get available models."""
  if APP_CONFIG is None:
    return jsonify({"models": [], "default_model_id": None})

  return jsonify(
    {
      "models": [m.to_dict() for m in APP_CONFIG.models],
      "default_model_id": APP_CONFIG.default_model_id,
    }
  )


@app.route("/api/delete", methods=["POST"])
def api_delete():
  """API endpoint to delete generation data for selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Connect to database (quadrants.db, not tiles.db)
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    deleted_count = 0
    for qx, qy in quadrants:
      # Clear the generation column (set to NULL) but keep the row
      # Columns are quadrant_x and quadrant_y
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET generation = NULL
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (qx, qy),
      )
      if cursor.rowcount > 0:
        deleted_count += 1

    conn.commit()

    return jsonify(
      {
        "success": True,
        "message": f"Deleted generation data for {deleted_count} quadrant{'s' if deleted_count != 1 else ''}",
        "deleted": deleted_count,
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


@app.route("/api/flag", methods=["POST"])
def api_flag():
  """API endpoint to flag/unflag selected quadrants."""
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify({"success": False, "error": "No quadrants specified"})

  quadrants = data["quadrants"]
  if not quadrants:
    return jsonify({"success": False, "error": "Empty quadrants list"})

  # Get flag value (default to True/1 for flagging, False/0 for unflagging)
  flag_value = 1 if data.get("flag", True) else 0

  conn = get_db_connection()

  try:
    # Ensure the flagged column exists
    ensure_flagged_column_exists(conn)

    flagged_count = 0
    for qx, qy in quadrants:
      cursor = conn.execute(
        """
        UPDATE quadrants
        SET flagged = ?
        WHERE quadrant_x = ? AND quadrant_y = ?
        """,
        (flag_value, qx, qy),
      )
      if cursor.rowcount > 0:
        flagged_count += 1

    conn.commit()

    action = "Flagged" if flag_value else "Unflagged"
    return jsonify(
      {
        "success": True,
        "message": f"{action} {flagged_count} quadrant{'s' if flagged_count != 1 else ''}",
        "count": flagged_count,
        "flagged": bool(flag_value),
      }
    )
  except Exception as e:
    return jsonify({"success": False, "error": str(e)})
  finally:
    conn.close()


# Hardcoded water replacement color
WATER_REPLACEMENT_COLOR = "#4A6372"
DEFAULT_SOFTNESS = 30.0  # Lower = more precise color matching


@app.route("/api/fix-water", methods=["POST"])
def api_fix_water():
  """API endpoint to fix water color in a quadrant using soft blending."""
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  # Required fields
  x = data.get("x")
  y = data.get("y")
  target_color = data.get("target_color")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  if not target_color:
    return jsonify({"success": False, "error": "Missing target_color"}), 400

  # Optional fields
  softness = data.get("softness", DEFAULT_SOFTNESS)

  # Parse colors
  try:
    target_rgb = hex_to_rgb(target_color)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid target color: {e}"}), 400

  try:
    replacement_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)
  except ValueError as e:
    return jsonify({"success": False, "error": f"Invalid replacement color: {e}"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fix request: quadrant ({x}, {y})")
  print(f"   Target color: {target_color} -> RGB{target_rgb}")
  print(f"   Replacement color: {WATER_REPLACEMENT_COLOR} -> RGB{replacement_rgb}")
  print(f"   Softness: {softness}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)
    exports_dir = Path(GENERATION_DIR) / "exports"

    success = process_color_replacement(
      conn=conn,
      config=config,
      x=int(x),
      y=int(y),
      target_color=target_rgb,
      replacement_color=replacement_rgb,
      softness=float(softness),
      dry_run=False,  # Apply directly to database
      exports_dir=exports_dir,
    )

    if success:
      print(f"‚úÖ Water fix complete for quadrant ({x}, {y})")
      return jsonify(
        {
          "success": True,
          "message": f"Fixed water color in quadrant ({x}, {y})",
          "quadrant": {"x": x, "y": y},
          "target_color": target_color,
          "replacement_color": WATER_REPLACEMENT_COLOR,
        }
      )
    else:
      print(f"‚ùå Water fix failed for quadrant ({x}, {y})")
      return jsonify(
        {"success": False, "error": f"Failed to process quadrant ({x}, {y})"}
      ), 400

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/water-fill", methods=["POST"])
def api_water_fill():
  """API endpoint to fill an entire quadrant with the water color."""

  from PIL import Image

  from isometric_nyc.e2e_generation.shared import (
    get_quadrant_generation,
    image_to_png_bytes,
    png_bytes_to_image,
    save_quadrant_generation,
  )

  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No data provided"}), 400

  x = data.get("x")
  y = data.get("y")

  if x is None or y is None:
    return jsonify({"success": False, "error": "Missing x or y coordinate"}), 400

  print(f"\n{'=' * 60}")
  print(f"üíß Water fill request: quadrant ({x}, {y})")
  print(f"   Fill color: {WATER_REPLACEMENT_COLOR}")
  print(f"{'=' * 60}")

  # Connect to database
  db_path = Path(GENERATION_DIR) / "quadrants.db"
  conn = sqlite3.connect(db_path)

  try:
    config = get_generation_config(conn)

    # Get existing generation to determine size, or use config defaults
    generation_bytes = get_quadrant_generation(conn, int(x), int(y))
    if generation_bytes is not None:
      # Get dimensions from existing image
      existing_img = png_bytes_to_image(generation_bytes)
      width, height = existing_img.size
      mode = existing_img.mode
    else:
      # No existing generation - use quadrant size from config
      # Quadrant is half the tile size
      width = config.get("width_px", 512) // 2
      height = config.get("height_px", 512) // 2
      mode = "RGBA"
      print(f"   No existing generation - creating new {width}x{height} image")

    # Parse water color
    water_rgb = hex_to_rgb(WATER_REPLACEMENT_COLOR)

    # Create solid color image
    if mode == "RGBA":
      fill_color = (*water_rgb, 255)  # Add full alpha
    else:
      fill_color = water_rgb

    filled_img = Image.new(mode, (width, height), fill_color)

    # Save to database
    png_bytes = image_to_png_bytes(filled_img)
    save_quadrant_generation(conn, config, int(x), int(y), png_bytes)

    print(f"‚úÖ Water fill complete for quadrant ({x}, {y})")
    return jsonify(
      {
        "success": True,
        "message": f"Filled quadrant ({x}, {y}) with water color",
        "quadrant": {"x": x, "y": y},
        "color": WATER_REPLACEMENT_COLOR,
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


@app.route("/api/render", methods=["POST"])
def api_render():
  """API endpoint to render tiles for selected quadrants."""
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Convert to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  print(f"\n{'=' * 60}")
  print(f"üé® Render request: {selected_quadrants}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(selected_quadrants, "render")
  return jsonify(result), 202  # 202 Accepted


@app.route("/api/generate", methods=["POST"])
def api_generate():
  """
  API endpoint to generate tiles for selected quadrants.

  Request body:
    {
      "quadrants": [[x, y], ...] or [{"x": x, "y": y}, ...],
      "model_id": "optional-model-id",
      "context": [[x, y], ...] or [{"x": x, "y": y}, ...]  // Optional context quadrants
    }

  The context quadrants are used to provide surrounding pixel art context for
  the generation. If a context quadrant has an existing generation, that will
  be used; otherwise the render content will be used.
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data or "quadrants" not in data:
    return jsonify(
      {
        "success": False,
        "error": "Missing 'quadrants' in request body",
      }
    ), 400

  quadrants = data["quadrants"]
  if not isinstance(quadrants, list) or len(quadrants) == 0:
    return jsonify(
      {
        "success": False,
        "error": "quadrants must be a non-empty list",
      }
    ), 400

  # Get optional model_id from request
  model_id = data.get("model_id")

  # Convert quadrants to list of tuples
  selected_quadrants = []
  for q in quadrants:
    if isinstance(q, list) and len(q) == 2:
      selected_quadrants.append((int(q[0]), int(q[1])))
    elif isinstance(q, dict) and "x" in q and "y" in q:
      selected_quadrants.append((int(q["x"]), int(q["y"])))
    else:
      return jsonify(
        {
          "success": False,
          "error": f"Invalid quadrant format: {q}",
        }
      ), 400

  # Parse optional context quadrants
  context_quadrants = None
  context_raw = data.get("context")
  if context_raw:
    if not isinstance(context_raw, list):
      return jsonify(
        {
          "success": False,
          "error": "context must be a list of quadrant coordinates",
        }
      ), 400

    context_quadrants = []
    for q in context_raw:
      if isinstance(q, list) and len(q) == 2:
        context_quadrants.append((int(q[0]), int(q[1])))
      elif isinstance(q, dict) and "x" in q and "y" in q:
        context_quadrants.append((int(q["x"]), int(q["y"])))
      else:
        return jsonify(
          {
            "success": False,
            "error": f"Invalid context quadrant format: {q}",
          }
        ), 400

  # Parse optional prompt
  prompt = data.get("prompt")
  if prompt and not isinstance(prompt, str):
    return jsonify(
      {
        "success": False,
        "error": "prompt must be a string",
      }
    ), 400

  # Clean up prompt (strip whitespace, None if empty)
  if prompt:
    prompt = prompt.strip()
    if not prompt:
      prompt = None

  print(f"\n{'=' * 60}")
  print(f"üéØ Generation request: {selected_quadrants}")
  if model_id:
    print(f"   Model: {model_id}")
  if context_quadrants:
    print(f"   Context: {context_quadrants}")
  if prompt:
    print(f"   Prompt: {prompt}")
  print(f"{'=' * 60}")

  # Always add to queue (database-backed queue handles everything)
  result = add_to_queue_db(
    selected_quadrants, "generate", model_id, context_quadrants, prompt
  )
  return jsonify(result), 202  # 202 Accepted


# =============================================================================
# Rectangle Generation API
# =============================================================================


def load_generated_quadrants(conn: sqlite3.Connection) -> set[Point]:
  """Load all quadrants that have generations from the database."""
  cursor = conn.cursor()
  cursor.execute(
    "SELECT quadrant_x, quadrant_y FROM quadrants WHERE generation IS NOT NULL"
  )
  return {Point(row[0], row[1]) for row in cursor.fetchall()}


@app.route("/api/generate-rectangle", methods=["POST"])
def api_generate_rectangle():
  """
  API endpoint to generate all quadrants within a rectangle.

  Request body:
    {
      "tl": [x, y] or {"x": x, "y": y},  // Top-left corner
      "br": [x, y] or {"x": x, "y": y},  // Bottom-right corner
      "model_id": "optional-model-id"    // Optional model ID
    }

  Returns:
    {
      "success": true,
      "plan_summary": {...},
      "queued_count": N,
      "message": "Queued N generation steps"
    }
  """
  global generation_state

  # Parse request
  data = request.get_json()
  if not data:
    return jsonify({"success": False, "error": "No JSON body provided"}), 400

  # Parse top-left coordinate
  tl_raw = data.get("tl")
  if not tl_raw:
    return jsonify(
      {"success": False, "error": "Missing 'tl' (top-left) coordinate"}
    ), 400

  try:
    if isinstance(tl_raw, list) and len(tl_raw) == 2:
      tl = Point(int(tl_raw[0]), int(tl_raw[1]))
    elif isinstance(tl_raw, dict) and "x" in tl_raw and "y" in tl_raw:
      tl = Point(int(tl_raw["x"]), int(tl_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'tl' format: {tl_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'tl' coordinate: {e}"}), 400

  # Parse bottom-right coordinate
  br_raw = data.get("br")
  if not br_raw:
    return jsonify(
      {"success": False, "error": "Missing 'br' (bottom-right) coordinate"}
    ), 400

  try:
    if isinstance(br_raw, list) and len(br_raw) == 2:
      br = Point(int(br_raw[0]), int(br_raw[1]))
    elif isinstance(br_raw, dict) and "x" in br_raw and "y" in br_raw:
      br = Point(int(br_raw["x"]), int(br_raw["y"]))
    else:
      return jsonify({"success": False, "error": f"Invalid 'br' format: {br_raw}"}), 400
  except (ValueError, TypeError) as e:
    return jsonify({"success": False, "error": f"Invalid 'br' coordinate: {e}"}), 400

  # Validate bounds
  if tl.x > br.x or tl.y > br.y:
    return jsonify(
      {
        "success": False,
        "error": "Invalid bounds: top-left must be above and to the left of bottom-right",
      }
    ), 400

  # Get optional model_id
  model_id = data.get("model_id")

  print(f"\n{'=' * 60}")
  print(f"üìê Rectangle generation request: ({tl.x},{tl.y}) to ({br.x},{br.y})")
  if model_id:
    print(f"   Model: {model_id}")
  print(f"{'=' * 60}")

  # Load existing generated quadrants
  conn = get_db_connection()
  try:
    generated = load_generated_quadrants(conn)

    # Create the rectangle plan
    bounds = RectBounds(tl, br)
    plan = create_rectangle_plan(bounds, generated)

    # Validate the plan
    is_valid, errors = validate_plan(plan)
    if not is_valid:
      print(f"‚ùå Invalid plan generated: {errors}")
      return jsonify(
        {
          "success": False,
          "error": f"Internal error: invalid plan generated - {errors}",
        }
      ), 500

    # Get plan summary for response
    summary = get_plan_summary(plan)

    if len(plan.steps) == 0:
      print("‚ÑπÔ∏è  No quadrants to generate (all already generated)")
      return jsonify(
        {
          "success": True,
          "plan_summary": summary,
          "queued_count": 0,
          "message": "No quadrants to generate - all already generated",
        }
      )

    # Queue all generation steps
    queued_count = 0
    for step in plan.steps:
      quadrants = [(q.x, q.y) for q in step.quadrants]
      add_to_queue(conn, QueueItemType.GENERATE, quadrants, model_id)
      queued_count += 1

    # Ensure queue worker is running
    start_queue_worker()

    print(f"‚úÖ Queued {queued_count} generation step(s)")
    print(f"   Steps by type: {summary['steps_by_type']}")

    return jsonify(
      {
        "success": True,
        "plan_summary": summary,
        "queued_count": queued_count,
        "message": f"Queued {queued_count} generation step(s) for {summary['total_quadrants']} quadrant(s)",
      }
    )

  except Exception as e:
    traceback.print_exc()
    return jsonify({"success": False, "error": str(e)}), 500
  finally:
    conn.close()


def main():
  global GENERATION_DIR, WEB_SERVER_PORT, APP_CONFIG

  parser = argparse.ArgumentParser(description="View generated tiles in a grid.")
  parser.add_argument(
    "generation_dir",
    type=Path,
    help="Path to the generation directory containing quadrants.db",
  )
  parser.add_argument(
    "--port",
    type=int,
    default=8080,
    help="Port to run the Flask server on (default: 8080)",
  )
  parser.add_argument(
    "--host",
    default="127.0.0.1",
    help="Host to bind to (default: 127.0.0.1)",
  )
  parser.add_argument(
    "--web-port",
    type=int,
    default=DEFAULT_WEB_PORT,
    help=f"Port for the Vite web server used for rendering (default: {DEFAULT_WEB_PORT})",
  )
  parser.add_argument(
    "--config",
    type=Path,
    default=None,
    help="Path to app_config.json (default: looks in the e2e_generation directory)",
  )

  args = parser.parse_args()

  GENERATION_DIR = args.generation_dir.resolve()
  WEB_SERVER_PORT = args.web_port

  if not GENERATION_DIR.exists():
    print(f"‚ùå Error: Directory not found: {GENERATION_DIR}")
    return 1

  db_path = GENERATION_DIR / "quadrants.db"
  if not db_path.exists():
    print(f"‚ùå Error: Database not found: {db_path}")
    return 1

  # Load app configuration
  APP_CONFIG = load_app_config(args.config)
  print(f"üì¶ Loaded {len(APP_CONFIG.models)} model(s) from configuration")
  for model in APP_CONFIG.models:
    default_marker = (
      " (default)" if model.model_id == APP_CONFIG.default_model_id else ""
    )
    has_key = "‚úì" if model.api_key else "‚úó"
    print(f"   {has_key} {model.name} ({model.model_id}){default_marker}")

  # Initialize the generation queue table
  conn = get_db_connection()
  try:
    init_queue_table(conn)
    # Reset any items that were mid-processing when server shut down
    # These will be retried automatically
    reset_count = reset_all_processing_items(conn)
    if reset_count > 0:
      print(f"üîÑ Reset {reset_count} interrupted generation(s) - will be retried")
    # Clean up old completed items
    deleted_count = clear_completed_items(conn)
    if deleted_count > 0:
      print(f"üßπ Cleaned up {deleted_count} old completed queue item(s)")
  finally:
    conn.close()

  # Start the queue worker
  start_queue_worker()

  # Start the global web renderer
  try:
    start_global_renderer(port=WEB_SERVER_PORT)
  except Exception as e:
    print(f"‚ö†Ô∏è  Failed to start web renderer: {e}")
    print("   Rendering will start on demand")

  print("üé® Starting tile viewer...")
  print(f"   Generation dir: {GENERATION_DIR}")
  print(f"   Flask server: http://{args.host}:{args.port}/")
  print(f"   Web render port: {WEB_SERVER_PORT}")
  print("   Press Ctrl+C to stop")

  try:
    app.run(host=args.host, port=args.port, debug=True, use_reloader=False)
  finally:
    # Clean up queue worker
    print("\nüõë Stopping queue worker...")
    stop_queue_worker()

    # Clean up web renderer
    print("üõë Stopping web renderer...")
    stop_global_renderer()

  return 0


if __name__ == "__main__":
  exit(main())

```

Fixed! The bug was in `api_cancel_queue_item()`. Here's what was happening:

**The Problem:**
When cancelling ANY queue item (even a pending one), the code was setting `generation_cancelled = True`. This global flag caused the queue worker to:
1. Reset ALL generation states
2. Clear ALL busy models
3. Stop any in-progress generations

So cancelling a **pending** item for Model B would accidentally cancel the **in-progress** generation for Model A.

**The Fix:**
Now the code checks if the cancelled item was actually **processing** before setting the global cancellation flag:

- **Pending items**: Just marked as cancelled in the database. Other generations continue unaffected.
- **Processing items**: Set the cancellation flag AND remove the model from the busy set so it can pick up new work.

This ensures that cancelling one queued item doesn't disrupt other generations that are running or waiting in the queue.

---

**User**

We're getting a lot of errors in the `call_oxen_api` method:

@uv (1001-1018) 

---

**Cursor**

I see the issue - the code assumes the image has a `url` key but the API response might use a different format. Let me add better error handling and logging:

```python
"""
Reusable library for generating pixel art using the Oxen.ai model.

This module provides the core generation logic that can be used by:
- view_generations.py (Flask web server)
- generate_tiles_omni.py (command-line script)
- automatic_generation.py (automated generation)

The main entry point is `run_generation_for_quadrants()` which handles:
1. Validating the quadrant selection
2. Rendering any missing quadrants
3. Building the template image
4. Uploading to GCS and calling the Oxen API
5. Saving the generated quadrants to the database
"""

import os
import re
import sqlite3
import tempfile
from io import BytesIO
from pathlib import Path
from typing import Callable
from urllib.parse import urlencode

import requests
from dotenv import load_dotenv
from PIL import Image
from playwright.sync_api import sync_playwright

from isometric_nyc.e2e_generation.infill_template import (
  QUADRANT_SIZE,
  InfillRegion,
  TemplateBuilder,
  validate_quadrant_selection,
)
from isometric_nyc.e2e_generation.shared import (
  DEFAULT_WEB_PORT,
  ensure_quadrant_exists,
  image_to_png_bytes,
  png_bytes_to_image,
  save_quadrant_generation,
  save_quadrant_render,
  split_tile_into_quadrants,
  upload_to_gcs,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_generation as shared_get_quadrant_generation,
)
from isometric_nyc.e2e_generation.shared import (
  get_quadrant_render as shared_get_quadrant_render,
)

# Load environment variables
load_dotenv()

# Oxen API configuration
OMNI_MODEL_ID = "cannoneyed-gentle-gold-antlion"
OMNI_WATER_MODEL_ID = "cannoneyed-quiet-green-lamprey"
OMNI_WATER_V2_MODEL_ID = "cannoneyed-rural-rose-dingo"

GCS_BUCKET_NAME = "isometric-nyc-infills"


# =============================================================================
# Quadrant Parsing Utilities
# =============================================================================


def parse_quadrant_tuple(s: str) -> tuple[int, int]:
  """
  Parse a quadrant tuple string like "(0,1)" or "0,1" into a tuple.

  Args:
      s: String in format "(x,y)" or "x,y"

  Returns:
      Tuple of (x, y) coordinates

  Raises:
      ValueError: If the format is invalid
  """
  s = s.strip()
  # Remove optional parentheses
  if s.startswith("(") and s.endswith(")"):
    s = s[1:-1]
  parts = s.split(",")
  if len(parts) != 2:
    raise ValueError(f"Invalid quadrant tuple format: {s}")
  return (int(parts[0].strip()), int(parts[1].strip()))


def parse_quadrant_list(s: str) -> list[tuple[int, int]]:
  """
  Parse a comma-separated list of quadrant tuples.

  Args:
      s: String like "(0,1),(0,2)" or "(0,1), (0,2)"

  Returns:
      List of (x, y) coordinate tuples

  Raises:
      ValueError: If the format is invalid
  """
  # Use regex to find all (x,y) patterns
  pattern = r"\(\s*(-?\d+)\s*,\s*(-?\d+)\s*\)"
  matches = re.findall(pattern, s)
  if not matches:
    raise ValueError(f"No valid quadrant tuples found in: {s}")
  return [(int(x), int(y)) for x, y in matches]


# =============================================================================
# Oxen API Functions
# =============================================================================


def call_oxen_api(
  image_url: str,
  model_config: "ModelConfig | None" = None,  # noqa: F821
  additional_prompt: str | None = None,
) -> str:
  """
  Call the Oxen API to generate pixel art.

  Args:
      image_url: Public URL of the input template image
      model_config: Optional model configuration (ModelConfig from model_config.py).
        If not provided, uses defaults.
      additional_prompt: Optional additional text to append to the base prompt

  Returns:
      URL of the generated image

  Raises:
      requests.HTTPError: If the API call fails
      ValueError: If the response format is unexpected
  """
  # Use provided config or defaults
  if model_config is not None:
    endpoint = model_config.endpoint
    model_id = model_config.model_id
    api_key = model_config.api_key
    num_inference_steps = model_config.num_inference_steps
  else:
    endpoint = "https://hub.oxen.ai/api/images/edit"
    model_id = OMNI_WATER_MODEL_ID
    api_key = os.getenv("OXEN_OMNI_v04_WATER_API_KEY")
    num_inference_steps = 28

  if not api_key:
    raise ValueError(f"API key not found for model {model_id}")

  headers = {
    "Authorization": f"Bearer {api_key}",
    "Content-Type": "application/json",
  }

  # Build prompt - base prompt plus any additional text
  base_prompt = (
    "Fill in the outlined section with the missing pixels corresponding to "
    "the <isometric nyc pixel art> style, removing the border and exactly "
    "following the shape/style/structure of the surrounding image (if present)."
  )

  if additional_prompt:
    prompt = f"{base_prompt} {additional_prompt}"
    print(f"   üìù Using additional prompt: {additional_prompt}")
  else:
    prompt = base_prompt

  payload = {
    "model": model_id,
    "input_image": image_url,
    "prompt": prompt,
    "num_inference_steps": num_inference_steps,
  }

  print(f"   ü§ñ Calling Oxen API with model {model_id}...")
  response = requests.post(endpoint, headers=headers, json=payload, timeout=300)
  response.raise_for_status()

  result = response.json()

  # Log the response structure for debugging
  print(f"   üì• API response keys: {list(result.keys())}")

  # Try various response formats
  if "images" in result and len(result["images"]) > 0:
    image_data = result["images"][0]
    print(f"   üì• Image data keys: {list(image_data.keys()) if isinstance(image_data, dict) else type(image_data)}")

    # Try different possible keys for the image URL
    if isinstance(image_data, dict):
      if "url" in image_data:
        return image_data["url"]
      elif "image_url" in image_data:
        return image_data["image_url"]
      elif "data" in image_data:
        # Some APIs return base64 data - we'd need to handle this differently
        raise ValueError(f"API returned base64 data instead of URL: {list(image_data.keys())}")
      else:
        raise ValueError(f"Image data missing 'url' key. Available keys: {list(image_data.keys())}")
    elif isinstance(image_data, str):
      # Direct URL string
      return image_data
    else:
      raise ValueError(f"Unexpected image data type: {type(image_data)}")
  elif "url" in result:
    return result["url"]
  elif "image_url" in result:
    return result["image_url"]
  elif "output" in result:
    return result["output"]
  elif "error" in result:
    raise ValueError(f"API returned error: {result['error']}")
  elif "message" in result:
    raise ValueError(f"API returned message: {result['message']}")
  else:
    raise ValueError(f"Unexpected API response format. Keys: {list(result.keys())}, Full response: {result}")


def download_image_to_pil(url: str) -> Image.Image:
  """
  Download an image from a URL and return as PIL Image.

  Args:
      url: URL of the image to download

  Returns:
      PIL Image object
  """
  response = requests.get(url, timeout=120)
  response.raise_for_status()
  return Image.open(BytesIO(response.content))


# =============================================================================
# Rendering Functions
# =============================================================================


def render_quadrant(
  conn: sqlite3.Connection,
  config: dict,
  x: int,
  y: int,
  port: int,
) -> bytes | None:
  """
  Render a quadrant and save to database.

  This renders the tile containing the quadrant and saves all 4 quadrants.

  Args:
      conn: Database connection
      config: Generation config dict
      x: Quadrant x coordinate
      y: Quadrant y coordinate
      port: Web server port for rendering

  Returns:
      PNG bytes of the rendered quadrant, or None if failed
  """
  # Ensure the quadrant exists in the database
  quadrant = ensure_quadrant_exists(conn, config, x, y)

  print(f"   üé® Rendering tile for quadrant ({x}, {y})...")

  # Build URL for rendering
  params = {
    "export": "true",
    "lat": quadrant["lat"],
    "lon": quadrant["lng"],
    "width": config["width_px"],
    "height": config["height_px"],
    "azimuth": config["camera_azimuth_degrees"],
    "elevation": config["camera_elevation_degrees"],
    "view_height": config.get("view_height_meters", 200),
  }
  query_string = urlencode(params)
  url = f"http://localhost:{port}/?{query_string}"

  # Render using Playwright
  with sync_playwright() as p:
    browser = p.chromium.launch(
      headless=True,
      args=[
        "--enable-webgl",
        "--use-gl=angle",
        "--ignore-gpu-blocklist",
      ],
    )

    context = browser.new_context(
      viewport={"width": config["width_px"], "height": config["height_px"]},
      device_scale_factor=1,
    )
    page = context.new_page()

    page.goto(url, wait_until="networkidle")

    try:
      page.wait_for_function("window.TILES_LOADED === true", timeout=60000)
    except Exception:
      print("      ‚ö†Ô∏è  Timeout waiting for tiles, continuing anyway...")

    # Get screenshot as bytes
    screenshot_bytes = page.screenshot(type="png")

    page.close()
    context.close()
    browser.close()

  # Open as PIL image and split into quadrants
  full_tile = Image.open(BytesIO(screenshot_bytes))
  quadrant_images = split_tile_into_quadrants(full_tile)

  # Save all quadrants to database
  result_bytes = None
  for (dx, dy), quad_img in quadrant_images.items():
    qx, qy = x + dx, y + dy
    png_bytes = image_to_png_bytes(quad_img)
    save_quadrant_render(conn, config, qx, qy, png_bytes)
    print(f"      ‚úì Saved render for ({qx}, {qy})")

    # Return the specific quadrant we were asked for
    if qx == x and qy == y:
      result_bytes = png_bytes

  return result_bytes


# =============================================================================
# Core Generation Logic
# =============================================================================


def run_generation_for_quadrants(
  conn: sqlite3.Connection,
  config: dict,
  selected_quadrants: list[tuple[int, int]],
  port: int = DEFAULT_WEB_PORT,
  bucket_name: str = GCS_BUCKET_NAME,
  status_callback: Callable[[str, str], None] | None = None,
  model_config: "ModelConfig | None" = None,  # noqa: F821
  context_quadrants: list[tuple[int, int]] | None = None,
  prompt: str | None = None,
) -> dict:
  """
  Run the full generation pipeline for selected quadrants.

  This is the main entry point for generation. It:
  1. Validates the quadrant selection
  2. Renders any missing quadrants
  3. Builds the template image with appropriate borders
  4. Uploads to GCS and calls the Oxen API
  5. Saves the generated quadrants to the database

  Args:
      conn: Database connection
      config: Generation config dict
      selected_quadrants: List of (x, y) quadrant coordinates to generate
      port: Web server port for rendering (default: 5173)
      bucket_name: GCS bucket name for uploads
      status_callback: Optional callback(status, message) for progress updates
      model_config: Optional model configuration for the Oxen API (ModelConfig from model_config.py)
      context_quadrants: Optional list of (x, y) quadrant coordinates to use as
        context. These quadrants provide surrounding pixel art context for the
        generation. If a context quadrant has a generation, that will be used;
        otherwise the render will be used.
      prompt: Optional additional prompt text for generation

  Returns:
      Dict with:
          - success: bool
          - message: str (on success)
          - error: str (on failure)
          - quadrants: list of generated quadrant coords (on success)
  """
  # Convert context quadrants to a set for fast lookup
  context_set: set[tuple[int, int]] = (
    set(context_quadrants) if context_quadrants else set()
  )
  if context_set:
    print(f"   üìã Using {len(context_set)} context quadrant(s): {list(context_set)}")
  if prompt:
    print(f"   üìù Additional prompt: {prompt}")

  def update_status(status: str, message: str = "") -> None:
    if status_callback:
      status_callback(status, message)

  update_status("validating", "Checking API key...")

  # Create helper functions for validation
  # These are modified to treat context quadrants as "generated" if they have
  # either a generation or a render
  def has_generation_in_db(qx: int, qy: int) -> bool:
    # Check if this quadrant has an actual generation
    gen = shared_get_quadrant_generation(conn, qx, qy)
    if gen is not None:
      return True

    # For context quadrants, treat them as "generated" if they have a render
    # This allows context quadrants to provide surrounding content even if
    # they don't have generations yet
    if (qx, qy) in context_set:
      render = shared_get_quadrant_render(conn, qx, qy)
      return render is not None

    return False

  def get_render_from_db_with_render(qx: int, qy: int) -> Image.Image | None:
    """Get render, rendering if it doesn't exist yet."""
    render_bytes = shared_get_quadrant_render(conn, qx, qy)
    if render_bytes:
      return png_bytes_to_image(render_bytes)

    # Need to render
    update_status("rendering", f"Rendering quadrant ({qx}, {qy})...")
    print(f"   üì¶ Rendering quadrant ({qx}, {qy})...")
    render_bytes = render_quadrant(conn, config, qx, qy, port)
    if render_bytes:
      return png_bytes_to_image(render_bytes)
    return None

  def get_generation_from_db(qx: int, qy: int) -> Image.Image | None:
    """Get generation, falling back to render for context quadrants."""
    gen_bytes = shared_get_quadrant_generation(conn, qx, qy)
    if gen_bytes:
      return png_bytes_to_image(gen_bytes)

    # For context quadrants, fall back to render if no generation exists
    # This allows context quadrants to provide surrounding pixel art context
    # even if they only have renders
    if (qx, qy) in context_set:
      render_bytes = shared_get_quadrant_render(conn, qx, qy)
      if render_bytes:
        print(f"   üìã Using render as context for ({qx}, {qy})")
        return png_bytes_to_image(render_bytes)

    return None

  update_status("validating", "Validating quadrant selection...")

  # Validate selection with auto-expansion
  is_valid, msg, placement = validate_quadrant_selection(
    selected_quadrants, has_generation_in_db, allow_expansion=True
  )

  if not is_valid:
    update_status("error", msg)
    return {"success": False, "error": msg}

  print(f"‚úÖ Validation: {msg}")

  # Get primary quadrants (the ones user selected, not padding)
  primary_quadrants = (
    placement.primary_quadrants if placement.primary_quadrants else selected_quadrants
  )
  padding_quadrants = placement.padding_quadrants if placement else []

  if padding_quadrants:
    print(f"   üì¶ Padding quadrants: {padding_quadrants}")

  # Create the infill region (may be expanded)
  if placement._expanded_region is not None:
    region = placement._expanded_region
  else:
    region = InfillRegion.from_quadrants(selected_quadrants)

  # Build the template
  update_status("rendering", "Building template image...")
  builder = TemplateBuilder(
    region, has_generation_in_db, get_render_from_db_with_render, get_generation_from_db
  )

  print("üìã Building template...")
  result = builder.build(border_width=2, allow_expansion=True)

  if result is None:
    error_msg = builder._last_validation_error or "Failed to build template"
    update_status("error", error_msg)
    return {
      "success": False,
      "error": error_msg,
    }

  template_image, placement = result

  # Save template to temp file and upload to GCS
  with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp:
    template_path = Path(tmp.name)
    template_image.save(template_path)

  try:
    update_status("uploading", "Uploading template to cloud...")
    print("üì§ Uploading template to GCS...")
    print(f"   Template path: {template_path}")
    print(f"   Template size: {template_image.size[0]}x{template_image.size[1]}")
    image_url = upload_to_gcs(template_path, bucket_name)
    print(f"   Uploaded URL: {image_url}")

    update_status("generating", "Calling AI model (this may take a minute)...")
    print("ü§ñ Calling Oxen API...")
    generated_url = call_oxen_api(image_url, model_config, prompt)

    update_status("saving", "Downloading and saving results...")
    print("üì• Downloading generated image...")
    print(f"   Generated URL: {generated_url}")
    generated_image = download_image_to_pil(generated_url)

    # Extract quadrants from generated image and save to database
    print("üíæ Saving generated quadrants to database...")

    # Figure out what quadrants are in the infill region
    all_infill_quadrants = (
      placement.all_infill_quadrants
      if placement.all_infill_quadrants
      else region.overlapping_quadrants()
    )

    # For each infill quadrant, extract pixels from the generated image
    saved_count = 0
    for qx, qy in all_infill_quadrants:
      # Calculate position in the generated image
      quad_world_x = qx * QUADRANT_SIZE
      quad_world_y = qy * QUADRANT_SIZE

      template_x = quad_world_x - placement.world_offset_x
      template_y = quad_world_y - placement.world_offset_y

      # Crop this quadrant from the generated image
      crop_box = (
        template_x,
        template_y,
        template_x + QUADRANT_SIZE,
        template_y + QUADRANT_SIZE,
      )
      quad_img = generated_image.crop(crop_box)
      png_bytes = image_to_png_bytes(quad_img)

      # Only save primary quadrants (not padding)
      if (qx, qy) in primary_quadrants or (qx, qy) in [
        (q[0], q[1]) for q in primary_quadrants
      ]:
        if save_quadrant_generation(conn, config, qx, qy, png_bytes):
          print(f"   ‚úì Saved generation for ({qx}, {qy})")
          saved_count += 1
        else:
          print(f"   ‚ö†Ô∏è Failed to save generation for ({qx}, {qy})")
      else:
        print(f"   ‚è≠Ô∏è Skipped padding quadrant ({qx}, {qy})")

    update_status("complete", f"Generated {saved_count} quadrant(s)")
    return {
      "success": True,
      "message": f"Generated {saved_count} quadrant{'s' if saved_count != 1 else ''}",
      "quadrants": list(primary_quadrants),
    }

  finally:
    # Clean up temp file
    template_path.unlink(missing_ok=True)

```

Done! I've added better error handling and logging to `call_oxen_api`. Now when the API responds:

1. **Logs the response keys**: `üì• API response keys: [...]`
2. **Logs the image data keys**: `üì• Image data keys: [...]` 
3. **Tries multiple URL formats**: `url`, `image_url`, or direct string
4. **Better error messages**: Shows exactly what keys are available and what's missing

If you run a generation now and it fails, you'll see detailed logs showing what the API actually returned, which will help identify:
- If the API returned an error message
- If it's using a different key for the image URL
- If it's returning base64 data instead of a URL

